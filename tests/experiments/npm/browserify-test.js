(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var jsPlumb = require('jsplumb');
jsPlumb.ready(function() {
  alert("hi");
  var jsp = jsPlumb.getInstance();
  jsp.connect({source:"one", target:"two"});
  jsp.draggable(document.querySelectorAll("div"));
});


},{"jsplumb":2}],2:[function(require,module,exports){
/**
 * jsBezier-0.8
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * licensed under the MIT license.
 *
 * a set of Bezier curve functions that deal with Beziers, used by jsPlumb, and perhaps useful for other people.  These functions work with Bezier
 * curves of arbitrary degree.
 *
 * - functions are all in the 'jsBezier' namespace.
 *
 * - all input points should be in the format {x:.., y:..}. all output points are in this format too.
 *
 * - all input curves should be in the format [ {x:.., y:..}, {x:.., y:..}, {x:.., y:..}, {x:.., y:..} ]
 *
 * - 'location' as used as an input here refers to a decimal in the range 0-1 inclusive, which indicates a point some proportion along the length
 * of the curve.  location as output has the same format and meaning.
 *
 *
 * Function List:
 * --------------
 *
 * distanceFromCurve(point, curve)
 *
 * 	Calculates the distance that the given point lies from the given Bezier.  Note that it is computed relative to the center of the Bezier,
 * so if you have stroked the curve with a wide pen you may wish to take that into account!  The distance returned is relative to the values
 * of the curve and the point - it will most likely be pixels.
 *
 * gradientAtPoint(curve, location)
 *
 * 	Calculates the gradient to the curve at the given location, as a decimal between 0 and 1 inclusive.
 *
 * gradientAtPointAlongCurveFrom (curve, location)
 *
 *	Calculates the gradient at the point on the given curve that is 'distance' units from location.
 *
 * nearestPointOnCurve(point, curve)
 *
 *	Calculates the nearest point to the given point on the given curve.  The return value of this is a JS object literal, containing both the
 *point's coordinates and also the 'location' of the point (see above), for example:  { point:{x:551,y:150}, location:0.263365 }.
 *
 * pointOnCurve(curve, location)
 *
 * 	Calculates the coordinates of the point on the given Bezier curve at the given location.
 *
 * pointAlongCurveFrom(curve, location, distance)
 *
 * 	Calculates the coordinates of the point on the given curve that is 'distance' units from location.  'distance' should be in the same coordinate
 * space as that used to construct the Bezier curve.  For an HTML Canvas usage, for example, distance would be a measure of pixels.
 *
 * locationAlongCurveFrom(curve, location, distance)
 *
 * 	Calculates the location on the given curve that is 'distance' units from location.  'distance' should be in the same coordinate
 * space as that used to construct the Bezier curve.  For an HTML Canvas usage, for example, distance would be a measure of pixels.
 *
 * perpendicularToCurveAt(curve, location, length, distance)
 *
 * 	Calculates the perpendicular to the given curve at the given location.  length is the length of the line you wish for (it will be centered
 * on the point at 'location'). distance is optional, and allows you to specify a point along the path from the given location as the center of
 * the perpendicular returned.  The return value of this is an array of two points: [ {x:...,y:...}, {x:...,y:...} ].
 *
 *
 */

(function() {

    var root = this;

    if(typeof Math.sgn == "undefined") {
        Math.sgn = function(x) { return x == 0 ? 0 : x > 0 ? 1 :-1; };
    }

    var Vectors = {
            subtract 	: 	function(v1, v2) { return {x:v1.x - v2.x, y:v1.y - v2.y }; },
            dotProduct	: 	function(v1, v2) { return (v1.x * v2.x)  + (v1.y * v2.y); },
            square		:	function(v) { return Math.sqrt((v.x * v.x) + (v.y * v.y)); },
            scale		:	function(v, s) { return {x:v.x * s, y:v.y * s }; }
        },

        maxRecursion = 64,
        flatnessTolerance = Math.pow(2.0,-maxRecursion-1);

    /**
     * Calculates the distance that the point lies from the curve.
     *
     * @param point a point in the form {x:567, y:3342}
     * @param curve a Bezier curve in the form [{x:..., y:...}, {x:..., y:...}, {x:..., y:...}, {x:..., y:...}].  note that this is currently
     * hardcoded to assume cubiz beziers, but would be better off supporting any degree.
     * @return a JS object literal containing location and distance, for example: {location:0.35, distance:10}.  Location is analogous to the location
     * argument you pass to the pointOnPath function: it is a ratio of distance travelled along the curve.  Distance is the distance in pixels from
     * the point to the curve.
     */
    var _distanceFromCurve = function(point, curve) {
        var candidates = [],
            w = _convertToBezier(point, curve),
            degree = curve.length - 1, higherDegree = (2 * degree) - 1,
            numSolutions = _findRoots(w, higherDegree, candidates, 0),
            v = Vectors.subtract(point, curve[0]), dist = Vectors.square(v), t = 0.0;

        for (var i = 0; i < numSolutions; i++) {
            v = Vectors.subtract(point, _bezier(curve, degree, candidates[i], null, null));
            var newDist = Vectors.square(v);
            if (newDist < dist) {
                dist = newDist;
                t = candidates[i];
            }
        }
        v = Vectors.subtract(point, curve[degree]);
        newDist = Vectors.square(v);
        if (newDist < dist) {
            dist = newDist;
            t = 1.0;
        }
        return {location:t, distance:dist};
    };
    /**
     * finds the nearest point on the curve to the given point.
     */
    var _nearestPointOnCurve = function(point, curve) {
        var td = _distanceFromCurve(point, curve);
        return {point:_bezier(curve, curve.length - 1, td.location, null, null), location:td.location};
    };
    var _convertToBezier = function(point, curve) {
        var degree = curve.length - 1, higherDegree = (2 * degree) - 1,
            c = [], d = [], cdTable = [], w = [],
            z = [ [1.0, 0.6, 0.3, 0.1], [0.4, 0.6, 0.6, 0.4], [0.1, 0.3, 0.6, 1.0] ];

        for (var i = 0; i <= degree; i++) c[i] = Vectors.subtract(curve[i], point);
        for (var i = 0; i <= degree - 1; i++) {
            d[i] = Vectors.subtract(curve[i+1], curve[i]);
            d[i] = Vectors.scale(d[i], 3.0);
        }
        for (var row = 0; row <= degree - 1; row++) {
            for (var column = 0; column <= degree; column++) {
                if (!cdTable[row]) cdTable[row] = [];
                cdTable[row][column] = Vectors.dotProduct(d[row], c[column]);
            }
        }
        for (i = 0; i <= higherDegree; i++) {
            if (!w[i]) w[i] = [];
            w[i].y = 0.0;
            w[i].x = parseFloat(i) / higherDegree;
        }
        var n = degree, m = degree-1;
        for (var k = 0; k <= n + m; k++) {
            var lb = Math.max(0, k - m),
                ub = Math.min(k, n);
            for (i = lb; i <= ub; i++) {
                j = k - i;
                w[i+j].y += cdTable[j][i] * z[j][i];
            }
        }
        return w;
    };
    /**
     * counts how many roots there are.
     */
    var _findRoots = function(w, degree, t, depth) {
        var left = [], right = [],
            left_count, right_count,
            left_t = [], right_t = [];

        switch (_getCrossingCount(w, degree)) {
            case 0 : {
                return 0;
            }
            case 1 : {
                if (depth >= maxRecursion) {
                    t[0] = (w[0].x + w[degree].x) / 2.0;
                    return 1;
                }
                if (_isFlatEnough(w, degree)) {
                    t[0] = _computeXIntercept(w, degree);
                    return 1;
                }
                break;
            }
        }
        _bezier(w, degree, 0.5, left, right);
        left_count  = _findRoots(left,  degree, left_t, depth+1);
        right_count = _findRoots(right, degree, right_t, depth+1);
        for (var i = 0; i < left_count; i++) t[i] = left_t[i];
        for (var i = 0; i < right_count; i++) t[i+left_count] = right_t[i];
        return (left_count+right_count);
    };
    var _getCrossingCount = function(curve, degree) {
        var n_crossings = 0, sign, old_sign;
        sign = old_sign = Math.sgn(curve[0].y);
        for (var i = 1; i <= degree; i++) {
            sign = Math.sgn(curve[i].y);
            if (sign != old_sign) n_crossings++;
            old_sign = sign;
        }
        return n_crossings;
    };
    var _isFlatEnough = function(curve, degree) {
        var  error,
            intercept_1, intercept_2, left_intercept, right_intercept,
            a, b, c, det, dInv, a1, b1, c1, a2, b2, c2;
        a = curve[0].y - curve[degree].y;
        b = curve[degree].x - curve[0].x;
        c = curve[0].x * curve[degree].y - curve[degree].x * curve[0].y;

        var max_distance_above = max_distance_below = 0.0;

        for (var i = 1; i < degree; i++) {
            var value = a * curve[i].x + b * curve[i].y + c;
            if (value > max_distance_above)
                max_distance_above = value;
            else if (value < max_distance_below)
                max_distance_below = value;
        }

        a1 = 0.0; b1 = 1.0; c1 = 0.0; a2 = a; b2 = b;
        c2 = c - max_distance_above;
        det = a1 * b2 - a2 * b1;
        dInv = 1.0/det;
        intercept_1 = (b1 * c2 - b2 * c1) * dInv;
        a2 = a; b2 = b; c2 = c - max_distance_below;
        det = a1 * b2 - a2 * b1;
        dInv = 1.0/det;
        intercept_2 = (b1 * c2 - b2 * c1) * dInv;
        left_intercept = Math.min(intercept_1, intercept_2);
        right_intercept = Math.max(intercept_1, intercept_2);
        error = right_intercept - left_intercept;
        return (error < flatnessTolerance)? 1 : 0;
    };
    var _computeXIntercept = function(curve, degree) {
        var XLK = 1.0, YLK = 0.0,
            XNM = curve[degree].x - curve[0].x, YNM = curve[degree].y - curve[0].y,
            XMK = curve[0].x - 0.0, YMK = curve[0].y - 0.0,
            det = XNM*YLK - YNM*XLK, detInv = 1.0/det,
            S = (XNM*YMK - YNM*XMK) * detInv;
        return 0.0 + XLK * S;
    };
    var _bezier = function(curve, degree, t, left, right) {
        var temp = [[]];
        for (var j =0; j <= degree; j++) temp[0][j] = curve[j];
        for (var i = 1; i <= degree; i++) {
            for (var j =0 ; j <= degree - i; j++) {
                if (!temp[i]) temp[i] = [];
                if (!temp[i][j]) temp[i][j] = {};
                temp[i][j].x = (1.0 - t) * temp[i-1][j].x + t * temp[i-1][j+1].x;
                temp[i][j].y = (1.0 - t) * temp[i-1][j].y + t * temp[i-1][j+1].y;
            }
        }
        if (left != null)
            for (j = 0; j <= degree; j++) left[j]  = temp[j][0];
        if (right != null)
            for (j = 0; j <= degree; j++) right[j] = temp[degree-j][j];

        return (temp[degree][0]);
    };

    var _curveFunctionCache = {};
    var _getCurveFunctions = function(order) {
        var fns = _curveFunctionCache[order];
        if (!fns) {
            fns = [];
            var f_term = function() { return function(t) { return Math.pow(t, order); }; },
                l_term = function() { return function(t) { return Math.pow((1-t), order); }; },
                c_term = function(c) { return function(t) { return c; }; },
                t_term = function() { return function(t) { return t; }; },
                one_minus_t_term = function() { return function(t) { return 1-t; }; },
                _termFunc = function(terms) {
                    return function(t) {
                        var p = 1;
                        for (var i = 0; i < terms.length; i++) p = p * terms[i](t);
                        return p;
                    };
                };

            fns.push(new f_term());  // first is t to the power of the curve order
            for (var i = 1; i < order; i++) {
                var terms = [new c_term(order)];
                for (var j = 0 ; j < (order - i); j++) terms.push(new t_term());
                for (var j = 0 ; j < i; j++) terms.push(new one_minus_t_term());
                fns.push(new _termFunc(terms));
            }
            fns.push(new l_term());  // last is (1-t) to the power of the curve order

            _curveFunctionCache[order] = fns;
        }

        return fns;
    };


    /**
     * calculates a point on the curve, for a Bezier of arbitrary order.
     * @param curve an array of control points, eg [{x:10,y:20}, {x:50,y:50}, {x:100,y:100}, {x:120,y:100}].  For a cubic bezier this should have four points.
     * @param location a decimal indicating the distance along the curve the point should be located at.  this is the distance along the curve as it travels, taking the way it bends into account.  should be a number from 0 to 1, inclusive.
     */
    var _pointOnPath = function(curve, location) {
        var cc = _getCurveFunctions(curve.length - 1),
            _x = 0, _y = 0;
        for (var i = 0; i < curve.length ; i++) {
            _x = _x + (curve[i].x * cc[i](location));
            _y = _y + (curve[i].y * cc[i](location));
        }

        return {x:_x, y:_y};
    };

    var _dist = function(p1,p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    };

    var _isPoint = function(curve) {
        return curve[0].x == curve[1].x && curve[0].y == curve[1].y;
    };

    /**
     * finds the point that is 'distance' along the path from 'location'.  this method returns both the x,y location of the point and also
     * its 'location' (proportion of travel along the path); the method below - _pointAlongPathFrom - calls this method and just returns the
     * point.
     */
    var _pointAlongPath = function(curve, location, distance) {

        if (_isPoint(curve)) {
            return {
                point:curve[0],
                location:location
            };
        }

        var prev = _pointOnPath(curve, location),
            tally = 0,
            curLoc = location,
            direction = distance > 0 ? 1 : -1,
            cur = null;

        while (tally < Math.abs(distance)) {
            curLoc += (0.005 * direction);
            cur = _pointOnPath(curve, curLoc);
            tally += _dist(cur, prev);
            prev = cur;
        }
        return {point:cur, location:curLoc};
    };

    var _length = function(curve) {
        if (_isPoint(curve)) return 0;

        var prev = _pointOnPath(curve, 0),
            tally = 0,
            curLoc = 0,
            direction = 1,
            cur = null;

        while (curLoc < 1) {
            curLoc += (0.005 * direction);
            cur = _pointOnPath(curve, curLoc);
            tally += _dist(cur, prev);
            prev = cur;
        }
        return tally;
    };

    /**
     * finds the point that is 'distance' along the path from 'location'.
     */
    var _pointAlongPathFrom = function(curve, location, distance) {
        return _pointAlongPath(curve, location, distance).point;
    };

    /**
     * finds the location that is 'distance' along the path from 'location'.
     */
    var _locationAlongPathFrom = function(curve, location, distance) {
        return _pointAlongPath(curve, location, distance).location;
    };

    /**
     * returns the gradient of the curve at the given location, which is a decimal between 0 and 1 inclusive.
     *
     * thanks // http://bimixual.org/AnimationLibrary/beziertangents.html
     */
    var _gradientAtPoint = function(curve, location) {
        var p1 = _pointOnPath(curve, location),
            p2 = _pointOnPath(curve.slice(0, curve.length - 1), location),
            dy = p2.y - p1.y, dx = p2.x - p1.x;
        return dy == 0 ? Infinity : Math.atan(dy / dx);
    };

    /**
     returns the gradient of the curve at the point which is 'distance' from the given location.
     if this point is greater than location 1, the gradient at location 1 is returned.
     if this point is less than location 0, the gradient at location 0 is returned.
     */
    var _gradientAtPointAlongPathFrom = function(curve, location, distance) {
        var p = _pointAlongPath(curve, location, distance);
        if (p.location > 1) p.location = 1;
        if (p.location < 0) p.location = 0;
        return _gradientAtPoint(curve, p.location);
    };

    /**
     * calculates a line that is 'length' pixels long, perpendicular to, and centered on, the path at 'distance' pixels from the given location.
     * if distance is not supplied, the perpendicular for the given location is computed (ie. we set distance to zero).
     */
    var _perpendicularToPathAt = function(curve, location, length, distance) {
        distance = distance == null ? 0 : distance;
        var p = _pointAlongPath(curve, location, distance),
            m = _gradientAtPoint(curve, p.location),
            _theta2 = Math.atan(-1 / m),
            y =  length / 2 * Math.sin(_theta2),
            x =  length / 2 * Math.cos(_theta2);
        return [{x:p.point.x + x, y:p.point.y + y}, {x:p.point.x - x, y:p.point.y - y}];
    };

    this.jsBezier = {
        distanceFromCurve : _distanceFromCurve,
        gradientAtPoint : _gradientAtPoint,
        gradientAtPointAlongCurveFrom : _gradientAtPointAlongPathFrom,
        nearestPointOnCurve : _nearestPointOnCurve,
        pointOnCurve : _pointOnPath,
        pointAlongCurveFrom : _pointAlongPathFrom,
        perpendicularToCurveAt : _perpendicularToPathAt,
        locationAlongCurveFrom:_locationAlongPathFrom,
        getLength:_length
    };
}).call(typeof window !== 'undefined' ? window : this);

/**
 * Biltong v0.3
 *
 * Various geometry functions written as part of jsPlumb and perhaps useful for others.
 *
 * Copyright (c) 2016 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
;(function() {

    "use strict";
    var root = this;

    var Biltong = root.Biltong = {};

    var _isa = function(a) { return Object.prototype.toString.call(a) === "[object Array]"; },
        _pointHelper = function(p1, p2, fn) {
            p1 = _isa(p1) ? p1 : [p1.x, p1.y];
            p2 = _isa(p2) ? p2 : [p2.x, p2.y];
            return fn(p1, p2);
        },
        /**
         * @name Biltong.gradient
         * @function
         * @desc Calculates the gradient of a line between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The gradient of a line between the two points.
         */
        _gradient = Biltong.gradient = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                if (_p2[0] == _p1[0])
                    return _p2[1] > _p1[1] ? Infinity : -Infinity;
                else if (_p2[1] == _p1[1])
                    return _p2[0] > _p1[0] ? 0 : -0;
                else
                    return (_p2[1] - _p1[1]) / (_p2[0] - _p1[0]);
            });
        },
        /**
         * @name Biltong.normal
         * @function
         * @desc Calculates the gradient of a normal to a line between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The gradient of a normal to a line between the two points.
         */
        _normal = Biltong.normal = function(p1, p2) {
            return -1 / _gradient(p1, p2);
        },
        /**
         * @name Biltong.lineLength
         * @function
         * @desc Calculates the length of a line between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The length of a line between the two points.
         */
        _lineLength = Biltong.lineLength = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                return Math.sqrt(Math.pow(_p2[1] - _p1[1], 2) + Math.pow(_p2[0] - _p1[0], 2));
            });
        },
        /**
         * @name Biltong.quadrant
         * @function
         * @desc Calculates the quadrant in which the angle between the two points lies.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Integer} The quadrant - 1 for upper right, 2 for lower right, 3 for lower left, 4 for upper left.
         */
        _quadrant = Biltong.quadrant = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                if (_p2[0] > _p1[0]) {
                    return (_p2[1] > _p1[1]) ? 2 : 1;
                }
                else if (_p2[0] == _p1[0]) {
                    return _p2[1] > _p1[1] ? 2 : 1;
                }
                else {
                    return (_p2[1] > _p1[1]) ? 3 : 4;
                }
            });
        },
        /**
         * @name Biltong.theta
         * @function
         * @desc Calculates the angle between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The angle between the two points.
         */
        _theta = Biltong.theta = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                var m = _gradient(_p1, _p2),
                    t = Math.atan(m),
                    s = _quadrant(_p1, _p2);
                if ((s == 4 || s== 3)) t += Math.PI;
                if (t < 0) t += (2 * Math.PI);

                return t;
            });
        },
        /**
         * @name Biltong.intersects
         * @function
         * @desc Calculates whether or not the two rectangles intersect.
         * @param {Rectangle} r1 First rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @param {Rectangle} r2 Second rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @return {Boolean} True if the rectangles intersect, false otherwise.
         */
        _intersects = Biltong.intersects = function(r1, r2) {
            var x1 = r1.x, x2 = r1.x + r1.w, y1 = r1.y, y2 = r1.y + r1.h,
                a1 = r2.x, a2 = r2.x + r2.w, b1 = r2.y, b2 = r2.y + r2.h;

            return  ( (x1 <= a1 && a1 <= x2) && (y1 <= b1 && b1 <= y2) ) ||
                ( (x1 <= a2 && a2 <= x2) && (y1 <= b1 && b1 <= y2) ) ||
                ( (x1 <= a1 && a1 <= x2) && (y1 <= b2 && b2 <= y2) ) ||
                ( (x1 <= a2 && a1 <= x2) && (y1 <= b2 && b2 <= y2) ) ||
                ( (a1 <= x1 && x1 <= a2) && (b1 <= y1 && y1 <= b2) ) ||
                ( (a1 <= x2 && x2 <= a2) && (b1 <= y1 && y1 <= b2) ) ||
                ( (a1 <= x1 && x1 <= a2) && (b1 <= y2 && y2 <= b2) ) ||
                ( (a1 <= x2 && x1 <= a2) && (b1 <= y2 && y2 <= b2) );
        },
        /**
         * @name Biltong.encloses
         * @function
         * @desc Calculates whether or not r2 is completely enclosed by r1.
         * @param {Rectangle} r1 First rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @param {Rectangle} r2 Second rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @param {Boolean} [allowSharedEdges=false] If true, the concept of enclosure allows for one or more edges to be shared by the two rectangles.
         * @return {Boolean} True if r1 encloses r2, false otherwise.
         */
        _encloses = Biltong.encloses = function(r1, r2, allowSharedEdges) {
            var x1 = r1.x, x2 = r1.x + r1.w, y1 = r1.y, y2 = r1.y + r1.h,
                a1 = r2.x, a2 = r2.x + r2.w, b1 = r2.y, b2 = r2.y + r2.h,
                c = function(v1, v2, v3, v4) { return allowSharedEdges ? v1 <= v2 && v3>= v4 : v1 < v2 && v3 > v4; };

            return c(x1,a1,x2,a2) && c(y1,b1,y2,b2);
        },
        _segmentMultipliers = [null, [1, -1], [1, 1], [-1, 1], [-1, -1] ],
        _inverseSegmentMultipliers = [null, [-1, -1], [-1, 1], [1, 1], [1, -1] ],
        /**
         * @name Biltong.pointOnLine
         * @function
         * @desc Calculates a point on the line from `fromPoint` to `toPoint` that is `distance` units along the length of the line.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Point} Point on the line, in the form `{ x:..., y:... }`.
         */
        _pointOnLine = Biltong.pointOnLine = function(fromPoint, toPoint, distance) {
            var m = _gradient(fromPoint, toPoint),
                s = _quadrant(fromPoint, toPoint),
                segmentMultiplier = distance > 0 ? _segmentMultipliers[s] : _inverseSegmentMultipliers[s],
                theta = Math.atan(m),
                y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1],
                x =  Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];
            return { x:fromPoint.x + x, y:fromPoint.y + y };
        },
        /**
         * @name Biltong.perpendicularLineTo
         * @function
         * @desc Calculates a line of length `length` that is perpendicular to the line from `fromPoint` to `toPoint` and passes through `toPoint`.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Line} Perpendicular line, in the form `[ { x:..., y:... }, { x:..., y:... } ]`.
         */
        _perpendicularLineTo = Biltong.perpendicularLineTo = function(fromPoint, toPoint, length) {
            var m = _gradient(fromPoint, toPoint),
                theta2 = Math.atan(-1 / m),
                y =  length / 2 * Math.sin(theta2),
                x =  length / 2 * Math.cos(theta2);
            return [{x:toPoint.x + x, y:toPoint.y + y}, {x:toPoint.x - x, y:toPoint.y - y}];
        };
}).call(typeof window !== 'undefined' ? window : this);
;
(function () {

    "use strict";

    var root = this,
        Sniff = {
            android: navigator.userAgent.toLowerCase().indexOf("android") > -1
        },
        matchesSelector = function (el, selector, ctx) {
            ctx = ctx || el.parentNode;
            var possibles = ctx.querySelectorAll(selector);
            for (var i = 0; i < possibles.length; i++) {
                if (possibles[i] === el) {
                    return true;
                }
            }
            return false;
        },
        _gel = function (el) {
            return (typeof el == "string" || el.constructor === String) ? document.getElementById(el) : el;
        },
        _t = function (e) {
            return e.srcElement || e.target;
        },
    //
    // gets path info for the given event - the path from target to obj, in the event's bubble chain. if doCompute
    // is false we just return target for the path.
    //
        _pi = function(e, target, obj, doCompute) {
            if (!doCompute) return { path:[target], end:1 };
            else if (typeof e.path !== "undefined") {
                return { path: e.path, end: e.path.indexOf(obj) };
            } else {
                var out = { path:[], end:-1 }, _one = function(el) {
                    out.path.push(el);
                    if (el === obj) {
                        out.end = out.path.length - 1;
                    }
                    else if (el.parentNode != null) {
                        _one(el.parentNode)
                    }
                };
                _one(target);
                return out;
            }
        },
        _d = function (l, fn) {
            for (var i = 0, j = l.length; i < j; i++) {
                if (l[i] == fn) break;
            }
            if (i < l.length) l.splice(i, 1);
        },
        guid = 1,
    //
    // this function generates a guid for every handler, sets it on the handler, then adds
    // it to the associated object's map of handlers for the given event. this is what enables us
    // to unbind all events of some type, or all events (the second of which can be requested by the user,
    // but it also used by Mottle when an element is removed.)
        _store = function (obj, event, fn) {
            var g = guid++;
            obj.__ta = obj.__ta || {};
            obj.__ta[event] = obj.__ta[event] || {};
            // store each handler with a unique guid.
            obj.__ta[event][g] = fn;
            // set the guid on the handler.
            fn.__tauid = g;
            return g;
        },
        _unstore = function (obj, event, fn) {
            obj.__ta && obj.__ta[event] && delete obj.__ta[event][fn.__tauid];
            // a handler might have attached extra functions, so we unbind those too.
            if (fn.__taExtra) {
                for (var i = 0; i < fn.__taExtra.length; i++) {
                    _unbind(obj, fn.__taExtra[i][0], fn.__taExtra[i][1]);
                }
                fn.__taExtra.length = 0;
            }
            // a handler might have attached an unstore callback
            fn.__taUnstore && fn.__taUnstore();
        },
        _curryChildFilter = function (children, obj, fn, evt) {
            if (children == null) return fn;
            else {
                var c = children.split(","),
                    _fn = function (e) {
                        _fn.__tauid = fn.__tauid;
                        var t = _t(e), target = t;  // t is the target element on which the event occurred. it is the
                        // element we will wish to pass to any callbacks.
                        var pathInfo = _pi(e, t, obj, children != null)
                        if (pathInfo.end != -1) {
                            for (var p = 0; p < pathInfo.end; p++) {
                                target = pathInfo.path[p];
                                for (var i = 0; i < c.length; i++) {
                                    if (matchesSelector(target, c[i], obj)) {
                                        fn.apply(target, arguments);
                                    }
                                }
                            }
                        }
                    };
                registerExtraFunction(fn, evt, _fn);
                return _fn;
            }
        },
    //
    // registers an 'extra' function on some event listener function we were given - a function that we
    // created and bound to the element as part of our housekeeping, and which we want to unbind and remove
    // whenever the given function is unbound.
        registerExtraFunction = function (fn, evt, newFn) {
            fn.__taExtra = fn.__taExtra || [];
            fn.__taExtra.push([evt, newFn]);
        },
        DefaultHandler = function (obj, evt, fn, children) {
            if (isTouchDevice && touchMap[evt]) {
                var tfn = _curryChildFilter(children, obj, fn, touchMap[evt]);
                _bind(obj, touchMap[evt], tfn , fn);
            }
            if (evt === "focus" && obj.getAttribute("tabindex") == null) {
                obj.setAttribute("tabindex", "1");
            }
            _bind(obj, evt, _curryChildFilter(children, obj, fn, evt), fn);
        },
        SmartClickHandler = function (obj, evt, fn, children) {
            if (obj.__taSmartClicks == null) {
                var down = function (e) {
                        obj.__tad = _pageLocation(e);
                    },
                    up = function (e) {
                        obj.__tau = _pageLocation(e);
                    },
                    click = function (e) {
                        if (obj.__tad && obj.__tau && obj.__tad[0] === obj.__tau[0] && obj.__tad[1] === obj.__tau[1]) {
                            for (var i = 0; i < obj.__taSmartClicks.length; i++)
                                obj.__taSmartClicks[i].apply(_t(e), [ e ]);
                        }
                    };
                DefaultHandler(obj, "mousedown", down, children);
                DefaultHandler(obj, "mouseup", up, children);
                DefaultHandler(obj, "click", click, children);
                obj.__taSmartClicks = [];
            }

            // store in the list of callbacks
            obj.__taSmartClicks.push(fn);
            // the unstore function removes this function from the object's listener list for this type.
            fn.__taUnstore = function () {
                _d(obj.__taSmartClicks, fn);
            };
        },
        _tapProfiles = {
            "tap": {touches: 1, taps: 1},
            "dbltap": {touches: 1, taps: 2},
            "contextmenu": {touches: 2, taps: 1}
        },
        TapHandler = function (clickThreshold, dblClickThreshold) {
            return function (obj, evt, fn, children) {
                // if event is contextmenu, for devices which are mouse only, we want to
                // use the default bind.
                if (evt == "contextmenu" && isMouseDevice)
                    DefaultHandler(obj, evt, fn, children);
                else {
                    // the issue here is that this down handler gets registered only for the
                    // child nodes in the first registration. in fact it should be registered with
                    // no child selector and then on down we should cycle through the registered
                    // functions to see if one of them matches. on mouseup we should execute ALL of
                    // the functions whose children are either null or match the element.
                    if (obj.__taTapHandler == null) {
                        var tt = obj.__taTapHandler = {
                            tap: [],
                            dbltap: [],
                            contextmenu: [],
                            down: false,
                            taps: 0,
                            downSelectors: []
                        };
                        var down = function (e) {
                                var target = _t(e), pathInfo = _pi(e, target, obj, children != null), finished = false;
                                for (var p = 0; p < pathInfo.end; p++) {
                                    if (finished) return;
                                    target = pathInfo.path[p];
                                    for (var i = 0; i < tt.downSelectors.length; i++) {
                                        if (tt.downSelectors[i] == null || matchesSelector(target, tt.downSelectors[i], obj)) {
                                            tt.down = true;
                                            setTimeout(clearSingle, clickThreshold);
                                            setTimeout(clearDouble, dblClickThreshold);
                                            finished = true;
                                            break; // we only need one match on mousedown
                                        }
                                    }
                                }
                            },
                            up = function (e) {
                                if (tt.down) {
                                    var target = _t(e), pathInfo;
                                    tt.taps++;
                                    var tc = _touchCount(e);
                                    for (var eventId in _tapProfiles) {
                                        if (_tapProfiles.hasOwnProperty(eventId)) {
                                            var p = _tapProfiles[eventId];
                                            if (p.touches === tc && (p.taps === 1 || p.taps === tt.taps)) {
                                                for (var i = 0; i < tt[eventId].length; i++) {
                                                    pathInfo = _pi(e, target, obj, tt[eventId][i][1] != null);
                                                    for (var pLoop = 0; pLoop < pathInfo.end; pLoop++) {
                                                        target = pathInfo.path[pLoop];
                                                        // this is a single event registration handler.
                                                        if (tt[eventId][i][1] == null || matchesSelector(target, tt[eventId][i][1], obj)) {
                                                            tt[eventId][i][0].apply(target, [ e ]);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            clearSingle = function () {
                                tt.down = false;
                            },
                            clearDouble = function () {
                                tt.taps = 0;
                            };

                        DefaultHandler(obj, "mousedown", down);
                        DefaultHandler(obj, "mouseup", up);
                    }
                    // add this child selector (it can be null, that's fine).
                    obj.__taTapHandler.downSelectors.push(children);

                    obj.__taTapHandler[evt].push([fn, children]);
                    // the unstore function removes this function from the object's listener list for this type.
                    fn.__taUnstore = function () {
                        _d(obj.__taTapHandler[evt], fn);
                    };
                }
            };
        },
        meeHelper = function (type, evt, obj, target) {
            for (var i in obj.__tamee[type]) {
                if (obj.__tamee[type].hasOwnProperty(i)) {
                    obj.__tamee[type][i].apply(target, [ evt ]);
                }
            }
        },
        MouseEnterExitHandler = function () {
            var activeElements = [];
            return function (obj, evt, fn, children) {
                if (!obj.__tamee) {
                    // __tamee holds a flag saying whether the mouse is currently "in" the element, and a list of
                    // both mouseenter and mouseexit functions.
                    obj.__tamee = { over: false, mouseenter: [], mouseexit: [] };
                    // register over and out functions
                    var over = function (e) {
                            var t = _t(e);
                            if ((children == null && (t == obj && !obj.__tamee.over)) || (matchesSelector(t, children, obj) && (t.__tamee == null || !t.__tamee.over))) {
                                meeHelper("mouseenter", e, obj, t);
                                t.__tamee = t.__tamee || {};
                                t.__tamee.over = true;
                                activeElements.push(t);
                            }
                        },
                        out = function (e) {
                            var t = _t(e);
                            // is the current target one of the activeElements? and is the
                            // related target NOT a descendant of it?
                            for (var i = 0; i < activeElements.length; i++) {
                                if (t == activeElements[i] && !matchesSelector((e.relatedTarget || e.toElement), "*", t)) {
                                    t.__tamee.over = false;
                                    activeElements.splice(i, 1);
                                    meeHelper("mouseexit", e, obj, t);
                                }
                            }
                        };

                    _bind(obj, "mouseover", _curryChildFilter(children, obj, over, "mouseover"), over);
                    _bind(obj, "mouseout", _curryChildFilter(children, obj, out, "mouseout"), out);
                }

                fn.__taUnstore = function () {
                    delete obj.__tamee[evt][fn.__tauid];
                };

                _store(obj, evt, fn);
                obj.__tamee[evt][fn.__tauid] = fn;
            };
        },
        isTouchDevice = "ontouchstart" in document.documentElement,
        isMouseDevice = "onmousedown" in document.documentElement,
        touchMap = { "mousedown": "touchstart", "mouseup": "touchend", "mousemove": "touchmove" },
        touchstart = "touchstart", touchend = "touchend", touchmove = "touchmove",
        iev = (function () {
            var rv = -1;
            if (navigator.appName == 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent,
                    re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                if (re.exec(ua) != null)
                    rv = parseFloat(RegExp.$1);
            }
            return rv;
        })(),
        isIELT9 = iev > -1 && iev < 9,
        _genLoc = function (e, prefix) {
            if (e == null) return [ 0, 0 ];
            var ts = _touches(e), t = _getTouch(ts, 0);
            return [t[prefix + "X"], t[prefix + "Y"]];
        },
        _pageLocation = function (e) {
            if (e == null) return [ 0, 0 ];
            if (isIELT9) {
                return [ e.clientX + document.documentElement.scrollLeft, e.clientY + document.documentElement.scrollTop ];
            }
            else {
                return _genLoc(e, "page");
            }
        },
        _screenLocation = function (e) {
            return _genLoc(e, "screen");
        },
        _clientLocation = function (e) {
            return _genLoc(e, "client");
        },
        _getTouch = function (touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
        },
        _touches = function (e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        },
        _touchCount = function (e) {
            return _touches(e).length;
        },
    //http://www.quirksmode.org/blog/archives/2005/10/_and_the_winner_1.html
        _bind = function (obj, type, fn, originalFn) {
            _store(obj, type, fn);
            originalFn.__tauid = fn.__tauid;
            if (obj.addEventListener)
                obj.addEventListener(type, fn, false);
            else if (obj.attachEvent) {
                var key = type + fn.__tauid;
                obj["e" + key] = fn;
                // TODO look at replacing with .call(..)
                obj[key] = function () {
                    obj["e" + key] && obj["e" + key](window.event);
                };
                obj.attachEvent("on" + type, obj[key]);
            }
        },
        _unbind = function (obj, type, fn) {
            if (fn == null) return;
            _each(obj, function () {
                var _el = _gel(this);
                _unstore(_el, type, fn);
                // it has been bound if there is a tauid. otherwise it was not bound and we can ignore it.
                if (fn.__tauid != null) {
                    if (_el.removeEventListener) {
                        _el.removeEventListener(type, fn, false);
                        if (isTouchDevice && touchMap[type]) _el.removeEventListener(touchMap[type], fn, false);
                    }
                    else if (this.detachEvent) {
                        var key = type + fn.__tauid;
                        _el[key] && _el.detachEvent("on" + type, _el[key]);
                        _el[key] = null;
                        _el["e" + key] = null;
                    }
                }

                // if a touch event was also registered, deregister now.
                if (fn.__taTouchProxy) {
                    _unbind(obj, fn.__taTouchProxy[1], fn.__taTouchProxy[0]);
                }
            });
        },
        _each = function (obj, fn) {
            if (obj == null) return;
            // if a list (or list-like), use it. if a string, get a list
            // by running the string through querySelectorAll. else, assume
            // it's an Element.
            // obj.top is "unknown" in IE8.
            obj = (typeof Window !== "undefined" && (typeof obj.top !== "unknown" && obj == obj.top)) ? [ obj ] :
                    (typeof obj !== "string") && (obj.tagName == null && obj.length != null) ? obj :
                    typeof obj === "string" ? document.querySelectorAll(obj)
                : [ obj ];

            for (var i = 0; i < obj.length; i++)
                fn.apply(obj[i]);
        };

    /**
     * Mottle offers support for abstracting out the differences
     * between touch and mouse devices, plus "smart click" functionality
     * (don't fire click if the mouse has moved between mousedown and mouseup),
     * and synthesized click/tap events.
     * @class Mottle
     * @constructor
     * @param {Object} params Constructor params
     * @param {Number} [params.clickThreshold=250] Threshold, in milliseconds beyond which a touchstart followed by a touchend is not considered to be a click.
     * @param {Number} [params.dblClickThreshold=450] Threshold, in milliseconds beyond which two successive tap events are not considered to be a click.
     * @param {Boolean} [params.smartClicks=false] If true, won't fire click events if the mouse has moved between mousedown and mouseup. Note that this functionality
     * requires that Mottle consume the mousedown event, and so may not be viable in all use cases.
     */
    root.Mottle = function (params) {
        params = params || {};
        var clickThreshold = params.clickThreshold || 250,
            dblClickThreshold = params.dblClickThreshold || 450,
            mouseEnterExitHandler = new MouseEnterExitHandler(),
            tapHandler = new TapHandler(clickThreshold, dblClickThreshold),
            _smartClicks = params.smartClicks,
            _doBind = function (obj, evt, fn, children) {
                if (fn == null) return;
                _each(obj, function () {
                    var _el = _gel(this);
                    if (_smartClicks && evt === "click")
                        SmartClickHandler(_el, evt, fn, children);
                    else if (evt === "tap" || evt === "dbltap" || evt === "contextmenu") {
                        tapHandler(_el, evt, fn, children);
                    }
                    else if (evt === "mouseenter" || evt == "mouseexit")
                        mouseEnterExitHandler(_el, evt, fn, children);
                    else
                        DefaultHandler(_el, evt, fn, children);
                });
            };

        /**
         * Removes an element from the DOM, and deregisters all event handlers for it. You should use this
         * to ensure you don't leak memory.
         * @method remove
         * @param {String|Element} el Element, or id of the element, to remove.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.remove = function (el) {
            _each(el, function () {
                var _el = _gel(this);
                if (_el.__ta) {
                    for (var evt in _el.__ta) {
                        if (_el.__ta.hasOwnProperty(evt)) {
                            for (var h in _el.__ta[evt]) {
                                if (_el.__ta[evt].hasOwnProperty(h))
                                    _unbind(_el, evt, _el.__ta[evt][h]);
                            }
                        }
                    }
                }
                _el.parentNode && _el.parentNode.removeChild(_el);
            });
            return this;
        };

        /**
         * Register an event handler, optionally as a delegate for some set of descendant elements. Note
         * that this method takes either 3 or 4 arguments - if you supply 3 arguments it is assumed you have
         * omitted the `children` parameter, and that the event handler should be bound directly to the given element.
         * @method on
         * @param {Element[]|Element|String} el Either an Element, or a CSS spec for a list of elements, or an array of Elements.
         * @param {String} [children] Comma-delimited list of selectors identifying allowed children.
         * @param {String} event Event ID.
         * @param {Function} fn Event handler function.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.on = function (el, event, children, fn) {
            var _el = arguments[0],
                _c = arguments.length == 4 ? arguments[2] : null,
                _e = arguments[1],
                _f = arguments[arguments.length - 1];

            _doBind(_el, _e, _f, _c);
            return this;
        };

        /**
         * Cancel delegate event handling for the given function. Note that unlike with 'on' you do not supply
         * a list of child selectors here: it removes event delegation from all of the child selectors for which the
         * given function was registered (if any).
         * @method off
         * @param {Element[]|Element|String} el Element - or ID of element - from which to remove event listener.
         * @param {String} event Event ID.
         * @param {Function} fn Event handler function.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.off = function (el, event, fn) {
            _unbind(el, event, fn);
            return this;
        };

        /**
         * Triggers some event for a given element.
         * @method trigger
         * @param {Element} el Element for which to trigger the event.
         * @param {String} event Event ID.
         * @param {Event} originalEvent The original event. Should be optional of course, but currently is not, due
         * to the jsPlumb use case that caused this method to be added.
         * @param {Object} [payload] Optional object to set as `payload` on the generated event; useful for message passing.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.trigger = function (el, event, originalEvent, payload) {
            // MouseEvent undefined in old IE; that's how we know it's a mouse event.  A fine Microsoft paradox.
            var originalIsMouse = isMouseDevice && (typeof MouseEvent === "undefined" || originalEvent == null || originalEvent.constructor === MouseEvent);

            var eventToBind = (isTouchDevice && !isMouseDevice && touchMap[event]) ? touchMap[event] : event,
                bindingAMouseEvent = !(isTouchDevice && !isMouseDevice && touchMap[event]);

            var pl = _pageLocation(originalEvent), sl = _screenLocation(originalEvent), cl = _clientLocation(originalEvent);
            _each(el, function () {
                var _el = _gel(this), evt;
                originalEvent = originalEvent || {
                    screenX: sl[0],
                    screenY: sl[1],
                    clientX: cl[0],
                    clientY: cl[1]
                };

                var _decorate = function (_evt) {
                    if (payload) _evt.payload = payload;
                };

                var eventGenerators = {
                    "TouchEvent": function (evt) {
                        var touch = document.createTouch(window, _el, 0, pl[0], pl[1],
                            sl[0], sl[1],
                            cl[0], cl[1],
                            0, 0, 0, 0);

                        // https://gist.github.com/sstephenson/448808
                        var touches = document.createTouchList(touch);
                        var targetTouches = document.createTouchList(touch);
                        var changedTouches = document.createTouchList(touch);
                        evt.initTouchEvent(eventToBind, true, true, window, null, sl[0], sl[1],
                            cl[0], cl[1], false, false, false, false,
                            touches, targetTouches, changedTouches, 1, 0);
                    },
                    "MouseEvents": function (evt) {
                        evt.initMouseEvent(eventToBind, true, true, window, 0,
                            sl[0], sl[1],
                            cl[0], cl[1],
                            false, false, false, false, 1, _el);

                        if (Sniff.android) {
                            // Android's touch events are not standard.
                            var t = document.createTouch(window, _el, 0, pl[0], pl[1],
                                sl[0], sl[1],
                                cl[0], cl[1],
                                0, 0, 0, 0);

                            evt.touches = evt.targetTouches = evt.changedTouches = document.createTouchList(t);
                        }
                    }
                };

                if (document.createEvent) {

                    var ite = !bindingAMouseEvent && !originalIsMouse && (isTouchDevice && touchMap[event] && !Sniff.android),
                        evtName = ite ? "TouchEvent" : "MouseEvents";

                    evt = document.createEvent(evtName);
                    eventGenerators[evtName](evt);
                    _decorate(evt);
                    _el.dispatchEvent(evt);
                }
                else if (document.createEventObject) {
                    evt = document.createEventObject();
                    evt.eventType = evt.eventName = eventToBind;
                    evt.screenX = sl[0];
                    evt.screenY = sl[1];
                    evt.clientX = cl[0];
                    evt.clientY = cl[1];
                    _decorate(evt);
                    _el.fireEvent('on' + eventToBind, evt);
                }
            });
            return this;
        }
    };

    /**
     * Static method to assist in 'consuming' an element: uses `stopPropagation` where available, or sets
     * `e.returnValue=false` where it is not.
     * @method Mottle.consume
     * @param {Event} e Event to consume
     * @param {Boolean} [doNotPreventDefault=false] If true, does not call `preventDefault()` on the event.
     */
    root.Mottle.consume = function (e, doNotPreventDefault) {
        if (e.stopPropagation)
            e.stopPropagation();
        else
            e.returnValue = false;

        if (!doNotPreventDefault && e.preventDefault)
            e.preventDefault();
    };

    /**
     * Gets the page location corresponding to the given event. For touch events this means get the page location of the first touch.
     * @method Mottle.pageLocation
     * @param {Event} e Event to get page location for.
     * @return {Number[]} [left, top] for the given event.
     */
    root.Mottle.pageLocation = _pageLocation;

    /**
     * Forces touch events to be turned "on". Useful for testing: even if you don't have a touch device, you can still
     * trigger a touch event when this is switched on and it will be captured and acted on.
     * @method setForceTouchEvents
     * @param {Boolean} value If true, force touch events to be on.
     */
    root.Mottle.setForceTouchEvents = function (value) {
        isTouchDevice = value;
    };

    /**
     * Forces mouse events to be turned "on". Useful for testing: even if you don't have a mouse, you can still
     * trigger a mouse event when this is switched on and it will be captured and acted on.
     * @method setForceMouseEvents
     * @param {Boolean} value If true, force mouse events to be on.
     */
    root.Mottle.setForceMouseEvents = function (value) {
        isMouseDevice = value;
    };

}).call(typeof window === "undefined" ? this : window);

/**
 drag/drop functionality for use with jsPlumb but with
 no knowledge of jsPlumb. supports multiple scopes (separated by whitespace), dragging
 multiple elements, constrain to parent, drop filters, drag start filters, custom
 css classes.

 a lot of the functionality of this script is expected to be plugged in:

 addClass
 removeClass

 addEvent
 removeEvent

 getPosition
 setPosition
 getSize

 indexOf
 intersects

 the name came from here:

 http://mrsharpoblunto.github.io/foswig.js/

 copyright 2016 jsPlumb
 */

;(function() {

    "use strict";
    var root = this;

    var _suggest = function(list, item, head) {
        if (list.indexOf(item) === -1) {
            head ? list.unshift(item) : list.push(item);
            return true;
        }
        return false;
    };

    var _vanquish = function(list, item) {
        var idx = list.indexOf(item);
        if (idx != -1) list.splice(idx, 1);
    };

    var _difference = function(l1, l2) {
        var d = [];
        for (var i = 0; i < l1.length; i++) {
            if (l2.indexOf(l1[i]) == -1)
                d.push(l1[i]);
        }
        return d;
    };

    var _isString = function(f) {
        return f == null ? false : (typeof f === "string" || f.constructor == String);
    };

    var getOffsetRect = function (elem) {
        // (1)
        var box = elem.getBoundingClientRect(),
            body = document.body,
            docElem = document.documentElement,
        // (2)
            scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
            scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
        // (3)
            clientTop = docElem.clientTop || body.clientTop || 0,
            clientLeft = docElem.clientLeft || body.clientLeft || 0,
        // (4)
            top  = box.top +  scrollTop - clientTop,
            left = box.left + scrollLeft - clientLeft;

        return { top: Math.round(top), left: Math.round(left) };
    };

    var matchesSelector = function(el, selector, ctx) {
        ctx = ctx || el.parentNode;
        var possibles = ctx.querySelectorAll(selector);
        for (var i = 0; i < possibles.length; i++) {
            if (possibles[i] === el)
                return true;
        }
        return false;
    };

    var iev = (function() {
            var rv = -1;
            if (navigator.appName == 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent,
                    re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                if (re.exec(ua) != null)
                    rv = parseFloat(RegExp.$1);
            }
            return rv;
        })(),
        DEFAULT_GRID_X = 50,
        DEFAULT_GRID_Y = 50,
        isIELT9 = iev > -1 && iev < 9,
        isIE9 = iev == 9,
        _pl = function(e) {
            if (isIELT9) {
                return [ e.clientX + document.documentElement.scrollLeft, e.clientY + document.documentElement.scrollTop ];
            }
            else {
                var ts = _touches(e), t = _getTouch(ts, 0);
                // for IE9 pageX might be null if the event was synthesized. We try for pageX/pageY first,
                // falling back to clientX/clientY if necessary. In every other browser we want to use pageX/pageY.
                return isIE9 ? [t.pageX || t.clientX, t.pageY || t.clientY] : [t.pageX, t.pageY];
            }
        },
        _getTouch = function(touches, idx) { return touches.item ? touches.item(idx) : touches[idx]; },
        _touches = function(e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        },
        _classes = {
            draggable:"katavorio-draggable",    // draggable elements
            droppable:"katavorio-droppable",    // droppable elements
            drag : "katavorio-drag",            // elements currently being dragged
            selected:"katavorio-drag-selected", // elements in current drag selection
            active : "katavorio-drag-active",   // droppables that are targets of a currently dragged element
            hover : "katavorio-drag-hover",     // droppables over which a matching drag element is hovering
            noSelect : "katavorio-drag-no-select", // added to the body to provide a hook to suppress text selection
            ghostProxy:"katavorio-ghost-proxy"  // added to a ghost proxy element in use when a drag has exited the bounds of its parent.
        },
        _defaultScope = "katavorio-drag-scope",
        _events = [ "stop", "start", "drag", "drop", "over", "out", "beforeStart" ],
        _devNull = function() {},
        _true = function() { return true; },
        _foreach = function(l, fn, from) {
            for (var i = 0; i < l.length; i++) {
                if (l[i] != from)
                    fn(l[i]);
            }
        },
        _setDroppablesActive = function(dd, val, andHover, drag) {
            _foreach(dd, function(e) {
                e.setActive(val);
                if (val) e.updatePosition();
                if (andHover) e.setHover(drag, val);
            });
        },
        _each = function(obj, fn) {
            if (obj == null) return;
            obj = !_isString(obj) && (obj.tagName == null && obj.length != null) ? obj : [ obj ];
            for (var i = 0; i < obj.length; i++)
                fn.apply(obj[i], [ obj[i] ]);
        },
        _consume = function(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
                e.preventDefault();
            }
            else {
                e.returnValue = false;
            }
        },
        _defaultInputFilterSelector = "input,textarea,select,button,option",
    //
    // filters out events on all input elements, like textarea, checkbox, input, select.
        _inputFilter = function(e, el, _katavorio) {
            var t = e.srcElement || e.target;
            return !matchesSelector(t, _katavorio.getInputFilterSelector(), el);
        };

    var Super = function(el, params, css, scope) {
        this.params = params || {};
        this.el = el;
        this.params.addClass(this.el, this._class);
        this.uuid = _uuid();
        var enabled = true;
        this.setEnabled = function(e) { enabled = e; };
        this.isEnabled = function() { return enabled; };
        this.toggleEnabled = function() { enabled = !enabled; };
        this.setScope = function(scopes) {
            this.scopes = scopes ? scopes.split(/\s+/) : [ scope ];
        };
        this.addScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) { m[s] = true;});
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.removeScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) { delete m[s];});
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.toggleScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) {
                if (m[s]) delete m[s];
                else m[s] = true;
            });
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.setScope(params.scope);
        this.k = params.katavorio;
        return params.katavorio;
    };

    var TRUE = function() { return true; };
    var FALSE = function() { return false; };

    var Drag = function(el, params, css, scope) {
        this._class = css.draggable;
        var k = Super.apply(this, arguments);
        this.rightButtonCanDrag = this.params.rightButtonCanDrag;
        var downAt = [0,0], posAtDown = null, pagePosAtDown = null, pageDelta = [0,0], moving = false,
            consumeStartEvent = this.params.consumeStartEvent !== false,
            dragEl = this.el,
            clone = this.params.clone,
            scroll = this.params.scroll,
            _multipleDrop = params.multipleDrop !== false,
            isConstrained = false,
            useGhostProxy = params.ghostProxy === true ? TRUE : params.ghostProxy && typeof params.ghostProxy === "function" ? params.ghostProxy : FALSE,
            ghostProxy = function(el) { return el.cloneNode(true); };

        var snapThreshold = params.snapThreshold || 5,
            _snap = function(pos, x, y, thresholdX, thresholdY) {
                thresholdX = thresholdX || snapThreshold;
                thresholdY = thresholdY || snapThreshold;
                var _dx = Math.floor(pos[0] / x),
                    _dxl = x * _dx,
                    _dxt = _dxl + x,
                    _x = Math.abs(pos[0] - _dxl) <= thresholdX ? _dxl : Math.abs(_dxt - pos[0]) <= thresholdX ? _dxt : pos[0];

                var _dy = Math.floor(pos[1] / y),
                    _dyl = y * _dy,
                    _dyt = _dyl + y,
                    _y = Math.abs(pos[1] - _dyl) <= thresholdY ? _dyl : Math.abs(_dyt - pos[1]) <= thresholdY ? _dyt : pos[1];

                return [ _x, _y];
            };

        this.posses = [];
        this.posseRoles = {};

        this.toGrid = function(pos) {
            if (this.params.grid == null) {
                return pos;
            }
            else {
                return _snap(pos, this.params.grid[0], this.params.grid[1]);
            }
        };

        this.snap = function(x, y) {
            if (dragEl == null) return;
            x = x || (this.params.grid ? this.params.grid[0] : DEFAULT_GRID_X);
            y = y || (this.params.grid ? this.params.grid[1] : DEFAULT_GRID_Y);
            var p = this.params.getPosition(dragEl);
            this.params.setPosition(dragEl, _snap(p, x, y, x, y));
        };

        this.setUseGhostProxy = function(val) {
            useGhostProxy = val ? TRUE : FALSE;
        };

        var constrain;
        var negativeFilter = function(pos) {
            return (params.allowNegative === false) ? [ Math.max (0, pos[0]), Math.max(0, pos[1]) ] : pos;
        };

        var _setConstrain = function(value) {
            constrain = typeof value === "function" ? value : value ? function(pos) {
                return negativeFilter([
                    Math.max(0, Math.min(constrainRect.w - this.size[0], pos[0])),
                    Math.max(0, Math.min(constrainRect.h - this.size[1], pos[1]))
                ]);
            }.bind(this) : function(pos) { return negativeFilter(pos); };
        }.bind(this);

        _setConstrain(typeof this.params.constrain === "function" ? this.params.constrain  : (this.params.constrain || this.params.containment));


        /**
         * Sets whether or not the Drag is constrained. A value of 'true' means constrain to parent bounds; a function
         * will be executed and returns true if the position is allowed.
         * @param value
         */
        this.setConstrain = function(value) {
            _setConstrain(value);
        };

        var revertFunction;
        /**
         * Sets a function to call on drag stop, which, if it returns true, indicates that the given element should
         * revert to its position before the previous drag.
         * @param fn
         */
        this.setRevert = function(fn) {
            revertFunction = fn;
        };

        var _assignId = function(obj) {
                if (typeof obj == "function") {
                    obj._katavorioId = _uuid();
                    return obj._katavorioId;
                } else {
                    return obj;
                }
            },
        // a map of { spec -> [ fn, exclusion ] } entries.
            _filters = {},
            _testFilter = function(e) {
                for (var key in _filters) {
                    var f = _filters[key];
                    var rv = f[0](e);
                    if (f[1]) rv = !rv;
                    if (!rv) return false;
                }
                return true;
            },
            _setFilter = this.setFilter = function(f, _exclude) {
                if (f) {
                    var key = _assignId(f);
                    _filters[key] = [
                        function(e) {
                            var t = e.srcElement || e.target, m;
                            if (_isString(f)) {
                                m = matchesSelector(t, f, el);
                            }
                            else if (typeof f === "function") {
                                m = f(e, el);
                            }
                            return m;
                        },
                            _exclude !== false
                    ];

                }
            },
            _addFilter = this.addFilter = _setFilter,
            _removeFilter = this.removeFilter = function(f) {
                var key = typeof f == "function" ? f._katavorioId : f;
                delete _filters[key];
            };

        this.clearAllFilters = function() {
            _filters = {};
        };

        this.canDrag = this.params.canDrag || _true;

        var constrainRect,
            matchingDroppables = [], intersectingDroppables = [];

        this.downListener = function(e) {
            var isNotRightClick = this.rightButtonCanDrag || (e.which !== 3 && e.button !== 2);
            if (isNotRightClick && this.isEnabled() && this.canDrag()) {
                var _f =  _testFilter(e) && _inputFilter(e, this.el, this.k);
                if (_f) {
                    if (!clone)
                        dragEl = this.el;
                    else {
                        dragEl = this.el.cloneNode(true);
                        dragEl.setAttribute("id", null);
                        dragEl.style.position = "absolute";
                        // the clone node is added to the body; getOffsetRect gives us a value
                        // relative to the body.
                        var b = getOffsetRect(this.el);
                        dragEl.style.left = b.left + "px";
                        dragEl.style.top = b.top + "px";
                        document.body.appendChild(dragEl);
                    }
                    consumeStartEvent && _consume(e);
                    downAt = _pl(e);
                    //
                    this.params.bind(document, "mousemove", this.moveListener);
                    this.params.bind(document, "mouseup", this.upListener);
                    k.markSelection(this);
                    k.markPosses(this);
                    this.params.addClass(document.body, css.noSelect);
                    _dispatch("beforeStart", {el:this.el, pos:posAtDown, e:e, drag:this});
                }
                else if (this.params.consumeFilteredEvents) {
                    _consume(e);
                }
            }
        }.bind(this);

        this.moveListener = function(e) {
            if (downAt) {
                if (!moving) {
                    var _continue = _dispatch("start", {el:this.el, pos:posAtDown, e:e, drag:this});
                    if (_continue !== false) {
                        if (!downAt) return;
                        this.mark(true);
                        moving = true;
                    }
                }

                // it is possible that the start event caused the drag to be aborted. So we check
                // again that we are currently dragging.
                if (downAt) {
                    intersectingDroppables.length = 0;
                    var pos = _pl(e), dx = pos[0] - downAt[0], dy = pos[1] - downAt[1],
                        z = this.params.ignoreZoom ? 1 : k.getZoom();
                    dx /= z;
                    dy /= z;
                    this.moveBy(dx, dy, e);
                    k.updateSelection(dx, dy, this);
                    k.updatePosses(dx, dy, this);
                }
            }
        }.bind(this);

        this.upListener = function(e) {
            if (downAt) {
                downAt = null;
                this.params.unbind(document, "mousemove", this.moveListener);
                this.params.unbind(document, "mouseup", this.upListener);
                this.params.removeClass(document.body, css.noSelect);
                this.unmark(e);
                k.unmarkSelection(this, e);
                k.unmarkPosses(this, e);
                this.stop(e);
                k.notifySelectionDragStop(this, e);
                k.notifyPosseDragStop(this, e);
                moving = false;
                if (clone) {
                    dragEl && dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
                    dragEl = null;
                }

                if (revertFunction && revertFunction(this.el, this.params.getPosition(this.el)) === true) {
                    this.params.setPosition(this.el, posAtDown);
                    _dispatch("revert", this.el);
                }
            }
        }.bind(this);

        this.getFilters = function() { return _filters; };

        this.abort = function() {
            if (downAt != null)
                this.upListener();
        };

        this.getDragElement = function() {
            return dragEl || this.el;
        };

        var listeners = {"start":[], "drag":[], "stop":[], "over":[], "out":[], "beforeStart":[], "revert":[] };
        if (params.events.start) listeners.start.push(params.events.start);
        if (params.events.beforeStart) listeners.beforeStart.push(params.events.beforeStart);
        if (params.events.stop) listeners.stop.push(params.events.stop);
        if (params.events.drag) listeners.drag.push(params.events.drag);
        if (params.events.revert) listeners.revert.push(params.events.revert);

        this.on = function(evt, fn) {
            if (listeners[evt]) listeners[evt].push(fn);
        };

        this.off = function(evt, fn) {
            if (listeners[evt]) {
                var l = [];
                for (var i = 0; i < listeners[evt].length; i++) {
                    if (listeners[evt][i] !== fn) l.push(listeners[evt][i]);
                }
                listeners[evt] = l;
            }
        };

        var _dispatch = function(evt, value) {
            if (listeners[evt]) {
                for (var i = 0; i < listeners[evt].length; i++) {
                    try {
                        listeners[evt][i](value);
                    }
                    catch (e) { }
                }
            }
        };

        this.notifyStart = function(e) {
            _dispatch("start", {el:this.el, pos:this.params.getPosition(dragEl), e:e, drag:this});
        };

        this.stop = function(e, force) {
            if (force || moving) {
                var positions = [],
                    sel = k.getSelection(),
                    dPos = this.params.getPosition(dragEl);

                if (sel.length > 1) {
                    for (var i = 0; i < sel.length; i++) {
                        var p = this.params.getPosition(sel[i].el);
                        positions.push([ sel[i].el, { left: p[0], top: p[1] }, sel[i] ]);
                    }
                }
                else {
                    positions.push([ dragEl, {left:dPos[0], top:dPos[1]}, this ]);
                }

                _dispatch("stop", {
                    el: dragEl,
                    pos: ghostProxyOffsets || dPos,
                    finalPos:dPos,
                    e: e,
                    drag: this,
                    selection:positions
                });
            }
        };

        this.mark = function(andNotify) {
            posAtDown = this.params.getPosition(dragEl);
            pagePosAtDown = this.params.getPosition(dragEl, true);
            pageDelta = [pagePosAtDown[0] - posAtDown[0], pagePosAtDown[1] - posAtDown[1]];
            this.size = this.params.getSize(dragEl);
            matchingDroppables = k.getMatchingDroppables(this);
            _setDroppablesActive(matchingDroppables, true, false, this);
            this.params.addClass(dragEl, this.params.dragClass || css.drag);
            //if (this.params.constrain || this.params.containment) {
            var cs = this.params.getSize(dragEl.parentNode);
            constrainRect = { w:cs[0], h:cs[1] };
            //}
            if (andNotify) {
                k.notifySelectionDragStart(this);
            }
        };
        var ghostProxyOffsets;
        this.unmark = function(e, doNotCheckDroppables) {
            _setDroppablesActive(matchingDroppables, false, true, this);


            if (isConstrained && useGhostProxy()) {
                ghostProxyOffsets = [dragEl.offsetLeft, dragEl.offsetTop];
                this.el.parentNode.removeChild(dragEl);
                dragEl = this.el;
            }
            else {
                ghostProxyOffsets = null;
            }

            this.params.removeClass(dragEl, this.params.dragClass || css.drag);
            matchingDroppables.length = 0;
            isConstrained = false;
            if (!doNotCheckDroppables) {
                if (intersectingDroppables.length > 0 && ghostProxyOffsets) {
                    params.setPosition(this.el, ghostProxyOffsets);
                }
                for (var i = 0; i < intersectingDroppables.length; i++) {
                    var retVal = intersectingDroppables[i].drop(this, e);
                    if (retVal === true) break;
                }
            }
        };
        this.moveBy = function(dx, dy, e) {
            intersectingDroppables.length = 0;
            var desiredLoc = this.toGrid([posAtDown[0] + dx, posAtDown[1] + dy]),
                cPos = constrain(desiredLoc, dragEl);

            if (useGhostProxy()) {
                if (desiredLoc[0] != cPos[0] || desiredLoc[1] != cPos[1]) {
                    if (!isConstrained) {
                        var gp = ghostProxy(this.el);
                        params.addClass(gp, _classes.ghostProxy);
                        this.el.parentNode.appendChild(gp);
                        dragEl = gp;
                        isConstrained = true;
                    }
                    cPos = desiredLoc;
                }
                else {
                    if (isConstrained) {
                        this.el.parentNode.removeChild(dragEl);
                        dragEl = this.el;
                        isConstrained = false;
                    }
                }
            }

            var rect = { x:cPos[0], y:cPos[1], w:this.size[0], h:this.size[1]},
                pageRect = { x:rect.x + pageDelta[0], y:rect.y + pageDelta[1], w:rect.w, h:rect.h},
                focusDropElement = null;



            this.params.setPosition(dragEl, cPos);
            for (var i = 0; i < matchingDroppables.length; i++) {
                var r2 = { x:matchingDroppables[i].pagePosition[0], y:matchingDroppables[i].pagePosition[1], w:matchingDroppables[i].size[0], h:matchingDroppables[i].size[1]};
                if (this.params.intersects(pageRect, r2) && (_multipleDrop || focusDropElement == null || focusDropElement == matchingDroppables[i].el) && matchingDroppables[i].canDrop(this)) {
                    if (!focusDropElement) focusDropElement = matchingDroppables[i].el;
                    intersectingDroppables.push(matchingDroppables[i]);
                    matchingDroppables[i].setHover(this, true, e);
                }
                else if (matchingDroppables[i].isHover()) {
                    matchingDroppables[i].setHover(this, false, e);
                }
            }

            _dispatch("drag", {el:this.el, pos:cPos, e:e, drag:this});

            /* test to see if the parent needs to be scrolled (future)
             if (scroll) {
             var pnsl = dragEl.parentNode.scrollLeft, pnst = dragEl.parentNode.scrollTop;
             console.log("scroll!", pnsl, pnst);
             }*/
        };
        this.destroy = function() {
            this.params.unbind(this.el, "mousedown", this.downListener);
            this.params.unbind(document, "mousemove", this.moveListener);
            this.params.unbind(document, "mouseup", this.upListener);
            this.downListener = null;
            this.upListener = null;
            this.moveListener = null;
        };

        // init:register mousedown, and perhaps set a filter
        this.params.bind(this.el, "mousedown", this.downListener);

        // if handle provded, use that.  otherwise, try to set a filter.
        // note that a `handle` selector always results in filterExclude being set to false, ie.
        // the selector defines the handle element(s).
        if (this.params.handle)
            _setFilter(this.params.handle, false);
        else
            _setFilter(this.params.filter, this.params.filterExclude);
    };

    var Drop = function(el, params, css, scope) {
        this._class = css.droppable;
        this.params = params || {};
        this._activeClass = this.params.activeClass || css.active;
        this._hoverClass = this.params.hoverClass || css.hover;
        Super.apply(this, arguments);
        var hover = false;
        this.allowLoopback = this.params.allowLoopback !== false;

        this.setActive = function(val) {
            this.params[val ? "addClass" : "removeClass"](this.el, this._activeClass);
        };

        this.updatePosition = function() {
            this.position = this.params.getPosition(this.el);
            this.pagePosition = this.params.getPosition(this.el, true);
            this.size = this.params.getSize(this.el);
        };

        this.canDrop = this.params.canDrop || function(drag) {
            return true;
        };

        this.isHover = function() { return hover; };

        this.setHover = function(drag, val, e) {
            // if turning off hover but this was not the drag that caused the hover, ignore.
            if (val || this.el._katavorioDragHover == null || this.el._katavorioDragHover == drag.el._katavorio) {
                this.params[val ? "addClass" : "removeClass"](this.el, this._hoverClass);
                //this.el._katavorioDragHover = val ? drag.el._katavorio : null;
                this.el._katavorioDragHover = val ? drag.el._katavorio : null;
                if (hover !== val)
                    this.params.events[val ? "over" : "out"]({el:this.el, e:e, drag:drag, drop:this});
                hover = val;
            }
        };

        this.drop = function(drag, event) {
            return this.params.events["drop"]({ drag:drag, e:event, drop:this });
        };

        this.destroy = function() {
            this._class = null;
            this._activeClass = null;
            this._hoverClass = null;
            //this.params = null;
            hover = null;
            //this.el = null;
        };
    };

    var _uuid = function() {
        return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        }));
    };

    var _gel = function(el) {
        if (el == null) return null;
        el = (typeof el === "string" || el.constructor == String)  ? document.getElementById(el) : el;
        if (el == null) return null;
        el._katavorio = el._katavorio || _uuid();
        return el;
    };

    root.Katavorio = function(katavorioParams) {

        var _selection = [],
            _selectionMap = {};

        this._dragsByScope = {};
        this._dropsByScope = {};
        var _zoom = 1,
            _reg = function(obj, map) {
                _each(obj, function(_obj) {
                    for(var i = 0; i < _obj.scopes.length; i++) {
                        map[_obj.scopes[i]] = map[_obj.scopes[i]] || [];
                        map[_obj.scopes[i]].push(_obj);
                    }
                });
            },
            _unreg = function(obj, map) {
                var c = 0;
                _each(obj, function(_obj) {
                    for(var i = 0; i < _obj.scopes.length; i++) {
                        if (map[_obj.scopes[i]]) {
                            var idx = katavorioParams.indexOf(map[_obj.scopes[i]], _obj);
                            if (idx != -1) {
                                map[_obj.scopes[i]].splice(idx, 1);
                                c++;
                            }
                        }
                    }
                });

                return c > 0 ;
            },
            _getMatchingDroppables = this.getMatchingDroppables = function(drag) {
                var dd = [], _m = {};
                for (var i = 0; i < drag.scopes.length; i++) {
                    var _dd = this._dropsByScope[drag.scopes[i]];
                    if (_dd) {
                        for (var j = 0; j < _dd.length; j++) {
                            if (_dd[j].canDrop(drag) &&  !_m[_dd[j].uuid] && (_dd[j].allowLoopback || _dd[j].el !== drag.el)) {
                                _m[_dd[j].uuid] = true;
                                dd.push(_dd[j]);
                            }
                        }
                    }
                }
                return dd;
            },
            _prepareParams = function(p) {
                p = p || {};
                var _p = {
                    events:{}
                }, i;
                for (i in katavorioParams) _p[i] = katavorioParams[i];
                for (i in p) _p[i] = p[i];
                // events

                for (i = 0; i < _events.length; i++) {
                    _p.events[_events[i]] = p[_events[i]] || _devNull;
                }
                _p.katavorio = this;
                return _p;
            }.bind(this),
            _mistletoe = function(existingDrag, params) {
                for (var i = 0; i < _events.length; i++) {
                    if (params[_events[i]]) {
                        existingDrag.on(_events[i], params[_events[i]]);
                    }
                }
            }.bind(this),
            _css = {},
            overrideCss = katavorioParams.css || {},
            _scope = katavorioParams.scope || _defaultScope;

        // prepare map of css classes based on defaults frst, then optional overrides
        for (var i in _classes) _css[i] = _classes[i];
        for (var i in overrideCss) _css[i] = overrideCss[i];

        var inputFilterSelector = katavorioParams.inputFilterSelector || _defaultInputFilterSelector;
        /**
         * Gets the selector identifying which input elements to filter from drag events.
         * @method getInputFilterSelector
         * @return {String} Current input filter selector.
         */
        this.getInputFilterSelector = function() { return inputFilterSelector; };

        /**
         * Sets the selector identifying which input elements to filter from drag events.
         * @method setInputFilterSelector
         * @param {String} selector Input filter selector to set.
         * @return {Katavorio} Current instance; method may be chained.
         */
        this.setInputFilterSelector = function(selector) {
            inputFilterSelector = selector;
            return this;
        };

        this.draggable = function(el, params) {
            var o = [];
            _each(el, function(_el) {
                _el = _gel(_el);
                if (_el != null) {
                    if (_el._katavorioDrag == null) {
                        var p = _prepareParams(params);
                        _el._katavorioDrag = new Drag(_el, p, _css, _scope);
                        _reg(_el._katavorioDrag, this._dragsByScope);
                        o.push(_el._katavorioDrag);
                        katavorioParams.addClass(_el, _css.draggable);
                    }
                    else {
                        _mistletoe(_el._katavorioDrag, params);
                    }
                }
            }.bind(this));
            return o;

        };

        this.droppable = function(el, params) {
            var o = [];
            _each(el, function(_el) {
                _el = _gel(_el);
                if (_el != null) {
                    var drop = new Drop(_el, _prepareParams(params), _css, _scope);
                    _el._katavorioDrop = _el._katavorioDrop || [];
                    _el._katavorioDrop.push(drop);
                    _reg(drop, this._dropsByScope);
                    o.push(drop);
                    katavorioParams.addClass(_el, _css.droppable);
                }
            }.bind(this));
            return o;
        };

        /**
         * @name Katavorio#select
         * @function
         * @desc Adds an element to the current selection (for multiple node drag)
         * @param {Element|String} DOM element - or id of the element - to add.
         */
        this.select = function(el) {
            _each(el, function() {
                var _el = _gel(this);
                if (_el && _el._katavorioDrag) {
                    if (!_selectionMap[_el._katavorio]) {
                        _selection.push(_el._katavorioDrag);
                        _selectionMap[_el._katavorio] = [ _el, _selection.length - 1 ];
                        katavorioParams.addClass(_el, _css.selected);
                    }
                }
            });
            return this;
        };

        /**
         * @name Katavorio#deselect
         * @function
         * @desc Removes an element from the current selection (for multiple node drag)
         * @param {Element|String} DOM element - or id of the element - to remove.
         */
        this.deselect = function(el) {
            _each(el, function() {
                var _el = _gel(this);
                if (_el && _el._katavorio) {
                    var e = _selectionMap[_el._katavorio];
                    if (e) {
                        var _s = [];
                        for (var i = 0; i < _selection.length; i++)
                            if (_selection[i].el !== _el) _s.push(_selection[i]);
                        _selection = _s;
                        delete _selectionMap[_el._katavorio];
                        katavorioParams.removeClass(_el, _css.selected);
                    }
                }
            });
            return this;
        };

        this.deselectAll = function() {
            for (var i in _selectionMap) {
                var d = _selectionMap[i];
                katavorioParams.removeClass(d[0], _css.selected);
            }

            _selection.length = 0;
            _selectionMap = {};
        };

        this.markSelection = function(drag) {
            _foreach(_selection, function(e) { e.mark(); }, drag);
        };

        this.markPosses = function(drag) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (d) {
                            d.mark();
                        }, drag);
                    }
                })
            }
        };

        this.unmarkSelection = function(drag, event) {
            _foreach(_selection, function(e) { e.unmark(event); }, drag);
        };

        this.unmarkPosses = function(drag, event) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (d) {
                            d.unmark(event, true);
                        }, drag);
                    }
                });
            }
        };

        this.getSelection = function() { return _selection.slice(0); };

        this.updateSelection = function(dx, dy, drag) {
            _foreach(_selection, function(e) { e.moveBy(dx, dy); }, drag);
        };

        var _posseAction = function(fn, drag) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (e) {
                            fn(e);
                        }, drag);
                    }
                });
            }
        };

        this.updatePosses = function(dx, dy, drag) {
            _posseAction(function(e) { e.moveBy(dx, dy); }, drag);
        };

        this.notifyPosseDragStop = function(drag, evt) {
            _posseAction(function(e) { e.stop(evt, true); }, drag);
        };

        this.notifySelectionDragStop = function(drag, evt) {
            _foreach(_selection, function(e) { e.stop(evt, true); }, drag);
        };

        this.notifySelectionDragStart = function(drag, evt) {
            _foreach(_selection, function(e) { e.notifyStart(evt);}, drag);
        };

        this.setZoom = function(z) { _zoom = z; };
        this.getZoom = function() { return _zoom; };

        // does the work of changing scopes
        var _scopeManip = function(kObj, scopes, map, fn) {
            _each(kObj, function(_kObj) {
                _unreg(_kObj, map);  // deregister existing scopes
                _kObj[fn](scopes); // set scopes
                _reg(_kObj, map); // register new ones
            });
        };

        _each([ "set", "add", "remove", "toggle"], function(v) {
            this[v + "Scope"] = function(el, scopes) {
                _scopeManip(el._katavorioDrag, scopes, this._dragsByScope, v + "Scope");
                _scopeManip(el._katavorioDrop, scopes, this._dropsByScope, v + "Scope");
            }.bind(this);
            this[v + "DragScope"] = function(el, scopes) {
                _scopeManip(el.constructor === Drag ? el : el._katavorioDrag, scopes, this._dragsByScope, v + "Scope");
            }.bind(this);
            this[v + "DropScope"] = function(el, scopes) {
                _scopeManip(el.constructor === Drop ? el : el._katavorioDrop, scopes, this._dropsByScope, v + "Scope");
            }.bind(this);
        }.bind(this));

        this.snapToGrid = function(x, y) {
            for (var s in this._dragsByScope) {
                _foreach(this._dragsByScope[s], function(d) { d.snap(x, y); });
            }
        };

        this.getDragsForScope = function(s) { return this._dragsByScope[s]; };
        this.getDropsForScope = function(s) { return this._dropsByScope[s]; };

        var _destroy = function(el, type, map) {
            el = _gel(el);
            if (el[type]) {
                if (_unreg(el[type], map)) {
                    _each(el[type], function(kObj) { kObj.destroy() });
                }

                delete el[type];
            }
        };

        this.elementRemoved = function(el) {
            this.destroyDraggable(el);
            this.destroyDroppable(el);
        };

        this.destroyDraggable = function(el) {
            _destroy(el, "_katavorioDrag", this._dragsByScope);
        };

        this.destroyDroppable = function(el) {
            _destroy(el, "_katavorioDrop", this._dropsByScope);
        };

        this.reset = function() {
            this._dragsByScope = {};
            this._dropsByScope = {};
            _selection = [];
            _selectionMap = {};
            _posses = {};
        };

        // ----- groups
        var _posses = {};

        var _processOneSpec = function(el, _spec, dontAddExisting) {
            var posseId = _isString(_spec) ? _spec : _spec.id;
            var active = _isString(_spec) ? true : _spec.active !== false;
            var posse = _posses[posseId] || (function() {
                var g = {name:posseId, members:[]};
                _posses[posseId] = g;
                return g;
            })();
            _each(el, function(_el) {
                if (_el._katavorioDrag) {

                    if (dontAddExisting && _el._katavorioDrag.posseRoles[posse.name] != null) return;

                    _suggest(posse.members, _el._katavorioDrag);
                    _suggest(_el._katavorioDrag.posses, posse.name);
                    _el._katavorioDrag.posseRoles[posse.name] = active;
                }
            });
            return posse;
        };

        /**
         * Add the given element to the posse with the given id, creating the group if it at first does not exist.
         * @method addToPosse
         * @param {Element} el Element to add.
         * @param {String...|Object...} spec Variable args parameters. Each argument can be a either a String, indicating
         * the ID of a Posse to which the element should be added as an active participant, or an Object containing
         * `{ id:"posseId", active:false/true}`. In the latter case, if `active` is not provided it is assumed to be
         * true.
         * @returns {Posse|Posse[]} The Posse(s) to which the element(s) was/were added.
         */
        this.addToPosse = function(el, spec) {

            var posses = [];

            for (var i = 1; i < arguments.length; i++) {
                posses.push(_processOneSpec(el, arguments[i]));
            }

            return posses.length == 1 ? posses[0] : posses;
        };

        /**
         * Sets the posse(s) for the element with the given id, creating those that do not yet exist, and removing from
         * the element any current Posses that are not specified by this method call. This method will not change the
         * active/passive state if it is given a posse in which the element is already a member.
         * @method setPosse
         * @param {Element} el Element to set posse(s) on.
         * @param {String...|Object...} spec Variable args parameters. Each argument can be a either a String, indicating
         * the ID of a Posse to which the element should be added as an active participant, or an Object containing
         * `{ id:"posseId", active:false/true}`. In the latter case, if `active` is not provided it is assumed to be
         * true.
         * @returns {Posse|Posse[]} The Posse(s) to which the element(s) now belongs.
         */
        this.setPosse = function(el, spec) {

            var posses = [];

            for (var i = 1; i < arguments.length; i++) {
                posses.push(_processOneSpec(el, arguments[i], true).name);
            }

            _each(el, function(_el) {
                if (_el._katavorioDrag) {
                    var diff = _difference(_el._katavorioDrag.posses, posses);
                    var p = [];
                    Array.prototype.push.apply(p, _el._katavorioDrag.posses);
                    for (var i = 0; i < diff.length; i++) {
                        this.removeFromPosse(_el, diff[i]);
                    }
                }
            }.bind(this));

            return posses.length == 1 ? posses[0] : posses;
        };

        /**
         * Remove the given element from the given posse(s).
         * @method removeFromPosse
         * @param {Element} el Element to remove.
         * @param {String...} posseId Varargs parameter: one value for each posse to remove the element from.
         */
        this.removeFromPosse = function(el, posseId) {
            if (arguments.length < 2) throw new TypeError("No posse id provided for remove operation");
            for(var i = 1; i < arguments.length; i++) {
                posseId = arguments[i];
                _each(el, function (_el) {
                    if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                        var d = _el._katavorioDrag;
                        _each(posseId, function (p) {
                            _vanquish(_posses[p].members, d);
                            _vanquish(d.posses, p);
                            delete d.posseRoles[p];
                        });
                    }
                });
            }
        };

        /**
         * Remove the given element from all Posses to which it belongs.
         * @method removeFromAllPosses
         * @param {Element|Element[]} el Element to remove from Posses.
         */
        this.removeFromAllPosses = function(el) {
            _each(el, function(_el) {
                if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                    var d = _el._katavorioDrag;
                    _each(d.posses, function(p) {
                        _vanquish(_posses[p].members, d);
                    });
                    d.posses.length = 0;
                    d.posseRoles = {};
                }
            });
        };

        /**
         * Changes the participation state for the element in the Posse with the given ID.
         * @param {Element|Element[]} el Element(s) to change state for.
         * @param {String} posseId ID of the Posse to change element state for.
         * @param {Boolean} state True to make active, false to make passive.
         */
        this.setPosseState = function(el, posseId, state) {
            var posse = _posses[posseId];
            if (posse) {
                _each(el, function(_el) {
                    if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                        _el._katavorioDrag.posseRoles[posse.name] = state;
                    }
                });
            }
        };
    };
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.1.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains utility functions that run in both browsers and headless.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */

;
(function () {

    var _isa = function (a) {
            return Object.prototype.toString.call(a) === "[object Array]";
        },
        _isnum = function (n) {
            return Object.prototype.toString.call(n) === "[object Number]";
        },
        _iss = function (s) {
            return typeof s === "string";
        },
        _isb = function (s) {
            return typeof s === "boolean";
        },
        _isnull = function (s) {
            return s == null;
        },
        _iso = function (o) {
            return o == null ? false : Object.prototype.toString.call(o) === "[object Object]";
        },
        _isd = function (o) {
            return Object.prototype.toString.call(o) === "[object Date]";
        },
        _isf = function (o) {
            return Object.prototype.toString.call(o) === "[object Function]";
        },
        _isNamedFunction = function(o) {
            return _isf(o) && o.name != null && o.name.length > 0;
        },
        _ise = function (o) {
            for (var i in o) {
                if (o.hasOwnProperty(i)) return false;
            }
            return true;
        };

    var root = this;
    var exports = root.jsPlumbUtil = {
        isArray: _isa,
        isString: _iss,
        isBoolean: _isb,
        isNull: _isnull,
        isObject: _iso,
        isDate: _isd,
        isFunction: _isf,
        isEmpty: _ise,
        isNumber: _isnum,
        clone: function (a) {
            if (_iss(a)) return "" + a;
            else if (_isb(a)) return !!a;
            else if (_isd(a)) return new Date(a.getTime());
            else if (_isf(a)) return a;
            else if (_isa(a)) {
                var b = [];
                for (var i = 0; i < a.length; i++)
                    b.push(this.clone(a[i]));
                return b;
            }
            else if (_iso(a)) {
                var c = {};
                for (var j in a)
                    c[j] = this.clone(a[j]);
                return c;
            }
            else return a;
        },
        merge: function (a, b, collations) {
            // first change the collations array - if present - into a lookup table, because its faster.
            var cMap = {}, ar, i;
            collations = collations || [];
            for (i = 0; i < collations.length; i++)
                cMap[collations[i]] = true;

            var c = this.clone(a);
            for (i in b) {
                if (c[i] == null) {
                    c[i] = b[i];
                }
                else if (_iss(b[i]) || _isb(b[i])) {
                    if (!cMap[i]) {
                        c[i] = b[i]; // if we dont want to collate, just copy it in.
                    }
                    else {
                        ar = [];
                        // if c's object is also an array we can keep its values.
                        ar.push.apply(ar, _isa(c[i]) ? c[i] : [ c[i] ]);
                        ar.push.apply(ar, _isa(b[i]) ? b[i] : [ b[i] ]);
                        c[i] = ar;
                    }
                }
                else {
                    if (_isa(b[i])) {
                        ar = [];
                        // if c's object is also an array we can keep its values.
                        if (_isa(c[i])) ar.push.apply(ar, c[i]);
                        ar.push.apply(ar, b[i]);
                        c[i] = ar;
                    }
                    else if (_iso(b[i])) {
                        // overwite c's value with an object if it is not already one.
                        if (!_iso(c[i]))
                            c[i] = {};
                        for (var j in b[i]) {
                            c[i][j] = b[i][j];
                        }
                    }
                }

            }
            return c;
        },
        replace: function (inObj, path, value) {
            if (inObj == null) return;
            var q = inObj, t = q;
            path.replace(/([^\.])+/g, function (term, lc, pos, str) {
                var array = term.match(/([^\[0-9]+){1}(\[)([0-9+])/),
                    last = pos + term.length >= str.length,
                    _getArray = function () {
                        return t[array[1]] || (function () {
                            t[array[1]] = [];
                            return t[array[1]];
                        })();
                    };

                if (last) {
                    // set term = value on current t, creating term as array if necessary.
                    if (array)
                        _getArray()[array[3]] = value;
                    else
                        t[term] = value;
                }
                else {
                    // set to current t[term], creating t[term] if necessary.
                    if (array) {
                        var a = _getArray();
                        t = a[array[3]] || (function () {
                            a[array[3]] = {};
                            return a[array[3]];
                        })();
                    }
                    else
                        t = t[term] || (function () {
                            t[term] = {};
                            return t[term];
                        })();
                }
            });

            return inObj;
        },
        //
        // chain a list of functions, supplied by [ object, method name, args ], and return on the first
        // one that returns the failValue. if none return the failValue, return the successValue.
        //
        functionChain: function (successValue, failValue, fns) {
            for (var i = 0; i < fns.length; i++) {
                var o = fns[i][0][fns[i][1]].apply(fns[i][0], fns[i][2]);
                if (o === failValue) {
                    return o;
                }
            }
            return successValue;
        },
        // take the given model and expand out any parameters.
        // 'functionPrefix' is optional, and if present, helps jsplumb figure out what to do if a value is a Function.
        // if you do not provide it, jsplumb will run the given values through any functions it finds, and use the function's
        // output as the value in the result. if you do provide the prefix, only functions that are named and have this prefix
        // will be executed; other functions will be passed as values to the output.
        populate: function (model, values, functionPrefix) {
            // for a string, see if it has parameter matches, and if so, try to make the substitutions.
            var getValue = function (fromString) {
                    var matches = fromString.match(/(\${.*?})/g);
                    if (matches != null) {
                        for (var i = 0; i < matches.length; i++) {
                            var val = values[matches[i].substring(2, matches[i].length - 1)] || "";
                            if (val != null) {
                                fromString = fromString.replace(matches[i], val);
                            }
                        }
                    }
                    return fromString;
                },
            // process one entry.
                _one = function (d) {
                    if (d != null) {
                        if (_iss(d)) {
                            return getValue(d);
                        }
                        else if (_isf(d) && (functionPrefix == null || (d.name || "").indexOf(functionPrefix) === 0)) {
                            return d(values);
                        }
                        else if (_isa(d)) {
                            var r = [];
                            for (var i = 0; i < d.length; i++)
                                r.push(_one(d[i]));
                            return r;
                        }
                        else if (_iso(d)) {
                            var s = {};
                            for (var j in d) {
                                s[j] = _one(d[j]);
                            }
                            return s;
                        }
                        else {
                            return d;
                        }
                    }
                };

            return _one(model);
        },
        findWithFunction: function (a, f) {
            if (a)
                for (var i = 0; i < a.length; i++) if (f(a[i])) return i;
            return -1;
        },
        removeWithFunction: function (a, f) {
            var idx = exports.findWithFunction(a, f);
            if (idx > -1) a.splice(idx, 1);
            return idx != -1;
        },
        remove: function (l, v) {
            var idx = l.indexOf(v);
            if (idx > -1) l.splice(idx, 1);
            return idx != -1;
        },
        // TODO support insert index
        addWithFunction: function (list, item, hashFunction) {
            if (exports.findWithFunction(list, hashFunction) == -1) list.push(item);
        },
        addToList: function (map, key, value, insertAtStart) {
            var l = map[key];
            if (l == null) {
                l = [];
                map[key] = l;
            }
            l[insertAtStart ? "unshift" : "push"](value);
            return l;
        },
        suggest : function(list, item, insertAtHead) {
            if (list.indexOf(item) === -1) {
                if (insertAtHead) {
                    list.unshift(item);
                } else {
                    list.push(item);
                }
                return true;
            }
            return false;
        },
        //
        // extends the given obj (which can be an array) with the given constructor function, prototype functions, and
        // class members, any of which may be null.
        //
        extend: function (child, parent, _protoFn) {
            var i;
            parent = _isa(parent) ? parent : [ parent ];

            for (i = 0; i < parent.length; i++) {
                for (var j in parent[i].prototype) {
                    if (parent[i].prototype.hasOwnProperty(j)) {
                        child.prototype[j] = parent[i].prototype[j];
                    }
                }
            }

            var _makeFn = function (name, protoFn) {
                return function () {
                    for (i = 0; i < parent.length; i++) {
                        if (parent[i].prototype[name])
                            parent[i].prototype[name].apply(this, arguments);
                    }
                    return protoFn.apply(this, arguments);
                };
            };

            var _oneSet = function (fns) {
                for (var k in fns) {
                    child.prototype[k] = _makeFn(k, fns[k]);
                }
            };

            if (arguments.length > 2) {
                for (i = 2; i < arguments.length; i++)
                    _oneSet(arguments[i]);
            }

            return child;
        },
        uuid: function () {
            return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            }));
        },
        logEnabled: true,
        log: function () {
            if (exports.logEnabled && typeof console != "undefined") {
                try {
                    var msg = arguments[arguments.length - 1];
                    console.log(msg);
                }
                catch (e) {
                }
            }
        },

        /**
         * Wraps one function with another, creating a placeholder for the
         * wrapped function if it was null. this is used to wrap the various
         * drag/drop event functions - to allow jsPlumb to be notified of
         * important lifecycle events without imposing itself on the user's
         * drag/drop functionality.
         * @method jsPlumbUtil.wrap
         * @param {Function} wrappedFunction original function to wrap; may be null.
         * @param {Function} newFunction function to wrap the original with.
         * @param {Object} [returnOnThisValue] Optional. Indicates that the wrappedFunction should
         * not be executed if the newFunction returns a value matching 'returnOnThisValue'.
         * note that this is a simple comparison and only works for primitives right now.
         */
        wrap: function (wrappedFunction, newFunction, returnOnThisValue) {
            wrappedFunction = wrappedFunction || function () {
            };
            newFunction = newFunction || function () {
            };
            return function () {
                var r = null;
                try {
                    r = newFunction.apply(this, arguments);
                } catch (e) {
                    exports.log("jsPlumb function failed : " + e);
                }
                if (returnOnThisValue == null || (r !== returnOnThisValue)) {
                    try {
                        r = wrappedFunction.apply(this, arguments);
                    } catch (e) {
                        exports.log("wrapped function failed : " + e);
                    }
                }
                return r;
            };
        }
    };

    exports.EventGenerator = function () {
        var _listeners = {},
            eventsSuspended = false,
        // this is a list of events that should re-throw any errors that occur during their dispatch. it is current private.
            eventsToDieOn = { "ready": true };

        this.bind = function (event, listener, insertAtStart) {
            var _one = function(evt) {
                exports.addToList(_listeners, evt, listener, insertAtStart);
                listener.__jsPlumb = listener.__jsPlumb || {};
                listener.__jsPlumb[root.jsPlumbUtil.uuid()] = evt;
            };

            if (typeof event === "string") _one(event);
            else if (event.length != null) {
                for (var i = 0; i < event.length; i++) {
                    _one(event[i]);
                }
            }

            return this;
        };

        this.fire = function (event, value, originalEvent) {
            if (!eventsSuspended && _listeners[event]) {
                var l = _listeners[event].length, i = 0, _gone = false, ret = null;
                if (!this.shouldFireEvent || this.shouldFireEvent(event, value, originalEvent)) {
                    while (!_gone && i < l && ret !== false) {
                        // doing it this way rather than catching and then possibly re-throwing means that an error propagated by this
                        // method will have the whole call stack available in the debugger.
                        if (eventsToDieOn[event])
                            _listeners[event][i].apply(this, [ value, originalEvent]);
                        else {
                            try {
                                ret = _listeners[event][i].apply(this, [ value, originalEvent ]);
                            } catch (e) {
                                exports.log("jsPlumb: fire failed for event " + event + " : " + e);
                            }
                        }
                        i++;
                        if (_listeners == null || _listeners[event] == null)
                            _gone = true;
                    }
                }
            }
            return this;
        };

        this.unbind = function (eventOrListener, listener) {

            if (arguments.length === 0) {
                _listeners = {};
            }
            else if (arguments.length === 1) {
                if (typeof eventOrListener === "string")
                    delete _listeners[eventOrListener];
                else if (eventOrListener.__jsPlumb) {
                    var evt;
                    for (var i in eventOrListener.__jsPlumb) {
                        evt = eventOrListener.__jsPlumb[i];
                        exports.remove(_listeners[evt] || [], eventOrListener);
                    }
                }
            }
            else if (arguments.length === 2) {
                exports.remove(_listeners[eventOrListener] || [], listener);
            }

            return this;
        };

        this.getListener = function (forEvent) {
            return _listeners[forEvent];
        };
        this.setSuspendEvents = function (val) {
            eventsSuspended = val;
        };
        this.isSuspendEvents = function () {
            return eventsSuspended;
        };
        this.silently = function(fn) {
            this.setSuspendEvents(true);
            try {
                fn();
            }
            catch (e) {
                root.jsPlumbUtil.log("Cannot execute silent function " + e);
            }
            this.setSuspendEvents(false);
        };
        this.cleanupListeners = function () {
            for (var i in _listeners) {
                _listeners[i] = null;
            }
        };
    };

    exports.EventGenerator.prototype = {
        cleanup: function () {
            this.cleanupListeners();
        }
    };

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.1.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains utility functions that run in browsers only.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
 ;(function() {

  "use strict";

   var root = this;
   var exports = root.jsPlumbUtil;

   exports.matchesSelector = function(el, selector, ctx) {
       ctx = ctx || el.parentNode;
       var possibles = ctx.querySelectorAll(selector);
       for (var i = 0; i < possibles.length; i++) {
           if (possibles[i] === el)
               return true;
       }
       return false;
   };

   exports.consume = function(e, doNotPreventDefault) {
       if (e.stopPropagation)
           e.stopPropagation();
       else
           e.returnValue = false;

       if (!doNotPreventDefault && e.preventDefault)
            e.preventDefault();
   };

   /*
    * Function: sizeElement
    * Helper to size and position an element. You would typically use
    * this when writing your own Connector or Endpoint implementation.
    *
    * Parameters:
    *  x - [int] x position for the element origin
    *  y - [int] y position for the element origin
    *  w - [int] width of the element
    *  h - [int] height of the element
    *
    */
   exports.sizeElement = function(el, x, y, w, h) {
       if (el) {
           el.style.height = h + "px";
           el.height = h;
           el.style.width = w + "px";
           el.width = w;
           el.style.left = x + "px";
           el.style.top = y + "px";
       }
   };


 }).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.1.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the core code.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
(function () {

    "use strict";

    var root = this;
    var connectorTypes = [], rendererTypes;

    var _ju = root.jsPlumbUtil,
        _getOffset = function (el, _instance, relativeToRoot) {
            return _instance.getOffset(el, relativeToRoot);
        },

        /**
         * creates a timestamp, using milliseconds since 1970, but as a string.
         */
        _timestamp = function () {
            return "" + (new Date()).getTime();
        },

    // helper method to update the hover style whenever it, or paintStyle, changes.
    // we use paintStyle as the foundation and merge hoverPaintStyle over the
    // top.
        _updateHoverStyle = function (component) {
            if (component._jsPlumb.paintStyle && component._jsPlumb.hoverPaintStyle) {
                var mergedHoverStyle = {};
                jsPlumb.extend(mergedHoverStyle, component._jsPlumb.paintStyle);
                jsPlumb.extend(mergedHoverStyle, component._jsPlumb.hoverPaintStyle);
                delete component._jsPlumb.hoverPaintStyle;
                // we want the fillStyle of paintStyle to override a gradient, if possible.
                if (mergedHoverStyle.gradient && component._jsPlumb.paintStyle.fillStyle)
                    delete mergedHoverStyle.gradient;
                component._jsPlumb.hoverPaintStyle = mergedHoverStyle;
            }
        },
        events = ["tap", "dbltap", "click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "contextmenu" ],
        eventFilters = { "mouseout": "mouseleave", "mouseexit": "mouseleave" },
        _updateAttachedElements = function (component, state, timestamp, sourceElement) {
            var affectedElements = component.getAttachedElements();
            if (affectedElements) {
                for (var i = 0, j = affectedElements.length; i < j; i++) {
                    if (!sourceElement || sourceElement != affectedElements[i])
                        affectedElements[i].setHover(state, true, timestamp);			// tell the attached elements not to inform their own attached elements.
                }
            }
        },
        _splitType = function (t) {
            return t == null ? null : t.split(" ");
        },
        _mapType = function(map, obj, typeId) {
            for (var i in obj)
                map[i] = typeId;
        },
        _each = function(fn, obj) {
            obj = _ju.isArray(obj) || (obj.length != null && !_ju.isString(obj)) ? obj : [ obj ];
            for (var i = 0; i < obj.length; i++) {
                try {
                    fn.apply(obj[i], [ obj[i] ]);
                }
                catch (e) {
                    _ju.log(".each iteration failed : " + e);
                }
            }
        },
        _applyTypes = function (component, params, doNotRepaint) {
            if (component.getDefaultType) {
                var td = component.getTypeDescriptor(), map = {};
                var defType = component.getDefaultType();
                var o = _ju.merge({}, defType);
                _mapType(map, defType, "__default");
                for (var i = 0, j = component._jsPlumb.types.length; i < j; i++) {
                    var tid = component._jsPlumb.types[i];
                    if (tid !== "__default") {
                        var _t = component._jsPlumb.instance.getType(tid, td);
                        if (_t != null) {
                            o = _ju.merge(o, _t, [ "cssClass" ]);
                            _mapType(map, _t, tid);
                        }
                    }
                }

                if (params) {
                    o = _ju.populate(o, params, "_");
                }

                component.applyType(o, doNotRepaint, map);
                if (!doNotRepaint) component.repaint();
            }
        },

// ------------------------------ BEGIN jsPlumbUIComponent --------------------------------------------

        jsPlumbUIComponent = root.jsPlumbUIComponent = function (params) {

            _ju.EventGenerator.apply(this, arguments);

            var self = this,
                a = arguments,
                idPrefix = self.idPrefix,
                id = idPrefix + (new Date()).getTime();

            this._jsPlumb = {
                instance: params._jsPlumb,
                parameters: params.parameters || {},
                paintStyle: null,
                hoverPaintStyle: null,
                paintStyleInUse: null,
                hover: false,
                beforeDetach: params.beforeDetach,
                beforeDrop: params.beforeDrop,
                overlayPlacements: [],
                hoverClass: params.hoverClass || params._jsPlumb.Defaults.HoverClass,
                types: [],
                typeCache:{}
            };

            this.cacheTypeItem = function(key, item, typeId) {
                this._jsPlumb.typeCache[typeId] = this._jsPlumb.typeCache[typeId] || {};
                this._jsPlumb.typeCache[typeId][key] = item;
            };
            this.getCachedTypeItem = function(key, typeId) {
                return this._jsPlumb.typeCache[typeId] ? this._jsPlumb.typeCache[typeId][key] : null;
            };

            this.getId = function () {
                return id;
            };

// ----------------------------- default type --------------------------------------------


            var o = params.overlays || [], oo = {};
            if (this.defaultOverlayKeys) {
                for (var i = 0; i < this.defaultOverlayKeys.length; i++)
                    Array.prototype.push.apply(o, this._jsPlumb.instance.Defaults[this.defaultOverlayKeys[i]] || []);

                for (i = 0; i < o.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = jsPlumb.convertToFullOverlaySpec(o[i]);
                    oo[fo[1].id] = fo;
                }
            }

            var _defaultType = {
                overlays:oo,
                parameters: params.parameters || {},
                scope: params.scope || this._jsPlumb.instance.getDefaultScope()
            };
            this.getDefaultType = function() {
                return _defaultType;
            };
            this.appendToDefaultType = function(obj) {
                for (var i in obj) _defaultType[i] = obj[i];
            };

// ----------------------------- end default type --------------------------------------------

            // all components can generate events

            if (params.events) {
                for (i in params.events)
                    self.bind(i, params.events[i]);
            }

            // all components get this clone function.
            // TODO issue 116 showed a problem with this - it seems 'a' that is in
            // the clone function's scope is shared by all invocations of it, the classic
            // JS closure problem.  for now, jsPlumb does a version of this inline where
            // it used to call clone.  but it would be nice to find some time to look
            // further at this.
            this.clone = function () {
                var o = Object.create(this.constructor.prototype);
                this.constructor.apply(o, a);
                return o;
            }.bind(this);

            // user can supply a beforeDetach callback, which will be executed before a detach
            // is performed; returning false prevents the detach.
            this.isDetachAllowed = function (connection) {
                var r = true;
                if (this._jsPlumb.beforeDetach) {
                    try {
                        r = this._jsPlumb.beforeDetach(connection);
                    }
                    catch (e) {
                        _ju.log("jsPlumb: beforeDetach callback failed", e);
                    }
                }
                return r;
            };

            // user can supply a beforeDrop callback, which will be executed before a dropped
            // connection is confirmed. user can return false to reject connection.
            this.isDropAllowed = function (sourceId, targetId, scope, connection, dropEndpoint, source, target) {
                var r = this._jsPlumb.instance.checkCondition("beforeDrop", {
                    sourceId: sourceId,
                    targetId: targetId,
                    scope: scope,
                    connection: connection,
                    dropEndpoint: dropEndpoint,
                    source: source, target: target
                });
                if (this._jsPlumb.beforeDrop) {
                    try {
                        r = this._jsPlumb.beforeDrop({
                            sourceId: sourceId,
                            targetId: targetId,
                            scope: scope,
                            connection: connection,
                            dropEndpoint: dropEndpoint,
                            source: source, target: target
                        });
                    }
                    catch (e) {
                        _ju.log("jsPlumb: beforeDrop callback failed", e);
                    }
                }
                return r;
            };

            var boundListeners = [],
                bindAListener = function (obj, type, fn) {
                    boundListeners.push([obj, type, fn]);
                    obj.bind(type, fn);
                },
                domListeners = [];

            // sets the component associated with listener events. for instance, an overlay delegates
            // its events back to a connector. but if the connector is swapped on the underlying connection,
            // then this component must be changed. This is called by setConnector in the Connection class.
            this.setListenerComponent = function (c) {
                for (var i = 0; i < domListeners.length; i++)
                    domListeners[i][3] = c;
            };


        };

    var _removeTypeCssHelper = function (component, typeIndex) {
        var typeId = component._jsPlumb.types[typeIndex],
            type = component._jsPlumb.instance.getType(typeId, component.getTypeDescriptor());

        if (type != null) {

            if (type.cssClass && component.canvas)
                component._jsPlumb.instance.removeClass(component.canvas, type.cssClass);
        }
    };

    _ju.extend(root.jsPlumbUIComponent, _ju.EventGenerator, {

        getParameter: function (name) {
            return this._jsPlumb.parameters[name];
        },

        setParameter: function (name, value) {
            this._jsPlumb.parameters[name] = value;
        },

        getParameters: function () {
            return this._jsPlumb.parameters;
        },

        setParameters: function (p) {
            this._jsPlumb.parameters = p;
        },

        getClass:function() {
            return jsPlumb.getClass(this.canvas);
        },

        hasClass:function(clazz) {
            return jsPlumb.hasClass(this.canvas, clazz);
        },

        addClass: function (clazz) {
            jsPlumb.addClass(this.canvas, clazz);
        },

        removeClass: function (clazz) {
            jsPlumb.removeClass(this.canvas, clazz);
        },

        updateClasses: function (classesToAdd, classesToRemove) {
            jsPlumb.updateClasses(this.canvas, classesToAdd, classesToRemove);
        },

        setType: function (typeId, params, doNotRepaint) {
            this.clearTypes();
            this._jsPlumb.types = _splitType(typeId) || [];
            _applyTypes(this, params, doNotRepaint);
        },

        getType: function () {
            return this._jsPlumb.types;
        },

        reapplyTypes: function (params, doNotRepaint) {
            _applyTypes(this, params, doNotRepaint);
        },

        hasType: function (typeId) {
            return this._jsPlumb.types.indexOf(typeId) != -1;
        },

        addType: function (typeId, params, doNotRepaint) {
            var t = _splitType(typeId), _cont = false;
            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    if (!this.hasType(t[i])) {
                        this._jsPlumb.types.push(t[i]);
                        _cont = true;
                    }
                }
                if (_cont) _applyTypes(this, params, doNotRepaint);
            }
        },

        removeType: function (typeId, params, doNotRepaint) {
            var t = _splitType(typeId), _cont = false, _one = function (tt) {
                var idx = this._jsPlumb.types.indexOf(tt);
                if (idx != -1) {
                    // remove css class if necessary
                    _removeTypeCssHelper(this, idx);
                    this._jsPlumb.types.splice(idx, 1);
                    return true;
                }
                return false;
            }.bind(this);

            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    _cont = _one(t[i]) || _cont;
                }
                if (_cont) _applyTypes(this, params, doNotRepaint);
            }
        },
        clearTypes: function (params, doNotRepaint) {
            var i = this._jsPlumb.types.length;
            for (var j = 0; j < i; j++) {
                _removeTypeCssHelper(this, 0);
                this._jsPlumb.types.splice(0, 1);
            }
            _applyTypes(this, params, doNotRepaint);
        },

        toggleType: function (typeId, params, doNotRepaint) {
            var t = _splitType(typeId);
            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    var idx = this._jsPlumb.types.indexOf(t[i]);
                    if (idx != -1) {
                        _removeTypeCssHelper(this, idx);
                        this._jsPlumb.types.splice(idx, 1);
                    }
                    else
                        this._jsPlumb.types.push(t[i]);
                }

                _applyTypes(this, params, doNotRepaint);
            }
        },
        applyType: function (t, doNotRepaint) {
            this.setPaintStyle(t.paintStyle, doNotRepaint);
            this.setHoverPaintStyle(t.hoverPaintStyle, doNotRepaint);
            if (t.parameters) {
                for (var i in t.parameters)
                    this.setParameter(i, t.parameters[i]);
            }
            this._jsPlumb.paintStyleInUse = this.getPaintStyle();
        },
        setPaintStyle: function (style, doNotRepaint) {
//		    	this._jsPlumb.paintStyle = jsPlumb.extend({}, style);
// TODO figure out if we want components to clone paintStyle so as not to share it.
            this._jsPlumb.paintStyle = style;
            this._jsPlumb.paintStyleInUse = this._jsPlumb.paintStyle;
            _updateHoverStyle(this);
            if (!doNotRepaint) this.repaint();
        },
        getPaintStyle: function () {
            return this._jsPlumb.paintStyle;
        },
        setHoverPaintStyle: function (style, doNotRepaint) {
            //this._jsPlumb.hoverPaintStyle = jsPlumb.extend({}, style);
// TODO figure out if we want components to clone paintStyle so as not to share it.		    	
            this._jsPlumb.hoverPaintStyle = style;
            _updateHoverStyle(this);
            if (!doNotRepaint) this.repaint();
        },
        getHoverPaintStyle: function () {
            return this._jsPlumb.hoverPaintStyle;
        },
        destroy: function (force) {
            if (force || this.typeId == null) {
                this.cleanupListeners(); // this is on EventGenerator
                this.clone = null;
                this._jsPlumb = null;
            }
        },

        isHover: function () {
            return this._jsPlumb.hover;
        },

        setHover: function (hover, ignoreAttachedElements, timestamp) {
            // while dragging, we ignore these events.  this keeps the UI from flashing and
            // swishing and whatevering.
            if (this._jsPlumb && !this._jsPlumb.instance.currentlyDragging && !this._jsPlumb.instance.isHoverSuspended()) {

                this._jsPlumb.hover = hover;

                if (this.canvas != null) {
                    if (this._jsPlumb.instance.hoverClass != null) {
                        var method = hover ? "addClass" : "removeClass";
                        this._jsPlumb.instance[method](this.canvas, this._jsPlumb.instance.hoverClass);
                    }
                    if (this._jsPlumb.hoverClass != null) {
                        this._jsPlumb.instance[method](this.canvas, this._jsPlumb.hoverClass);
                    }
                }
                if (this._jsPlumb.hoverPaintStyle != null) {
                    this._jsPlumb.paintStyleInUse = hover ? this._jsPlumb.hoverPaintStyle : this._jsPlumb.paintStyle;
                    if (!this._jsPlumb.instance.isSuspendDrawing()) {
                        timestamp = timestamp || _timestamp();
                        this.repaint({timestamp: timestamp, recalc: false});
                    }
                }
                // get the list of other affected elements, if supported by this component.
                // for a connection, its the endpoints.  for an endpoint, its the connections! surprise.
                if (this.getAttachedElements && !ignoreAttachedElements)
                    _updateAttachedElements(this, hover, _timestamp(), this);
            }
        }
    });

// ------------------------------ END jsPlumbUIComponent --------------------------------------------

    var _jsPlumbInstanceIndex = 0,
        getInstanceIndex = function () {
            var i = _jsPlumbInstanceIndex + 1;
            _jsPlumbInstanceIndex++;
            return i;
        };

    var jsPlumbInstance = root.jsPlumbInstance = function (_defaults) {

        this.Defaults = {
            Anchor: "Bottom",
            Anchors: [ null, null ],
            ConnectionsDetachable: true,
            ConnectionOverlays: [ ],
            Connector: "Bezier",
            Container: null,
            DoNotThrowErrors: false,
            DragOptions: { },
            DropOptions: { },
            Endpoint: "Dot",
            EndpointOverlays: [ ],
            Endpoints: [ null, null ],
            EndpointStyle: { fillStyle: "#456" },
            EndpointStyles: [ null, null ],
            EndpointHoverStyle: null,
            EndpointHoverStyles: [ null, null ],
            HoverPaintStyle: null,
            LabelStyle: { color: "black" },
            LogEnabled: false,
            Overlays: [ ],
            MaxConnections: 1,
            PaintStyle: { lineWidth: 4, strokeStyle: "#456" },
            ReattachConnections: false,
            RenderMode: "svg",
            Scope: "jsPlumb_DefaultScope"
        };
        if (_defaults) jsPlumb.extend(this.Defaults, _defaults);

        this.logEnabled = this.Defaults.LogEnabled;
        this._connectionTypes = {};
        this._endpointTypes = {};

        _ju.EventGenerator.apply(this);

        var _currentInstance = this,
            _instanceIndex = getInstanceIndex(),
            _bb = _currentInstance.bind,
            _initialDefaults = {},
            _zoom = 1,
            _info = function (el) {
                if (el == null) return null;
                else if (el.nodeType == 3 || el.nodeType == 8) {
                    return { el:el, text:true };
                }
                else {
                    var _el = _currentInstance.getElement(el);
                    return { el: _el, id: (_ju.isString(el) && _el == null) ? el : _getId(_el) };
                }
            };

        this.getInstanceIndex = function () {
            return _instanceIndex;
        };

        this.setZoom = function (z, repaintEverything) {
            _zoom = z;
            _currentInstance.fire("zoom", _zoom);
            if (repaintEverything) _currentInstance.repaintEverything();
            return true;
        };
        this.getZoom = function () {
            return _zoom;
        };

        for (var i in this.Defaults)
            _initialDefaults[i] = this.Defaults[i];

        var _container, _containerDelegations = [];
        this.unbindContainer = function() {
            if (_container != null && _containerDelegations.length > 0) {
                for (var i = 0; i < _containerDelegations.length; i++) {
                    _currentInstance.off(_container, _containerDelegations[i][0], _containerDelegations[i][1]);
                }
            }
        };
        this.setContainer = function (c) {

            this.unbindContainer();

            // get container as dom element.
            c = this.getElement(c);
            // move existing connections and endpoints, if any.
            this.select().each(function (conn) {
                conn.moveParent(c);
            });
            this.selectEndpoints().each(function (ep) {
                ep.moveParent(c);
            });

            // set container.
            var previousContainer = _container;
            _container = c;
            _containerDelegations.length = 0;

            var _oneDelegateHandler = function (id, e) {
                var t = e.srcElement || e.target,
                    jp = (t && t.parentNode ? t.parentNode._jsPlumb : null) || (t ? t._jsPlumb : null) || (t && t.parentNode && t.parentNode.parentNode ? t.parentNode.parentNode._jsPlumb : null);
                if (jp) {
                    jp.fire(id, jp, e);
                    // jsplumb also fires every event coming from components/overlays. That's what the test for `jp.component` is for.
                    _currentInstance.fire(id, jp.component || jp, e);
                }
            };

            var _addOneDelegate = function(eventId, selector, fn) {
                _containerDelegations.push([eventId, fn]);
                _currentInstance.on(_container, eventId, selector, fn);
            };

            // delegate one event on the container to jsplumb elements. it might be possible to
            // abstract this out: each of endpoint, connection and overlay could register themselves with
            // jsplumb as "component types" or whatever, and provide a suitable selector. this would be
            // done by the renderer (although admittedly from 2.0 onwards we're not supporting vml anymore)
            var _oneDelegate = function (id) {
                // connections.
                _addOneDelegate(id, ".jsplumb-connector > *", function (e) {
                    _oneDelegateHandler(id, e);
                });
                // endpoints. note they can have an enclosing div, or not.
                _addOneDelegate(id, ".jsplumb-endpoint, .jsplumb-endpoint > *, .jsplumb-endpoint svg *", function (e) {
                    _oneDelegateHandler(id, e);
                });
                // overlays
                _addOneDelegate(id, ".jsplumb-overlay, .jsplumb-overlay *", function (e) {
                    _oneDelegateHandler(id, e);
                });
            };

            for (var i = 0; i < events.length; i++)
                _oneDelegate(events[i]);

            // managed elements
            for (var elId in managedElements) {
                var el = managedElements[elId].el;
                if (el.parentNode === previousContainer) {
                    previousContainer.removeChild(el);
                    _container.appendChild(el);
                }
            }

        };
        this.getContainer = function () {
            return _container;
        };

        this.bind = function (event, fn) {
            if ("ready" === event && initialized) fn();
            else _bb.apply(_currentInstance, [event, fn]);
        };

        _currentInstance.importDefaults = function (d) {
            for (var i in d) {
                _currentInstance.Defaults[i] = d[i];
            }
            if (d.Container)
                _currentInstance.setContainer(d.Container);

            return _currentInstance;
        };

        _currentInstance.restoreDefaults = function () {
            _currentInstance.Defaults = jsPlumb.extend({}, _initialDefaults);
            return _currentInstance;
        };

        var log = null,
            initialized = false,
        // TODO remove from window scope
            connections = [],
        // map of element id -> endpoint lists. an element can have an arbitrary
        // number of endpoints on it, and not all of them have to be connected
        // to anything.
            endpointsByElement = {},
            endpointsByUUID = {},
            managedElements = {},
            offsets = {},
            offsetTimestamps = {},
            draggableStates = {},
            connectionBeingDragged = false,
            sizes = [],
            _suspendDrawing = false,
            _suspendedAt = null,
            DEFAULT_SCOPE = this.Defaults.Scope,
            renderMode = null,  // will be set in init()
            _curIdStamp = 1,
            _idstamp = function () {
                return "" + _curIdStamp++;
            },

        //
        // appends an element to some other element, which is calculated as follows:
        //
        // 1. if Container exists, use that element.
        // 2. if the 'parent' parameter exists, use that.
        // 3. otherwise just use the root element.
        //
        //
            _appendElement = function (el, parent) {
                if (_container)
                    _container.appendChild(el);
                else if (!parent)
                    this.appendToRoot(el);
                else
                    this.getElement(parent).appendChild(el);
            }.bind(this),

        //
        // Draws an endpoint and its connections. this is the main entry point into drawing connections as well
        // as endpoints, since jsPlumb is endpoint-centric under the hood.
        //
        // @param element element to draw (of type library specific element object)
        // @param ui UI object from current library's event system. optional.
        // @param timestamp timestamp for this paint cycle. used to speed things up a little by cutting down the amount of offset calculations we do.
        // @param clearEdits defaults to false; indicates that mouse edits for connectors should be cleared
        ///
            _draw = function (element, ui, timestamp, clearEdits) {

                // TODO is it correct to filter by headless at this top level? how would a headless adapter ever repaint?
                // NO. it is not correct.
                if (!jsPlumb.headless && !_suspendDrawing) {
                    var id = _getId(element),
                        repaintEls = _currentInstance.getDragManager().getElementsForDraggable(id);

                    if (timestamp == null) timestamp = _timestamp();

                    // update the offset of everything _before_ we try to draw anything.
                    var o = _updateOffset({ elId: id, offset: ui, recalc: false, timestamp: timestamp });

                    if (repaintEls) {
                        for (var i in repaintEls) {
                            _updateOffset({
                                elId: repaintEls[i].id,
                                offset: {
                                    left: o.o.left + repaintEls[i].offset.left,
                                    top: o.o.top + repaintEls[i].offset.top
                                },
                                recalc: false,
                                timestamp: timestamp
                            });
                        }
                    }

                    _currentInstance.anchorManager.redraw(id, ui, timestamp, null, clearEdits);

                    if (repaintEls) {
                        for (var j in repaintEls) {
                            _currentInstance.anchorManager.redraw(repaintEls[j].id, ui, timestamp, repaintEls[j].offset, clearEdits, true);
                        }
                    }
                }
            },

        //
        // gets an Endpoint by uuid.
        //
            _getEndpoint = function (uuid) {
                return endpointsByUUID[uuid];
            },

            /**
             * inits a draggable if it's not already initialised.
             * TODO: somehow abstract this to the adapter, because the concept of "draggable" has no
             * place on the server.
             */
            _initDraggableIfNecessary = function (element, isDraggable, dragOptions, id, fireEvent) {
                // move to DragManager?
                if (!jsPlumb.headless) {
                    var _draggable = isDraggable == null ? false : isDraggable;
                    if (_draggable) {
                        if (jsPlumb.isDragSupported(element, _currentInstance)) {
                            var options = dragOptions || _currentInstance.Defaults.DragOptions;
                            options = jsPlumb.extend({}, options); // make a copy.
                            if (!jsPlumb.isAlreadyDraggable(element, _currentInstance)) {
                                var dragEvent = jsPlumb.dragEvents.drag,
                                    stopEvent = jsPlumb.dragEvents.stop,
                                    startEvent = jsPlumb.dragEvents.start,
                                    _del = _currentInstance.getElement(element),
                                    _ancestor = _currentInstance.getDragManager().getDragAncestor(_del),
                                    _noOffset = {left: 0, top: 0},
                                    _ancestorOffset = _noOffset,
                                    _started = false;

                                _manage(id, element);

                                options[startEvent] = _ju.wrap(options[startEvent], function () {
                                    _ancestorOffset = _ancestor != null ? _currentInstance.getOffset(_ancestor) : _noOffset;
                                    _currentInstance.setHoverSuspended(true);
                                    _currentInstance.select({source: element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
                                    _currentInstance.select({target: element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
                                    _currentInstance.setConnectionBeingDragged(true);
                                    if (options.canDrag) return dragOptions.canDrag();
                                }, false);

                                options[dragEvent] = _ju.wrap(options[dragEvent], function () {
                                    // TODO: here we could actually use getDragObject, and then compute it ourselves,
                                    // since every adapter does the same thing. but i'm not sure why YUI's getDragObject
                                    // differs from getUIPosition so much
                                    var ui = _currentInstance.getUIPosition(arguments, _currentInstance.getZoom());
                                    if (ui != null) {
                                        // adjust by ancestor offset if there is one: this is for the case that a draggable
                                        // is contained inside some other element that is not the Container.
                                        ui.left += _ancestorOffset.left;
                                        ui.top += _ancestorOffset.top;
                                        _draw(element, ui, null, true);
                                        if (_started) _currentInstance.addClass(element, "jsplumb-dragged");
                                        _started = true;
                                    }
                                });
                                options[stopEvent] = _ju.wrap(options[stopEvent], function () {
                                    var elements = arguments[0].selection;
                                    var uip = _currentInstance.getUIPosition(arguments);

                                    // this is one element
                                    var _one = function (_e) {
                                        if (uip != null) _draw(_e[0], uip);
                                        _currentInstance.removeClass(_e[0], "jsplumb-dragged");
                                        _currentInstance.select({source: _e[0]}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
                                        _currentInstance.select({target: _e[0]}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
                                        _currentInstance.getDragManager().dragEnded(_e[0]);
                                    };

                                    for (var i = 0; i < elements.length; i++)
                                        _one(elements[i]);

                                    // this is common across all
                                    _started = false;
                                    _currentInstance.setHoverSuspended(false);
                                    _currentInstance.setConnectionBeingDragged(false);
                                });
                                var elId = _getId(element); // need ID
                                draggableStates[elId] = true;
                                var draggable = draggableStates[elId];
                                options.disabled = draggable == null ? false : !draggable;
                                _currentInstance.initDraggable(element, options);
                                _currentInstance.getDragManager().register(element);
                                if (fireEvent) _currentInstance.fire("elementDraggable", {el:element, options:options});
                            }
                            else {
                                // already draggable. attach any start, drag or stop listeners to the current Drag.
                                if (dragOptions.force) {
                                    _currentInstance.initDraggable(element, options);
                                }
                            }
                        }
                    }
                }
            },

            _scopeMatch = function (e1, e2) {
                var s1 = e1.scope.split(/\s/), s2 = e2.scope.split(/\s/);
                for (var i = 0; i < s1.length; i++)
                    for (var j = 0; j < s2.length; j++)
                        if (s2[j] == s1[i]) return true;

                return false;
            },

        /*
         * prepares a final params object that can be passed to _newConnection, taking into account defaults, events, etc.
         */
            _prepareConnectionParams = function (params, referenceParams) {
                var _p = jsPlumb.extend({ }, params);
                if (referenceParams) jsPlumb.extend(_p, referenceParams);

                // hotwire endpoints passed as source or target to sourceEndpoint/targetEndpoint, respectively.
                if (_p.source) {
                    if (_p.source.endpoint)
                        _p.sourceEndpoint = _p.source;
                    else
                        _p.source = _currentInstance.getElement(_p.source);
                }
                if (_p.target) {
                    if (_p.target.endpoint)
                        _p.targetEndpoint = _p.target;
                    else
                        _p.target = _currentInstance.getElement(_p.target);
                }

                // test for endpoint uuids to connect
                if (params.uuids) {
                    _p.sourceEndpoint = _getEndpoint(params.uuids[0]);
                    _p.targetEndpoint = _getEndpoint(params.uuids[1]);
                }

                // now ensure that if we do have Endpoints already, they're not full.
                // source:
                if (_p.sourceEndpoint && _p.sourceEndpoint.isFull()) {
                    _ju.log(_currentInstance, "could not add connection; source endpoint is full");
                    return;
                }

                // target:
                if (_p.targetEndpoint && _p.targetEndpoint.isFull()) {
                    _ju.log(_currentInstance, "could not add connection; target endpoint is full");
                    return;
                }

                // if source endpoint mandates connection type and nothing specified in our params, use it.
                if (!_p.type && _p.sourceEndpoint)
                    _p.type = _p.sourceEndpoint.connectionType;

                // copy in any connectorOverlays that were specified on the source endpoint.
                // it doesnt copy target endpoint overlays.  i'm not sure if we want it to or not.
                if (_p.sourceEndpoint && _p.sourceEndpoint.connectorOverlays) {
                    _p.overlays = _p.overlays || [];
                    for (var i = 0, j = _p.sourceEndpoint.connectorOverlays.length; i < j; i++) {
                        _p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);
                    }
                }

                // scope
                if (_p.sourceEndpoint && _p.sourceEndpoint.scope) {
                    _p.scope = _p.sourceEndpoint.scope;
                }

                // pointer events
                if (!_p["pointer-events"] && _p.sourceEndpoint && _p.sourceEndpoint.connectorPointerEvents)
                    _p["pointer-events"] = _p.sourceEndpoint.connectorPointerEvents;

                var _mergeOverrides = function (def, values) {
                    var m = jsPlumb.extend({}, def);
                    for (var i in values) {
                        if (values[i]) m[i] = values[i];
                    }
                    return m;
                };

                var _addEndpoint = function (el, def, idx) {
                    return _currentInstance.addEndpoint(el, _mergeOverrides(def, {
                        anchor: _p.anchors ? _p.anchors[idx] : _p.anchor,
                        endpoint: _p.endpoints ? _p.endpoints[idx] : _p.endpoint,
                        paintStyle: _p.endpointStyles ? _p.endpointStyles[idx] : _p.endpointStyle,
                        hoverPaintStyle: _p.endpointHoverStyles ? _p.endpointHoverStyles[idx] : _p.endpointHoverStyle
                    }));
                };

                // check for makeSource/makeTarget specs.

                var _oneElementDef = function (type, idx, defs, matchType) {
                    if (_p[type] && !_p[type].endpoint && !_p[type + "Endpoint"] && !_p.newConnection) {
                        var tid = _getId(_p[type]), tep = defs[tid];

                        tep = tep ? tep[matchType] : null;

                        if (tep) {
                            // if not enabled, return.
                            if (!tep.enabled) return false;
                            var newEndpoint = tep.endpoint != null && tep.endpoint._jsPlumb ? tep.endpoint : _addEndpoint(_p[type], tep.def, idx);
                            if (newEndpoint.isFull()) return false;
                            _p[type + "Endpoint"] = newEndpoint;
                            newEndpoint._doNotDeleteOnDetach = false; // reset.
                            newEndpoint._deleteOnDetach = true;
                            if (tep.uniqueEndpoint) {
                                if (!tep.endpoint) {
                                    tep.endpoint = newEndpoint;
                                    newEndpoint._deleteOnDetach = false;
                                    newEndpoint._doNotDeleteOnDetach = true;
                                }
                                else
                                    newEndpoint.finalEndpoint = tep.endpoint;
                            }
                        }
                    }
                };

                if (_oneElementDef("source", 0, this.sourceEndpointDefinitions, _p.type || "default") === false) return;
                if (_oneElementDef("target", 1, this.targetEndpointDefinitions, _p.type || "default") === false) return;

                // last, ensure scopes match
                if (_p.sourceEndpoint && _p.targetEndpoint)
                    if (!_scopeMatch(_p.sourceEndpoint, _p.targetEndpoint)) _p = null;

                return _p;
            }.bind(_currentInstance),

            _newConnection = function (params) {
                var connectionFunc = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType();

                params._jsPlumb = _currentInstance;
                params.newConnection = _newConnection;
                params.newEndpoint = _newEndpoint;
                params.endpointsByUUID = endpointsByUUID;
                params.endpointsByElement = endpointsByElement;
                params.finaliseConnection = _finaliseConnection;
                params.id = "con_" + _idstamp();
                var con = new connectionFunc(params);

                // if the connection is draggable, then maybe we need to tell the target endpoint to init the
                // dragging code. it won't run again if it already configured to be draggable.
                if (con.isDetachable()) {
                    con.endpoints[0].initDraggable("_jsPlumbSource");
                    con.endpoints[1].initDraggable("_jsPlumbTarget");
                }

                return con;
            },

        //
        // adds the connection to the backing model, fires an event if necessary and then redraws
        //
            _finaliseConnection = _currentInstance.finaliseConnection = function (jpc, params, originalEvent, doInformAnchorManager) {
                params = params || {};
                // add to list of connections (by scope).
                if (!jpc.suspendedEndpoint)
                    connections.push(jpc);

                jpc.pending = null;

                // turn off isTemporarySource on the source endpoint (only viable on first draw)
                jpc.endpoints[0].isTemporarySource = false;

                // always inform the anchor manager
                // except that if jpc has a suspended endpoint it's not true to say the
                // connection is new; it has just (possibly) moved. the question is whether
                // to make that call here or in the anchor manager.  i think perhaps here.
                if (doInformAnchorManager !== false)
                    _currentInstance.anchorManager.newConnection(jpc);

                // force a paint
                _draw(jpc.source);

                // fire an event
                if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {

                    var eventArgs = {
                        connection: jpc,
                        source: jpc.source, target: jpc.target,
                        sourceId: jpc.sourceId, targetId: jpc.targetId,
                        sourceEndpoint: jpc.endpoints[0], targetEndpoint: jpc.endpoints[1]
                    };

                    _currentInstance.fire("connection", eventArgs, originalEvent);
                }
            },

        /*
         factory method to prepare a new endpoint.  this should always be used instead of creating Endpoints
         manually, since this method attaches event listeners and an id.
         */
            _newEndpoint = function (params, id) {
                var endpointFunc = _currentInstance.Defaults.EndpointType || jsPlumb.Endpoint;
                var _p = jsPlumb.extend({}, params);
                _p._jsPlumb = _currentInstance;
                _p.newConnection = _newConnection;
                _p.newEndpoint = _newEndpoint;
                _p.endpointsByUUID = endpointsByUUID;
                _p.endpointsByElement = endpointsByElement;
                _p.fireDetachEvent = fireDetachEvent;
                _p.elementId = id || _getId(_p.source);
                var ep = new endpointFunc(_p);
                ep.id = "ep_" + _idstamp();
                _manage(_p.elementId, _p.source);

                if (!jsPlumb.headless)
                    _currentInstance.getDragManager().endpointAdded(_p.source, id);

                return ep;
            },

        /*
         * performs the given function operation on all the connections found
         * for the given element id; this means we find all the endpoints for
         * the given element, and then for each endpoint find the connectors
         * connected to it. then we pass each connection in to the given
         * function.
         */
            _operation = function (elId, func, endpointFunc) {
                var endpoints = endpointsByElement[elId];
                if (endpoints && endpoints.length) {
                    for (var i = 0, ii = endpoints.length; i < ii; i++) {
                        for (var j = 0, jj = endpoints[i].connections.length; j < jj; j++) {
                            var retVal = func(endpoints[i].connections[j]);
                            // if the function passed in returns true, we exit.
                            // most functions return false.
                            if (retVal) return;
                        }
                        if (endpointFunc) endpointFunc(endpoints[i]);
                    }
                }
            },

            _setDraggable = function (element, draggable) {
                return jsPlumb.each(element, function (el) {
                    if (_currentInstance.isDragSupported(el)) {
                        draggableStates[_currentInstance.getAttribute(el, "id")] = draggable;
                        _currentInstance.setElementDraggable(el, draggable);
                    }
                });
            },
        /*
         * private method to do the business of hiding/showing.
         *
         * @param el
         *            either Id of the element in question or a library specific
         *            object for the element.
         * @param state
         *            String specifying a value for the css 'display' property
         *            ('block' or 'none').
         */
            _setVisible = function (el, state, alsoChangeEndpoints) {
                state = state === "block";
                var endpointFunc = null;
                if (alsoChangeEndpoints) {
                    endpointFunc = function (ep) {
                        ep.setVisible(state, true, true);
                    };
                }
                var info = _info(el);
                _operation(info.id, function (jpc) {
                    if (state && alsoChangeEndpoints) {
                        // this test is necessary because this functionality is new, and i wanted to maintain backwards compatibility.
                        // this block will only set a connection to be visible if the other endpoint in the connection is also visible.
                        var oidx = jpc.sourceId === info.id ? 1 : 0;
                        if (jpc.endpoints[oidx].isVisible()) jpc.setVisible(true);
                    }
                    else  // the default behaviour for show, and what always happens for hide, is to just set the visibility without getting clever.
                        jpc.setVisible(state);
                }, endpointFunc);
            },
        /*
         * toggles the draggable state of the given element(s).
         * el is either an id, or an element object, or a list of ids/element objects.
         */
            _toggleDraggable = function (el) {
                var state;
                jsPlumb.each(el, function (el) {
                    var elId = _currentInstance.getAttribute(el, "id");
                    state = draggableStates[elId] == null ? false : draggableStates[elId];
                    state = !state;
                    draggableStates[elId] = state;
                    _currentInstance.setDraggable(el, state);
                    return state;
                }.bind(this));
                return state;
            },
            /**
             * private method to do the business of toggling hiding/showing.
             */
            _toggleVisible = function (elId, changeEndpoints) {
                var endpointFunc = null;
                if (changeEndpoints) {
                    endpointFunc = function (ep) {
                        var state = ep.isVisible();
                        ep.setVisible(!state);
                    };
                }
                _operation(elId, function (jpc) {
                    var state = jpc.isVisible();
                    jpc.setVisible(!state);
                }, endpointFunc);
            },

        // TODO comparison performance
            _getCachedData = function (elId) {
                var o = offsets[elId];
                if (!o)
                    return _updateOffset({elId: elId});
                else
                    return {o: o, s: sizes[elId]};
            },

            /**
             * gets an id for the given element, creating and setting one if
             * necessary.  the id is of the form
             *
             *    jsPlumb_<instance index>_<index in instance>
             *
             * where "index in instance" is a monotonically increasing integer that starts at 0,
             * for each instance.  this method is used not only to assign ids to elements that do not
             * have them but also to connections and endpoints.
             */
            _getId = function (element, uuid, doNotCreateIfNotFound) {
                if (_ju.isString(element)) return element;
                if (element == null) return null;
                var id = _currentInstance.getAttribute(element, "id");
                if (!id || id === "undefined") {
                    // check if fixed uuid parameter is given
                    if (arguments.length == 2 && arguments[1] !== undefined)
                        id = uuid;
                    else if (arguments.length == 1 || (arguments.length == 3 && !arguments[2]))
                        id = "jsPlumb_" + _instanceIndex + "_" + _idstamp();

                    if (!doNotCreateIfNotFound) _currentInstance.setAttribute(element, "id", id);
                }
                return id;
            };

        this.setConnectionBeingDragged = function (v) {
            connectionBeingDragged = v;
        };
        this.isConnectionBeingDragged = function () {
            return connectionBeingDragged;
        };

        /**
         * Returns a map of all the elements this jsPlumbInstance is currently managing.
         * @returns {Object} Map of [id-> {el, endpoint[], connection, position}] information.
         */
        this.getManagedElements = function() {
            return managedElements;
        };

        this.getRenderMode = function() { return "svg"; };

        this.connectorClass = "jsplumb-connector";
        this.connectorOutlineClass = "jsplumb-connector-outline";
        this.editableConnectorClass = "jsplumb-connector-editable";
        this.connectedClass = "jsplumb-connected";
        this.hoverClass = "jsplumb-hover";
        this.endpointClass = "jsplumb-endpoint";
        this.endpointConnectedClass = "jsplumb-endpoint-connected";
        this.endpointFullClass = "jsplumb-endpoint-full";
        this.endpointDropAllowedClass = "jsplumb-endpoint-drop-allowed";
        this.endpointDropForbiddenClass = "jsplumb-endpoint-drop-forbidden";
        this.overlayClass = "jsplumb-overlay";
        this.draggingClass = "jsplumb-dragging";
        this.elementDraggingClass = "jsplumb-element-dragging";
        this.sourceElementDraggingClass = "jsplumb-source-element-dragging";
        this.targetElementDraggingClass = "jsplumb-target-element-dragging";
        this.endpointAnchorClassPrefix = "jsplumb-endpoint-anchor";
        this.hoverSourceClass = "jsplumb-source-hover";
        this.hoverTargetClass = "jsplumb-target-hover";
        this.dragSelectClass = "jsplumb-drag-select";

        this.Anchors = {};
        this.Connectors = {  "svg": {} };
        this.Endpoints = { "svg": {} };
        this.Overlays = { "svg": {} } ;
        this.ConnectorRenderers = {};
        this.SVG = "svg";

// --------------------------- jsPlumbInstance public API ---------------------------------------------------------


        this.addEndpoint = function (el, params, referenceParams) {
            referenceParams = referenceParams || {};
            var p = jsPlumb.extend({}, referenceParams);
            jsPlumb.extend(p, params);
            p.endpoint = p.endpoint || _currentInstance.Defaults.Endpoint;
            p.paintStyle = p.paintStyle || _currentInstance.Defaults.EndpointStyle;

            var results = [],
                inputs = (_ju.isArray(el) || (el.length != null && !_ju.isString(el))) ? el : [ el ];

            for (var i = 0, j = inputs.length; i < j; i++) {
                p.source = _currentInstance.getElement(inputs[i]);
                _ensureContainer(p.source);

                var id = _getId(p.source), e = _newEndpoint(p, id);

                // SP new. here we have introduced a class-wide element manager, which is responsible
                // for getting object dimensions and width/height, and for updating these values only
                // when necessary (after a drag, or on a forced refresh call).
                var myOffset = _manage(id, p.source).info.o;
                _ju.addToList(endpointsByElement, id, e);

                if (!_suspendDrawing) {
                    e.paint({
                        anchorLoc: e.anchor.compute({ xy: [ myOffset.left, myOffset.top ], wh: sizes[id], element: e, timestamp: _suspendedAt }),
                        timestamp: _suspendedAt
                    });
                }

                results.push(e);
                e._doNotDeleteOnDetach = true; // mark this as being added via addEndpoint.
            }

            return results.length == 1 ? results[0] : results;
        };

        this.addEndpoints = function (el, endpoints, referenceParams) {
            var results = [];
            for (var i = 0, j = endpoints.length; i < j; i++) {
                var e = _currentInstance.addEndpoint(el, endpoints[i], referenceParams);
                if (_ju.isArray(e))
                    Array.prototype.push.apply(results, e);
                else results.push(e);
            }
            return results;
        };

        this.animate = function (el, properties, options) {
            if (!this.animationSupported) return false;

            options = options || {};
            var del = _currentInstance.getElement(el),
                id = _getId(del),
                stepFunction = jsPlumb.animEvents.step,
                completeFunction = jsPlumb.animEvents.complete;

            options[stepFunction] = _ju.wrap(options[stepFunction], function () {
                _currentInstance.revalidate(id);
            });

            // onComplete repaints, just to make sure everything looks good at the end of the animation.
            options[completeFunction] = _ju.wrap(options[completeFunction], function () {
                _currentInstance.revalidate(id);
            });

            _currentInstance.doAnimate(del, properties, options);
        };

        /**
         * checks for a listener for the given condition, executing it if found, passing in the given value.
         * condition listeners would have been attached using "bind" (which is, you could argue, now overloaded, since
         * firing click events etc is a bit different to what this does).  i thought about adding a "bindCondition"
         * or something, but decided against it, for the sake of simplicity. jsPlumb will never fire one of these
         * condition events anyway.
         */
        this.checkCondition = function (conditionName, args) {
            var l = _currentInstance.getListener(conditionName),
                r = true;

            if (l && l.length > 0) {
                var values = Array.prototype.slice.call(arguments, 1);
                try {
                    for (var i = 0, j = l.length; i < j; i++) {
                        r = r && l[i].apply(l[i], values);
                    }
                }
                catch (e) {
                    _ju.log(_currentInstance, "cannot check condition [" + conditionName + "]" + e);
                }
            }
            return r;
        };

        this.connect = function (params, referenceParams) {
            // prepare a final set of parameters to create connection with
            var _p = _prepareConnectionParams(params, referenceParams), jpc;
            // TODO probably a nicer return value if the connection was not made.  _prepareConnectionParams
            // will return null (and log something) if either endpoint was full.  what would be nicer is to
            // create a dedicated 'error' object.
            if (_p) {
                if (_p.source == null && _p.sourceEndpoint == null) {
                    _ju.log("Cannot establish connection - source does not exist");
                    return;
                }
                if (_p.target == null && _p.targetEndpoint == null) {
                    _ju.log("Cannot establish connection - target does not exist");
                    return;
                }
                _ensureContainer(_p.source);
                // create the connection.  it is not yet registered
                jpc = _newConnection(_p);
                // now add it the model, fire an event, and redraw
                _finaliseConnection(jpc, _p);
            }
            return jpc;
        };

        var stTypes = [
            { el: "source", elId: "sourceId", epDefs: "sourceEndpointDefinitions" },
            { el: "target", elId: "targetId", epDefs: "targetEndpointDefinitions" }
        ];

        var _set = function (c, el, idx, doNotRepaint) {
            var ep, _st = stTypes[idx], cId = c[_st.elId], cEl = c[_st.el], sid, sep,
                oldEndpoint = c.endpoints[idx];

            var evtParams = {
                index: idx,
                originalSourceId: idx === 0 ? cId : c.sourceId,
                newSourceId: c.sourceId,
                originalTargetId: idx == 1 ? cId : c.targetId,
                newTargetId: c.targetId,
                connection: c
            };

            if (el.constructor == jsPlumb.Endpoint) { // TODO here match the current endpoint class; users can change it {
                ep = el;
                ep.addConnection(c);
                el = ep.element;
            }
            else {
                sid = _getId(el);
                sep = this[_st.epDefs][sid];

                if (sid === c[_st.elId])
                    ep = null;  // dont change source/target if the element is already the one given.
                else if (sep) {
                    for (var t in sep) {
                        if (!sep[t].enabled) return;
                        ep = sep[t].endpoint != null && sep[t].endpoint._jsPlumb ? sep[t].endpoint : this.addEndpoint(el, sep[t].def);
                        if (sep[t].uniqueEndpoint) sep[t].endpoint = ep;
                        ep._doNotDeleteOnDetach = false;
                        ep._deleteOnDetach = true;
                        ep.addConnection(c);
                    }
                }
                else {
                    ep = c.makeEndpoint(idx === 0, el, sid);
                    ep._doNotDeleteOnDetach = false;
                    ep._deleteOnDetach = true;
                }
            }

            if (ep != null) {
                oldEndpoint.detachFromConnection(c);
                c.endpoints[idx] = ep;
                c[_st.el] = ep.element;
                c[_st.elId] = ep.elementId;
                evtParams[idx === 0 ? "newSourceId" : "newTargetId"] = ep.elementId;

                fireMoveEvent(evtParams);

                if (!doNotRepaint)
                    c.repaint();
            }

            evtParams.element = el;
            return evtParams;

        }.bind(this);

        this.setSource = function (connection, el, doNotRepaint) {
            var p = _set(connection, el, 0, doNotRepaint);
            this.anchorManager.sourceChanged(p.originalSourceId, p.newSourceId, connection, p.el);
        };
        this.setTarget = function (connection, el, doNotRepaint) {
            var p = _set(connection, el, 1, doNotRepaint);
            this.anchorManager.updateOtherEndpoint(p.originalSourceId, p.originalTargetId, p.newTargetId, connection);
        };

        this.deleteEndpoint = function (object, dontUpdateHover, deleteAttachedObjects) {
            var endpoint = (typeof object === "string") ? endpointsByUUID[object] : object;
            if (endpoint) {
                _currentInstance.deleteObject({ endpoint: endpoint, dontUpdateHover: dontUpdateHover, deleteAttachedObjects:deleteAttachedObjects });
            }
            return _currentInstance;
        };

        this.deleteEveryEndpoint = function () {
            var _is = _currentInstance.setSuspendDrawing(true);
            for (var id in endpointsByElement) {
                var endpoints = endpointsByElement[id];
                if (endpoints && endpoints.length) {
                    for (var i = 0, j = endpoints.length; i < j; i++) {
                        _currentInstance.deleteEndpoint(endpoints[i], true);
                    }
                }
            }
            endpointsByElement = {};
            // SP new
            managedElements = {};
            endpointsByUUID = {};
            offsets = {};
            offsetTimestamps = {};
            _currentInstance.anchorManager.reset();
            _currentInstance.getDragManager().reset();
            if (!_is) _currentInstance.setSuspendDrawing(false);
            return _currentInstance;
        };

        var fireDetachEvent = function (jpc, doFireEvent, originalEvent) {
            // may have been given a connection, or in special cases, an object
            var connType = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
                argIsConnection = jpc.constructor == connType,
                params = argIsConnection ? {
                    connection: jpc,
                    source: jpc.source, target: jpc.target,
                    sourceId: jpc.sourceId, targetId: jpc.targetId,
                    sourceEndpoint: jpc.endpoints[0], targetEndpoint: jpc.endpoints[1]
                } : jpc;

            if (doFireEvent)
                _currentInstance.fire("connectionDetached", params, originalEvent);

            _currentInstance.anchorManager.connectionDetached(params);
        };

        var fireMoveEvent = _currentInstance.fireMoveEvent = function (params, evt) {
            _currentInstance.fire("connectionMoved", params, evt);
        };

        this.unregisterEndpoint = function (endpoint) {
            //if (endpoint._jsPlumb == null) return;
            if (endpoint._jsPlumb.uuid) endpointsByUUID[endpoint._jsPlumb.uuid] = null;
            _currentInstance.anchorManager.deleteEndpoint(endpoint);
            // TODO at least replace this with a removeWithFunction call.
            for (var e in endpointsByElement) {
                var endpoints = endpointsByElement[e];
                if (endpoints) {
                    var newEndpoints = [];
                    for (var i = 0, j = endpoints.length; i < j; i++)
                        if (endpoints[i] != endpoint) newEndpoints.push(endpoints[i]);

                    endpointsByElement[e] = newEndpoints;
                }
                if (endpointsByElement[e].length < 1) {
                    delete endpointsByElement[e];
                }
            }
        };

        this.detach = function () {

            if (arguments.length === 0) return;
            var connType = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
                firstArgIsConnection = arguments[0].constructor == connType,
                params = arguments.length == 2 ? firstArgIsConnection ? (arguments[1] || {}) : arguments[0] : arguments[0],
                fireEvent = (params.fireEvent !== false),
                forceDetach = params.forceDetach,
                conn = firstArgIsConnection ? arguments[0] : params.connection,
                deleteAttachedObjects = firstArgIsConnection ? null : params.deleteAttachedObjects;

            if (conn) {
                if (forceDetach || _ju.functionChain(true, false, [
                    [ conn.endpoints[0], "isDetachAllowed", [ conn ] ],
                    [ conn.endpoints[1], "isDetachAllowed", [ conn ] ],
                    [ conn, "isDetachAllowed", [ conn ] ],
                    [ _currentInstance, "checkCondition", [ "beforeDetach", conn ] ]
                ])) {

                    conn.endpoints[0].detach({
                        connection:conn,
                        ignoreTarget:false,
                        forceDetach:true,
                        fireEvent:fireEvent,
                        deleteAttachedObjects:deleteAttachedObjects
                    });
                }
            }
            else {
                var _p = jsPlumb.extend({}, params); // a backwards compatibility hack: source should be thought of as 'params' in this case.
                // test for endpoint uuids to detach
                if (_p.uuids) {
                    _getEndpoint(_p.uuids[0]).detachFrom(_getEndpoint(_p.uuids[1]), fireEvent);
                } else if (_p.sourceEndpoint && _p.targetEndpoint) {
                    _p.sourceEndpoint.detachFrom(_p.targetEndpoint);
                } else {
                    var sourceId = _getId(_currentInstance.getElement(_p.source)),
                        targetId = _getId(_currentInstance.getElement(_p.target));
                    _operation(sourceId, function (jpc) {
                        if ((jpc.sourceId == sourceId && jpc.targetId == targetId) || (jpc.targetId == sourceId && jpc.sourceId == targetId)) {
                            if (_currentInstance.checkCondition("beforeDetach", jpc)) {
                                jpc.endpoints[0].detach({
                                    connection:jpc,
                                    ignoreTarget:false,
                                    forceDetach:true,
                                    fireEvent:fireEvent
                                });
                            }
                        }
                    });
                }
            }
        };

        this.detachAllConnections = function (el, params) {
            params = params || {};
            el = _currentInstance.getElement(el);
            var id = _getId(el),
                endpoints = endpointsByElement[id];
            if (endpoints && endpoints.length) {
                for (var i = 0, j = endpoints.length; i < j; i++) {
                    endpoints[i].detachAll(params.fireEvent !== false, params.forceDetach);
                }
            }
            return _currentInstance;
        };

        this.detachEveryConnection = function (params) {
            params = params || {};
            _currentInstance.batch(function () {
                for (var id in endpointsByElement) {
                    var endpoints = endpointsByElement[id];
                    if (endpoints && endpoints.length) {
                        for (var i = 0, j = endpoints.length; i < j; i++) {
                            endpoints[i].detachAll(params.fireEvent !== false, params.forceDetach);
                        }
                    }
                }
                connections.length = 0;
            });
            return _currentInstance;
        };

        /// not public.  but of course its exposed. how to change this.
        this.deleteObject = function (params) {
            var result = {
                    endpoints: {},
                    connections: {},
                    endpointCount: 0,
                    connectionCount: 0
                },
                fireEvent = params.fireEvent !== false,
                deleteAttachedObjects = params.deleteAttachedObjects !== false;

            var unravelConnection = function (connection) {
                if (connection != null && result.connections[connection.id] == null) {
                    if (!params.dontUpdateHover && connection._jsPlumb != null) connection.setHover(false);
                    result.connections[connection.id] = connection;
                    result.connectionCount++;
                    if (deleteAttachedObjects) {
                        for (var j = 0; j < connection.endpoints.length; j++) {
                            if (connection.endpoints[j]._deleteOnDetach)
                                unravelEndpoint(connection.endpoints[j]);
                        }
                    }
                }
            };
            var unravelEndpoint = function (endpoint) {
                if (endpoint != null && result.endpoints[endpoint.id] == null) {
                    if (!params.dontUpdateHover && endpoint._jsPlumb != null) endpoint.setHover(false);
                    result.endpoints[endpoint.id] = endpoint;
                    result.endpointCount++;

                    if (deleteAttachedObjects) {
                        for (var i = 0; i < endpoint.connections.length; i++) {
                            var c = endpoint.connections[i];
                            unravelConnection(c);
                        }
                    }
                }
            };

            if (params.connection)
                unravelConnection(params.connection);
            else unravelEndpoint(params.endpoint);

            // loop through connections
            for (var i in result.connections) {
                var c = result.connections[i];
                if (c._jsPlumb) {
                    _ju.removeWithFunction(connections, function (_c) {
                        return c.id == _c.id;
                    });

                    fireDetachEvent(c, params.fireEvent === false ? false : !c.pending, params.originalEvent);
                    var doNotCleanup = params.deleteAttachedObjects == null ? null : !params.deleteAttachedObjects;

                    // SP GROUPS. this works but blows up lots of original tests
                    c.endpoints[0].detachFromConnection(c, null, doNotCleanup);
                    c.endpoints[1].detachFromConnection(c, null, doNotCleanup);

                    // SP GROUPS. this does not work but makes all the original tests work.
                    //c.endpoints[0].detachFromConnection(c);
                    //c.endpoints[1].detachFromConnection(c);

                    c.cleanup(true);
                    c.destroy(true);
                }
            }

            // loop through endpoints
            for (var j in result.endpoints) {
                var e = result.endpoints[j];
                if (e._jsPlumb) {
                    _currentInstance.unregisterEndpoint(e);
                    // FIRE some endpoint deleted event?
                    e.cleanup(true);
                    e.destroy(true);
                }
            }

            return result;
        };

        this.draggable = function (el, options) {
            var info;
            _each(function(_el) {
                 info = _info(_el);
                if (info.el) _initDraggableIfNecessary(info.el, true, options, info.id, true);
            }, el);
            return _currentInstance;
        };

        this.droppable = function(el, options) {
            var info;
            options = options || {};
            options.allowLoopback = false;
            _each(function(_el) {
                info = _info(_el);
                if (info.el) _currentInstance.initDroppable(info.el, options);
            }, el);
            return _currentInstance;
        };

        // helpers for select/selectEndpoints
        var _setOperation = function (list, func, args, selector) {
                for (var i = 0, j = list.length; i < j; i++) {
                    list[i][func].apply(list[i], args);
                }
                return selector(list);
            },
            _getOperation = function (list, func, args) {
                var out = [];
                for (var i = 0, j = list.length; i < j; i++) {
                    out.push([ list[i][func].apply(list[i], args), list[i] ]);
                }
                return out;
            },
            setter = function (list, func, selector) {
                return function () {
                    return _setOperation(list, func, arguments, selector);
                };
            },
            getter = function (list, func) {
                return function () {
                    return _getOperation(list, func, arguments);
                };
            },
            prepareList = function (input, doNotGetIds) {
                var r = [];
                if (input) {
                    if (typeof input == 'string') {
                        if (input === "*") return input;
                        r.push(input);
                    }
                    else {
                        if (doNotGetIds) r = input;
                        else {
                            if (input.length) {
                                for (var i = 0, j = input.length; i < j; i++)
                                    r.push(_info(input[i]).id);
                            }
                            else
                                r.push(_info(input).id);
                        }
                    }
                }
                return r;
            },
            filterList = function (list, value, missingIsFalse) {
                if (list === "*") return true;
                return list.length > 0 ? list.indexOf(value) != -1 : !missingIsFalse;
            };

        // get some connections, specifying source/target/scope
        this.getConnections = function (options, flat) {
            if (!options) {
                options = {};
            } else if (options.constructor == String) {
                options = { "scope": options };
            }
            var scope = options.scope || _currentInstance.getDefaultScope(),
                scopes = prepareList(scope, true),
                sources = prepareList(options.source),
                targets = prepareList(options.target),
                results = (!flat && scopes.length > 1) ? {} : [],
                _addOne = function (scope, obj) {
                    if (!flat && scopes.length > 1) {
                        var ss = results[scope];
                        if (ss == null) {
                            ss = results[scope] = [];
                        }
                        ss.push(obj);
                    } else results.push(obj);
                };

            for (var j = 0, jj = connections.length; j < jj; j++) {
                var c = connections[j],
                    sourceId = c.proxies && c.proxies[0] ? c.proxies[0].originalEp.elementId : c.sourceId,
                    targetId = c.proxies && c.proxies[1] ? c.proxies[1].originalEp.elementId : c.targetId;

                if (filterList(scopes, c.scope) && filterList(sources, sourceId) && filterList(targets, targetId))
                    _addOne(c.scope, c);
            }

            return results;
        };

        var _curryEach = function (list, executor) {
                return function (f) {
                    for (var i = 0, ii = list.length; i < ii; i++) {
                        f(list[i]);
                    }
                    return executor(list);
                };
            },
            _curryGet = function (list) {
                return function (idx) {
                    return list[idx];
                };
            };

        var _makeCommonSelectHandler = function (list, executor) {
            var out = {
                    length: list.length,
                    each: _curryEach(list, executor),
                    get: _curryGet(list)
                },
                setters = ["setHover", "removeAllOverlays", "setLabel", "addClass", "addOverlay", "removeOverlay",
                    "removeOverlays", "showOverlay", "hideOverlay", "showOverlays", "hideOverlays", "setPaintStyle",
                    "setHoverPaintStyle", "setSuspendEvents", "setParameter", "setParameters", "setVisible",
                    "repaint", "addType", "toggleType", "removeType", "removeClass", "setType", "bind", "unbind" ],

                getters = ["getLabel", "getOverlay", "isHover", "getParameter", "getParameters", "getPaintStyle",
                    "getHoverPaintStyle", "isVisible", "hasType", "getType", "isSuspendEvents" ],
                i, ii;

            for (i = 0, ii = setters.length; i < ii; i++)
                out[setters[i]] = setter(list, setters[i], executor);

            for (i = 0, ii = getters.length; i < ii; i++)
                out[getters[i]] = getter(list, getters[i]);

            return out;
        };

        var _makeConnectionSelectHandler = function (list) {
            var common = _makeCommonSelectHandler(list, _makeConnectionSelectHandler);
            return jsPlumb.extend(common, {
                // setters
                setDetachable: setter(list, "setDetachable", _makeConnectionSelectHandler),
                setReattach: setter(list, "setReattach", _makeConnectionSelectHandler),
                setConnector: setter(list, "setConnector", _makeConnectionSelectHandler),
                detach: function () {
                    for (var i = 0, ii = list.length; i < ii; i++)
                        _currentInstance.detach(list[i]);
                },
                // getters
                isDetachable: getter(list, "isDetachable"),
                isReattach: getter(list, "isReattach")
            });
        };

        var _makeEndpointSelectHandler = function (list) {
            var common = _makeCommonSelectHandler(list, _makeEndpointSelectHandler);
            return jsPlumb.extend(common, {
                setEnabled: setter(list, "setEnabled", _makeEndpointSelectHandler),
                setAnchor: setter(list, "setAnchor", _makeEndpointSelectHandler),
                isEnabled: getter(list, "isEnabled"),
                detachAll: function () {
                    for (var i = 0, ii = list.length; i < ii; i++)
                        list[i].detachAll();
                },
                "remove": function () {
                    for (var i = 0, ii = list.length; i < ii; i++)
                        _currentInstance.deleteObject({endpoint: list[i]});
                }
            });
        };

        this.select = function (params) {
            params = params || {};
            params.scope = params.scope || "*";
            return _makeConnectionSelectHandler(params.connections || _currentInstance.getConnections(params, true));
        };

        this.selectEndpoints = function (params) {
            params = params || {};
            params.scope = params.scope || "*";
            var noElementFilters = !params.element && !params.source && !params.target,
                elements = noElementFilters ? "*" : prepareList(params.element),
                sources = noElementFilters ? "*" : prepareList(params.source),
                targets = noElementFilters ? "*" : prepareList(params.target),
                scopes = prepareList(params.scope, true);

            var ep = [];

            for (var el in endpointsByElement) {
                var either = filterList(elements, el, true),
                    source = filterList(sources, el, true),
                    sourceMatchExact = sources != "*",
                    target = filterList(targets, el, true),
                    targetMatchExact = targets != "*";

                // if they requested 'either' then just match scope. otherwise if they requested 'source' (not as a wildcard) then we have to match only endpoints that have isSource set to to true, and the same thing with isTarget.
                if (either || source || target) {
                    inner:
                        for (var i = 0, ii = endpointsByElement[el].length; i < ii; i++) {
                            var _ep = endpointsByElement[el][i];
                            if (filterList(scopes, _ep.scope, true)) {

                                var noMatchSource = (sourceMatchExact && sources.length > 0 && !_ep.isSource),
                                    noMatchTarget = (targetMatchExact && targets.length > 0 && !_ep.isTarget);

                                if (noMatchSource || noMatchTarget)
                                    continue inner;

                                ep.push(_ep);
                            }
                        }
                }
            }

            return _makeEndpointSelectHandler(ep);
        };

        // get all connections managed by the instance of jsplumb.
        this.getAllConnections = function () {
            return connections;
        };
        this.getDefaultScope = function () {
            return DEFAULT_SCOPE;
        };
        // get an endpoint by uuid.
        this.getEndpoint = _getEndpoint;
        // get endpoints for some element.
        this.getEndpoints = function (el) {
            return endpointsByElement[_info(el).id];
        };
        // gets the default endpoint type. used when subclassing. see wiki.
        this.getDefaultEndpointType = function () {
            return jsPlumb.Endpoint;
        };
        // gets the default connection type. used when subclassing.  see wiki.
        this.getDefaultConnectionType = function () {
            return jsPlumb.Connection;
        };
        /*
         * Gets an element's id, creating one if necessary. really only exposed
         * for the lib-specific functionality to access; would be better to pass
         * the current instance into the lib-specific code (even though this is
         * a static call. i just don't want to expose it to the public API).
         */
        this.getId = _getId;

        this.appendElement = _appendElement;

        var _hoverSuspended = false;
        this.isHoverSuspended = function () {
            return _hoverSuspended;
        };
        this.setHoverSuspended = function (s) {
            _hoverSuspended = s;
        };

        // set an element's connections to be hidden
        this.hide = function (el, changeEndpoints) {
            _setVisible(el, "none", changeEndpoints);
            return _currentInstance;
        };

        // exposed for other objects to use to get a unique id.
        this.idstamp = _idstamp;

        this.connectorsInitialized = false;
        this.registerConnectorType = function (connector, name) {
            connectorTypes.push([connector, name]);
        };

        // ensure that, if the current container exists, it is a DOM element and not a selector.
        // if it does not exist and `candidate` is supplied, the offset parent of that element will be set as the Container.
        // this is used to do a better default behaviour for the case that the user has not set a container:
        // addEndpoint, makeSource, makeTarget and connect all call this method with the offsetParent of the
        // element in question (for connect it is the source element). So if no container is set, it is inferred
        // to be the offsetParent of the first element the user tries to connect.
        var _ensureContainer = function (candidate) {
            if (!_container && candidate) {
                var can = _currentInstance.getElement(candidate);
                if (can.offsetParent) _currentInstance.setContainer(can.offsetParent);
            }
        };

        var _getContainerFromDefaults = function () {
            if (_currentInstance.Defaults.Container)
                _currentInstance.setContainer(_currentInstance.Defaults.Container);
        };

        // check if a given element is managed or not. if not, add to our map. if drawing is not suspended then
        // we'll also stash its dimensions; otherwise we'll do this in a lazy way through updateOffset.
        var _manage = _currentInstance.manage = function (id, element, _transient) {
            if (!managedElements[id]) {
                managedElements[id] = {
                    el: element,
                    endpoints: [],
                    connections: []
                };

                managedElements[id].info = _updateOffset({ elId: id, timestamp: _suspendedAt });
                if (!_transient) {
                    _currentInstance.fire("manageElement", { id:id, info:managedElements[id].info, el:element });
                }
            }

            return managedElements[id];
        };

        var _unmanage = function(id) {
            if (managedElements[id]) {
                delete managedElements[id];
                _currentInstance.fire("unmanageElement", id);
            }
        };

        /**
         * updates the offset and size for a given element, and stores the
         * values. if 'offset' is not null we use that (it would have been
         * passed in from a drag call) because it's faster; but if it is null,
         * or if 'recalc' is true in order to force a recalculation, we get the current values.
         */
        var _updateOffset = this.updateOffset = function (params) {

            var timestamp = params.timestamp, recalc = params.recalc, offset = params.offset, elId = params.elId, s;
            if (_suspendDrawing && !timestamp) timestamp = _suspendedAt;
            if (!recalc) {
                if (timestamp && timestamp === offsetTimestamps[elId]) {
                    return {o: params.offset || offsets[elId], s: sizes[elId]};
                }
            }
            if (recalc || (!offset && offsets[elId] == null)) { // if forced repaint or no offset available, we recalculate.

                // get the current size and offset, and store them
                s = managedElements[elId] ? managedElements[elId].el : null;
                if (s != null) {
                    sizes[elId] = _currentInstance.getSize(s);
                    offsets[elId] = _currentInstance.getOffset(s);
                    offsetTimestamps[elId] = timestamp;
                }
            } else {
                offsets[elId] = offset || offsets[elId];
                if (sizes[elId] == null) {
                    s = managedElements[elId].el;
                    if (s != null) sizes[elId] = _currentInstance.getSize(s);
                }
                offsetTimestamps[elId] = timestamp;
            }

            if (offsets[elId] && !offsets[elId].right) {
                offsets[elId].right = offsets[elId].left + sizes[elId][0];
                offsets[elId].bottom = offsets[elId].top + sizes[elId][1];
                offsets[elId].width = sizes[elId][0];
                offsets[elId].height = sizes[elId][1];
                offsets[elId].centerx = offsets[elId].left + (offsets[elId].width / 2);
                offsets[elId].centery = offsets[elId].top + (offsets[elId].height / 2);
            }

            return {o: offsets[elId], s: sizes[elId]};
        };

        /**
         * callback from the current library to tell us to prepare ourselves (attach
         * mouse listeners etc; can't do that until the library has provided a bind method)
         */
        this.init = function () {
            rendererTypes = root.jsPlumb.getRenderModes();

            var _oneType = function (renderer, name, fn) {
                root.jsPlumb.Connectors[renderer][name] = function () {
                    fn.apply(this, arguments);
                    root.jsPlumb.ConnectorRenderers[renderer].apply(this, arguments);
                };
                _ju.extend(root.jsPlumb.Connectors[renderer][name], [ fn, root.jsPlumb.ConnectorRenderers[renderer]]);
            };

            if (!root.jsPlumb.connectorsInitialized) {
                for (var i = 0; i < connectorTypes.length; i++) {
                    for (var j = 0; j < rendererTypes.length; j++) {
                        _oneType(rendererTypes[j], connectorTypes[i][1], connectorTypes[i][0]);
                    }

                }
                root.jsPlumb.connectorsInitialized = true;
            }

            if (!initialized) {
                _getContainerFromDefaults();
                _currentInstance.anchorManager = new root.jsPlumb.AnchorManager({jsPlumbInstance: _currentInstance});
                initialized = true;
                _currentInstance.fire("ready", _currentInstance);
            }
        }.bind(this);

        this.log = log;
        this.jsPlumbUIComponent = jsPlumbUIComponent;

        /*
         * Creates an anchor with the given params.
         *
         *
         * Returns: The newly created Anchor.
         * Throws: an error if a named anchor was not found.
         */
        this.makeAnchor = function () {
            var pp, _a = function (t, p) {
                if (root.jsPlumb.Anchors[t]) return new root.jsPlumb.Anchors[t](p);
                if (!_currentInstance.Defaults.DoNotThrowErrors)
                    throw { msg: "jsPlumb: unknown anchor type '" + t + "'" };
            };
            if (arguments.length === 0) return null;
            var specimen = arguments[0], elementId = arguments[1], jsPlumbInstance = arguments[2], newAnchor = null;
            // if it appears to be an anchor already...
            if (specimen.compute && specimen.getOrientation) return specimen;  //TODO hazy here about whether it should be added or is already added somehow.
            // is it the name of an anchor type?
            else if (typeof specimen == "string") {
                newAnchor = _a(arguments[0], {elementId: elementId, jsPlumbInstance: _currentInstance});
            }
            // is it an array? it will be one of:
            // 		an array of [spec, params] - this defines a single anchor, which may be dynamic, but has parameters.
            //		an array of arrays - this defines some dynamic anchors
            //		an array of numbers - this defines a single anchor.
            else if (_ju.isArray(specimen)) {
                if (_ju.isArray(specimen[0]) || _ju.isString(specimen[0])) {
                    // if [spec, params] format
                    if (specimen.length == 2 && _ju.isObject(specimen[1])) {
                        // if first arg is a string, its a named anchor with params
                        if (_ju.isString(specimen[0])) {
                            pp = root.jsPlumb.extend({elementId: elementId, jsPlumbInstance: _currentInstance}, specimen[1]);
                            newAnchor = _a(specimen[0], pp);
                        }
                        // otherwise first arg is array, second is params. we treat as a dynamic anchor, which is fine
                        // even if the first arg has only one entry. you could argue all anchors should be implicitly dynamic in fact.
                        else {
                            pp = root.jsPlumb.extend({elementId: elementId, jsPlumbInstance: _currentInstance, anchors: specimen[0]}, specimen[1]);
                            newAnchor = new root.jsPlumb.DynamicAnchor(pp);
                        }
                    }
                    else
                        newAnchor = new jsPlumb.DynamicAnchor({anchors: specimen, selector: null, elementId: elementId, jsPlumbInstance: _currentInstance});

                }
                else {
                    var anchorParams = {
                        x: specimen[0], y: specimen[1],
                        orientation: (specimen.length >= 4) ? [ specimen[2], specimen[3] ] : [0, 0],
                        offsets: (specimen.length >= 6) ? [ specimen[4], specimen[5] ] : [ 0, 0 ],
                        elementId: elementId,
                        jsPlumbInstance: _currentInstance,
                        cssClass: specimen.length == 7 ? specimen[6] : null
                    };
                    newAnchor = new root.jsPlumb.Anchor(anchorParams);
                    newAnchor.clone = function () {
                        return new root.jsPlumb.Anchor(anchorParams);
                    };
                }
            }

            if (!newAnchor.id) newAnchor.id = "anchor_" + _idstamp();
            return newAnchor;
        };

        /**
         * makes a list of anchors from the given list of types or coords, eg
         * ["TopCenter", "RightMiddle", "BottomCenter", [0, 1, -1, -1] ]
         */
        this.makeAnchors = function (types, elementId, jsPlumbInstance) {
            var r = [];
            for (var i = 0, ii = types.length; i < ii; i++) {
                if (typeof types[i] == "string")
                    r.push(root.jsPlumb.Anchors[types[i]]({elementId: elementId, jsPlumbInstance: jsPlumbInstance}));
                else if (_ju.isArray(types[i]))
                    r.push(_currentInstance.makeAnchor(types[i], elementId, jsPlumbInstance));
            }
            return r;
        };

        /**
         * Makes a dynamic anchor from the given list of anchors (which may be in shorthand notation as strings or dimension arrays, or Anchor
         * objects themselves) and the given, optional, anchorSelector function (jsPlumb uses a default if this is not provided; most people will
         * not need to provide this - i think).
         */
        this.makeDynamicAnchor = function (anchors, anchorSelector) {
            return new root.jsPlumb.DynamicAnchor({anchors: anchors, selector: anchorSelector, elementId: null, jsPlumbInstance: _currentInstance});
        };

// --------------------- makeSource/makeTarget ---------------------------------------------- 

        this.targetEndpointDefinitions = {};
        var _setEndpointPaintStylesAndAnchor = function (ep, epIndex, _instance) {
           /* ep.paintStyle = ep.paintStyle ||
                _instance.Defaults.EndpointStyles[epIndex] ||
                _instance.Defaults.EndpointStyle;

            ep.hoverPaintStyle = ep.hoverPaintStyle ||
                _instance.Defaults.EndpointHoverStyles[epIndex] ||
                _instance.Defaults.EndpointHoverStyle;

            ep.anchor = ep.anchor ||
                _instance.Defaults.Anchors[epIndex] ||
                _instance.Defaults.Anchor;

            ep.endpoint = ep.endpoint ||
                _instance.Defaults.Endpoints[epIndex] ||
                _instance.Defaults.Endpoint;*/
        };

        // TODO put all the source stuff inside one parent, keyed by id.
        this.sourceEndpointDefinitions = {};

        var selectorFilter = function (evt, _el, selector, _instance, negate) {
            var t = evt.target || evt.srcElement, ok = false,
                sel = _instance.getSelector(_el, selector);
            for (var j = 0; j < sel.length; j++) {
                if (sel[j] == t) {
                    ok = true;
                    break;
                }
            }
            return negate ? !ok : ok;
        };

        // SP target source refactor
        var _makeElementDropHandler = function (elInfo, p, dropOptions, isSource, isTarget) {
            var proxyComponent = new jsPlumbUIComponent(p);
            var _drop = p._jsPlumb.EndpointDropHandler({
                jsPlumb: _currentInstance,
                enabled: function () {
                    return elInfo.def.enabled;
                },
                isFull: function () {
                    var targetCount = _currentInstance.select({target: elInfo.id}).length;
                    return elInfo.def.maxConnections > 0 && targetCount >= elInfo.def.maxConnections;
                },
                element: elInfo.el,
                elementId: elInfo.id,
                isSource: isSource,
                isTarget: isTarget,
                addClass: function (clazz) {
                    _currentInstance.addClass(elInfo.el, clazz);
                },
                removeClass: function (clazz) {
                    _currentInstance.removeClass(elInfo.el, clazz);
                },
                onDrop: function (jpc) {
                    var source = jpc.endpoints[0];
                    source.anchor.locked = false;
                },
                isDropAllowed: function () {
                    return proxyComponent.isDropAllowed.apply(proxyComponent, arguments);
                },
                isRedrop:function(jpc) {
                    return (jpc.suspendedElement != null && jpc.suspendedEndpoint != null && jpc.suspendedEndpoint.element === elInfo.el);
                },
                getEndpoint: function (jpc) {

                    // make a new Endpoint for the target, or get it from the cache if uniqueEndpoint
                    // is set. if its a redrop the new endpoint will be immediately cleaned up.

                    var newEndpoint = elInfo.def.endpoint;

                    // if no cached endpoint, or there was one but it has been cleaned up
                    // (ie. detached), create a new one
                    if (newEndpoint == null || newEndpoint._jsPlumb == null) {
                        var eps = _currentInstance.deriveEndpointAndAnchorSpec(jpc.getType().join(" "), true);
                        var pp = eps.endpoints ? root.jsPlumb.extend(p, {
                            endpoint:elInfo.def.def.endpoint || eps.endpoints[1]
                        }) :p;
                        if (eps.anchors) {
                            pp = root.jsPlumb.extend(pp, {
                                anchor:elInfo.def.def.anchor || eps.anchors[1]
                            });
                        }
                        newEndpoint = _currentInstance.addEndpoint(elInfo.el, pp);
                        newEndpoint._mtNew = true;
                    }

                    if (p.uniqueEndpoint) elInfo.def.endpoint = newEndpoint;  // may of course just store what it just pulled out. that's ok.
                    // TODO test options to makeTarget to see if we should do this?
                    newEndpoint._doNotDeleteOnDetach = false; // reset.
                    newEndpoint._deleteOnDetach = true;

                    // if connection is detachable, init the new endpoint to be draggable, to support that happening.
                    if (jpc.isDetachable())
                        newEndpoint.initDraggable();

                    // if the anchor has a 'positionFinder' set, then delegate to that function to find
                    // out where to locate the anchor.
                    if (newEndpoint.anchor.positionFinder != null) {
                        var dropPosition = _currentInstance.getUIPosition(arguments, _currentInstance.getZoom()),
                            elPosition = _currentInstance.getOffset(elInfo.el),
                            elSize = _currentInstance.getSize(elInfo.el),
                            ap = dropPosition == null ? [0,0] : newEndpoint.anchor.positionFinder(dropPosition, elPosition, elSize, newEndpoint.anchor.constructorParams);

                        newEndpoint.anchor.x = ap[0];
                        newEndpoint.anchor.y = ap[1];
                        // now figure an orientation for it..kind of hard to know what to do actually. probably the best thing i can do is to
                        // support specifying an orientation in the anchor's spec. if one is not supplied then i will make the orientation
                        // be what will cause the most natural link to the source: it will be pointing at the source, but it needs to be
                        // specified in one axis only, and so how to make that choice? i think i will use whichever axis is the one in which
                        // the target is furthest away from the source.
                    }

                    return newEndpoint;
                },
                maybeCleanup: function (ep) {
                    if (ep._mtNew && ep.connections.length === 0) {
                        _currentInstance.deleteObject({endpoint: ep});
                    }
                    else
                        delete ep._mtNew;
                }
            });

            // wrap drop events as needed and initialise droppable
            var dropEvent = root.jsPlumb.dragEvents.drop;
            dropOptions.scope = dropOptions.scope || (p.scope || _currentInstance.Defaults.Scope);
            dropOptions[dropEvent] = _ju.wrap(dropOptions[dropEvent], _drop, true);

            // if target, return true from the over event. this will cause katavorio to stop setting drops to hover
            // if multipleDrop is set to false.
            if (isTarget) {
                dropOptions[root.jsPlumb.dragEvents.over] = function () { return true; };
            }

            // vanilla jsplumb only
            if (p.allowLoopback === false) {
                dropOptions.canDrop = function (_drag) {
                    var de = _drag.getDragElement()._jsPlumbRelatedElement;
                    return de != elInfo.el;
                };
            }
            _currentInstance.initDroppable(elInfo.el, dropOptions, "internal");

            return _drop;

        };

        // see API docs
        this.makeTarget = function (el, params, referenceParams) {

            // put jsplumb ref into params without altering the params passed in
            var p = root.jsPlumb.extend({_jsPlumb: this}, referenceParams);
            root.jsPlumb.extend(p, params);

            // calculate appropriate paint styles and anchor from the params given
            _setEndpointPaintStylesAndAnchor(p, 1, this);

            var deleteEndpointsOnDetach = !(p.deleteEndpointsOnDetach === false),
                maxConnections = p.maxConnections || -1,

                _doOne = function (el) {

                    // get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
                    // and use the endpoint definition if found.
                    // decode the info for this element (id and element)
                    var elInfo = _info(el),
                        elid = elInfo.id,
                        dropOptions = root.jsPlumb.extend({}, p.dropOptions || {}),
                        type = "default";

                    this.targetEndpointDefinitions[elid] = this.targetEndpointDefinitions[elid] || {};

                    _ensureContainer(elid);

                    // store the definition
                    var _def = {
                        def: root.jsPlumb.extend({}, p),
                        uniqueEndpoint: p.uniqueEndpoint,
                        maxConnections: maxConnections,
                        enabled: true
                    };
                    elInfo.def = _def;
                    this.targetEndpointDefinitions[elid][type] = _def;
                    _makeElementDropHandler(elInfo, p, dropOptions, p.isSource === true, true);
                    // stash the definition on the drop
                    elInfo.el._katavorioDrop[elInfo.el._katavorioDrop.length - 1].targetDef = _def;

                }.bind(this);

            // make an array if only given one element
            var inputs = el.length && el.constructor != String ? el : [ el ];

            // register each one in the list.
            for (var i = 0, ii = inputs.length; i < ii; i++) {
                _doOne(inputs[i]);
            }

            return this;
        };

        // see api docs
        this.unmakeTarget = function (el, doNotClearArrays) {
            var info = _info(el);
            _currentInstance.destroyDroppable(info.el, "internal");
            if (!doNotClearArrays) {
                delete this.targetEndpointDefinitions[info.id];
            }

            return this;
        };

        // see api docs
        this.makeSource = function (el, params, referenceParams) {
            var p = root.jsPlumb.extend({_jsPlumb: this}, referenceParams);
            root.jsPlumb.extend(p, params);
            var type = p.connectionType || "default";
            var aae = _currentInstance.deriveEndpointAndAnchorSpec(type);
            p.endpoint = p.endpoint || aae.endpoints[0];
            p.anchor = p.anchor || aae.anchors[0];
            _setEndpointPaintStylesAndAnchor(p, 0, this);
            var maxConnections = p.maxConnections || -1,
                onMaxConnections = p.onMaxConnections,
                _doOne = function (elInfo) {
                    // get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
                    // and use the endpoint definition if found.
                    var elid = elInfo.id,
                        _del = this.getElement(elInfo.el);

                    this.sourceEndpointDefinitions[elid] = this.sourceEndpointDefinitions[elid] || {};
                    _ensureContainer(elid);

                    var _def = {
                        def:root.jsPlumb.extend({}, p),
                        uniqueEndpoint: p.uniqueEndpoint,
                        maxConnections: maxConnections,
                        enabled: true
                    };


                    this.sourceEndpointDefinitions[elid][type] = _def;
                    elInfo.def = _def;

                    var stopEvent = root.jsPlumb.dragEvents.stop,
                        dragEvent = root.jsPlumb.dragEvents.drag,
                        dragOptions = root.jsPlumb.extend({ }, p.dragOptions || {}),
                        existingDrag = dragOptions.drag,
                        existingStop = dragOptions.stop,
                        ep = null,
                        endpointAddedButNoDragYet = false;

                    // set scope if its not set in dragOptions but was passed in in params
                    dragOptions.scope = dragOptions.scope || p.scope;

                    dragOptions[dragEvent] = _ju.wrap(dragOptions[dragEvent], function () {
                        if (existingDrag) existingDrag.apply(this, arguments);
                        endpointAddedButNoDragYet = false;
                    });

                    dragOptions[stopEvent] = _ju.wrap(dragOptions[stopEvent], function () {

                        if (existingStop) existingStop.apply(this, arguments);
                        this.currentlyDragging = false;
                        if (ep._jsPlumb != null) { // if not cleaned up...

                            // reset the anchor to the anchor that was initially provided. the one we were using to drag
                            // the connection was just a placeholder that was located at the place the user pressed the
                            // mouse button to initiate the drag.
                            var anchorDef = p.anchor || this.Defaults.Anchor,
                                oldAnchor = ep.anchor,
                                oldConnection = ep.connections[0];

                            var    newAnchor = this.makeAnchor(anchorDef, elid, this),
                                _el = ep.element;

                            // if the anchor has a 'positionFinder' set, then delegate to that function to find
                            // out where to locate the anchor. issue 117.
                            if (newAnchor.positionFinder != null) {
                                var elPosition = _currentInstance.getOffset(_el),
                                    elSize = this.getSize(_el),
                                    dropPosition = { left: elPosition.left + (oldAnchor.x * elSize[0]), top: elPosition.top + (oldAnchor.y * elSize[1]) },
                                    ap = newAnchor.positionFinder(dropPosition, elPosition, elSize, newAnchor.constructorParams);

                                newAnchor.x = ap[0];
                                newAnchor.y = ap[1];
                            }

                            ep.setAnchor(newAnchor, true);
                            ep.repaint();
                            this.repaint(ep.elementId);
                            if (oldConnection != null) this.repaint(oldConnection.targetId);
                        }
                    }.bind(this));

                    // when the user presses the mouse, add an Endpoint, if we are enabled.
                    var mouseDownListener = function (e) {
                        // on right mouse button, abort.
                        if (e.which === 3 || e.button === 2) return;

                        // TODO store def on element.
                        var def = this.sourceEndpointDefinitions[elid][type];

                        // if disabled, return.
                        if (!def.enabled) return;

                        elid = this.getId(this.getElement(elInfo.el)); // elid might have changed since this method was called to configure the element.

                        // if a filter was given, run it, and return if it says no.
                        if (p.filter) {
                            var r = _ju.isString(p.filter) ? selectorFilter(e, elInfo.el, p.filter, this, p.filterExclude) : p.filter(e, elInfo.el);
                            if (r === false) return;
                        }

                        // if maxConnections reached
                        var sourceCount = this.select({source: elid}).length;
                        if (def.maxConnections >= 0 && (sourceCount >= def.maxConnections)) {
                            if (onMaxConnections) {
                                onMaxConnections({
                                    element: elInfo.el,
                                    maxConnections: maxConnections
                                }, e);
                            }
                            return false;
                        }

                        // find the position on the element at which the mouse was pressed; this is where the endpoint
                        // will be located.
                        var elxy = root.jsPlumb.getPositionOnElement(e, _del, _zoom);

                        // we need to override the anchor in here, and force 'isSource', but we don't want to mess with
                        // the params passed in, because after a connection is established we're going to reset the endpoint
                        // to have the anchor we were given.
                        var tempEndpointParams = {};
                        root.jsPlumb.extend(tempEndpointParams, p);
                        tempEndpointParams.isTemporarySource = true;
                        tempEndpointParams.anchor = [ elxy[0], elxy[1] , 0, 0];
                        tempEndpointParams.dragOptions = dragOptions;

                        if (def.def.scope) tempEndpointParams.scope = def.def.scope;

                        ep = this.addEndpoint(elid, tempEndpointParams);
                        endpointAddedButNoDragYet = true;
                        ep._doNotDeleteOnDetach = false; // reset.
                        ep._deleteOnDetach = true;

                        // if unique endpoint and it's already been created, push it onto the endpoint we create. at the end
                        // of a successful connection we'll switch to that endpoint.
                        // TODO this is the same code as the programmatic endpoints create on line 1050 ish
                        if (def.uniqueEndpoint) {
                            if (!def.endpoint) {
                                def.endpoint = ep;
                                ep._deleteOnDetach = false;
                                ep._doNotDeleteOnDetach = true;
                            }
                            else
                                ep.finalEndpoint = def.endpoint;
                        }

                        var _delTempEndpoint = function () {
                            // this mouseup event is fired only if no dragging occurred, by jquery and yui, but for mootools
                            // it is fired even if dragging has occurred, in which case we would blow away a perfectly
                            // legitimate endpoint, were it not for this check.  the flag is set after adding an
                            // endpoint and cleared in a drag listener we set in the dragOptions above.
                            _currentInstance.off(ep.canvas, "mouseup", _delTempEndpoint);
                            _currentInstance.off(elInfo.el, "mouseup", _delTempEndpoint);
                            if (endpointAddedButNoDragYet) {
                                endpointAddedButNoDragYet = false;
                                _currentInstance.deleteEndpoint(ep);
                            }
                        };

                        _currentInstance.on(ep.canvas, "mouseup", _delTempEndpoint);
                        _currentInstance.on(elInfo.el, "mouseup", _delTempEndpoint);

                        // optionally check for attributes to extract from the source element
                        var payload = {};
                        if (def.def.extract) {
                            for (var att in def.def.extract) {
                                var v = (e.srcElement || e.target).getAttribute(att);
                                if (v) {
                                    payload[def.def.extract[att]] = v;
                                }
                            }
                        }

                        // and then trigger its mousedown event, which will kick off a drag, which will start dragging
                        // a new connection from this endpoint.
                        _currentInstance.trigger(ep.canvas, "mousedown", e, payload);

                        _ju.consume(e);

                    }.bind(this);

                    this.on(elInfo.el, "mousedown", mouseDownListener);
                    _def.trigger = mouseDownListener;

                    // if a filter was provided, set it as a dragFilter on the element,
                    // to prevent the element drag function from kicking in when we want to
                    // drag a new connection
                    if (p.filter && (_ju.isString(p.filter) || _ju.isFunction(p.filter))) {
                        _currentInstance.setDragFilter(elInfo.el, p.filter);
                    }

                    var dropOptions = root.jsPlumb.extend({}, p.dropOptions || {});

                    _makeElementDropHandler(elInfo, p, dropOptions, true, p.isTarget === true);

                }.bind(this);

            var inputs = el.length && el.constructor != String ? el : [ el ];
            for (var i = 0, ii = inputs.length; i < ii; i++) {
                _doOne(_info(inputs[i]));
            }

            return this;
        };

        // see api docs
        this.unmakeSource = function (el, connectionType, doNotClearArrays) {
            var info = _info(el);
            _currentInstance.destroyDroppable(info.el, "internal");
            var eldefs = this.sourceEndpointDefinitions[info.id];
            if (eldefs) {
                for (var def in eldefs) {
                    if (connectionType == null || connectionType === def) {
                        var mouseDownListener = eldefs[def].trigger;
                        if (mouseDownListener)
                            _currentInstance.off(info.el, "mousedown", mouseDownListener);
                        if (!doNotClearArrays) {
                            delete this.sourceEndpointDefinitions[info.id][def];
                        }
                    }
                }
            }

            return this;
        };

        // see api docs
        this.unmakeEverySource = function () {
            for (var i in this.sourceEndpointDefinitions)
                _currentInstance.unmakeSource(i, null, true);

            this.sourceEndpointDefinitions = {};
            return this;
        };

        var _getScope = function (el, types, connectionType) {
            types = _ju.isArray(types) ? types : [ types ];
            var id = _getId(el);
            connectionType = connectionType || "default";
            for (var i = 0; i < types.length; i++) {
                var eldefs = this[types[i]][id];
                if (eldefs && eldefs[connectionType]) return eldefs[connectionType].def.scope || this.Defaults.Scope;
            }
        }.bind(this);

        var _setScope = function (el, scope, types, connectionType) {
            types = _ju.isArray(types) ? types : [ types ];
            var id = _getId(el);
            connectionType = connectionType || "default";
            for (var i = 0; i < types.length; i++) {
                var eldefs = this[types[i]][id];
                if (eldefs && eldefs[connectionType]) {
                    eldefs[connectionType].def.scope = scope;
                }
            }

        }.bind(this);

        this.getScope = function (el, scope) {
            return _getScope(el, [ "sourceEndpointDefinitions", "targetEndpointDefinitions" ]);
        };
        this.getSourceScope = function (el) {
            return _getScope(el, "sourceEndpointDefinitions");
        };
        this.getTargetScope = function (el) {
            return _getScope(el, "targetEndpointDefinitions");
        };
        this.setScope = function (el, scope, connectionType) {
            this.setSourceScope(el, scope, connectionType);
            this.setTargetScope(el, scope, connectionType);
        };
        this.setSourceScope = function (el, scope, connectionType) {
            _setScope(el, scope, "sourceEndpointDefinitions", connectionType);
            // we get the source scope during the mousedown event, but we also want to set this.
            this.setDragScope(el, scope);
        };
        this.setTargetScope = function (el, scope, connectionType) {
            _setScope(el, scope, "targetEndpointDefinitions", connectionType);
            this.setDropScope(el, scope);
        };

        // see api docs
        this.unmakeEveryTarget = function () {
            for (var i in this.targetEndpointDefinitions)
                _currentInstance.unmakeTarget(i, true);

            this.targetEndpointDefinitions = {};
            return this;
        };

        // does the work of setting a source enabled or disabled.
        var _setEnabled = function (type, el, state, toggle, connectionType) {
            var a = type == "source" ? this.sourceEndpointDefinitions : this.targetEndpointDefinitions;
            connectionType = connectionType || "default";


            if (_ju.isString(el) && a[el] && a[el][connectionType]) {
                a[el][connectionType].enabled = toggle ? !a[el][connectionType].enabled : state;
            }
            else if (el.length) {
                for (var i = 0, ii = el.length; i < ii; i++) {
                    var info = _info(el[i]);
                    if (a[info.id] && a[info.id][connectionType])
                        a[info.id][connectionType].enabled = toggle ? !a[info.id][connectionType].enabled : state;
                }
            }
            // otherwise a DOM element
            else {
                var id = _info(el).id;
                if (a[id] && a[id][connectionType])
                    a[id][connectionType].enabled = toggle ? !a[id][connectionType].enabled : state;
            }
            return this;
        }.bind(this);

        var _first = function (el, fn) {
            if (_ju.isString(el) || !el.length)
                return fn.apply(this, [ el ]);
            else if (el.length)
                return fn.apply(this, [ el[0] ]);

        }.bind(this);

        this.toggleSourceEnabled = function (el, connectionType) {
            _setEnabled("source", el, null, true, connectionType);
            return this.isSourceEnabled(el, connectionType);
        };

        this.setSourceEnabled = function (el, state, connectionType) {
            return _setEnabled("source", el, state, null, connectionType);
        };
        this.isSource = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var eldefs = this.sourceEndpointDefinitions[_info(_el).id];
                return eldefs != null && eldefs[connectionType] != null;
            }.bind(this));
        };
        this.isSourceEnabled = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var sep = this.sourceEndpointDefinitions[_info(_el).id];
                return sep && sep[connectionType] && sep[connectionType].enabled === true;
            }.bind(this));
        };

        this.toggleTargetEnabled = function (el, connectionType) {
            _setEnabled("target", el, null, true, connectionType);
            return this.isTargetEnabled(el, connectionType);
        };

        this.isTarget = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var eldefs = this.targetEndpointDefinitions[_info(_el).id];
                return eldefs != null && eldefs[connectionType] != null;
            }.bind(this));
        };
        this.isTargetEnabled = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var tep = this.targetEndpointDefinitions[_info(_el).id];
                return tep && tep[connectionType] && tep[connectionType].enabled === true;
            }.bind(this));
        };
        this.setTargetEnabled = function (el, state, connectionType) {
            return _setEnabled("target", el, state, null, connectionType);
        };

// --------------------- end makeSource/makeTarget ---------------------------------------------- 				

        this.ready = function (fn) {
            _currentInstance.bind("ready", fn);
        };

        var _elEach = function(el, fn) {
            // support both lists...
            if (typeof el == 'object' && el.length)
                for (var i = 0, ii = el.length; i < ii; i++) {
                    fn(el[i]);
                }
            else // ...and single strings or elements.
                fn(el);

            return _currentInstance;
        };

        // repaint some element's endpoints and connections
        this.repaint = function (el, ui, timestamp) {
            return _elEach(el, function(_el) {
                _draw(_el, ui, timestamp);
            });
        };

        this.revalidate = function (el, timestamp, isIdAlready) {
            return _elEach(el, function(_el) {
                var elId = isIdAlready ? _el : _currentInstance.getId(_el);
                _currentInstance.updateOffset({ elId: elId, recalc: true, timestamp:timestamp });
                _currentInstance.repaint(_el);
            });
        };

        // repaint every endpoint and connection.
        this.repaintEverything = function () {
            // TODO this timestamp causes continuous anchors to not repaint properly.
            // fix this. do not just take out the timestamp. it runs a lot faster with
            // the timestamp included.
            var timestamp = _timestamp(), elId;

            for (elId in endpointsByElement) {
                _currentInstance.updateOffset({ elId: elId, recalc: true, timestamp: timestamp });
            }

            for (elId in endpointsByElement) {
                _draw(elId, null, timestamp);
            }

            return this;
        };

        this.removeAllEndpoints = function (el, recurse, affectedElements) {
            affectedElements = affectedElements || [];
            var _one = function (_el) {
                var info = _info(_el),
                    ebe = endpointsByElement[info.id],
                    i, ii;

                if (ebe) {
                    affectedElements.push(info);
                    for (i = 0, ii = ebe.length; i < ii; i++)
                        _currentInstance.deleteEndpoint(ebe[i], false);
                }
                delete endpointsByElement[info.id];

                if (recurse) {
                    if (info.el && info.el.nodeType != 3 && info.el.nodeType != 8) {
                        for (i = 0, ii = info.el.childNodes.length; i < ii; i++) {
                            _one(info.el.childNodes[i]);
                        }
                    }
                }

            };
            _one(el);
            return this;
        };

        var _doRemove = function(info, affectedElements) {
            _currentInstance.removeAllEndpoints(info.id, true, affectedElements);
            var _one = function(_info) {
                _currentInstance.getDragManager().elementRemoved(_info.id);
                _currentInstance.anchorManager.clearFor(_info.id);
                _currentInstance.anchorManager.removeFloatingConnection(_info.id);

                if (_currentInstance.isSource(_info.el)) _currentInstance.unmakeSource(_info.el);
                if (_currentInstance.isTarget(_info.el)) _currentInstance.unmakeTarget(_info.el);
                _currentInstance.destroyDraggable(_info.el);
                _currentInstance.destroyDroppable(_info.el);


                delete _currentInstance.floatingConnections[_info.id];
                delete managedElements[_info.id];
                delete offsets[_info.id];
                if (_info.el) {
                    _currentInstance.removeElement(_info.el);
                    _info.el._jsPlumb = null;
                }
            };

            // remove all affected child elements
            for (var ae = 1; ae < affectedElements.length; ae++) {
                _one(affectedElements[ae]);
            }
            // and always remove the requested one from the dom.
            _one(info);
        };

        /**
         * Remove the given element, including cleaning up all endpoints registered for it.
         * This is exposed in the public API but also used internally by jsPlumb when removing the
         * element associated with a connection drag.
         */
        this.remove = function (el, doNotRepaint) {
            var info = _info(el), affectedElements = [];
            if (info.text) {
                info.el.parentNode.removeChild(info.el);
            }
            else if (info.id) {
                _currentInstance.batch(function () {
                    _doRemove(info, affectedElements);
                }, doNotRepaint === false);
            }
            return _currentInstance;
        };

        this.empty = function (el, doNotRepaint) {
            var affectedElements = [];
            var _one = function(el, dontRemoveFocus) {
                var info = _info(el);
                if (info.text) {
                    info.el.parentNode.removeChild(info.el);
                }
                else if (info.el) {
                    while(info.el.childNodes.length > 0) {
                        _one(info.el.childNodes[0]);
                    }
                    if (!dontRemoveFocus) _doRemove(info, affectedElements);
                }
            };

            _currentInstance.batch(function() {
                _one(el, true);
            }, doNotRepaint === false);

            return _currentInstance;
        };

        this.reset = function () {
            _currentInstance.silently(function() {
                _currentInstance.removeAllGroups();
                _currentInstance.removeGroupManager();
                _currentInstance.deleteEveryEndpoint();
                _currentInstance.unbind();
                this.targetEndpointDefinitions = {};
                this.sourceEndpointDefinitions = {};
                connections.length = 0;
                if (this.doReset) this.doReset();
            }.bind(this));
        };

        var _clearObject = function (obj) {
            if (obj.canvas && obj.canvas.parentNode)
                obj.canvas.parentNode.removeChild(obj.canvas);
            obj.cleanup();
            obj.destroy();
        };

        this.clear = function () {
            _currentInstance.select().each(_clearObject);
            _currentInstance.selectEndpoints().each(_clearObject);

            endpointsByElement = {};
            endpointsByUUID = {};
        };

        this.setDefaultScope = function (scope) {
            DEFAULT_SCOPE = scope;
            return _currentInstance;
        };

        // sets whether or not some element should be currently draggable.
        this.setDraggable = _setDraggable;

        this.deriveEndpointAndAnchorSpec = function(type, dontPrependDefault) {
            var bits = ((dontPrependDefault ? "" : "default ") + type).split(/[\s]/), eps = null, ep = null, a = null, as = null;
            for (var i = 0; i < bits.length; i++) {
                var _t = _currentInstance.getType(bits[i], "connection");
                if (_t) {
                    if (_t.endpoints) eps = _t.endpoints;
                    if (_t.endpoint) ep = _t.endpoint;
                    if (_t.anchors) as = _t.anchors;
                    if (_t.anchor) a = _t.anchor;
                }
            }
            return { endpoints: eps ? eps : [ ep, ep ], anchors: as ? as : [a, a ]};
        };

        // sets the id of some element, changing whatever we need to to keep track.
        this.setId = function (el, newId, doNotSetAttribute) {
            //
            var id;

            if (_ju.isString(el)) {
                id = el;
            }
            else {
                el = this.getElement(el);
                id = this.getId(el);
            }

            var sConns = this.getConnections({source: id, scope: '*'}, true),
                tConns = this.getConnections({target: id, scope: '*'}, true);

            newId = "" + newId;

            if (!doNotSetAttribute) {
                el = this.getElement(id);
                this.setAttribute(el, "id", newId);
            }
            else
                el = this.getElement(newId);

            endpointsByElement[newId] = endpointsByElement[id] || [];
            for (var i = 0, ii = endpointsByElement[newId].length; i < ii; i++) {
                endpointsByElement[newId][i].setElementId(newId);
                endpointsByElement[newId][i].setReferenceElement(el);
            }
            delete endpointsByElement[id];

            this.sourceEndpointDefinitions[newId] = this.sourceEndpointDefinitions[id];
            delete this.sourceEndpointDefinitions[id];
            this.targetEndpointDefinitions[newId] = this.targetEndpointDefinitions[id];
            delete this.targetEndpointDefinitions[id];

            this.anchorManager.changeId(id, newId);
            this.getDragManager().changeId(id, newId);
            managedElements[newId] = managedElements[id];
            delete managedElements[id];

            var _conns = function (list, epIdx, type) {
                for (var i = 0, ii = list.length; i < ii; i++) {
                    list[i].endpoints[epIdx].setElementId(newId);
                    list[i].endpoints[epIdx].setReferenceElement(el);
                    list[i][type + "Id"] = newId;
                    list[i][type] = el;
                }
            };
            _conns(sConns, 0, "source");
            _conns(tConns, 1, "target");

            this.repaint(newId);
        };

        this.setDebugLog = function (debugLog) {
            log = debugLog;
        };

        this.setSuspendDrawing = function (val, repaintAfterwards) {
            var curVal = _suspendDrawing;
            _suspendDrawing = val;
            if (val) _suspendedAt = new Date().getTime(); else _suspendedAt = null;
            if (repaintAfterwards) this.repaintEverything();
            return curVal;
        };

        // returns whether or not drawing is currently suspended.
        this.isSuspendDrawing = function () {
            return _suspendDrawing;
        };

        // return timestamp for when drawing was suspended.
        this.getSuspendedAt = function () {
            return _suspendedAt;
        };

        this.batch = function (fn, doNotRepaintAfterwards) {
            var _wasSuspended = this.isSuspendDrawing();
            if (!_wasSuspended)
                this.setSuspendDrawing(true);
            try {
                fn();
            }
            catch (e) {
                _ju.log("Function run while suspended failed", e);
            }
            if (!_wasSuspended)
                this.setSuspendDrawing(false, !doNotRepaintAfterwards);
        };

        this.doWhileSuspended = this.batch;

        this.getCachedData = _getCachedData;
        this.timestamp = _timestamp;
        this.show = function (el, changeEndpoints) {
            _setVisible(el, "block", changeEndpoints);
            return _currentInstance;
        };

        // TODO: update this method to return the current state.
        this.toggleVisible = _toggleVisible;
        this.toggleDraggable = _toggleDraggable;
        this.addListener = this.bind;
    };

    _ju.extend(root.jsPlumbInstance, _ju.EventGenerator, {
        setAttribute: function (el, a, v) {
            this.setAttribute(el, a, v);
        },
        getAttribute: function (el, a) {
            return this.getAttribute(root.jsPlumb.getElement(el), a);
        },
        convertToFullOverlaySpec: function(spec) {
            if (_ju.isString(spec)) {
                spec = [ spec, { } ];
            }
            spec[1].id = spec[1].id || _ju.uuid();
            return spec;
        },
        registerConnectionType: function (id, type) {
            this._connectionTypes[id] = root.jsPlumb.extend({}, type);
            if (type.overlays) {
                var to = {};
                for (var i = 0; i < type.overlays.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = this.convertToFullOverlaySpec(type.overlays[i]);
                    to[fo[1].id] = fo;
                }
                this._connectionTypes[id].overlays = to;
            }
        },
        registerConnectionTypes: function (types) {
            for (var i in types)
                this.registerConnectionType(i, types[i]);
        },
        registerEndpointType: function (id, type) {
            this._endpointTypes[id] = root.jsPlumb.extend({}, type);
            if (type.overlays) {
                var to = {};
                for (var i = 0; i < type.overlays.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = this.convertToFullOverlaySpec(type.overlays[i]);
                    to[fo[1].id] = fo;
                }
                this._endpointTypes[id].overlays = to;
            }
        },
        registerEndpointTypes: function (types) {
            for (var i in types)
                //this._endpointTypes[i] = jsPlumb.extend({}, types[i]);
                this.registerEndpointType(i, types[i]);
        },
        getType: function (id, typeDescriptor) {
            return typeDescriptor === "connection" ? this._connectionTypes[id] : this._endpointTypes[id];
        },
        setIdChanged: function (oldId, newId) {
            this.setId(oldId, newId, true);
        },
        // set parent: change the parent for some node and update all the registrations we need to.
        setParent: function (el, newParent) {
            var _dom = this.getElement(el),
                _id = this.getId(_dom),
                _pdom = this.getElement(newParent),
                _pid = this.getId(_pdom);

            _dom.parentNode.removeChild(_dom);
            _pdom.appendChild(_dom);
            this.getDragManager().setParent(_dom, _id, _pdom, _pid);
        },
        extend: function (o1, o2, names) {
            var i;
            if (names) {
                for (i = 0; i < names.length; i++)
                    o1[names[i]] = o2[names[i]];
            }
            else
                for (i in o2) o1[i] = o2[i];
            return o1;
        },
        floatingConnections: {},
        getFloatingAnchorIndex: function (jpc) {
            return jpc.endpoints[0].isFloating() ? 0 : jpc.endpoints[1].isFloating() ? 1 : -1;
        }
    });

// --------------------- static instance + AMD registration -------------------------------------------	

// create static instance and assign to window if window exists.	
    var jsPlumb = new jsPlumbInstance();
    // register on 'root' (lets us run on server or browser)
    root.jsPlumb = jsPlumb;
    // add 'getInstance' method to static instance
    jsPlumb.getInstance = function (_defaults) {
        var j = new jsPlumbInstance(_defaults);
        j.init();
        return j;
    };
    jsPlumb.each = function (spec, fn) {
        if (spec == null) return;
        if (typeof spec === "string")
            fn(jsPlumb.getElement(spec));
        else if (spec.length != null) {
            for (var i = 0; i < spec.length; i++)
                fn(jsPlumb.getElement(spec[i]));
        }
        else
            fn(spec); // assume it's an element.
    };
// maybe register static instance as an AMD module, and getInstance method too.
    if (typeof define === "function") {
        define("jsplumb", [], function () {
            return jsPlumb;
        });
        define("jsplumbinstance", [], function () {
            return jsPlumb.getInstance();
        });
    }
    // CommonJS
    if (typeof exports !== 'undefined') {
        exports.jsPlumb = jsPlumb;
    }

    // npm
    if (typeof module !== "undefined") {
        module.exports = jsPlumb;
    }

// --------------------- end static instance + AMD registration -------------------------------------------		

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.1.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the base functionality for DOM type adapters.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    var root = this, _ju = root.jsPlumbUtil;

    var svgAvailable = !!window.SVGAngle || document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"),

        _genLoc = function (e, prefix) {
            if (e == null) return [ 0, 0 ];
            var ts = _touches(e), t = _getTouch(ts, 0);
            return [t[prefix + "X"], t[prefix + "Y"]];
        },
        _pageLocation = function (e) {
            if (e == null) return [ 0, 0 ];
            return _genLoc(e, "page");
        },
        _screenLocation = function (e) {
            return _genLoc(e, "screen");
        },
        _clientLocation = function (e) {
            return _genLoc(e, "client");
        },
        _getTouch = function (touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
        },
        _touches = function (e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        };

    /**
     Manages dragging for some instance of jsPlumb.

     TODO instead of this being accessed directly, it should subscribe to events on the jsPlumb instance: every method
     in here is called directly by jsPlumb. But what should happen is that we have unpublished events that this listens
     to.  The only trick is getting one of these instantiated with every jsPlumb instance: it needs to have a hook somehow.
     Basically the general idea is to pull ALL the drag code out (prototype method registrations plus this) into a
     dedicated drag script), that does not necessarily need to be included.


     */
    var DragManager = function (_currentInstance) {
        var _draggables = {}, _dlist = [], _delements = {}, _elementsWithEndpoints = {},
        // elementids mapped to the draggable to which they belong.
            _draggablesForElements = {};

        /**
         register some element as draggable.  right now the drag init stuff is done elsewhere, and it is
         possible that will continue to be the case.
         */
        this.register = function (el) {
            var id = _currentInstance.getId(el),
                parentOffset = _currentInstance.getOffset(el);

            if (!_draggables[id]) {
                _draggables[id] = el;
                _dlist.push(el);
                _delements[id] = {};
            }

            // look for child elements that have endpoints and register them against this draggable.
            var _oneLevel = function (p) {
                if (p) {
                    for (var i = 0; i < p.childNodes.length; i++) {
                        if (p.childNodes[i].nodeType != 3 && p.childNodes[i].nodeType != 8) {
                            var cEl = jsPlumb.getElement(p.childNodes[i]),
                                cid = _currentInstance.getId(p.childNodes[i], null, true);
                            if (cid && _elementsWithEndpoints[cid] && _elementsWithEndpoints[cid] > 0) {
                                var cOff = _currentInstance.getOffset(cEl);
                                _delements[id][cid] = {
                                    id: cid,
                                    offset: {
                                        left: cOff.left - parentOffset.left,
                                        top: cOff.top - parentOffset.top
                                    }
                                };
                                _draggablesForElements[cid] = id;
                            }
                            _oneLevel(p.childNodes[i]);
                        }
                    }
                }
            };

            _oneLevel(el);
        };

        // refresh the offsets for child elements of this element.
        this.updateOffsets = function (elId, childOffsetOverrides) {
            if (elId != null) {
                childOffsetOverrides = childOffsetOverrides || {};
                var domEl = jsPlumb.getElement(elId),
                    id = _currentInstance.getId(domEl),
                    children = _delements[id],
                    parentOffset = _currentInstance.getOffset(domEl);

                if (children) {
                    for (var i in children) {
                        if (children.hasOwnProperty(i)) {
                            var cel = jsPlumb.getElement(i),
                                cOff = childOffsetOverrides[i] || _currentInstance.getOffset(cel);

                            // do not update if we have a value already and we'd just be writing 0,0
                            if (cel.offsetParent == null && _delements[id][i] != null) continue;

                            _delements[id][i] = {
                                id: i,
                                offset: {
                                    left: cOff.left - parentOffset.left,
                                    top: cOff.top - parentOffset.top
                                }
                            };
                            _draggablesForElements[i] = id;
                        }
                    }
                }
            }
        };

        /**
         notification that an endpoint was added to the given el.  we go up from that el's parent
         node, looking for a parent that has been registered as a draggable. if we find one, we add this
         el to that parent's list of elements to update on drag (if it is not there already)
         */
        this.endpointAdded = function (el, id) {

            id = id || _currentInstance.getId(el);

            var b = document.body,
                p = el.parentNode;

            _elementsWithEndpoints[id] = _elementsWithEndpoints[id] ? _elementsWithEndpoints[id] + 1 : 1;

            while (p != null && p != b) {
                var pid = _currentInstance.getId(p, null, true);
                if (pid && _draggables[pid]) {
                    var pLoc = _currentInstance.getOffset(p);

                    if (_delements[pid][id] == null) {
                        var cLoc = _currentInstance.getOffset(el);
                        _delements[pid][id] = {
                            id: id,
                            offset: {
                                left: cLoc.left - pLoc.left,
                                top: cLoc.top - pLoc.top
                            }
                        };
                        _draggablesForElements[id] = pid;
                    }
                    break;
                }
                p = p.parentNode;
            }
        };

        this.endpointDeleted = function (endpoint) {
            if (_elementsWithEndpoints[endpoint.elementId]) {
                _elementsWithEndpoints[endpoint.elementId]--;
                if (_elementsWithEndpoints[endpoint.elementId] <= 0) {
                    for (var i in _delements) {
                        if (_delements.hasOwnProperty(i) && _delements[i]) {
                            delete _delements[i][endpoint.elementId];
                            delete _draggablesForElements[endpoint.elementId];
                        }
                    }
                }
            }
        };

        this.changeId = function (oldId, newId) {
            _delements[newId] = _delements[oldId];
            _delements[oldId] = {};
            _draggablesForElements[newId] = _draggablesForElements[oldId];
            _draggablesForElements[oldId] = null;
        };

        this.getElementsForDraggable = function (id) {
            return _delements[id];
        };

        this.elementRemoved = function (elementId) {
            var elId = _draggablesForElements[elementId];
            if (elId) {
                delete _delements[elId][elementId];
                delete _draggablesForElements[elementId];
            }
        };

        this.reset = function () {
            _draggables = {};
            _dlist = [];
            _delements = {};
            _elementsWithEndpoints = {};
        };

        //
        // notification drag ended. We check automatically if need to update some
        // ancestor's offsets.
        //
        this.dragEnded = function (el) {
            if (el.offsetParent != null) {
                var id = _currentInstance.getId(el),
                    ancestor = _draggablesForElements[id];

                if (ancestor) this.updateOffsets(ancestor);
            }
        };

        this.setParent = function (el, elId, p, pId, currentChildLocation) {
            var current = _draggablesForElements[elId];
            if (!_delements[pId]) {
                _delements[pId] = {};
            }
            var pLoc = _currentInstance.getOffset(p),
                cLoc = currentChildLocation || _currentInstance.getOffset(el);
            if (current) {
                delete _delements[current][elId];
            }

            _delements[pId][elId] = {
                id:elId,
                offset : {
                    left: cLoc.left - pLoc.left,
                    top: cLoc.top - pLoc.top
                }
            };
            _draggablesForElements[elId] = pId;
        };

        this.clearParent = function(el, elId) {
            var current = _draggablesForElements[elId];
            if (current) {
                delete _delements[current][elId];
                delete _draggablesForElements[elId];
            }
        };

        this.revalidateParent = function(el, elId, childOffset) {
            var current = _draggablesForElements[elId];
            if (current) {
                var co = {};
                co[elId] = childOffset;
                this.updateOffsets(current, co);
                _currentInstance.revalidate(current);
            }
        };

        this.getDragAncestor = function (el) {
            var de = jsPlumb.getElement(el),
                id = _currentInstance.getId(de),
                aid = _draggablesForElements[id];

            if (aid)
                return jsPlumb.getElement(aid);
            else
                return null;
        };

    };

    var trim = function (str) {
            return str == null ? null : (str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''));
        },
        _setClassName = function (el, cn) {
            cn = trim(cn);
            if (typeof el.className.baseVal != "undefined")  // SVG
                el.className.baseVal = cn;
            else
                el.className = cn;
        },
        _getClassName = function (el) {
            return (typeof el.className.baseVal == "undefined") ? el.className : el.className.baseVal;
        },
        _classManip = function (el, classesToAdd, classesToRemove) {
            classesToAdd = classesToAdd == null ? [] : _ju.isArray(classesToAdd) ? classesToAdd : classesToAdd.split(/\s+/);
            classesToRemove = classesToRemove == null ? [] : _ju.isArray(classesToRemove) ? classesToRemove : classesToRemove.split(/\s+/);

            var className = _getClassName(el),
                curClasses = className.split(/\s+/);

            var _oneSet = function (add, classes) {
                for (var i = 0; i < classes.length; i++) {
                    if (add) {
                        if (curClasses.indexOf(classes[i]) == -1)
                            curClasses.push(classes[i]);
                    }
                    else {
                        var idx = curClasses.indexOf(classes[i]);
                        if (idx != -1)
                            curClasses.splice(idx, 1);
                    }
                }
            };

            _oneSet(true, classesToAdd);
            _oneSet(false, classesToRemove);

            _setClassName(el, curClasses.join(" "));
        };

    root.jsPlumb.extend(root.jsPlumbInstance.prototype, {

        headless: false,

        pageLocation: _pageLocation,
        screenLocation: _screenLocation,
        clientLocation: _clientLocation,

        getDragManager:function() {
            if (this.dragManager == null)
                this.dragManager = new DragManager(this);

            return this.dragManager;
        },

        recalculateOffsets:function(elId) {
            this.getDragManager().updateOffsets(elId);
        },

        createElement:function(tag, style, clazz, atts) {
            return this.createElementNS(null, tag, style, clazz, atts);
        },

        createElementNS:function(ns, tag, style, clazz, atts) {
            var e = ns == null ? document.createElement(tag) : document.createElementNS(ns, tag);
            var i;
            style = style || {};
            for (i in style)
                e.style[i] = style[i];

            if (clazz)
                e.className = clazz;

            atts = atts || {};
            for (i in atts)
                e.setAttribute(i, "" + atts[i]);

            return e;
        },

        getAttribute: function (el, attName) {
            return el.getAttribute != null ? el.getAttribute(attName) : null;
        },

        setAttribute: function (el, a, v) {
            if (el.setAttribute != null) el.setAttribute(a, v);
        },

        setAttributes: function (el, atts) {
            for (var i in atts)
                if (atts.hasOwnProperty(i)) el.setAttribute(i, atts[i]);
        },
        appendToRoot: function (node) {
            document.body.appendChild(node);
        },
        getRenderModes: function () {
            return [ "svg"  ];
        },
        getClass:_getClassName,
        addClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _classManip(e, clazz);
            });
        },
        hasClass: function (el, clazz) {
            el = jsPlumb.getElement(el);
            if (el.classList) return el.classList.contains(clazz);
            else {
                return _getClassName(el).indexOf(clazz) != -1;
            }
        },
        removeClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _classManip(e, null, clazz);
            });
        },
        updateClasses: function (el, toAdd, toRemove) {
            jsPlumb.each(el, function (e) {
                _classManip(e, toAdd, toRemove);
            });
        },
        setClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _setClassName(e, clazz);
            });
        },
        setPosition: function (el, p) {
            el.style.left = p.left + "px";
            el.style.top = p.top + "px";
        },
        getPosition: function (el) {
            var _one = function (prop) {
                var v = el.style[prop];
                return v ? v.substring(0, v.length - 2) : 0;
            };
            return {
                left: _one("left"),
                top: _one("top")
            };
        },
        getStyle:function(el, prop) {
            if (typeof window.getComputedStyle !== 'undefined') {
                return getComputedStyle(el, null).getPropertyValue(prop);
            } else {
                return el.currentStyle[prop];
            }
        },
        getSelector: function (ctx, spec) {
            var sel = null;
            if (arguments.length == 1) {
                sel = ctx.nodeType != null ? ctx : document.querySelectorAll(ctx);
            }
            else
                sel = ctx.querySelectorAll(spec);

            return sel;
        },
        getOffset:function(el, relativeToRoot, container) {
            el = jsPlumb.getElement(el);
            container = container || this.getContainer();
            var out = {
                    left: el.offsetLeft,
                    top: el.offsetTop
                },
                op = (relativeToRoot  || (container != null && (el != container && el.offsetParent != container))) ?  el.offsetParent : null,
                _maybeAdjustScroll = function(offsetParent) {
                    if (offsetParent != null && offsetParent !== document.body && (offsetParent.scrollTop > 0 || offsetParent.scrollLeft > 0)) {
                        out.left -= offsetParent.scrollLeft;
                        out.top -= offsetParent.scrollTop;
                    }
                }.bind(this);

            while (op != null) {
                out.left += op.offsetLeft;
                out.top += op.offsetTop;
                _maybeAdjustScroll(op);
                op = relativeToRoot ? op.offsetParent :
                        op.offsetParent == container ? null : op.offsetParent;
            }

            // if container is scrolled and the element (or its offset parent) is not absolute or fixed, adjust accordingly.
            if (container != null && !relativeToRoot && (container.scrollTop > 0 || container.scrollLeft > 0)) {
                var pp = el.offsetParent != null ? this.getStyle(el.offsetParent, "position") : "static",
                    p = this.getStyle(el, "position");
                if (p !== "absolute" && p !== "fixed" && pp !== "absolute" && pp != "fixed") {
                    out.left -= container.scrollLeft;
                    out.top -= container.scrollTop;
                }
            }
            return out;
        },
        //
        // return x+y proportion of the given element's size corresponding to the location of the given event.
        //
        getPositionOnElement: function (evt, el, zoom) {
            var box = typeof el.getBoundingClientRect !== "undefined" ? el.getBoundingClientRect() : { left: 0, top: 0, width: 0, height: 0 },
                body = document.body,
                docElem = document.documentElement,
                scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
                scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
                clientTop = docElem.clientTop || body.clientTop || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                pst = 0,
                psl = 0,
                top = box.top + scrollTop - clientTop + (pst * zoom),
                left = box.left + scrollLeft - clientLeft + (psl * zoom),
                cl = jsPlumb.pageLocation(evt),
                w = box.width || (el.offsetWidth * zoom),
                h = box.height || (el.offsetHeight * zoom),
                x = (cl[0] - left) / w,
                y = (cl[1] - top) / h;

            return [ x, y ];
        },

        /**
         * Gets the absolute position of some element as read from the left/top properties in its style.
         * @method getAbsolutePosition
         * @param {Element} el The element to retrieve the absolute coordinates from. **Note** this is a DOM element, not a selector from the underlying library.
         * @return {Number[]} [left, top] pixel values.
         */
        getAbsolutePosition: function (el) {
            var _one = function (s) {
                var ss = el.style[s];
                if (ss) return parseFloat(ss.substring(0, ss.length - 2));
            };
            return [ _one("left"), _one("top") ];
        },

        /**
         * Sets the absolute position of some element by setting the left/top properties in its style.
         * @method setAbsolutePosition
         * @param {Element} el The element to set the absolute coordinates on. **Note** this is a DOM element, not a selector from the underlying library.
         * @param {Number[]} xy x and y coordinates
         * @param {Number[]} [animateFrom] Optional previous xy to animate from.
         * @param {Object} [animateOptions] Options for the animation.
         */
        setAbsolutePosition: function (el, xy, animateFrom, animateOptions) {
            if (animateFrom) {
                this.animate(el, {
                    left: "+=" + (xy[0] - animateFrom[0]),
                    top: "+=" + (xy[1] - animateFrom[1])
                }, animateOptions);
            }
            else {
                el.style.left = xy[0] + "px";
                el.style.top = xy[1] + "px";
            }
        },
        /**
         * gets the size for the element, in an array : [ width, height ].
         */
        getSize: function (el) {
            return [ el.offsetWidth, el.offsetHeight ];
        },
        getWidth: function (el) {
            return el.offsetWidth;
        },
        getHeight: function (el) {
            return el.offsetHeight;
        }

    });
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.1.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains code for components that support overlays.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    // ------------------------------ BEGIN OverlayCapablejsPlumbUIComponent --------------------------------------------

    var _internalLabelOverlayId = "__label",
    // this is a shortcut helper method to let people add a label as
    // overlay.
        _makeLabelOverlay = function (component, params) {

            var _params = {
                    cssClass: params.cssClass,
                    labelStyle: component.labelStyle,
                    id: _internalLabelOverlayId,
                    component: component,
                    _jsPlumb: component._jsPlumb.instance  // TODO not necessary, since the instance can be accessed through the component.
                },
                mergedParams = _jp.extend(_params, params);

            return new _jp.Overlays[component._jsPlumb.instance.getRenderMode()].Label(mergedParams);
        },
        _processOverlay = function (component, o) {
            var _newOverlay = null;
            if (_ju.isArray(o)) {	// this is for the shorthand ["Arrow", { width:50 }] syntax
                // there's also a three arg version:
                // ["Arrow", { width:50 }, {location:0.7}]
                // which merges the 3rd arg into the 2nd.
                var type = o[0],
                // make a copy of the object so as not to mess up anyone else's reference...
                    p = _jp.extend({component: component, _jsPlumb: component._jsPlumb.instance}, o[1]);
                if (o.length == 3) _jp.extend(p, o[2]);
                _newOverlay = new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][type](p);
            } else if (o.constructor == String) {
                _newOverlay = new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][o]({component: component, _jsPlumb: component._jsPlumb.instance});
            } else {
                _newOverlay = o;
            }

            _newOverlay.id = _newOverlay.id || _ju.uuid();
            component.cacheTypeItem("overlay", _newOverlay, _newOverlay.id);
            //component._jsPlumb.overlays.push(_newOverlay);
            component._jsPlumb.overlays[_newOverlay.id] = _newOverlay;

            return _newOverlay;
        };

    _jp.OverlayCapableJsPlumbUIComponent = function (params) {

        root.jsPlumbUIComponent.apply(this, arguments);
        this._jsPlumb.overlays = {};
        this._jsPlumb.overlayPositions = {};

        if (params.label) {
            this.getDefaultType().overlays[_internalLabelOverlayId] = ["Label", {
                label: params.label,
                location: params.labelLocation || this.defaultLabelLocation || 0.5,
                labelStyle: params.labelStyle || this._jsPlumb.instance.Defaults.LabelStyle,
                id:_internalLabelOverlayId
            }];
        }

        this.setListenerComponent = function (c) {
            if (this._jsPlumb) {
                for (var i in this._jsPlumb.overlays)
                    this._jsPlumb.overlays[i].setListenerComponent(c);
            }
        };
    };

    _jp.OverlayCapableJsPlumbUIComponent.applyType = function (component, t) {
        if (t.overlays) {
            // loop through the ones in the type. if already present on the component,
            // dont remove or re-add.
            var keep = {}, i;

            for (i in t.overlays) {

                var existing = component._jsPlumb.overlays[t.overlays[i][1].id];
                if (existing) {
                    // maybe update from data, if there were parameterised values for instance.
                    existing.updateFrom(t.overlays[i][1]);
                    keep[t.overlays[i][1].id] = true;
                }
                else {
                    var c = component.getCachedTypeItem("overlay", t.overlays[i][1].id);
                    if (c != null) {
                        c.reattach(component._jsPlumb.instance);
                        // maybe update from data, if there were parameterised values for instance.
                        c.updateFrom(t.overlays[i][1]);
                        component._jsPlumb.overlays[c.id] = c;
                    }
                    else {
                        c = component.addOverlay(t.overlays[i], true);
                    }
                    keep[c.id] = true;
                }
            }

            // now loop through the full overlays and remove those that we dont want to keep
            for (i in component._jsPlumb.overlays) {
                if (keep[component._jsPlumb.overlays[i].id] == null)
                    component.removeOverlay(component._jsPlumb.overlays[i].id, true); // remove overlay but dont clean it up.
                    // that would remove event listeners etc; overlays are never discarded by the types stuff, they are
                    // just detached/reattached.
            }
        }
    };

    _ju.extend(_jp.OverlayCapableJsPlumbUIComponent, root.jsPlumbUIComponent, {

        setHover: function (hover, ignoreAttachedElements) {
            if (this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) {
                for (var i in this._jsPlumb.overlays) {
                    this._jsPlumb.overlays[i][hover ? "addClass" : "removeClass"](this._jsPlumb.instance.hoverClass);
                }
            }
        },
        addOverlay: function (overlay, doNotRepaint) {
            var o = _processOverlay(this, overlay);
            if (!doNotRepaint) this.repaint();
            return o;
        },
        getOverlay: function (id) {
            return this._jsPlumb.overlays[id];
        },
        getOverlays: function () {
            return this._jsPlumb.overlays;
        },
        hideOverlay: function (id) {
            var o = this.getOverlay(id);
            if (o) o.hide();
        },
        hideOverlays: function () {
            for (var i in this._jsPlumb.overlays)
                this._jsPlumb.overlays[i].hide();
        },
        showOverlay: function (id) {
            var o = this.getOverlay(id);
            if (o) o.show();
        },
        showOverlays: function () {
            for (var i in this._jsPlumb.overlays)
                this._jsPlumb.overlays[i].show();
        },
        removeAllOverlays: function (doNotRepaint) {
            for (var i in this._jsPlumb.overlays) {
                if (this._jsPlumb.overlays[i].cleanup) this._jsPlumb.overlays[i].cleanup();
            }

            this._jsPlumb.overlays = {};
            this._jsPlumb.overlayPositions = null;
            if (!doNotRepaint)
                this.repaint();
        },
        removeOverlay: function (overlayId, dontCleanup) {
            var o = this._jsPlumb.overlays[overlayId];
            if (o) {
                if (!dontCleanup && o.cleanup) o.cleanup();
                delete this._jsPlumb.overlays[overlayId];
                if (this._jsPlumb.overlayPositions)
                    delete this._jsPlumb.overlayPositions[overlayId];
            }
        },
        removeOverlays: function () {
            for (var i = 0, j = arguments.length; i < j; i++)
                this.removeOverlay(arguments[i]);
        },
        moveParent: function (newParent) {
            if (this.bgCanvas) {
                this.bgCanvas.parentNode.removeChild(this.bgCanvas);
                newParent.appendChild(this.bgCanvas);
            }

            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
                newParent.appendChild(this.canvas);

                for (var i in this._jsPlumb.overlays) {
                    if (this._jsPlumb.overlays[i].isAppendedAtTopLevel) {
                        var el = this._jsPlumb.overlays[i].getElement();
                        el.parentNode.removeChild(el);
                        newParent.appendChild(el);
                    }
                }
            }
        },
        getLabel: function () {
            var lo = this.getOverlay(_internalLabelOverlayId);
            return lo != null ? lo.getLabel() : null;
        },
        getLabelOverlay: function () {
            return this.getOverlay(_internalLabelOverlayId);
        },
        setLabel: function (l) {
            var lo = this.getOverlay(_internalLabelOverlayId);
            if (!lo) {
                var params = l.constructor == String || l.constructor == Function ? { label: l } : l;
                lo = _makeLabelOverlay(this, params);
                this._jsPlumb.overlays[_internalLabelOverlayId] = lo;
            }
            else {
                if (l.constructor == String || l.constructor == Function) lo.setLabel(l);
                else {
                    if (l.label) lo.setLabel(l.label);
                    if (l.location) lo.setLocation(l.location);
                }
            }

            if (!this._jsPlumb.instance.isSuspendDrawing())
                this.repaint();
        },
        cleanup: function (force) {
            for (var i in this._jsPlumb.overlays) {
                this._jsPlumb.overlays[i].cleanup(force);
                this._jsPlumb.overlays[i].destroy(force);
            }
            if (force) {
                this._jsPlumb.overlays = {};
                this._jsPlumb.overlayPositions = null;
            }
        },
        setVisible: function (v) {
            this[v ? "showOverlays" : "hideOverlays"]();
        },
        setAbsoluteOverlayPosition: function (overlay, xy) {
            this._jsPlumb.overlayPositions[overlay.id] = xy;
        },
        getAbsoluteOverlayPosition: function (overlay) {
            return this._jsPlumb.overlayPositions ? this._jsPlumb.overlayPositions[overlay.id] : null;
        },
        _clazzManip:function(action, clazz, dontUpdateOverlays) {
            if (!dontUpdateOverlays) {
                for (var i in this._jsPlumb.overlays) {
                    this._jsPlumb.overlays[i][action + "Class"](clazz);
                }
            }
        },
        addClass:function(clazz, dontUpdateOverlays) {
            this._clazzManip("add", clazz, dontUpdateOverlays)
        },
        removeClass:function(clazz, dontUpdateOverlays) {
            this._clazzManip("remove", clazz, dontUpdateOverlays)
        }
    });

// ------------------------------ END OverlayCapablejsPlumbUIComponent --------------------------------------------

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.1.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for Endpoints.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    // create the drag handler for a connection
    var _makeConnectionDragHandler = function (endpoint, placeholder, _jsPlumb) {
        var stopped = false;
        return {
            drag: function () {
                if (stopped) {
                    stopped = false;
                    return true;
                }

                if (placeholder.element) {
                    var _ui = _jsPlumb.getUIPosition(arguments, _jsPlumb.getZoom());
                    if (_ui != null) jsPlumb.setPosition(placeholder.element, _ui);
                    _jsPlumb.repaint(placeholder.element, _ui);
                    // always repaint the source endpoint, because only continuous/dynamic anchors cause the endpoint
                    // to be repainted, so static anchors need to be told (or the endpoint gets dragged around)
                    endpoint.paint({anchorPoint:endpoint.anchor.getCurrentLocation({element:endpoint.element})});
                }
            },
            stopDrag: function () {
                stopped = true;
            }
        };
    };

    // creates a placeholder div for dragging purposes, adds it, and pre-computes its offset.
    var _makeDraggablePlaceholder = function (placeholder, _jsPlumb, ipco, ips) {
        var n = jsPlumb.createElement("div", { position : "absolute" });
        _jsPlumb.appendElement(n);
        var id = _jsPlumb.getId(n);
        jsPlumb.setPosition(n, ipco);
        n.style.width = ips[0] + "px";
        n.style.height = ips[1] + "px";
        _jsPlumb.manage(id, n, true); // TRANSIENT MANAGE
        // create and assign an id, and initialize the offset.
        placeholder.id = id;
        placeholder.element = n;
    };

    // create a floating endpoint (for drag connections)
    var _makeFloatingEndpoint = function (paintStyle, referenceAnchor, endpoint, referenceCanvas, sourceElement, _jsPlumb, _newEndpoint, scope) {
        var floatingAnchor = new _jp.FloatingAnchor({ reference: referenceAnchor, referenceCanvas: referenceCanvas, jsPlumbInstance: _jsPlumb });
        //setting the scope here should not be the way to fix that mootools issue.  it should be fixed by not
        // adding the floating endpoint as a droppable.  that makes more sense anyway!
        // TRANSIENT MANAGE
        return _newEndpoint({
            paintStyle: paintStyle,
            endpoint: endpoint,
            anchor: floatingAnchor,
            source: sourceElement,
            scope: scope
        });
    };

    var typeParameters = [ "connectorStyle", "connectorHoverStyle", "connectorOverlays",
        "connector", "connectionType", "connectorClass", "connectorHoverClass" ];

    // a helper function that tries to find a connection to the given element, and returns it if so. if elementWithPrecedence is null,
    // or no connection to it is found, we return the first connection in our list.
    var findConnectionToUseForDynamicAnchor = function (ep, elementWithPrecedence) {
        var idx = 0;
        if (elementWithPrecedence != null) {
            for (var i = 0; i < ep.connections.length; i++) {
                if (ep.connections[i].sourceId == elementWithPrecedence || ep.connections[i].targetId == elementWithPrecedence) {
                    idx = i;
                    break;
                }
            }
        }

        return ep.connections[idx];
    };

    _jp.Endpoint = function (params) {
        var _jsPlumb = params._jsPlumb,
            _newConnection = params.newConnection,
            _newEndpoint = params.newEndpoint;

        this.idPrefix = "_jsplumb_e_";
        this.defaultLabelLocation = [ 0.5, 0.5 ];
        this.defaultOverlayKeys = ["Overlays", "EndpointOverlays"];
        _jp.OverlayCapableJsPlumbUIComponent.apply(this, arguments);

// TYPE

        this.appendToDefaultType({
            connectionType:params.connectionType,
            maxConnections: params.maxConnections == null ? this._jsPlumb.instance.Defaults.MaxConnections : params.maxConnections, // maximum number of connections this endpoint can be the source of.,
            paintStyle: params.endpointStyle || params.paintStyle || params.style || this._jsPlumb.instance.Defaults.EndpointStyle || _jp.Defaults.EndpointStyle,
            hoverPaintStyle: params.endpointHoverStyle || params.hoverPaintStyle || this._jsPlumb.instance.Defaults.EndpointHoverStyle || _jp.Defaults.EndpointHoverStyle,
            connectorStyle: params.connectorStyle,
            connectorHoverStyle: params.connectorHoverStyle,
            connectorClass: params.connectorClass,
            connectorHoverClass: params.connectorHoverClass,
            connectorOverlays: params.connectorOverlays,
            connector: params.connector,
            connectorTooltip: params.connectorTooltip
        });

// END TYPE

        this._jsPlumb.enabled = !(params.enabled === false);
        this._jsPlumb.visible = true;
        this.element = _jp.getElement(params.source);
        this._jsPlumb.uuid = params.uuid;
        this._jsPlumb.floatingEndpoint = null;
        var inPlaceCopy = null;
        if (this._jsPlumb.uuid) params.endpointsByUUID[this._jsPlumb.uuid] = this;
        this.elementId = params.elementId;
        this.dragProxy = params.dragProxy;

        this._jsPlumb.connectionCost = params.connectionCost;
        this._jsPlumb.connectionsDirected = params.connectionsDirected;
        this._jsPlumb.currentAnchorClass = "";
        this._jsPlumb.events = {};

        var _updateAnchorClass = function () {
            // stash old, get new
            var oldAnchorClass = _jsPlumb.endpointAnchorClassPrefix + "-" + this._jsPlumb.currentAnchorClass;
            this._jsPlumb.currentAnchorClass = this.anchor.getCssClass();
            var anchorClass = _jsPlumb.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");

            this.removeClass(oldAnchorClass);
            this.addClass(anchorClass);
            // add and remove at the same time to reduce the number of reflows.
            jsPlumb.updateClasses(this.element, anchorClass, oldAnchorClass);
        }.bind(this);

        this.prepareAnchor = function(anchorParams) {
            var a = this._jsPlumb.instance.makeAnchor(anchorParams, this.elementId, _jsPlumb);
            a.bind("anchorChanged", function (currentAnchor) {
                this.fire("anchorChanged", {endpoint: this, anchor: currentAnchor});
                _updateAnchorClass();
            }.bind(this));
            return a;
        };

        this.setPreparedAnchor = function(anchor, doNotRepaint) {
            this._jsPlumb.instance.continuousAnchorFactory.clear(this.elementId);
            this.anchor = anchor;
            _updateAnchorClass();

            if (!doNotRepaint)
                this._jsPlumb.instance.repaint(this.elementId);

            return this;
        };

        this.setAnchor = function (anchorParams, doNotRepaint) {
            var a = this.prepareAnchor(anchorParams);
            this.setPreparedAnchor(a, doNotRepaint);
            return this;
        };

        var internalHover = function (state) {
            if (this.connections.length > 0) {
                for (var i = 0; i < this.connections.length; i++)
                    this.connections[i].setHover(state, false);
            }
            else
                this.setHover(state);
        }.bind(this);

        this.bind("mouseover", function () {
            internalHover(true);
        });
        this.bind("mouseout", function () {
            internalHover(false);
        });

        // ANCHOR MANAGER
        if (!params._transient) // in place copies, for example, are transient.  they will never need to be retrieved during a paint cycle, because they dont move, and then they are deleted.
            this._jsPlumb.instance.anchorManager.add(this, this.elementId);

        this.prepareEndpoint = function(ep, typeId) {
            var _e = function (t, p) {
                var rm = _jsPlumb.getRenderMode();
                if (_jp.Endpoints[rm][t]) return new _jp.Endpoints[rm][t](p);
                if (!_jsPlumb.Defaults.DoNotThrowErrors)
                    throw { msg: "jsPlumb: unknown endpoint type '" + t + "'" };
            };

            var endpointArgs = {
                _jsPlumb: this._jsPlumb.instance,
                cssClass: params.cssClass,
                container: params.container,
                tooltip: params.tooltip,
                connectorTooltip: params.connectorTooltip,
                endpoint: this
            };

            var endpoint;

            if (_ju.isString(ep))
                endpoint = _e(ep, endpointArgs);
            else if (_ju.isArray(ep)) {
                endpointArgs = _ju.merge(ep[1], endpointArgs);
                endpoint = _e(ep[0], endpointArgs);
            }
            else {
                endpoint = ep.clone();
            }

            // assign a clone function using a copy of endpointArgs. this is used when a drag starts: the endpoint that was dragged is cloned,
            // and the clone is left in its place while the original one goes off on a magical journey.
            // the copy is to get around a closure problem, in which endpointArgs ends up getting shared by
            // the whole world.
            //var argsForClone = jsPlumb.extend({}, endpointArgs);
            endpoint.clone = function () {
                // TODO this, and the code above, can be refactored to be more dry.
                if (_ju.isString(ep))
                    return _e(ep, endpointArgs);
                else if (_ju.isArray(ep)) {
                    endpointArgs = _ju.merge(ep[1], endpointArgs);
                    return _e(ep[0], endpointArgs);
                }
            }.bind(this);

            endpoint.typeId = typeId;
            return endpoint;
        };

        this.setEndpoint = function(ep, doNotRepaint) {
            var _ep = this.prepareEndpoint(ep);
            this.setPreparedEndpoint(_ep, true);
        };

        this.setPreparedEndpoint = function (ep, doNotRepaint) {
            if (this.endpoint != null) {
                this.endpoint.cleanup();
                this.endpoint.destroy();
            }
            this.endpoint = ep;
            this.type = this.endpoint.type;
            this.canvas = this.endpoint.canvas;
        };

        _jp.extend(this, params, typeParameters);

        this.isSource = params.isSource || false;
        this.isTemporarySource = params.isTemporarySource || false;
        this.isTarget = params.isTarget || false;

        this.connections = params.connections || [];
        this.connectorPointerEvents = params["connector-pointer-events"];

        this.scope = params.scope || _jsPlumb.getDefaultScope();
        this.timestamp = null;
        this.reattachConnections = params.reattach || _jsPlumb.Defaults.ReattachConnections;
        this.connectionsDetachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.connectionsDetachable === false || params.detachable === false)
            this.connectionsDetachable = false;
        this.dragAllowedWhenFull = params.dragAllowedWhenFull !== false;

        if (params.onMaxConnections)
            this.bind("maxConnections", params.onMaxConnections);

        //
        // add a connection. not part of public API.
        //
        this.addConnection = function (connection) {
            this.connections.push(connection);
            this[(this.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);
            this[(this.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass);
        };

        this.detachFromConnection = function (connection, idx, doNotCleanup) {
            idx = idx == null ? this.connections.indexOf(connection) : idx;
            if (idx >= 0) {
                this.connections.splice(idx, 1);
                this[(this.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);
                this[(this.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass);
            }

            if ((this._forceDeleteOnDetach || (!doNotCleanup && this._deleteOnDetach)) && this.connections.length === 0) {
                _jsPlumb.deleteObject({
                    endpoint: this,
                    fireEvent: false,
                    //deleteAttachedObjects: false
                    deleteAttachedObjects: doNotCleanup !== true
                });
            }
        };

        //this.detach = function (connection, ignoreTarget, forceDetach, fireEvent, originalEvent, endpointBeingDeleted, connectionIndex) {

        this.detach = function (params) {
            var connectionIndex = params.connectionIndex,
                connection = params.connection,
                ignoreTarget = params.ignoreTarget,
                fireEvent = params.fireEvent,
                originalEvent = params.originalEvent,
                endpointBeingDeleted = params.endpointBeingDeleted,
                forceDetach = params.forceDetach;

            var idx = connectionIndex == null ? this.connections.indexOf(connection) : connectionIndex,
                actuallyDetached = false;
            fireEvent = (fireEvent !== false);

            if (idx >= 0) {

                if (forceDetach || connection._forceDetach || (connection.isDetachable() && connection.isDetachAllowed(connection) && this.isDetachAllowed(connection) && _jsPlumb.checkCondition("beforeDetach", connection, endpointBeingDeleted) )) {

                    _jsPlumb.deleteObject({
                        connection: connection,
                        fireEvent: (!ignoreTarget && fireEvent),
                        originalEvent: originalEvent,
                        deleteAttachedObjects:params.deleteAttachedObjects
                        //deleteAttachedObjects:null
                    });
                    actuallyDetached = true;
                }
            }
            return actuallyDetached;
        };

        this.detachAll = function (fireEvent, forceDetach) {
            var unaffectedConns = [];
            while (this.connections.length > 0) {
                // TODO this could pass the index in to the detach method to save some time (index will always be zero in this while loop)
                var actuallyDetached = this.detach({
                    connection:this.connections[0],
                    ignoreTarget:false,
                    forceDetach:forceDetach === true,
                    fireEvent:fireEvent !== false,
                    originalEvent:null,
                    endpointBeingDeleted:this,
                    connectionIndex:0
                });
                if (!actuallyDetached) {
                    unaffectedConns.push(this.connections[0]);
                    this.connections.splice(0, 1);
                }
            }
            this.connections = unaffectedConns;
            return this;
        };
        this.detachFrom = function (targetEndpoint, fireEvent, originalEvent) {
            var c = [];
            for (var i = 0; i < this.connections.length; i++) {
                if (this.connections[i].endpoints[1] == targetEndpoint || this.connections[i].endpoints[0] == targetEndpoint) {
                    c.push(this.connections[i]);
                }
            }
            for (var j = 0; j < c.length; j++) {
                this.detach({
                    connection:c[j],
                    ignoreTarget:false,
                    forceDetach:true,
                    fireEvent:fireEvent,
                    originalEvent:originalEvent
                });
            }
            return this;
        };

        this.getElement = function () {
            return this.element;
        };

        this.setElement = function (el) {
            var parentId = this._jsPlumb.instance.getId(el),
                curId = this.elementId;
            // remove the endpoint from the list for the current endpoint's element
            _ju.removeWithFunction(params.endpointsByElement[this.elementId], function (e) {
                return e.id == this.id;
            }.bind(this));
            this.element = jsPlumb.getElement(el);
            this.elementId = _jsPlumb.getId(this.element);
            _jsPlumb.anchorManager.rehomeEndpoint(this, curId, this.element);
            _jsPlumb.dragManager.endpointAdded(this.element);
            _ju.addToList(params.endpointsByElement, parentId, this);
            return this;
        };

        /**
         * private but must be exposed.
         */
        this.makeInPlaceCopy = function () {
            var loc = this.anchor.getCurrentLocation({element: this}),
                o = this.anchor.getOrientation(this),
                acc = this.anchor.getCssClass(),
                inPlaceAnchor = {
                    bind: function () {
                    },
                    compute: function () {
                        return [ loc[0], loc[1] ];
                    },
                    getCurrentLocation: function () {
                        return [ loc[0], loc[1] ];
                    },
                    getOrientation: function () {
                        return o;
                    },
                    getCssClass: function () {
                        return acc;
                    }
                };

            return _newEndpoint({
                dropOptions: params.dropOptions,
                anchor: inPlaceAnchor,
                source: this.element,
                paintStyle: this.getPaintStyle(),
                endpoint: params.hideOnDrag ? "Blank" : this.endpoint,
                _transient: true,
                scope: this.scope,
                reference:this
            });
        };

        /**
         * returns a connection from the pool; used when dragging starts.  just gets the head of the array if it can.
         */
        this.connectorSelector = function () {
            var candidate = this.connections[0];
            // SP target source refactor
            if (/*this.isTarget && */candidate) return candidate;
            else {
                return (this.connections.length < this._jsPlumb.maxConnections) || this._jsPlumb.maxConnections == -1 ? null : candidate;
            }
        };

        this.setStyle = this.setPaintStyle;

        this.paint = function (params) {
            params = params || {};
            var timestamp = params.timestamp, recalc = !(params.recalc === false);
            if (!timestamp || this.timestamp !== timestamp) {

                var info = _jsPlumb.updateOffset({ elId: this.elementId, timestamp: timestamp });

                var xy = params.offset ? params.offset.o : info.o;
                if (xy != null) {
                    var ap = params.anchorPoint, connectorPaintStyle = params.connectorPaintStyle;
                    if (ap == null) {
                        var wh = params.dimensions || info.s,
                            anchorParams = { xy: [ xy.left, xy.top ], wh: wh, element: this, timestamp: timestamp };
                        if (recalc && this.anchor.isDynamic && this.connections.length > 0) {
                            var c = findConnectionToUseForDynamicAnchor(this, params.elementWithPrecedence),
                                oIdx = c.endpoints[0] == this ? 1 : 0,
                                oId = oIdx === 0 ? c.sourceId : c.targetId,
                                oInfo = _jsPlumb.getCachedData(oId),
                                oOffset = oInfo.o, oWH = oInfo.s;
                            anchorParams.txy = [ oOffset.left, oOffset.top ];
                            anchorParams.twh = oWH;
                            anchorParams.tElement = c.endpoints[oIdx];
                        }
                        ap = this.anchor.compute(anchorParams);
                    }

                    this.endpoint.compute(ap, this.anchor.getOrientation(this), this._jsPlumb.paintStyleInUse, connectorPaintStyle || this.paintStyleInUse);
                    this.endpoint.paint(this._jsPlumb.paintStyleInUse, this.anchor);
                    this.timestamp = timestamp;

                    // paint overlays
                    for (var i in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(i)) {
                            var o = this._jsPlumb.overlays[i];
                            if (o.isVisible()) {
                                this._jsPlumb.overlayPlacements[i] = o.draw(this.endpoint, this._jsPlumb.paintStyleInUse);
                                o.paint(this._jsPlumb.overlayPlacements[i]);
                            }
                        }
                    }
                }
            }
        };

        this.getTypeDescriptor = function () {
            return "endpoint";
        };
        this.isVisible = function () {
            return this._jsPlumb.visible;
        };

        this.repaint = this.paint;

        var draggingInitialised = false;
        this.initDraggable = function () {

            // is this a connection source? we make it draggable and have the
            // drag listener maintain a connection with a floating endpoint.
            if (!draggingInitialised && _jp.isDragSupported(this.element)) {
                var placeholderInfo = { id: null, element: null },
                    jpc = null,
                    existingJpc = false,
                    existingJpcParams = null,
                    _dragHandler = _makeConnectionDragHandler(this, placeholderInfo, _jsPlumb),
                    dragOptions = params.dragOptions || {},
                    defaultOpts = {},
                    startEvent = _jp.dragEvents.start,
                    stopEvent = _jp.dragEvents.stop,
                    dragEvent = _jp.dragEvents.drag,
                    beforeStartEvent = _jp.dragEvents.beforeStart,
                    payload;

                // respond to beforeStart from katavorio; this will have, optionally, a payload of attribute values
                // that were placed there by the makeSource mousedown listener.
                var beforeStart = function(beforeStartParams) {
                    payload = beforeStartParams.e.payload || {};
                };

                var start = function (startParams) {

// -------------   first, get a connection to drag. this may be null, in which case we are dragging a new one.

                    jpc = this.connectorSelector();

// -------------------------------- now a bunch of tests about whether or not to proceed -------------------------

                    var _continue = true;
                    // if not enabled, return
                    if (!this.isEnabled()) _continue = false;
                    // if no connection and we're not a source - or temporarily a source, as is the case with makeSource - return.
                    if (jpc == null && !this.isSource && !this.isTemporarySource) _continue = false;
                    // otherwise if we're full and not allowed to drag, also return false.
                    if (this.isSource && this.isFull() && !(jpc != null && this.dragAllowedWhenFull)) _continue = false;
                    // if the connection was setup as not detachable or one of its endpoints
                    // was setup as connectionsDetachable = false, or Defaults.ConnectionsDetachable
                    // is set to false...
                    if (jpc != null && !jpc.isDetachable(this)) _continue = false;

                    var beforeDrag = _jsPlumb.checkCondition(jpc == null ? "beforeDrag" : "beforeStartDetach", {
                        endpoint:this,
                        source:this.element,
                        sourceId:this.elementId,
                        connection:jpc
                    });
                    if (beforeDrag === false) _continue = false;
                    // else we might have been given some data. we'll pass it in to a new connection as 'data'.
                    // here we also merge in the optional payload we were given on mousedown.
                    else if (typeof beforeDrag === "object") {
                        jsPlumb.extend(beforeDrag, payload || {});
                    }
                    else
                        // or if no beforeDrag data, maybe use the payload on its own.
                        beforeDrag = payload || {};

                    if (_continue === false) {
                        // this is for mootools and yui. returning false from this causes jquery to stop drag.
                        // the events are wrapped in both mootools and yui anyway, but i don't think returning
                        // false from the start callback would stop a drag.
                        if (_jsPlumb.stopDrag) _jsPlumb.stopDrag(this.canvas);
                        _dragHandler.stopDrag();
                        return false;
                    }

// ---------------------------------------------------------------------------------------------------------------------

                    // ok to proceed.

                    // clear hover for all connections for this endpoint before continuing.
                    for (var i = 0; i < this.connections.length; i++)
                        this.connections[i].setHover(false);

                    this.addClass("endpointDrag");
                    _jsPlumb.setConnectionBeingDragged(true);

                    // if we're not full but there was a connection, make it null. we'll create a new one.
                    if (jpc && !this.isFull() && this.isSource) jpc = null;

                    _jsPlumb.updateOffset({ elId: this.elementId });

// ----------------    make the element we will drag around, and position it -----------------------------

                    var ipco = this._jsPlumb.instance.getOffset(this.canvas),
                        canvasElement = this.canvas,
                        ips = this._jsPlumb.instance.getSize(this.canvas);

                    _makeDraggablePlaceholder(placeholderInfo, _jsPlumb, ipco, ips);

                    // store the id of the dragging div and the source element. the drop function will pick these up.                   
                    _jsPlumb.setAttributes(this.canvas, {
                        "dragId": placeholderInfo.id,
                        "elId": this.elementId
                    });

// ------------------- create an endpoint that will be our floating endpoint ------------------------------------

                    var endpointToFloat = this.dragProxy || this.endpoint;
                    if (this.dragProxy == null && this.connectionType != null) {
                        var aae = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(this.connectionType);
                        if (aae.endpoints[1]) endpointToFloat = aae.endpoints[1];
                    }
                    var centerAnchor = this._jsPlumb.instance.makeAnchor("Center");
                    centerAnchor.isFloating = true;
                    this._jsPlumb.floatingEndpoint = _makeFloatingEndpoint(this.getPaintStyle(), centerAnchor, endpointToFloat, this.canvas, placeholderInfo.element, _jsPlumb, _newEndpoint, this.scope);
                    var _savedAnchor = this._jsPlumb.floatingEndpoint.anchor;


                    if (jpc == null) {

                        this.setHover(false, false);
                        // create a connection. one end is this endpoint, the other is a floating endpoint.                    
                        jpc = _newConnection({
                            sourceEndpoint: this,
                            targetEndpoint: this._jsPlumb.floatingEndpoint,
                            source: this.element,  // for makeSource with parent option.  ensure source element is represented correctly.
                            target: placeholderInfo.element,
                            anchors: [ this.anchor, this._jsPlumb.floatingEndpoint.anchor ],
                            paintStyle: params.connectorStyle, // this can be null. Connection will use the default.
                            hoverPaintStyle: params.connectorHoverStyle,
                            connector: params.connector, // this can also be null. Connection will use the default.
                            overlays: params.connectorOverlays,
                            type: this.connectionType,
                            cssClass: this.connectorClass,
                            hoverClass: this.connectorHoverClass,
                            scope:params.scope,
                            data:beforeDrag
                        });
                        jpc.pending = true;
                        jpc.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.anchor = _savedAnchor;
                        // fire an event that informs that a connection is being dragged
                        _jsPlumb.fire("connectionDrag", jpc);

                        // register the new connection on the drag manager. This connection, at this point, is 'pending',
                        // and has as its target a temporary element (the 'placeholder'). If the connection subsequently
                        // becomes established, the anchor manager is informed that the target of the connection has
                        // changed.

                        _jsPlumb.anchorManager.newConnection(jpc);

                    } else {
                        existingJpc = true;
                        jpc.setHover(false);
                        // new anchor idx
                        var anchorIdx = jpc.endpoints[0].id == this.id ? 0 : 1;
                        this.detachFromConnection(jpc, null, true);                         // detach from the connection while dragging is occurring. but dont cleanup automatically.

                        // store the original scope (issue 57)
                        var dragScope = _jsPlumb.getDragScope(canvasElement);
                        _jsPlumb.setAttribute(this.canvas, "originalScope", dragScope);

                        // fire an event that informs that a connection is being dragged. we do this before
                        // replacing the original target with the floating element info.
                        _jsPlumb.fire("connectionDrag", jpc);

                        // now we replace ourselves with the temporary div we created above:
                        if (anchorIdx === 0) {
                            existingJpcParams = [ jpc.source, jpc.sourceId, canvasElement, dragScope ];
                            _jsPlumb.anchorManager.sourceChanged(jpc.endpoints[anchorIdx].elementId, placeholderInfo.id, jpc, placeholderInfo.element);

                        } else {
                            existingJpcParams = [ jpc.target, jpc.targetId, canvasElement, dragScope ];
                            jpc.target = placeholderInfo.element;
                            jpc.targetId = placeholderInfo.id;

                            _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.endpoints[anchorIdx].elementId, jpc.targetId, jpc);
                        }

                        // store the original endpoint and assign the new floating endpoint for the drag.
                        jpc.suspendedEndpoint = jpc.endpoints[anchorIdx];

                        // PROVIDE THE SUSPENDED ELEMENT, BE IT A SOURCE OR TARGET (ISSUE 39)
                        jpc.suspendedElement = jpc.endpoints[anchorIdx].getElement();
                        jpc.suspendedElementId = jpc.endpoints[anchorIdx].elementId;
                        jpc.suspendedElementType = anchorIdx === 0 ? "source" : "target";

                        jpc.suspendedEndpoint.setHover(false);
                        this._jsPlumb.floatingEndpoint.referenceEndpoint = jpc.suspendedEndpoint;
                        jpc.endpoints[anchorIdx] = this._jsPlumb.floatingEndpoint;

                        jpc.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);
                    }

                    // register it and register connection on it.
                    _jsPlumb.floatingConnections[placeholderInfo.id] = jpc;
                    // only register for the target endpoint; we will not be dragging the source at any time
                    // before this connection is either discarded or made into a permanent connection.
                    _ju.addToList(params.endpointsByElement, placeholderInfo.id, this._jsPlumb.floatingEndpoint);
                    // tell jsplumb about it
                    _jsPlumb.currentlyDragging = true;
                }.bind(this);

                var stop = function () {
                    _jsPlumb.setConnectionBeingDragged(false);

                    if (jpc && jpc.endpoints != null) {
                        // get the actual drop event (decode from library args to stop function)
                        var originalEvent = _jsPlumb.getDropEvent(arguments);
                        // unlock the other endpoint (if it is dynamic, it would have been locked at drag start)
                        var idx = _jsPlumb.getFloatingAnchorIndex(jpc);
                        jpc.endpoints[idx === 0 ? 1 : 0].anchor.locked = false;
                        // TODO: Dont want to know about css classes inside jsplumb, ideally.
                        jpc.removeClass(_jsPlumb.draggingClass);

                        // if we have the floating endpoint then the connection has not been dropped
                        // on another endpoint.  If it is a new connection we throw it away. If it is an
                        // existing connection we check to see if we should reattach it, throwing it away
                        // if not.
                        if (this._jsPlumb && (jpc.deleteConnectionNow || jpc.endpoints[idx] == this._jsPlumb.floatingEndpoint)) {
                            // 6a. if the connection was an existing one...
                            if (existingJpc && jpc.suspendedEndpoint) {
                                // fix for issue35, thanks Sylvain Gizard: when firing the detach event make sure the
                                // floating endpoint has been replaced.
                                if (idx === 0) {
                                    jpc.floatingElement = jpc.source;
                                    jpc.floatingId = jpc.sourceId;
                                    jpc.floatingEndpoint = jpc.endpoints[0];
                                    jpc.floatingIndex = 0;
                                    jpc.source = existingJpcParams[0];
                                    jpc.sourceId = existingJpcParams[1];
                                } else {
                                    // keep a copy of the floating element; the anchor manager will want to clean up.
                                    jpc.floatingElement = jpc.target;
                                    jpc.floatingId = jpc.targetId;
                                    jpc.floatingEndpoint = jpc.endpoints[1];
                                    jpc.floatingIndex = 1;
                                    jpc.target = existingJpcParams[0];
                                    jpc.targetId = existingJpcParams[1];
                                }

                                var fe = this._jsPlumb.floatingEndpoint; // store for later removal.
                                // restore the original scope (issue 57)
                                _jsPlumb.setDragScope(existingJpcParams[2], existingJpcParams[3]);
                                jpc.endpoints[idx] = jpc.suspendedEndpoint;
                                // IF the connection should be reattached, or the other endpoint refuses detach, then
                                // reset the connection to its original state
                                if (jpc.isReattach() || jpc._forceReattach || jpc._forceDetach || !jpc.endpoints[idx === 0 ? 1 : 0].detach({connection:jpc, ignoreTarget:false, forceDetach:false, fireEvent:true, originalEvent:originalEvent, endpointBeingDeleted:true})) {

                                    jpc.setHover(false);
                                    jpc._forceDetach = null;
                                    jpc._forceReattach = null;
                                    this._jsPlumb.floatingEndpoint.detachFromConnection(jpc);
                                    jpc.suspendedEndpoint.addConnection(jpc);

                                    // TODO this code is duplicated in lots of places...and there is nothing external
                                    // in the code; it all refers to the connection itself. we could add a
                                    // `checkSanity(connection)` method to anchorManager that did this.
                                    if (idx == 1) {
                                        _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                                    }
                                    else {
                                        _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc, jpc.source);
                                    }

                                    _jsPlumb.repaint(existingJpcParams[1]);
                                }
                                else {
                                    _jsPlumb.deleteObject({endpoint: fe});
                                }
                            }
                        }

                        // makeTargets sets this flag, to tell us we have been replaced and should delete this object.
                        if (this.deleteAfterDragStop) {
                            _jsPlumb.deleteObject({endpoint: this});
                        }
                        else {
                            if (this._jsPlumb) {
                                 this.paint({recalc: false});
                            }
                        }

                        // although the connection is no longer valid, there are use cases where this is useful.
                        _jsPlumb.fire("connectionDragStop", jpc, originalEvent);
                        // fire this event to give people more fine-grained control (connectionDragStop fires a lot)
                        if (jpc.pending) {
                            _jsPlumb.fire("connectionAborted", jpc, originalEvent);
                        }
                        // tell jsplumb that dragging is finished.
                        _jsPlumb.currentlyDragging = false;
                        jpc.suspendedElement = null;
                        jpc.suspendedEndpoint = null;
                        jpc = null;
                    }

                    // if no endpoints, jpc already cleaned up. but still we want to ensure we're reset properly.
                    // remove the element associated with the floating endpoint
                    // (and its associated floating endpoint and visual artefacts)
                    if (placeholderInfo && placeholderInfo.element) {
                        _jsPlumb.remove(placeholderInfo.element, false, false);
                    }
                    // remove the inplace copy
                    if (inPlaceCopy) {
                        _jsPlumb.deleteObject({endpoint: inPlaceCopy});
                    }

                    if (this._jsPlumb) {
                        // make our canvas visible (TODO: hand off to library; we should not know about DOM)
                        this.canvas.style.visibility = "visible";
                        // unlock our anchor
                        this.anchor.locked = false;
                        // clear floating anchor.
                        this._jsPlumb.floatingEndpoint = null;
                    }

                }.bind(this);

                dragOptions = _jp.extend(defaultOpts, dragOptions);
                dragOptions.scope = this.scope || dragOptions.scope;
                dragOptions[beforeStartEvent] = _ju.wrap(dragOptions[beforeStartEvent], beforeStart, false);
                dragOptions[startEvent] = _ju.wrap(dragOptions[startEvent], start, false);
                // extracted drag handler function so can be used by makeSource
                dragOptions[dragEvent] = _ju.wrap(dragOptions[dragEvent], _dragHandler.drag);
                dragOptions[stopEvent] = _ju.wrap(dragOptions[stopEvent], stop);
                dragOptions.multipleDrop = false;

                dragOptions.canDrag = function () {
                    return this.isSource || this.isTemporarySource || /*(this.isTarget && */this.connections.length > 0/*)*/;
                }.bind(this);

                _jsPlumb.initDraggable(this.canvas, dragOptions, "internal");

                this.canvas._jsPlumbRelatedElement = this.element;

                draggingInitialised = true;
            }
        };

        var ep = params.endpoint || this._jsPlumb.instance.Defaults.Endpoint || _jp.Defaults.Endpoint;
        this.setEndpoint(ep, true);
        var anchorParamsToUse = params.anchor ? params.anchor : params.anchors ? params.anchors : (_jsPlumb.Defaults.Anchor || "Top");
        this.setAnchor(anchorParamsToUse, true);

        // finally, set type if it was provided
        var type = [ "default", (params.type || "")].join(" ");
        this.addType(type, params.data, true);
        this.canvas = this.endpoint.canvas;
        this.canvas._jsPlumb = this;

        this.initDraggable();

        // pulled this out into a function so we can reuse it for the inPlaceCopy canvas; you can now drop detached connections
        // back onto the endpoint you detached it from.
        var _initDropTarget = function (canvas, isTransient, endpoint, referenceEndpoint) {

            if (_jp.isDropSupported(this.element)) {
                var dropOptions = params.dropOptions || _jsPlumb.Defaults.DropOptions || _jp.Defaults.DropOptions;
                dropOptions = _jp.extend({}, dropOptions);
                dropOptions.scope = dropOptions.scope || this.scope;
                var dropEvent = _jp.dragEvents.drop,
                    overEvent = _jp.dragEvents.over,
                    outEvent = _jp.dragEvents.out,
                    _ep = this,
                    drop = _jsPlumb.EndpointDropHandler({
                        getEndpoint: function () {
                            return _ep;
                        },
                        jsPlumb: _jsPlumb,
                        enabled: function () {
                            return endpoint != null ? endpoint.isEnabled() : true;
                        },
                        isFull: function () {
                            return endpoint.isFull();
                        },
                        element: this.element,
                        elementId: this.elementId,
                        isSource: this.isSource,
                        isTarget: this.isTarget,
                        addClass: function (clazz) {
                            _ep.addClass(clazz);
                        },
                        removeClass: function (clazz) {
                            _ep.removeClass(clazz);
                        },
                        isDropAllowed: function () {
                            return _ep.isDropAllowed.apply(_ep, arguments);
                        },
                        reference:referenceEndpoint,
                        isRedrop:function(jpc, dhParams) {
                            return jpc.suspendedEndpoint && dhParams.reference && (jpc.suspendedEndpoint.id === dhParams.reference.id);
                        }
                    });

                dropOptions[dropEvent] = _ju.wrap(dropOptions[dropEvent], drop, true);
                dropOptions[overEvent] = _ju.wrap(dropOptions[overEvent], function () {
                    var draggable = _jp.getDragObject(arguments),
                        id = _jsPlumb.getAttribute(_jp.getElement(draggable), "dragId"),
                        _jpc = _jsPlumb.floatingConnections[id];

                    if (_jpc != null) {
                        var idx = _jsPlumb.getFloatingAnchorIndex(_jpc);
                        // here we should fire the 'over' event if we are a target and this is a new connection,
                        // or we are the same as the floating endpoint.
                        var _cont = (this.isTarget && idx !== 0) || (_jpc.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id == _jpc.suspendedEndpoint.id);
                        if (_cont) {
                            var bb = _jsPlumb.checkCondition("checkDropAllowed", {
                                sourceEndpoint: _jpc.endpoints[idx],
                                targetEndpoint: this,
                                connection: _jpc
                            });
                            this[(bb ? "add" : "remove") + "Class"](_jsPlumb.endpointDropAllowedClass);
                            this[(bb ? "remove" : "add") + "Class"](_jsPlumb.endpointDropForbiddenClass);
                            _jpc.endpoints[idx].anchor.over(this.anchor, this);
                        }
                    }
                }.bind(this));

                dropOptions[outEvent] = _ju.wrap(dropOptions[outEvent], function () {
                    var draggable = _jp.getDragObject(arguments),
                        id = draggable == null ? null : _jsPlumb.getAttribute(_jp.getElement(draggable), "dragId"),
                        _jpc = id ? _jsPlumb.floatingConnections[id] : null;

                    if (_jpc != null) {
                        var idx = _jsPlumb.getFloatingAnchorIndex(_jpc);
                        var _cont = (this.isTarget && idx !== 0) || (_jpc.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id == _jpc.suspendedEndpoint.id);
                        if (_cont) {
                            this.removeClass(_jsPlumb.endpointDropAllowedClass);
                            this.removeClass(_jsPlumb.endpointDropForbiddenClass);
                            _jpc.endpoints[idx].anchor.out();
                        }
                    }
                }.bind(this));

                _jsPlumb.initDroppable(canvas, dropOptions, "internal", isTransient);
            }
        }.bind(this);

        // Initialise the endpoint's canvas as a drop target. The drop handler will take care of the logic of whether
        // something can actually be dropped.
        if (!this.anchor.isFloating)
            _initDropTarget(this.canvas, !(params._transient || this.anchor.isFloating), this, params.reference);


        return this;
    };

    _ju.extend(_jp.Endpoint, _jp.OverlayCapableJsPlumbUIComponent, {

        setVisible: function (v, doNotChangeConnections, doNotNotifyOtherEndpoint) {
            this._jsPlumb.visible = v;
            if (this.canvas) this.canvas.style.display = v ? "block" : "none";
            this[v ? "showOverlays" : "hideOverlays"]();
            if (!doNotChangeConnections) {
                for (var i = 0; i < this.connections.length; i++) {
                    this.connections[i].setVisible(v);
                    if (!doNotNotifyOtherEndpoint) {
                        var oIdx = this === this.connections[i].endpoints[0] ? 1 : 0;
                        // only change the other endpoint if this is its only connection.
                        if (this.connections[i].endpoints[oIdx].connections.length == 1) this.connections[i].endpoints[oIdx].setVisible(v, true, true);
                    }
                }
            }
        },
        getAttachedElements: function () {
            return this.connections;
        },
        applyType: function (t, doNotRepaint) {
            this.setPaintStyle(t.endpointStyle || t.paintStyle, doNotRepaint);
            this.setHoverPaintStyle(t.endpointHoverStyle || t.hoverPaintStyle, doNotRepaint);
            if (t.maxConnections != null) this._jsPlumb.maxConnections = t.maxConnections;
            if (t.scope) this.scope = t.scope;
            _jp.extend(this, t, typeParameters);
            if (t.cssClass != null && this.canvas) this._jsPlumb.instance.addClass(this.canvas, t.cssClass);
            _jp.OverlayCapableJsPlumbUIComponent.applyType(this, t);
        },
        isEnabled: function () {
            return this._jsPlumb.enabled;
        },
        setEnabled: function (e) {
            this._jsPlumb.enabled = e;
        },
        cleanup: function () {
            var anchorClass = this._jsPlumb.instance.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");
            jsPlumb.removeClass(this.element, anchorClass);
            this.anchor = null;
            this.endpoint.cleanup(true);
            this.endpoint.destroy();
            this.endpoint = null;
            // drag/drop
            this._jsPlumb.instance.destroyDraggable(this.canvas, "internal");
            this._jsPlumb.instance.destroyDroppable(this.canvas, "internal");
        },
        setHover: function (h) {
            if (this.endpoint && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged())
                this.endpoint.setHover(h);
        },
        isFull: function () {
            return this._jsPlumb.maxConnections === 0 ? true : !(this.isFloating() || this._jsPlumb.maxConnections < 0 || this.connections.length < this._jsPlumb.maxConnections);
        },
        /**
         * private but needs to be exposed.
         */
        isFloating: function () {
            return this.anchor != null && this.anchor.isFloating;
        },
        isConnectedTo: function (endpoint) {
            var found = false;
            if (endpoint) {
                for (var i = 0; i < this.connections.length; i++) {
                    if (this.connections[i].endpoints[1] == endpoint || this.connections[i].endpoints[0] == endpoint) {
                        found = true;
                        break;
                    }
                }
            }
            return found;
        },
        getConnectionCost: function () {
            return this._jsPlumb.connectionCost;
        },
        setConnectionCost: function (c) {
            this._jsPlumb.connectionCost = c;
        },
        areConnectionsDirected: function () {
            return this._jsPlumb.connectionsDirected;
        },
        setConnectionsDirected: function (b) {
            this._jsPlumb.connectionsDirected = b;
        },
        setElementId: function (_elId) {
            this.elementId = _elId;
            this.anchor.elementId = _elId;
        },
        setReferenceElement: function (_el) {
            this.element = _jp.getElement(_el);
        },
        setDragAllowedWhenFull: function (allowed) {
            this.dragAllowedWhenFull = allowed;
        },
        equals: function (endpoint) {
            return this.anchor.equals(endpoint.anchor);
        },
        getUuid: function () {
            return this._jsPlumb.uuid;
        },
        computeAnchor: function (params) {
            return this.anchor.compute(params);
        }
    });

    root.jsPlumbInstance.prototype.EndpointDropHandler = function (dhParams) {
        return function (e) {

            var _jsPlumb = dhParams.jsPlumb;

            // remove the classes that are added dynamically. drop is neither forbidden nor allowed now that
            // the drop is finishing.
            dhParams.removeClass(_jsPlumb.endpointDropAllowedClass);
            dhParams.removeClass(_jsPlumb.endpointDropForbiddenClass);

            var originalEvent = _jsPlumb.getDropEvent(arguments),
                draggable = _jsPlumb.getDragObject(arguments),
                id = _jsPlumb.getAttribute(draggable, "dragId"),
                elId = _jsPlumb.getAttribute(draggable, "elId"),
                scope = _jsPlumb.getAttribute(draggable, "originalScope"),
                jpc = _jsPlumb.floatingConnections[id];

            // if no active connection, bail.
            if (jpc == null) return;

            // calculate if this is an existing connection.
            var existingConnection = jpc.suspendedEndpoint != null;

            // if suspended endpoint exists but has been cleaned up, bail. This means it's an existing connection
            // that has been detached and will shortly be discarded.
            if (existingConnection && jpc.suspendedEndpoint._jsPlumb == null) return;

            // get the drop endpoint. for a normal connection this is just the one that would replace the currently
            // floating endpoint. for a makeTarget this is a new endpoint that is created on drop. But we leave that to
            // the handler to figure out.
            var _ep = dhParams.getEndpoint(jpc);

            // If we're not given an endpoint to use, bail.
            if (_ep == null) return;

            // if this is a drop back where the connection came from, mark it force reattach and
            // return; the stop handler will reattach. without firing an event.
            if (dhParams.isRedrop(jpc, dhParams)) {
                jpc._forceReattach = true;
                jpc.setHover(false);
                if (dhParams.maybeCleanup) dhParams.maybeCleanup(_ep);
                return;
            }

            // ensure we dont bother trying to drop sources on non-source eps, and same for target.
            var idx = _jsPlumb.getFloatingAnchorIndex(jpc);
            if ((idx === 0 && !dhParams.isSource)|| (idx === 1 && !dhParams.isTarget)){
                if (dhParams.maybeCleanup) dhParams.maybeCleanup(_ep);
                return;
            }

            if (dhParams.onDrop) dhParams.onDrop(jpc);

            // restore the original scope if necessary (issue 57)
            if (scope) _jsPlumb.setDragScope(draggable, scope);

            // if the target of the drop is full, fire an event (we abort below)
            // makeTarget: keep.
            var isFull = dhParams.isFull(e);
            if (isFull) {
                _ep.fire("maxConnections", {
                    endpoint: this,
                    connection: jpc,
                    maxConnections: _ep._jsPlumb.maxConnections
                }, originalEvent);
            }
            //
            // if endpoint enabled, not full, and matches the index of the floating endpoint...
            if (!isFull &&  dhParams.enabled()) {
                var _doContinue = true;

                // before testing for beforeDrop, reset the connection's source/target to be the actual DOM elements
                // involved (that is, stash any temporary stuff used for dragging. but we need to keep it around in
                // order that the anchor manager can clean things up properly).
                if (idx === 0) {
                    jpc.floatingElement = jpc.source;
                    jpc.floatingId = jpc.sourceId;
                    jpc.floatingEndpoint = jpc.endpoints[0];
                    jpc.floatingIndex = 0;
                    jpc.source = dhParams.element;
                    jpc.sourceId = dhParams.elementId;
                } else {
                    jpc.floatingElement = jpc.target;
                    jpc.floatingId = jpc.targetId;
                    jpc.floatingEndpoint = jpc.endpoints[1];
                    jpc.floatingIndex = 1;
                    jpc.target = dhParams.element;
                    jpc.targetId = dhParams.elementId;
                }

                // if this is an existing connection and detach is not allowed we won't continue. The connection's
                // endpoints have been reinstated; everything is back to how it was.
                if (existingConnection && jpc.suspendedEndpoint.id != _ep.id) {

                    if (!jpc.isDetachAllowed(jpc) || !jpc.endpoints[idx].isDetachAllowed(jpc) || !jpc.suspendedEndpoint.isDetachAllowed(jpc) || !_jsPlumb.checkCondition("beforeDetach", jpc))
                        _doContinue = false;
                }

// ------------ wrap the execution path in a function so we can support asynchronous beforeDrop

                var continueFunction = function (optionalData) {
                    // remove this jpc from the current endpoint, which is a floating endpoint that we will
                    // subsequently discard.
                    jpc.endpoints[idx].detachFromConnection(jpc);

                    // if there's a suspended endpoint, detach it from the connection.
                    if (jpc.suspendedEndpoint) jpc.suspendedEndpoint.detachFromConnection(jpc);

                    jpc.endpoints[idx] = _ep;
                    _ep.addConnection(jpc);

                    // copy our parameters in to the connection:
                    var params = _ep.getParameters();
                    for (var aParam in params)
                        jpc.setParameter(aParam, params[aParam]);

                    if (!existingConnection) {
                        // if not an existing connection and
                        if (params.draggable)
                            _jsPlumb.initDraggable(this.element, dragOptions, "internal", _jsPlumb);
                    }
                    else {
                        var suspendedElementId = jpc.suspendedEndpoint.elementId;
                        _jsPlumb.fireMoveEvent({
                            index: idx,
                            originalSourceId: idx === 0 ? suspendedElementId : jpc.sourceId,
                            newSourceId: idx === 0 ? _ep.elementId : jpc.sourceId,
                            originalTargetId: idx == 1 ? suspendedElementId : jpc.targetId,
                            newTargetId: idx == 1 ? _ep.elementId : jpc.targetId,
                            originalSourceEndpoint: idx === 0 ? jpc.suspendedEndpoint : jpc.endpoints[0],
                            newSourceEndpoint: idx === 0 ? _ep : jpc.endpoints[0],
                            originalTargetEndpoint: idx == 1 ? jpc.suspendedEndpoint : jpc.endpoints[1],
                            newTargetEndpoint: idx == 1 ? _ep : jpc.endpoints[1],
                            connection: jpc
                        }, originalEvent);
                    }

                    if (idx == 1) {
                        _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                    }
                    else {
                        _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc, jpc.source);
                    }

                    // when makeSource has uniqueEndpoint:true, we want to create connections with new endpoints
                    // that are subsequently deleted. So makeSource sets `finalEndpoint`, which is the Endpoint to
                    // which the connection should be attached. The `detachFromConnection` call below results in the
                    // temporary endpoint being cleaned up.
                    if (jpc.endpoints[0].finalEndpoint) {
                        var _toDelete = jpc.endpoints[0];
                        _toDelete.detachFromConnection(jpc);
                        jpc.endpoints[0] = jpc.endpoints[0].finalEndpoint;
                        jpc.endpoints[0].addConnection(jpc);
                    }

                    // if optionalData was given, merge it onto the connection's data.
                    if (_ju.isObject(optionalData)) {
                        jpc.mergeData(optionalData);
                    }
                    // finalise will inform the anchor manager and also add to
                    // connectionsByScope if necessary.
                    _jsPlumb.finaliseConnection(jpc, null, originalEvent, false);
                    jpc.setHover(false);

                }.bind(this);

                var dontContinueFunction = function () {
                    // otherwise just put it back on the endpoint it was on before the drag.
                    if (jpc.suspendedEndpoint) {
                        jpc.endpoints[idx] = jpc.suspendedEndpoint;
                        jpc.setHover(false);
                        jpc._forceDetach = true;
                        if (idx === 0) {
                            jpc.source = jpc.suspendedEndpoint.element;
                            jpc.sourceId = jpc.suspendedEndpoint.elementId;
                        } else {
                            jpc.target = jpc.suspendedEndpoint.element;
                            jpc.targetId = jpc.suspendedEndpoint.elementId;
                        }
                        jpc.suspendedEndpoint.addConnection(jpc);

                        // TODO checkSanity
                        if (idx == 1) {
                            _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                        }
                        else {
                            _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc, jpc.source);
                        }

                        _jsPlumb.repaint(jpc.sourceId);
                        jpc._forceDetach = false;
                    }
                };

// --------------------------------------
                // now check beforeDrop.  this will be available only on Endpoints that are setup to
                // have a beforeDrop condition (although, secretly, under the hood all Endpoints and
                // the Connection have them, because they are on jsPlumbUIComponent.  shhh!), because
                // it only makes sense to have it on a target endpoint.
                _doContinue = _doContinue && dhParams.isDropAllowed(jpc.sourceId, jpc.targetId, jpc.scope, jpc, _ep);// && jpc.pending;

                if (_doContinue) {
                    continueFunction(_doContinue);
                    return true;
                }
                else {
                    dontContinueFunction();
                }
            }

            if (dhParams.maybeCleanup) dhParams.maybeCleanup(_ep);

            _jsPlumb.currentlyDragging = false;
        };
    };
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.1.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for Connections.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * https://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this,
        _jp = root.jsPlumb,
        _ju = root.jsPlumbUtil;

    var makeConnector = function (_jsPlumb, renderMode, connectorName, connectorArgs, forComponent) {
            if (!_jsPlumb.Defaults.DoNotThrowErrors && jsPlumb.Connectors[renderMode][connectorName] == null)
                throw { msg: "jsPlumb: unknown connector type '" + connectorName + "'" };

            return new _jp.Connectors[renderMode][connectorName](connectorArgs, forComponent);
        },
        _makeAnchor = function (anchorParams, elementId, _jsPlumb) {
            return (anchorParams) ? _jsPlumb.makeAnchor(anchorParams, elementId, _jsPlumb) : null;
        },
        _updateConnectedClass = function (conn, element, _jsPlumb, remove) {
            if (element != null) {
                element._jsPlumbConnections = element._jsPlumbConnections || {};
                if (remove)
                    delete element._jsPlumbConnections[conn.id];
                else
                    element._jsPlumbConnections[conn.id] = true;

                if (_ju.isEmpty(element._jsPlumbConnections)) {
                    _jsPlumb.removeClass(element, _jsPlumb.connectedClass);
                }
                else
                    _jsPlumb.addClass(element, _jsPlumb.connectedClass);
            }
        };

    _jp.Connection = function (params) {
        var _newEndpoint = params.newEndpoint;

        this.id = params.id;
        this.connector = null;
        this.idPrefix = "_jsplumb_c_";
        this.defaultLabelLocation = 0.5;
        this.defaultOverlayKeys = ["Overlays", "ConnectionOverlays"];
        // if a new connection is the result of moving some existing connection, params.previousConnection
        // will have that Connection in it. listeners for the jsPlumbConnection event can look for that
        // member and take action if they need to.
        this.previousConnection = params.previousConnection;
        this.source = _jp.getElement(params.source);
        this.target = _jp.getElement(params.target);
        // sourceEndpoint and targetEndpoint override source/target, if they are present. but 
        // source is not overridden if the Endpoint has declared it is not the final target of a connection;
        // instead we use the source that the Endpoint declares will be the final source element.
        if (params.sourceEndpoint) this.source = params.sourceEndpoint.getElement();
        if (params.targetEndpoint) this.target = params.targetEndpoint.getElement();

        _jp.OverlayCapableJsPlumbUIComponent.apply(this, arguments);

        this.sourceId = this._jsPlumb.instance.getId(this.source);
        this.targetId = this._jsPlumb.instance.getId(this.target);
        this.scope = params.scope; // scope may have been passed in to the connect call. if it wasn't, we will pull it from the source endpoint, after having initialised the endpoints.            
        this.endpoints = [];
        this.endpointStyles = [];

        var _jsPlumb = this._jsPlumb.instance;

        _jsPlumb.manage(this.sourceId, this.source);
        _jsPlumb.manage(this.targetId, this.target);

        this._jsPlumb.visible = true;
        this._jsPlumb.editable = params.editable === true;
        this._jsPlumb.params = {
            cssClass: params.cssClass,
            container: params.container,
            "pointer-events": params["pointer-events"],
            editorParams: params.editorParams,
            overlays: params.overlays
        };
        this._jsPlumb.lastPaintedAt = null;

        // listen to mouseover and mouseout events passed from the container delegate.
        this.bind("mouseover", function () {
            this.setHover(true);
        }.bind(this));
        this.bind("mouseout", function () {
            this.setHover(false);
        }.bind(this));

        this.editableRequested = params.editable !== false;
        this.setEditable = function(e) {
            return this.connector ? this.connector.setEditable(e) : false;
        };
        this.isEditable = function() { return this.connector ? this.connector.isEditable() : false; };
        this.isEditing = function() { return this.connector ? this.connector.isEditing() : false; };

// INITIALISATION CODE

        this.makeEndpoint = function (isSource, el, elId, ep) {
            elId = elId || this._jsPlumb.instance.getId(el);
            return this.prepareEndpoint(_jsPlumb, _newEndpoint, this, ep, isSource ? 0 : 1, params, el, elId);
        };

        // if type given, get the endpoint definitions mapping to that type from the jsplumb instance, and use those.
        // we apply types at the end of this constructor but endpoints are only honoured in a type definition at
        // create time.
        if (params.type) {
            params.endpoints = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(params.type).endpoints;
        }

        var eS = this.makeEndpoint(true, this.source, this.sourceId, params.sourceEndpoint),
            eT = this.makeEndpoint(false, this.target, this.targetId, params.targetEndpoint);

        if (eS) _ju.addToList(params.endpointsByElement, this.sourceId, eS);
        if (eT) _ju.addToList(params.endpointsByElement, this.targetId, eT);
        // if scope not set, set it to be the scope for the source endpoint.
        if (!this.scope) this.scope = this.endpoints[0].scope;

        // if explicitly told to (or not to) delete endpoints on detach, override endpoint's preferences
        if (params.deleteEndpointsOnDetach != null) {
            this.endpoints[0]._deleteOnDetach = params.deleteEndpointsOnDetach;
            this.endpoints[1]._deleteOnDetach = params.deleteEndpointsOnDetach;
        }
        else {
            // otherwise, unless the endpoints say otherwise, mark them for deletion.
            if (!this.endpoints[0]._doNotDeleteOnDetach) this.endpoints[0]._deleteOnDetach = true;
            if (!this.endpoints[1]._doNotDeleteOnDetach) this.endpoints[1]._deleteOnDetach = true;
        }

// -------------------------- DEFAULT TYPE ---------------------------------------------

        // DETACHABLE
        var _detachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.detachable === false) _detachable = false;
        if (this.endpoints[0].connectionsDetachable === false) _detachable = false;
        if (this.endpoints[1].connectionsDetachable === false) _detachable = false;
        // REATTACH
        var _reattach = params.reattach || this.endpoints[0].reattachConnections || this.endpoints[1].reattachConnections || _jsPlumb.Defaults.ReattachConnections;

        this.appendToDefaultType({
            detachable: _detachable,
            reattach: _reattach,
            paintStyle:this.endpoints[0].connectorStyle || this.endpoints[1].connectorStyle || params.paintStyle || _jsPlumb.Defaults.PaintStyle || jsPlumb.Defaults.PaintStyle,
            hoverPaintStyle:this.endpoints[0].connectorHoverStyle || this.endpoints[1].connectorHoverStyle || params.hoverPaintStyle || _jsPlumb.Defaults.HoverPaintStyle || jsPlumb.Defaults.HoverPaintStyle
        });


        var _suspendedAt = _jsPlumb.getSuspendedAt();
        if (!_jsPlumb.isSuspendDrawing()) {
            // paint the endpoints
            var myInfo = _jsPlumb.getCachedData(this.sourceId),
                myOffset = myInfo.o, myWH = myInfo.s,
                otherInfo = _jsPlumb.getCachedData(this.targetId),
                otherOffset = otherInfo.o,
                otherWH = otherInfo.s,
                initialTimestamp = _suspendedAt || _jsPlumb.timestamp(),
                anchorLoc = this.endpoints[0].anchor.compute({
                    xy: [ myOffset.left, myOffset.top ], wh: myWH, element: this.endpoints[0],
                    elementId: this.endpoints[0].elementId,
                    txy: [ otherOffset.left, otherOffset.top ], twh: otherWH, tElement: this.endpoints[1],
                    timestamp: initialTimestamp
                });

            this.endpoints[0].paint({ anchorLoc: anchorLoc, timestamp: initialTimestamp });

            anchorLoc = this.endpoints[1].anchor.compute({
                xy: [ otherOffset.left, otherOffset.top ], wh: otherWH, element: this.endpoints[1],
                elementId: this.endpoints[1].elementId,
                txy: [ myOffset.left, myOffset.top ], twh: myWH, tElement: this.endpoints[0],
                timestamp: initialTimestamp
            });
            this.endpoints[1].paint({ anchorLoc: anchorLoc, timestamp: initialTimestamp });
        }

        this.getTypeDescriptor = function () {
            return "connection";
        };
        this.getAttachedElements = function () {
            return this.endpoints;
        };

        this.isDetachable = function () {
            return this._jsPlumb.detachable === true;
        };
        this.setDetachable = function (detachable) {
            this._jsPlumb.detachable = detachable === true;
        };
        this.isReattach = function () {
            return this._jsPlumb.reattach === true || this.endpoints[0].reattachConnections === true || this.endpoints[1].reattachConnections === true;
        };
        this.setReattach = function (reattach) {
            this._jsPlumb.reattach = reattach === true;
        };

// END INITIALISATION CODE


// COST + DIRECTIONALITY
        // if cost not supplied, try to inherit from source endpoint
        this._jsPlumb.cost = params.cost || this.endpoints[0].getConnectionCost();
        this._jsPlumb.directed = params.directed;
        // inherit directed flag if set no source endpoint
        if (params.directed == null) this._jsPlumb.directed = this.endpoints[0].areConnectionsDirected();
// END COST + DIRECTIONALITY

// PARAMETERS
        // merge all the parameters objects into the connection.  parameters set
        // on the connection take precedence; then source endpoint params, then
        // finally target endpoint params.
        var _p = jsPlumb.extend({}, this.endpoints[1].getParameters());
        _jp.extend(_p, this.endpoints[0].getParameters());
        _jp.extend(_p, this.getParameters());
        this.setParameters(_p);
// END PARAMETERS

// PAINTING

        this.setConnector(this.endpoints[0].connector || this.endpoints[1].connector || params.connector || _jsPlumb.Defaults.Connector || _jp.Defaults.Connector, true);
        if (params.geometry) {
            this.connector.setGeometry(params.geometry);
        }
        var data = params.data == null || !_ju.isObject(params.data) ? {} : params.data;
        this.getData = function() { return data; };
        this.setData = function(d) { data = d || {}; };
        this.mergeData = function(d) { data = jsPlumb.extend(data, d); };

        // the very last thing we do is apply types, if there are any.
        var _types = [ "default", this.endpoints[0].connectionType, this.endpoints[1].connectionType,  params.type ].join(" ");
        if (/[^\s]/.test(_types))
            this.addType(_types, params.data, true);

        this.updateConnectedClass();

// END PAINTING    
    };

    _ju.extend(_jp.Connection, _jp.OverlayCapableJsPlumbUIComponent, {
        applyType: function (t, doNotRepaint, typeMap) {

            // none of these things result in the creation of objects so can be ignored.
            if (t.detachable != null) this.setDetachable(t.detachable);
            if (t.reattach != null) this.setReattach(t.reattach);
            if (t.scope) this.scope = t.scope;

            if (t.cssClass != null && this.canvas) this._jsPlumb.instance.addClass(this.canvas, t.cssClass);

            var _anchors = null;
            // this also results in the creation of objects.
            if (t.anchor) {
                // note that even if the param was anchor, we store `anchors`.
                _anchors = this.getCachedTypeItem("anchors", typeMap.anchor);
                if (_anchors == null) {
                    _anchors = [ this._jsPlumb.instance.makeAnchor(t.anchor), this._jsPlumb.instance.makeAnchor(t.anchor) ];
                    this.cacheTypeItem("anchors", _anchors, typeMap.anchor);
                }
            }
            else if (t.anchors) {
                _anchors = this.getCachedTypeItem("anchors", typeMap.anchors);
                if (_anchors == null) {
                    _anchors = [
                        this._jsPlumb.instance.makeAnchor(t.anchors[0]),
                        this._jsPlumb.instance.makeAnchor(t.anchors[1])
                    ];
                    this.cacheTypeItem("anchors", _anchors, typeMap.anchors);
                }
            }
            if (_anchors != null) {
                this.endpoints[0].anchor = _anchors[0];
                this.endpoints[1].anchor = _anchors[1];
                if (this.endpoints[1].anchor.isDynamic) this._jsPlumb.instance.repaint(this.endpoints[1].elementId);
            }

            _jp.OverlayCapableJsPlumbUIComponent.applyType(this, t);
        },
        addClass: function (c, informEndpoints) {
            if (informEndpoints) {
                this.endpoints[0].addClass(c);
                this.endpoints[1].addClass(c);
                if (this.suspendedEndpoint) this.suspendedEndpoint.addClass(c);
            }
            if (this.connector) {
                this.connector.addClass(c);
            }
        },
        removeClass: function (c, informEndpoints) {
            if (informEndpoints) {
                this.endpoints[0].removeClass(c);
                this.endpoints[1].removeClass(c);
                if (this.suspendedEndpoint) this.suspendedEndpoint.removeClass(c);
            }
            if (this.connector) {
                this.connector.removeClass(c);
            }
        },
        isVisible: function () {
            return this._jsPlumb.visible;
        },
        setVisible: function (v) {
            this._jsPlumb.visible = v;
            if (this.connector)
                this.connector.setVisible(v);
            this.repaint();
        },
        cleanup: function () {
            this.updateConnectedClass(true);
            this.endpoints = null;
            this.source = null;
            this.target = null;
            if (this.connector != null) {
                this.connector.cleanup(true);
                this.connector.destroy(true);
            }
            this.connector = null;
        },
        updateConnectedClass:function(remove) {
            if (this._jsPlumb) {
                _updateConnectedClass(this, this.source, this._jsPlumb.instance, remove);
                _updateConnectedClass(this, this.target, this._jsPlumb.instance, remove);
            }
        },
        setHover: function (state) {
            if (this.connector && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) {
                this.connector.setHover(state);
                root.jsPlumb[state ? "addClass" : "removeClass"](this.source, this._jsPlumb.instance.hoverSourceClass);
                root.jsPlumb[state ? "addClass" : "removeClass"](this.target, this._jsPlumb.instance.hoverTargetClass);
            }
        },
        getUuids:function() {
            return [ this.endpoints[0].getUuid(), this.endpoints[1].getUuid() ];
        },
        getCost: function () {
            return this._jsPlumb ? this._jsPlumb.cost : -Infinity;
        },
        setCost: function (c) {
            this._jsPlumb.cost = c;
        },
        isDirected: function () {
            return this._jsPlumb.directed === true;
        },
        getConnector: function () {
            return this.connector;
        },
        getGeometry : function() { return this.connector ? this.connector.getGeometry() : null; },
        setGeometry : function(g) { if (this.connector) this.connector.setGeometry(g); },
        prepareConnector:function(connectorSpec, typeId) {
            var connectorArgs = {
                    _jsPlumb: this._jsPlumb.instance,
                    cssClass: (this._jsPlumb.params.cssClass || "") + (this.isEditable() ? this._jsPlumb.instance.editableConnectorClass : ""),
                    container: this._jsPlumb.params.container,
                    "pointer-events": this._jsPlumb.params["pointer-events"],
                    editable:this.editableRequested
                },
                renderMode = this._jsPlumb.instance.getRenderMode(),
                connector;

            if (_ju.isString(connectorSpec))
                connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec, connectorArgs, this); // lets you use a string as shorthand.
            else if (_ju.isArray(connectorSpec)) {
                if (connectorSpec.length == 1)
                    connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec[0], connectorArgs, this);
                else
                    connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec[0], _ju.merge(connectorSpec[1], connectorArgs), this);
            }
            if (typeId != null) connector.typeId = typeId;
            return connector;
        },
        setPreparedConnector: function(connector, doNotRepaint, doNotChangeListenerComponent, typeId) {

            var previous, previousClasses = "";
            // the connector will not be cleaned up if it was set as part of a type, because `typeId` will be set on it
            // and we havent passed in `true` for "force" here.
            if (this.connector != null) {
                previous = this.connector;
                previousClasses = previous.getClass();
                this.connector.cleanup();
                this.connector.destroy();
            }

            this.connector = connector;
            if (typeId) {
                this.cacheTypeItem("connector", connector, typeId);
            }

            this.canvas = this.connector.canvas;
            this.bgCanvas = this.connector.bgCanvas;

            // put classes from prior connector onto the canvas
            this.addClass(previousClasses);

            // new: instead of binding listeners per connector, we now just have one delegate on the container.
            // so for that handler we set the connection as the '_jsPlumb' member of the canvas element, and
            // bgCanvas, if it exists, which it does right now in the VML renderer, so it won't from v 2.0.0 onwards.
            if (this.canvas) this.canvas._jsPlumb = this;
            if (this.bgCanvas) this.bgCanvas._jsPlumb = this;

            if (previous != null) {
                var o = this.getOverlays();
                for (var i = 0; i < o.length; i++) {
                    if (o[i].transfer) o[i].transfer(this.connector);
                }
            }

            if (!doNotChangeListenerComponent) this.setListenerComponent(this.connector);
            if (!doNotRepaint) this.repaint();
        },
        setConnector: function (connectorSpec, doNotRepaint, doNotChangeListenerComponent, typeId) {
            var connector = this.prepareConnector(connectorSpec, typeId);
            this.setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId);
        },
        paint: function (params) {

            if (!this._jsPlumb.instance.isSuspendDrawing() && this._jsPlumb.visible) {
                params = params || {};
                var timestamp = params.timestamp,
                // if the moving object is not the source we must transpose the two references.
                    swap = false,
                    tId = swap ? this.sourceId : this.targetId, sId = swap ? this.targetId : this.sourceId,
                    tIdx = swap ? 0 : 1, sIdx = swap ? 1 : 0;

                if (timestamp == null || timestamp != this._jsPlumb.lastPaintedAt) {
                    var sourceInfo = this._jsPlumb.instance.updateOffset({elId:sId}).o,
                        targetInfo = this._jsPlumb.instance.updateOffset({elId:tId}).o,
                        sE = this.endpoints[sIdx], tE = this.endpoints[tIdx];

                    var sAnchorP = sE.anchor.getCurrentLocation({xy: [sourceInfo.left, sourceInfo.top], wh: [sourceInfo.width, sourceInfo.height], element: sE, timestamp: timestamp}),
                        tAnchorP = tE.anchor.getCurrentLocation({xy: [targetInfo.left, targetInfo.top], wh: [targetInfo.width, targetInfo.height], element: tE, timestamp: timestamp});

                    this.connector.resetBounds();

                    this.connector.compute({
                        sourcePos: sAnchorP,
                        targetPos: tAnchorP,
                        sourceEndpoint: this.endpoints[sIdx],
                        targetEndpoint: this.endpoints[tIdx],
                        lineWidth: this._jsPlumb.paintStyleInUse.lineWidth,
                        sourceInfo: sourceInfo,
                        targetInfo: targetInfo
                    });

                    var overlayExtents = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };

                    // compute overlays. we do this first so we can get their placements, and adjust the
                    // container if needs be (if an overlay would be clipped)
                    for (var i in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(i)) {
                            var o = this._jsPlumb.overlays[i];
                            if (o.isVisible()) {
                                this._jsPlumb.overlayPlacements[i] = o.draw(this.connector, this._jsPlumb.paintStyleInUse, this.getAbsoluteOverlayPosition(o));
                                overlayExtents.minX = Math.min(overlayExtents.minX, this._jsPlumb.overlayPlacements[i].minX);
                                overlayExtents.maxX = Math.max(overlayExtents.maxX, this._jsPlumb.overlayPlacements[i].maxX);
                                overlayExtents.minY = Math.min(overlayExtents.minY, this._jsPlumb.overlayPlacements[i].minY);
                                overlayExtents.maxY = Math.max(overlayExtents.maxY, this._jsPlumb.overlayPlacements[i].maxY);
                            }
                        }
                    }

                    var lineWidth = parseFloat(this._jsPlumb.paintStyleInUse.lineWidth || 1) / 2,
                        outlineWidth = parseFloat(this._jsPlumb.paintStyleInUse.lineWidth || 0),
                        extents = {
                            xmin: Math.min(this.connector.bounds.minX - (lineWidth + outlineWidth), overlayExtents.minX),
                            ymin: Math.min(this.connector.bounds.minY - (lineWidth + outlineWidth), overlayExtents.minY),
                            xmax: Math.max(this.connector.bounds.maxX + (lineWidth + outlineWidth), overlayExtents.maxX),
                            ymax: Math.max(this.connector.bounds.maxY + (lineWidth + outlineWidth), overlayExtents.maxY)
                        };
                    // paint the connector.
                    this.connector.paint(this._jsPlumb.paintStyleInUse, null, extents);
                    // and then the overlays
                    for (var j in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(j)) {
                            var p = this._jsPlumb.overlays[j];
                            if (p.isVisible()) {
                                p.paint(this._jsPlumb.overlayPlacements[j], extents);
                            }
                        }
                    }
                }
                this._jsPlumb.lastPaintedAt = timestamp;
            }
        },
        repaint: function (params) {
            params = params || {};
            this.paint({ elId: this.sourceId, recalc: !(params.recalc === false), timestamp: params.timestamp});
        },
        prepareEndpoint: function (_jsPlumb, _newEndpoint, conn, existing, index, params, element, elementId) {
            var e;
            if (existing) {
                conn.endpoints[index] = existing;
                existing.addConnection(conn);
            } else {
                if (!params.endpoints) params.endpoints = [ null, null ];
                var ep = params.endpoints[index] || params.endpoint || _jsPlumb.Defaults.Endpoints[index] || jsPlumb.Defaults.Endpoints[index] || _jsPlumb.Defaults.Endpoint || jsPlumb.Defaults.Endpoint;
                if (!params.endpointStyles) params.endpointStyles = [ null, null ];
                if (!params.endpointHoverStyles) params.endpointHoverStyles = [ null, null ];
                var es = params.endpointStyles[index] || params.endpointStyle || _jsPlumb.Defaults.EndpointStyles[index] || jsPlumb.Defaults.EndpointStyles[index] || _jsPlumb.Defaults.EndpointStyle || jsPlumb.Defaults.EndpointStyle;
                // Endpoints derive their fillStyle from the connector's strokeStyle, if no fillStyle was specified.
                if (es.fillStyle == null && params.paintStyle != null)
                    es.fillStyle = params.paintStyle.strokeStyle;

                if (es.outlineColor == null && params.paintStyle != null)
                    es.outlineColor = params.paintStyle.outlineColor;
                if (es.outlineWidth == null && params.paintStyle != null)
                    es.outlineWidth = params.paintStyle.outlineWidth;

                var ehs = params.endpointHoverStyles[index] || params.endpointHoverStyle || _jsPlumb.Defaults.EndpointHoverStyles[index] || jsPlumb.Defaults.EndpointHoverStyles[index] || _jsPlumb.Defaults.EndpointHoverStyle || jsPlumb.Defaults.EndpointHoverStyle;
                // endpoint hover fill style is derived from connector's hover stroke style
                if (params.hoverPaintStyle != null) {
                    if (ehs == null) ehs = {};
                    if (ehs.fillStyle == null) {
                        ehs.fillStyle = params.hoverPaintStyle.strokeStyle;
                    }
                }
                var a = params.anchors ? params.anchors[index] :
                        params.anchor ? params.anchor :
                            _makeAnchor(_jsPlumb.Defaults.Anchors[index], elementId, _jsPlumb) ||
                            _makeAnchor(_jp.Defaults.Anchors[index], elementId, _jsPlumb) ||
                            _makeAnchor(_jsPlumb.Defaults.Anchor, elementId, _jsPlumb) ||
                            _makeAnchor(_jp.Defaults.Anchor, elementId, _jsPlumb),
                    u = params.uuids ? params.uuids[index] : null;

                e = _newEndpoint({
                    paintStyle: es, hoverPaintStyle: ehs, endpoint: ep, connections: [ conn ],
                    uuid: u, anchor: a, source: element, scope: params.scope,
                    reattach: params.reattach || _jsPlumb.Defaults.ReattachConnections,
                    detachable: params.detachable || _jsPlumb.Defaults.ConnectionsDetachable
                });
                conn.endpoints[index] = e;

                if (params.drawEndpoints === false) e.setVisible(false, true, true);

            }
            return e;
        }

    }); // END Connection class            
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.1.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for creating and manipulating anchors.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";

    var root = this,
        _ju = root.jsPlumbUtil,
        _jp = root.jsPlumb;

    //
    // manages anchors for all elements.
    //
    _jp.AnchorManager = function (params) {
        var _amEndpoints = {},
            continuousAnchorLocations = {},
            userDefinedContinuousAnchorLocations = {},
            continuousAnchorOrientations = {},
            Orientation = { HORIZONTAL: "horizontal", VERTICAL: "vertical", DIAGONAL: "diagonal", IDENTITY: "identity" },
            axes = ["left", "top", "right", "bottom"],
            connectionsByElementId = {},
            self = this,
            anchorLists = {},
            jsPlumbInstance = params.jsPlumbInstance,
            floatingConnections = {},
            calculateOrientation = function (sourceId, targetId, sd, td, sourceAnchor, targetAnchor) {

                if (sourceId === targetId) return {
                    orientation: Orientation.IDENTITY,
                    a: ["top", "top"]
                };

                var theta = Math.atan2((td.centery - sd.centery), (td.centerx - sd.centerx)),
                    theta2 = Math.atan2((sd.centery - td.centery), (sd.centerx - td.centerx));

// --------------------------------------------------------------------------------------

                // improved face calculation. get midpoints of each face for source and target, then put in an array with all combinations of
                // source/target faces. sort this array by distance between midpoints. the entry at index 0 is our preferred option. we can
                // go through the array one by one until we find an entry in which each requested face is supported.
                var candidates = [], midpoints = { };
                (function (types, dim) {
                    for (var i = 0; i < types.length; i++) {
                        midpoints[types[i]] = {
                            "left": [ dim[i].left, dim[i].centery ],
                            "right": [ dim[i].right, dim[i].centery ],
                            "top": [ dim[i].centerx, dim[i].top ],
                            "bottom": [ dim[i].centerx , dim[i].bottom]
                        };
                    }
                })([ "source", "target" ], [ sd, td ]);

                for (var sf = 0; sf < axes.length; sf++) {
                    for (var tf = 0; tf < axes.length; tf++) {
                        candidates.push({
                            source: axes[sf],
                            target: axes[tf],
                            dist: Biltong.lineLength(midpoints.source[axes[sf]], midpoints.target[axes[tf]])
                        });
                    }
                }

                candidates.sort(function (a, b) {
                    return a.dist < b.dist ? -1 : a.dist > b.dist ? 1 : 0;
                });

                // now go through this list and try to get an entry that satisfies both (there will be one, unless one of the anchors
                // declares no available faces)
                var sourceEdge = candidates[0].source, targetEdge = candidates[0].target;
                for (var i = 0; i < candidates.length; i++) {

                    if (!sourceAnchor.isContinuous || sourceAnchor.isEdgeSupported(candidates[i].source))
                        sourceEdge = candidates[i].source;
                    else
                        sourceEdge = null;

                    if (!targetAnchor.isContinuous || targetAnchor.isEdgeSupported(candidates[i].target))
                        targetEdge = candidates[i].target;
                    else {
                        targetEdge = null;
                    }

                    if (sourceEdge != null && targetEdge != null) break;
                }

// --------------------------------------------------------------------------------------

                return {
                    a: [ sourceEdge, targetEdge ],
                    theta: theta,
                    theta2: theta2
                };
            },
        // used by placeAnchors function
            placeAnchorsOnLine = function (desc, elementDimensions, elementPosition, connections, horizontal, otherMultiplier, reverse) {
                var a = [], step = elementDimensions[horizontal ? 0 : 1] / (connections.length + 1);

                for (var i = 0; i < connections.length; i++) {
                    var val = (i + 1) * step, other = otherMultiplier * elementDimensions[horizontal ? 1 : 0];
                    if (reverse)
                        val = elementDimensions[horizontal ? 0 : 1] - val;

                    var dx = (horizontal ? val : other), x = elementPosition[0] + dx, xp = dx / elementDimensions[0],
                        dy = (horizontal ? other : val), y = elementPosition[1] + dy, yp = dy / elementDimensions[1];

                    a.push([ x, y, xp, yp, connections[i][1], connections[i][2] ]);
                }

                return a;
            },
        // used by edgeSortFunctions
            currySort = function (reverseAngles) {
                return function (a, b) {
                    var r = true;
                    if (reverseAngles) {
                        r = a[0][0] < b[0][0];
                    }
                    else {
                        r = a[0][0] > b[0][0];
                    }
                    return r === false ? -1 : 1;
                };
            },
        // used by edgeSortFunctions
            leftSort = function (a, b) {
                // first get adjusted values
                var p1 = a[0][0] < 0 ? -Math.PI - a[0][0] : Math.PI - a[0][0],
                    p2 = b[0][0] < 0 ? -Math.PI - b[0][0] : Math.PI - b[0][0];
                if (p1 > p2) return 1;
                else return a[0][1] > b[0][1] ? 1 : -1;
            },
        // used by placeAnchors
            edgeSortFunctions = {
                "top": function (a, b) {
                    return a[0] > b[0] ? 1 : -1;
                },
                "right": currySort(true),
                "bottom": currySort(true),
                "left": leftSort
            },
        // used by placeAnchors
            _sortHelper = function (_array, _fn) {
                return _array.sort(_fn);
            },
        // used by AnchorManager.redraw
            placeAnchors = function (elementId, _anchorLists) {
                var cd = jsPlumbInstance.getCachedData(elementId), sS = cd.s, sO = cd.o,
                    placeSomeAnchors = function (desc, elementDimensions, elementPosition, unsortedConnections, isHorizontal, otherMultiplier, orientation) {
                        if (unsortedConnections.length > 0) {
                            var sc = _sortHelper(unsortedConnections, edgeSortFunctions[desc]), // puts them in order based on the target element's pos on screen
                                reverse = desc === "right" || desc === "top",
                                anchors = placeAnchorsOnLine(desc, elementDimensions,
                                    elementPosition, sc,
                                    isHorizontal, otherMultiplier, reverse);

                            // takes a computed anchor position and adjusts it for parent offset and scroll, then stores it.
                            var _setAnchorLocation = function (endpoint, anchorPos) {
                                continuousAnchorLocations[endpoint.id] = [ anchorPos[0], anchorPos[1], anchorPos[2], anchorPos[3] ];
                                continuousAnchorOrientations[endpoint.id] = orientation;
                            };

                            for (var i = 0; i < anchors.length; i++) {
                                var c = anchors[i][4], weAreSource = c.endpoints[0].elementId === elementId, weAreTarget = c.endpoints[1].elementId === elementId;
                                if (weAreSource)
                                    _setAnchorLocation(c.endpoints[0], anchors[i]);
                                if (weAreTarget)
                                    _setAnchorLocation(c.endpoints[1], anchors[i]);
                            }
                        }
                    };

                placeSomeAnchors("bottom", sS, [sO.left, sO.top], _anchorLists.bottom, true, 1, [0, 1]);
                placeSomeAnchors("top", sS, [sO.left, sO.top], _anchorLists.top, true, 0, [0, -1]);
                placeSomeAnchors("left", sS, [sO.left, sO.top], _anchorLists.left, false, 0, [-1, 0]);
                placeSomeAnchors("right", sS, [sO.left, sO.top], _anchorLists.right, false, 1, [1, 0]);
            };

        this.reset = function () {
            _amEndpoints = {};
            connectionsByElementId = {};
            anchorLists = {};
        };
        this.addFloatingConnection = function (key, conn) {
            floatingConnections[key] = conn;
        };
        this.removeFloatingConnection = function (key) {
            delete floatingConnections[key];
        };
        this.newConnection = function (conn) {
            var sourceId = conn.sourceId, targetId = conn.targetId,
                ep = conn.endpoints,
                doRegisterTarget = true,
                registerConnection = function (otherIndex, otherEndpoint, otherAnchor, elId, c) {
                    if ((sourceId == targetId) && otherAnchor.isContinuous) {
                        // remove the target endpoint's canvas.  we dont need it.
                        conn._jsPlumb.instance.removeElement(ep[1].canvas);
                        doRegisterTarget = false;
                    }
                    _ju.addToList(connectionsByElementId, elId, [c, otherEndpoint, otherAnchor.constructor == _jp.DynamicAnchor]);
                };

            registerConnection(0, ep[0], ep[0].anchor, targetId, conn);
            if (doRegisterTarget)
                registerConnection(1, ep[1], ep[1].anchor, sourceId, conn);
        };
        var removeEndpointFromAnchorLists = function (endpoint) {
            (function (list, eId) {
                if (list) {  // transient anchors dont get entries in this list.
                    var f = function (e) {
                        return e[4] == eId;
                    };
                    _ju.removeWithFunction(list.top, f);
                    _ju.removeWithFunction(list.left, f);
                    _ju.removeWithFunction(list.bottom, f);
                    _ju.removeWithFunction(list.right, f);
                }
            })(anchorLists[endpoint.elementId], endpoint.id);
        };
        this.connectionDetached = function (connInfo, doNotRedraw) {
            var connection = connInfo.connection || connInfo,
                sourceId = connInfo.sourceId,
                targetId = connInfo.targetId,
                ep = connection.endpoints,
                removeConnection = function (otherIndex, otherEndpoint, otherAnchor, elId, c) {
                   _ju.removeWithFunction(connectionsByElementId[elId], function (_c) {
                        return _c[0].id == c.id;
                    });
                };

            removeConnection(1, ep[1], ep[1].anchor, sourceId, connection);
            removeConnection(0, ep[0], ep[0].anchor, targetId, connection);
            if (connection.floatingId) {
                removeConnection(connection.floatingIndex, connection.floatingEndpoint, connection.floatingEndpoint.anchor, connection.floatingId, connection);
                removeEndpointFromAnchorLists(connection.floatingEndpoint);
            }

            // remove from anchorLists            
            removeEndpointFromAnchorLists(connection.endpoints[0]);
            removeEndpointFromAnchorLists(connection.endpoints[1]);

            if (!doNotRedraw) {
                self.redraw(connection.sourceId);
                if (connection.targetId !== connection.sourceId)
                    self.redraw(connection.targetId);
            }
        };
        this.add = function (endpoint, elementId) {
            _ju.addToList(_amEndpoints, elementId, endpoint);
        };
        this.changeId = function (oldId, newId) {
            connectionsByElementId[newId] = connectionsByElementId[oldId];
            _amEndpoints[newId] = _amEndpoints[oldId];
            delete connectionsByElementId[oldId];
            delete _amEndpoints[oldId];
        };
        this.getConnectionsFor = function (elementId) {
            return connectionsByElementId[elementId] || [];
        };
        this.getEndpointsFor = function (elementId) {
            return _amEndpoints[elementId] || [];
        };
        this.deleteEndpoint = function (endpoint) {
            _ju.removeWithFunction(_amEndpoints[endpoint.elementId], function (e) {
                return e.id == endpoint.id;
            });
            removeEndpointFromAnchorLists(endpoint);
        };
        this.clearFor = function (elementId) {
            delete _amEndpoints[elementId];
            _amEndpoints[elementId] = [];
        };
        // updates the given anchor list by either updating an existing anchor's info, or adding it. this function
        // also removes the anchor from its previous list, if the edge it is on has changed.
        // all connections found along the way (those that are connected to one of the faces this function
        // operates on) are added to the connsToPaint list, as are their endpoints. in this way we know to repaint
        // them wthout having to calculate anything else about them.
        var _updateAnchorList = function (lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, elId, connsToPaint, endpointsToPaint) {
            // first try to find the exact match, but keep track of the first index of a matching element id along the way.s
            var exactIdx = -1,
                firstMatchingElIdx = -1,
                endpoint = conn.endpoints[idx],
                endpointId = endpoint.id,
                oIdx = [1, 0][idx],
                values = [
                    [ theta, order ],
                    conn,
                    aBoolean,
                    otherElId,
                    endpointId
                ],
                listToAddTo = lists[edgeId],
                listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null,
                i,
                candidate;

            if (listToRemoveFrom) {
                var rIdx = _ju.findWithFunction(listToRemoveFrom, function (e) {
                    return e[4] == endpointId;
                });
                if (rIdx != -1) {
                    listToRemoveFrom.splice(rIdx, 1);
                    // get all connections from this list
                    for (i = 0; i < listToRemoveFrom.length; i++) {
                        candidate = listToRemoveFrom[i][1];
                        _ju.addWithFunction(connsToPaint, candidate, function (c) {
                            return c.id == candidate.id;
                        });
                        _ju.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[idx], function (e) {
                            return e.id == candidate.endpoints[idx].id;
                        });
                        _ju.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[oIdx], function (e) {
                            return e.id == candidate.endpoints[oIdx].id;
                        });
                    }
                }
            }

            for (i = 0; i < listToAddTo.length; i++) {
                candidate = listToAddTo[i][1];
                if (params.idx == 1 && listToAddTo[i][3] === otherElId && firstMatchingElIdx == -1)
                    firstMatchingElIdx = i;
                _ju.addWithFunction(connsToPaint, candidate, function (c) {
                    return c.id == candidate.id;
                });
                _ju.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[idx], function (e) {
                    return e.id == candidate.endpoints[idx].id;
                });
                _ju.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[oIdx], function (e) {
                    return e.id == candidate.endpoints[oIdx].id;
                });
            }
            if (exactIdx != -1) {
                listToAddTo[exactIdx] = values;
            }
            else {
                var insertIdx = reverse ? firstMatchingElIdx != -1 ? firstMatchingElIdx : 0 : listToAddTo.length; // of course we will get this from having looked through the array shortly.
                listToAddTo.splice(insertIdx, 0, values);
            }

            // store this for next time.
            endpoint._continuousAnchorEdge = edgeId;
        };

        //
        // find the entry in an endpoint's list for this connection and update its target endpoint
        // with the current target in the connection.
        // This method and sourceChanged need to be folder into one.
        //
        this.updateOtherEndpoint = function (sourceElId, oldTargetId, newTargetId, connection) {
            var sIndex = _ju.findWithFunction(connectionsByElementId[sourceElId], function (i) {
                    return i[0].id === connection.id;
                }),
                tIndex = _ju.findWithFunction(connectionsByElementId[oldTargetId], function (i) {
                    return i[0].id === connection.id;
                });

            // update or add data for source
            if (sIndex != -1) {
                connectionsByElementId[sourceElId][sIndex][0] = connection;
                connectionsByElementId[sourceElId][sIndex][1] = connection.endpoints[1];
                connectionsByElementId[sourceElId][sIndex][2] = connection.endpoints[1].anchor.constructor == _jp.DynamicAnchor;
            }

            // remove entry for previous target (if there)
            if (tIndex > -1) {
                connectionsByElementId[oldTargetId].splice(tIndex, 1);
                // add entry for new target
                _ju.addToList(connectionsByElementId, newTargetId, [connection, connection.endpoints[0], connection.endpoints[0].anchor.constructor == _jp.DynamicAnchor]);
            }

            connection.updateConnectedClass();
        };

        //
        // notification that the connection given has changed source from the originalId to the newId.
        // This involves:
        // 1. removing the connection from the list of connections stored for the originalId
        // 2. updating the source information for the target of the connection
        // 3. re-registering the connection in connectionsByElementId with the newId
        //
        this.sourceChanged = function (originalId, newId, connection, newElement) {
            if (originalId !== newId) {

                connection.sourceId = newId;
                connection.source = newElement;

                // remove the entry that points from the old source to the target
                _ju.removeWithFunction(connectionsByElementId[originalId], function (info) {
                    return info[0].id === connection.id;
                });
                // find entry for target and update it
                var tIdx = _ju.findWithFunction(connectionsByElementId[connection.targetId], function (i) {
                    return i[0].id === connection.id;
                });
                if (tIdx > -1) {
                    connectionsByElementId[connection.targetId][tIdx][0] = connection;
                    connectionsByElementId[connection.targetId][tIdx][1] = connection.endpoints[0];
                    connectionsByElementId[connection.targetId][tIdx][2] = connection.endpoints[0].anchor.constructor == _jp.DynamicAnchor;
                }
                // add entry for new source
                _ju.addToList(connectionsByElementId, newId, [connection, connection.endpoints[1], connection.endpoints[1].anchor.constructor == _jp.DynamicAnchor]);

                // TODO SP not final on this yet. when a user drags an existing connection and it turns into a self
                // loop, then this code hides the target endpoint (by removing it from the DOM) But I think this should
                // occur only if the anchor is Continuous
                if (connection.endpoints[1].anchor.isContinuous) {
                    if (connection.source === connection.target) {
                        connection._jsPlumb.instance.removeElement(connection.endpoints[1].canvas);
                    }
                    else {
                        if (connection.endpoints[1].canvas.parentNode == null) {
                            connection._jsPlumb.instance.appendElement(connection.endpoints[1].canvas);
                        }
                    }
                }

                connection.updateConnectedClass();
            }
        };

        //
        // moves the given endpoint from `currentId` to `element`.
        // This involves:
        //
        // 1. changing the key in _amEndpoints under which the endpoint is stored
        // 2. changing the source or target values in all of the endpoint's connections
        // 3. changing the array in connectionsByElementId in which the endpoint's connections
        //    are stored (done by either sourceChanged or updateOtherEndpoint)
        //
        this.rehomeEndpoint = function (ep, currentId, element) {
            var eps = _amEndpoints[currentId] || [],
                elementId = jsPlumbInstance.getId(element);

            if (elementId !== currentId) {
                var idx = eps.indexOf(ep);
                if (idx > -1) {
                    var _ep = eps.splice(idx, 1)[0];
                    self.add(_ep, elementId);
                }
            }

            for (var i = 0; i < ep.connections.length; i++) {
                if (ep.connections[i].sourceId == currentId) {
                    //ep.connections[i].sourceId = ep.elementId;
                    //ep.connections[i].source = ep.element;
                    self.sourceChanged(currentId, ep.elementId, ep.connections[i], ep.element);
                }
                else if (ep.connections[i].targetId == currentId) {
                    ep.connections[i].targetId = ep.elementId;
                    ep.connections[i].target = ep.element;
                    self.updateOtherEndpoint(ep.connections[i].sourceId, currentId, ep.elementId, ep.connections[i]);
                }
            }
        };

        this.redraw = function (elementId, ui, timestamp, offsetToUI, clearEdits, doNotRecalcEndpoint) {

            if (!jsPlumbInstance.isSuspendDrawing()) {
                // get all the endpoints for this element
                var ep = _amEndpoints[elementId] || [],
                    endpointConnections = connectionsByElementId[elementId] || [],
                    connectionsToPaint = [],
                    endpointsToPaint = [],
                    anchorsToUpdate = [];

                timestamp = timestamp || jsPlumbInstance.timestamp();
                // offsetToUI are values that would have been calculated in the dragManager when registering
                // an endpoint for an element that had a parent (somewhere in the hierarchy) that had been
                // registered as draggable.
                offsetToUI = offsetToUI || {left: 0, top: 0};
                if (ui) {
                    ui = {
                        left: ui.left + offsetToUI.left,
                        top: ui.top + offsetToUI.top
                    };
                }

                // valid for one paint cycle.
                var myOffset = jsPlumbInstance.updateOffset({ elId: elementId, offset: ui, recalc: false, timestamp: timestamp }),
                    orientationCache = {};

                // actually, first we should compute the orientation of this element to all other elements to which
                // this element is connected with a continuous anchor (whether both ends of the connection have
                // a continuous anchor or just one)

                for (var i = 0; i < endpointConnections.length; i++) {
                    var conn = endpointConnections[i][0],
                        sourceId = conn.sourceId,
                        targetId = conn.targetId,
                        sourceContinuous = conn.endpoints[0].anchor.isContinuous,
                        targetContinuous = conn.endpoints[1].anchor.isContinuous;

                    if (sourceContinuous || targetContinuous) {
                        var oKey = sourceId + "_" + targetId,
                            o = orientationCache[oKey],
                            oIdx = conn.sourceId == elementId ? 1 : 0;

                        if (sourceContinuous && !anchorLists[sourceId]) anchorLists[sourceId] = { top: [], right: [], bottom: [], left: [] };
                        if (targetContinuous && !anchorLists[targetId]) anchorLists[targetId] = { top: [], right: [], bottom: [], left: [] };

                        if (elementId != targetId) jsPlumbInstance.updateOffset({ elId: targetId, timestamp: timestamp });
                        if (elementId != sourceId) jsPlumbInstance.updateOffset({ elId: sourceId, timestamp: timestamp });

                        var td = jsPlumbInstance.getCachedData(targetId),
                            sd = jsPlumbInstance.getCachedData(sourceId);

                        if (targetId == sourceId && (sourceContinuous || targetContinuous)) {
                            // here we may want to improve this by somehow determining the face we'd like
                            // to put the connector on.  ideally, when drawing, the face should be calculated
                            // by determining which face is closest to the point at which the mouse button
                            // was released.  for now, we're putting it on the top face.
                            _updateAnchorList( anchorLists[sourceId], -Math.PI / 2, 0, conn, false, targetId, 0, false, "top", sourceId, connectionsToPaint, endpointsToPaint);
                            _updateAnchorList( anchorLists[targetId], -Math.PI / 2, 0, conn, false, sourceId, 1, false, "top", targetId, connectionsToPaint, endpointsToPaint);
                        }
                        else {
                            if (!o) {
                                o = calculateOrientation(sourceId, targetId, sd.o, td.o, conn.endpoints[0].anchor, conn.endpoints[1].anchor);
                                orientationCache[oKey] = o;
                                // this would be a performance enhancement, but the computed angles need to be clamped to
                                //the (-PI/2 -> PI/2) range in order for the sorting to work properly.
                                /*  orientationCache[oKey2] = {
                                 orientation:o.orientation,
                                 a:[o.a[1], o.a[0]],
                                 theta:o.theta + Math.PI,
                                 theta2:o.theta2 + Math.PI
                                 };*/
                            }
                            if (sourceContinuous) _updateAnchorList(anchorLists[sourceId], o.theta, 0, conn, false, targetId, 0, false, o.a[0], sourceId, connectionsToPaint, endpointsToPaint);
                            if (targetContinuous) _updateAnchorList(anchorLists[targetId], o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], targetId, connectionsToPaint, endpointsToPaint);
                        }

                        if (sourceContinuous) _ju.addWithFunction(anchorsToUpdate, sourceId, function (a) {
                            return a === sourceId;
                        });
                        if (targetContinuous) _ju.addWithFunction(anchorsToUpdate, targetId, function (a) {
                            return a === targetId;
                        });
                        _ju.addWithFunction(connectionsToPaint, conn, function (c) {
                            return c.id == conn.id;
                        });
                        if ((sourceContinuous && oIdx === 0) || (targetContinuous && oIdx === 1))
                            _ju.addWithFunction(endpointsToPaint, conn.endpoints[oIdx], function (e) {
                                return e.id == conn.endpoints[oIdx].id;
                            });
                    }
                }

                // place Endpoints whose anchors are continuous but have no Connections
                for (i = 0; i < ep.length; i++) {
                    if (ep[i].connections.length === 0 && ep[i].anchor.isContinuous) {
                        if (!anchorLists[elementId]) anchorLists[elementId] = { top: [], right: [], bottom: [], left: [] };
                        _updateAnchorList(anchorLists[elementId], -Math.PI / 2, 0, {endpoints: [ep[i], ep[i]], paint: function () {
                        }}, false, elementId, 0, false, ep[i].anchor.getDefaultFace(), elementId, connectionsToPaint, endpointsToPaint);
                        _ju.addWithFunction(anchorsToUpdate, elementId, function (a) {
                            return a === elementId;
                        });
                    }
                }


                // now place all the continuous anchors we need to;
                for (i = 0; i < anchorsToUpdate.length; i++) {
                    placeAnchors(anchorsToUpdate[i], anchorLists[anchorsToUpdate[i]]);
                }

                // now that continuous anchors have been placed, paint all the endpoints for this element
                // TODO performance: add the endpoint ids to a temp array, and then when iterating in the next
                // loop, check that we didn't just paint that endpoint. we can probably shave off a few more milliseconds this way.
                for (i = 0; i < ep.length; i++) {
                    ep[i].paint({ timestamp: timestamp, offset: myOffset, dimensions: myOffset.s, recalc: doNotRecalcEndpoint !== true });
                }

                // ... and any other endpoints we came across as a result of the continuous anchors.
                for (i = 0; i < endpointsToPaint.length; i++) {
                    var cd = jsPlumbInstance.getCachedData(endpointsToPaint[i].elementId);
                    endpointsToPaint[i].paint({ timestamp: timestamp, offset: cd, dimensions: cd.s });
                }

                // paint all the standard and "dynamic connections", which are connections whose other anchor is
                // static and therefore does need to be recomputed; we make sure that happens only one time.

                // TODO we could have compiled a list of these in the first pass through connections; might save some time.
                for (i = 0; i < endpointConnections.length; i++) {
                    var otherEndpoint = endpointConnections[i][1];
                    if (otherEndpoint.anchor.constructor == _jp.DynamicAnchor) {
                        otherEndpoint.paint({ elementWithPrecedence: elementId, timestamp: timestamp });
                        _ju.addWithFunction(connectionsToPaint, endpointConnections[i][0], function (c) {
                            return c.id == endpointConnections[i][0].id;
                        });
                        // all the connections for the other endpoint now need to be repainted
                        for (var k = 0; k < otherEndpoint.connections.length; k++) {
                            if (otherEndpoint.connections[k] !== endpointConnections[i][0])
                                _ju.addWithFunction(connectionsToPaint, otherEndpoint.connections[k], function (c) {
                                    return c.id == otherEndpoint.connections[k].id;
                                });
                        }
                    } else if (otherEndpoint.anchor.constructor == _jp.Anchor) {
                        _ju.addWithFunction(connectionsToPaint, endpointConnections[i][0], function (c) {
                            return c.id == endpointConnections[i][0].id;
                        });
                    }
                }

                // paint current floating connection for this element, if there is one.
                var fc = floatingConnections[elementId];
                if (fc)
                    fc.paint({timestamp: timestamp, recalc: false, elId: elementId});

                // paint all the connections
                for (i = 0; i < connectionsToPaint.length; i++) {
                    connectionsToPaint[i].paint({elId: elementId, timestamp: timestamp, recalc: false, clearEdits: clearEdits});
                }
            }
        };

        var ContinuousAnchor = function (anchorParams) {
            _ju.EventGenerator.apply(this);
            this.type = "Continuous";
            this.isDynamic = true;
            this.isContinuous = true;
            var faces = anchorParams.faces || ["top", "right", "bottom", "left"],
                clockwise = !(anchorParams.clockwise === false),
                availableFaces = { },
                opposites = { "top": "bottom", "right": "left", "left": "right", "bottom": "top" },
                clockwiseOptions = { "top": "right", "right": "bottom", "left": "top", "bottom": "left" },
                antiClockwiseOptions = { "top": "left", "right": "top", "left": "bottom", "bottom": "right" },
                secondBest = clockwise ? clockwiseOptions : antiClockwiseOptions,
                lastChoice = clockwise ? antiClockwiseOptions : clockwiseOptions,
                cssClass = anchorParams.cssClass || "";

            for (var i = 0; i < faces.length; i++) {
                availableFaces[faces[i]] = true;
            }

            this.getDefaultFace = function () {
                return faces.length === 0 ? "top" : faces[0];
            };

            // if the given edge is supported, returns it. otherwise looks for a substitute that _is_
            // supported. if none supported we also return the request edge.
            this.verifyEdge = function (edge) {
                if (availableFaces[edge]) return edge;
                else if (availableFaces[opposites[edge]]) return opposites[edge];
                else if (availableFaces[secondBest[edge]]) return secondBest[edge];
                else if (availableFaces[lastChoice[edge]]) return lastChoice[edge];
                return edge; // we have to give them something.
            };

            this.isEdgeSupported = function (edge) {
                return availableFaces[edge] === true;
            };

            this.compute = function (params) {
                return userDefinedContinuousAnchorLocations[params.element.id] || continuousAnchorLocations[params.element.id] || [0, 0];
            };
            this.getCurrentLocation = function (params) {
                return userDefinedContinuousAnchorLocations[params.element.id] || continuousAnchorLocations[params.element.id] || [0, 0];
            };
            this.getOrientation = function (endpoint) {
                return continuousAnchorOrientations[endpoint.id] || [0, 0];
            };
            this.clearUserDefinedLocation = function () {
                delete userDefinedContinuousAnchorLocations[anchorParams.elementId];
            };
            this.setUserDefinedLocation = function (loc) {
                userDefinedContinuousAnchorLocations[anchorParams.elementId] = loc;
            };
            this.getCssClass = function () {
                return cssClass;
            };
        };

        // continuous anchors
        jsPlumbInstance.continuousAnchorFactory = {
            get: function (params) {
                return new ContinuousAnchor(params);
            },
            clear: function (elementId) {
                delete userDefinedContinuousAnchorLocations[elementId];
                delete continuousAnchorLocations[elementId];
            }
        };
    };

    /**
     * Anchors model a position on some element at which an Endpoint may be located.  They began as a first class citizen of jsPlumb, ie. a user
     * was required to create these themselves, but over time this has been replaced by the concept of referring to them either by name (eg. "TopMiddle"),
     * or by an array describing their coordinates (eg. [ 0, 0.5, 0, -1 ], which is the same as "TopMiddle").  jsPlumb now handles all of the
     * creation of Anchors without user intervention.
     */
    _jp.Anchor = function (params) {
        this.x = params.x || 0;
        this.y = params.y || 0;
        this.elementId = params.elementId;
        this.cssClass = params.cssClass || "";
        this.userDefinedLocation = null;
        this.orientation = params.orientation || [ 0, 0 ];
        this.lastReturnValue = null;
        this.offsets = params.offsets || [ 0, 0 ];
        this.timestamp = null;

        _ju.EventGenerator.apply(this);

        this.compute = function (params) {

            var xy = params.xy, wh = params.wh, timestamp = params.timestamp;

            if (params.clearUserDefinedLocation)
                this.userDefinedLocation = null;

            if (timestamp && timestamp === self.timestamp)
                return this.lastReturnValue;

            if (this.userDefinedLocation != null) {
                this.lastReturnValue = this.userDefinedLocation;
            }
            else {
                this.lastReturnValue = [ xy[0] + (this.x * wh[0]) + this.offsets[0], xy[1] + (this.y * wh[1]) + this.offsets[1] ];
            }

            this.timestamp = timestamp;
            return this.lastReturnValue;
        };

        this.getCurrentLocation = function (params) {
            params = params || {};
            return (this.lastReturnValue == null || (params.timestamp != null && this.timestamp != params.timestamp)) ? this.compute(params) : this.lastReturnValue;
        };
    };
    _ju.extend(_jp.Anchor, _ju.EventGenerator, {
        equals: function (anchor) {
            if (!anchor) return false;
            var ao = anchor.getOrientation(),
                o = this.getOrientation();
            return this.x == anchor.x && this.y == anchor.y && this.offsets[0] == anchor.offsets[0] && this.offsets[1] == anchor.offsets[1] && o[0] == ao[0] && o[1] == ao[1];
        },
        getUserDefinedLocation: function () {
            return this.userDefinedLocation;
        },
        setUserDefinedLocation: function (l) {
            this.userDefinedLocation = l;
        },
        clearUserDefinedLocation: function () {
            this.userDefinedLocation = null;
        },
        getOrientation: function () {
            return this.orientation;
        },
        getCssClass: function () {
            return this.cssClass;
        }
    });

    /**
     * An Anchor that floats. its orientation is computed dynamically from
     * its position relative to the anchor it is floating relative to.  It is used when creating
     * a connection through drag and drop.
     *
     * TODO FloatingAnchor could totally be refactored to extend Anchor just slightly.
     */
    _jp.FloatingAnchor = function (params) {

        _jp.Anchor.apply(this, arguments);

        // this is the anchor that this floating anchor is referenced to for
        // purposes of calculating the orientation.
        var ref = params.reference,
            // the canvas this refers to.
            refCanvas = params.referenceCanvas,
            size = _jp.getSize(refCanvas),
            // these are used to store the current relative position of our
            // anchor wrt the reference anchor. they only indicate
            // direction, so have a value of 1 or -1 (or, very rarely, 0). these
            // values are written by the compute method, and read
            // by the getOrientation method.
            xDir = 0, yDir = 0,
            // temporary member used to store an orientation when the floating
            // anchor is hovering over another anchor.
            orientation = null,
            _lastResult = null;

        // clear from parent. we want floating anchor orientation to always be computed.
        this.orientation = null;

        // set these to 0 each; they are used by certain types of connectors in the loopback case,
        // when the connector is trying to clear the element it is on. but for floating anchor it's not
        // very important.
        this.x = 0;
        this.y = 0;

        this.isFloating = true;

        this.compute = function (params) {
            var xy = params.xy,
                result = [ xy[0] + (size[0] / 2), xy[1] + (size[1] / 2) ]; // return origin of the element. we may wish to improve this so that any object can be the drag proxy.
            _lastResult = result;
            return result;
        };

        this.getOrientation = function (_endpoint) {
            if (orientation) return orientation;
            else {
                var o = ref.getOrientation(_endpoint);
                // here we take into account the orientation of the other
                // anchor: if it declares zero for some direction, we declare zero too. this might not be the most awesome. perhaps we can come
                // up with a better way. it's just so that the line we draw looks like it makes sense. maybe this wont make sense.
                return [ Math.abs(o[0]) * xDir * -1,
                        Math.abs(o[1]) * yDir * -1 ];
            }
        };

        /**
         * notification the endpoint associated with this anchor is hovering
         * over another anchor; we want to assume that anchor's orientation
         * for the duration of the hover.
         */
        this.over = function (anchor, endpoint) {
            orientation = anchor.getOrientation(endpoint);
        };

        /**
         * notification the endpoint associated with this anchor is no
         * longer hovering over another anchor; we should resume calculating
         * orientation as we normally do.
         */
        this.out = function () {
            orientation = null;
        };

        this.getCurrentLocation = function (params) {
            return _lastResult == null ? this.compute(params) : _lastResult;
        };
    };
    _ju.extend(_jp.FloatingAnchor, _jp.Anchor);

    var _convertAnchor = function (anchor, jsPlumbInstance, elementId) {
        return anchor.constructor == _jp.Anchor ? anchor : jsPlumbInstance.makeAnchor(anchor, elementId, jsPlumbInstance);
    };

    /* 
     * A DynamicAnchor is an Anchor that contains a list of other Anchors, which it cycles
     * through at compute time to find the one that is located closest to
     * the center of the target element, and returns that Anchor's compute
     * method result. this causes endpoints to follow each other with
     * respect to the orientation of their target elements, which is a useful
     * feature for some applications.
     * 
     */
    _jp.DynamicAnchor = function (params) {
        _jp.Anchor.apply(this, arguments);

        this.isDynamic = true;
        this.anchors = [];
        this.elementId = params.elementId;
        this.jsPlumbInstance = params.jsPlumbInstance;

        for (var i = 0; i < params.anchors.length; i++)
            this.anchors[i] = _convertAnchor(params.anchors[i], this.jsPlumbInstance, this.elementId);

        this.getAnchors = function () {
            return this.anchors;
        };
        this.locked = false;
        var _curAnchor = this.anchors.length > 0 ? this.anchors[0] : null,
            _lastAnchor = _curAnchor,
            self = this,

        // helper method to calculate the distance between the centers of the two elements.
            _distance = function (anchor, cx, cy, xy, wh) {
                var ax = xy[0] + (anchor.x * wh[0]), ay = xy[1] + (anchor.y * wh[1]),
                    acx = xy[0] + (wh[0] / 2), acy = xy[1] + (wh[1] / 2);
                return (Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2)) +
                    Math.sqrt(Math.pow(acx - ax, 2) + Math.pow(acy - ay, 2)));
            },
        // default method uses distance between element centers.  you can provide your own method in the dynamic anchor
        // constructor (and also to jsPlumb.makeDynamicAnchor). the arguments to it are four arrays:
        // xy - xy loc of the anchor's element
        // wh - anchor's element's dimensions
        // txy - xy loc of the element of the other anchor in the connection
        // twh - dimensions of the element of the other anchor in the connection.
        // anchors - the list of selectable anchors
            _anchorSelector = params.selector || function (xy, wh, txy, twh, anchors) {
                var cx = txy[0] + (twh[0] / 2), cy = txy[1] + (twh[1] / 2);
                var minIdx = -1, minDist = Infinity;
                for (var i = 0; i < anchors.length; i++) {
                    var d = _distance(anchors[i], cx, cy, xy, wh);
                    if (d < minDist) {
                        minIdx = i + 0;
                        minDist = d;
                    }
                }
                return anchors[minIdx];
            };

        this.compute = function (params) {
            var xy = params.xy, wh = params.wh, txy = params.txy, twh = params.twh;

            this.timestamp = params.timestamp;

            var udl = self.getUserDefinedLocation();
            if (udl != null) {
                return udl;
            }

            // if anchor is locked or an opposite element was not given, we
            // maintain our state. anchor will be locked
            // if it is the source of a drag and drop.
            if (this.locked || txy == null || twh == null)
                return _curAnchor.compute(params);
            else
                params.timestamp = null; // otherwise clear this, i think. we want the anchor to compute.

            _curAnchor = _anchorSelector(xy, wh, txy, twh, this.anchors);
            this.x = _curAnchor.x;
            this.y = _curAnchor.y;

            if (_curAnchor != _lastAnchor)
                this.fire("anchorChanged", _curAnchor);

            _lastAnchor = _curAnchor;

            return _curAnchor.compute(params);
        };

        this.getCurrentLocation = function (params) {
            return this.getUserDefinedLocation() || (_curAnchor != null ? _curAnchor.getCurrentLocation(params) : null);
        };

        this.getOrientation = function (_endpoint) {
            return _curAnchor != null ? _curAnchor.getOrientation(_endpoint) : [ 0, 0 ];
        };
        this.over = function (anchor, endpoint) {
            if (_curAnchor != null) _curAnchor.over(anchor, endpoint);
        };
        this.out = function () {
            if (_curAnchor != null) _curAnchor.out();
        };

        this.getCssClass = function () {
            return (_curAnchor && _curAnchor.getCssClass()) || "";
        };
    };
    _ju.extend(_jp.DynamicAnchor, _jp.Anchor);

// -------- basic anchors ------------------    
    var _curryAnchor = function (x, y, ox, oy, type, fnInit) {
        _jp.Anchors[type] = function (params) {
            var a = params.jsPlumbInstance.makeAnchor([ x, y, ox, oy, 0, 0 ], params.elementId, params.jsPlumbInstance);
            a.type = type;
            if (fnInit) fnInit(a, params);
            return a;
        };
    };

    _curryAnchor(0.5, 0, 0, -1, "TopCenter");
    _curryAnchor(0.5, 1, 0, 1, "BottomCenter");
    _curryAnchor(0, 0.5, -1, 0, "LeftMiddle");
    _curryAnchor(1, 0.5, 1, 0, "RightMiddle");

    _curryAnchor(0.5, 0, 0, -1, "Top");
    _curryAnchor(0.5, 1, 0, 1, "Bottom");
    _curryAnchor(0, 0.5, -1, 0, "Left");
    _curryAnchor(1, 0.5, 1, 0, "Right");
    _curryAnchor(0.5, 0.5, 0, 0, "Center");
    _curryAnchor(1, 0, 0, -1, "TopRight");
    _curryAnchor(1, 1, 0, 1, "BottomRight");
    _curryAnchor(0, 0, 0, -1, "TopLeft");
    _curryAnchor(0, 1, 0, 1, "BottomLeft");

// ------- dynamic anchors -------------------    

    // default dynamic anchors chooses from Top, Right, Bottom, Left
    _jp.Defaults.DynamicAnchors = function (params) {
        return params.jsPlumbInstance.makeAnchors(["TopCenter", "RightMiddle", "BottomCenter", "LeftMiddle"], params.elementId, params.jsPlumbInstance);
    };

    // default dynamic anchors bound to name 'AutoDefault'
    _jp.Anchors.AutoDefault = function (params) {
        var a = params.jsPlumbInstance.makeDynamicAnchor(_jp.Defaults.DynamicAnchors(params));
        a.type = "AutoDefault";
        return a;
    };

// ------- continuous anchors -------------------    

    var _curryContinuousAnchor = function (type, faces) {
        _jp.Anchors[type] = function (params) {
            var a = params.jsPlumbInstance.makeAnchor(["Continuous", { faces: faces }], params.elementId, params.jsPlumbInstance);
            a.type = type;
            return a;
        };
    };

    _jp.Anchors.Continuous = function (params) {
        return params.jsPlumbInstance.continuousAnchorFactory.get(params);
    };

    _curryContinuousAnchor("ContinuousLeft", ["left"]);
    _curryContinuousAnchor("ContinuousTop", ["top"]);
    _curryContinuousAnchor("ContinuousBottom", ["bottom"]);
    _curryContinuousAnchor("ContinuousRight", ["right"]);

// ------- position assign anchors -------------------    

    // this anchor type lets you assign the position at connection time.
    _curryAnchor(0, 0, 0, 0, "Assign", function (anchor, params) {
        // find what to use as the "position finder". the user may have supplied a String which represents
        // the id of a position finder in jsPlumb.AnchorPositionFinders, or the user may have supplied the
        // position finder as a function.  we find out what to use and then set it on the anchor.
        var pf = params.position || "Fixed";
        anchor.positionFinder = pf.constructor == String ? params.jsPlumbInstance.AnchorPositionFinders[pf] : pf;
        // always set the constructor params; the position finder might need them later (the Grid one does,
        // for example)
        anchor.constructorParams = params;
    });

    // these are the default anchor positions finders, which are used by the makeTarget function.  supplying
    // a position finder argument to that function allows you to specify where the resulting anchor will
    // be located
    root.jsPlumbInstance.prototype.AnchorPositionFinders = {
        "Fixed": function (dp, ep, es) {
            return [ (dp.left - ep.left) / es[0], (dp.top - ep.top) / es[1] ];
        },
        "Grid": function (dp, ep, es, params) {
            var dx = dp.left - ep.left, dy = dp.top - ep.top,
                gx = es[0] / (params.grid[0]), gy = es[1] / (params.grid[1]),
                mx = Math.floor(dx / gx), my = Math.floor(dy / gy);
            return [ ((mx * gx) + (gx / 2)) / es[0], ((my * gy) + (gy / 2)) / es[1] ];
        }
    };

// ------- perimeter anchors -------------------    

    _jp.Anchors.Perimeter = function (params) {
        params = params || {};
        var anchorCount = params.anchorCount || 60,
            shape = params.shape;

        if (!shape) throw new Error("no shape supplied to Perimeter Anchor type");

        var _circle = function () {
                var r = 0.5, step = Math.PI * 2 / anchorCount, current = 0, a = [];
                for (var i = 0; i < anchorCount; i++) {
                    var x = r + (r * Math.sin(current)),
                        y = r + (r * Math.cos(current));
                    a.push([ x, y, 0, 0 ]);
                    current += step;
                }
                return a;
            },
            _path = function (segments) {
                var anchorsPerFace = anchorCount / segments.length, a = [],
                    _computeFace = function (x1, y1, x2, y2, fractionalLength) {
                        anchorsPerFace = anchorCount * fractionalLength;
                        var dx = (x2 - x1) / anchorsPerFace, dy = (y2 - y1) / anchorsPerFace;
                        for (var i = 0; i < anchorsPerFace; i++) {
                            a.push([
                                    x1 + (dx * i),
                                    y1 + (dy * i),
                                0,
                                0
                            ]);
                        }
                    };

                for (var i = 0; i < segments.length; i++)
                    _computeFace.apply(null, segments[i]);

                return a;
            },
            _shape = function (faces) {
                var s = [];
                for (var i = 0; i < faces.length; i++) {
                    s.push([faces[i][0], faces[i][1], faces[i][2], faces[i][3], 1 / faces.length]);
                }
                return _path(s);
            },
            _rectangle = function () {
                return _shape([
                    [ 0, 0, 1, 0 ],
                    [ 1, 0, 1, 1 ],
                    [ 1, 1, 0, 1 ],
                    [ 0, 1, 0, 0 ]
                ]);
            };

        var _shapes = {
                "Circle": _circle,
                "Ellipse": _circle,
                "Diamond": function () {
                    return _shape([
                        [ 0.5, 0, 1, 0.5 ],
                        [ 1, 0.5, 0.5, 1 ],
                        [ 0.5, 1, 0, 0.5 ],
                        [ 0, 0.5, 0.5, 0 ]
                    ]);
                },
                "Rectangle": _rectangle,
                "Square": _rectangle,
                "Triangle": function () {
                    return _shape([
                        [ 0.5, 0, 1, 1 ],
                        [ 1, 1, 0, 1 ],
                        [ 0, 1, 0.5, 0]
                    ]);
                },
                "Path": function (params) {
                    var points = params.points, p = [], tl = 0;
                    for (var i = 0; i < points.length - 1; i++) {
                        var l = Math.sqrt(Math.pow(points[i][2] - points[i][0]) + Math.pow(points[i][3] - points[i][1]));
                        tl += l;
                        p.push([points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], l]);
                    }
                    for (var j = 0; j < p.length; j++) {
                        p[j][4] = p[j][4] / tl;
                    }
                    return _path(p);
                }
            },
            _rotate = function (points, amountInDegrees) {
                var o = [], theta = amountInDegrees / 180 * Math.PI;
                for (var i = 0; i < points.length; i++) {
                    var _x = points[i][0] - 0.5,
                        _y = points[i][1] - 0.5;

                    o.push([
                            0.5 + ((_x * Math.cos(theta)) - (_y * Math.sin(theta))),
                            0.5 + ((_x * Math.sin(theta)) + (_y * Math.cos(theta))),
                        points[i][2],
                        points[i][3]
                    ]);
                }
                return o;
            };

        if (!_shapes[shape]) throw new Error("Shape [" + shape + "] is unknown by Perimeter Anchor type");

        var da = _shapes[shape](params);
        if (params.rotation) da = _rotate(da, params.rotation);
        var a = params.jsPlumbInstance.makeDynamicAnchor(da);
        a.type = "Perimeter";
        return a;
    };
}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.1.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the default Connectors, Endpoint and Overlay definitions.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil, _jg = root.Biltong;

    _jp.Segments = {

        /*
         * Class: AbstractSegment
         * A Connector is made up of 1..N Segments, each of which has a Type, such as 'Straight', 'Arc',
         * 'Bezier'. This is new from 1.4.2, and gives us a lot more flexibility when drawing connections: things such
         * as rounded corners for flowchart connectors, for example, or a straight line stub for Bezier connections, are
         * much easier to do now.
         *
         * A Segment is responsible for providing coordinates for painting it, and also must be able to report its length.
         * 
         */
        AbstractSegment: function (params) {
            this.params = params;

            /**
             * Function: findClosestPointOnPath
             * Finds the closest point on this segment to the given [x, y],
             * returning both the x and y of the point plus its distance from
             * the supplied point, and its location along the length of the
             * path inscribed by the segment.  This implementation returns
             * Infinity for distance and null values for everything else;
             * subclasses are expected to override.
             */
            this.findClosestPointOnPath = function (x, y) {
                return {
                    d: Infinity,
                    x: null,
                    y: null,
                    l: null
                };
            };

            this.getBounds = function () {
                return {
                    minX: Math.min(params.x1, params.x2),
                    minY: Math.min(params.y1, params.y2),
                    maxX: Math.max(params.x1, params.x2),
                    maxY: Math.max(params.y1, params.y2)
                };
            };
        },
        Straight: function (params) {
            var _super = _jp.Segments.AbstractSegment.apply(this, arguments),
                length, m, m2, x1, x2, y1, y2,
                _recalc = function () {
                    length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    m = _jg.gradient({x: x1, y: y1}, {x: x2, y: y2});
                    m2 = -1 / m;
                };

            this.type = "Straight";

            this.getLength = function () {
                return length;
            };
            this.getGradient = function () {
                return m;
            };

            this.getCoordinates = function () {
                return { x1: x1, y1: y1, x2: x2, y2: y2 };
            };
            this.setCoordinates = function (coords) {
                x1 = coords.x1;
                y1 = coords.y1;
                x2 = coords.x2;
                y2 = coords.y2;
                _recalc();
            };
            this.setCoordinates({x1: params.x1, y1: params.y1, x2: params.x2, y2: params.y2});

            this.getBounds = function () {
                return {
                    minX: Math.min(x1, x2),
                    minY: Math.min(y1, y2),
                    maxX: Math.max(x1, x2),
                    maxY: Math.max(y1, y2)
                };
            };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive. for the straight line segment this is simple maths.
             */
            this.pointOnPath = function (location, absolute) {
                if (location === 0 && !absolute)
                    return { x: x1, y: y1 };
                else if (location == 1 && !absolute)
                    return { x: x2, y: y2 };
                else {
                    var l = absolute ? location > 0 ? location : length + location : location * length;
                    return _jg.pointOnLine({x: x1, y: y1}, {x: x2, y: y2}, l);
                }
            };

            /**
             * returns the gradient of the segment at the given point - which for us is constant.
             */
            this.gradientAtPoint = function (_) {
                return m;
            };

            /**
             * returns the point on the segment's path that is 'distance' along the length of the path from 'location', where
             * 'location' is a decimal from 0 to 1 inclusive, and 'distance' is a number of pixels.
             * this hands off to jsPlumbUtil to do the maths, supplying two points and the distance.
             */
            this.pointAlongPathFrom = function (location, distance, absolute) {
                var p = this.pointOnPath(location, absolute),
                    farAwayPoint = distance <= 0 ? {x: x1, y: y1} : {x: x2, y: y2 };

                /*
                 location == 1 ? {
                 x:x1 + ((x2 - x1) * 10),
                 y:y1 + ((y1 - y2) * 10)
                 } :
                 */

                if (distance <= 0 && Math.abs(distance) > 1) distance *= -1;

                return _jg.pointOnLine(p, farAwayPoint, distance);
            };

            // is c between a and b?
            var within = function (a, b, c) {
                return c >= Math.min(a, b) && c <= Math.max(a, b);
            };
            // find which of a and b is closest to c
            var closest = function (a, b, c) {
                return Math.abs(c - a) < Math.abs(c - b) ? a : b;
            };

            /**
             Function: findClosestPointOnPath
             Finds the closest point on this segment to [x,y]. See
             notes on this method in AbstractSegment.
             */
            this.findClosestPointOnPath = function (x, y) {
                var out = {
                    d: Infinity,
                    x: null,
                    y: null,
                    l: null,
                    x1: x1,
                    x2: x2,
                    y1: y1,
                    y2: y2
                };

                if (m === 0) {
                    out.y = y1;
                    out.x = within(x1, x2, x) ? x : closest(x1, x2, x);
                }
                else if (m == Infinity || m == -Infinity) {
                    out.x = x1;
                    out.y = within(y1, y2, y) ? y : closest(y1, y2, y);
                }
                else {
                    // closest point lies on normal from given point to this line.  
                    var b = y1 - (m * x1),
                        b2 = y - (m2 * x),
                    // y1 = m.x1 + b and y1 = m2.x1 + b2
                    // so m.x1 + b = m2.x1 + b2
                    // x1(m - m2) = b2 - b
                    // x1 = (b2 - b) / (m - m2)
                        _x1 = (b2 - b) / (m - m2),
                        _y1 = (m * _x1) + b;

                    out.x = within(x1, x2, _x1) ? _x1 : closest(x1, x2, _x1);//_x1;
                    out.y = within(y1, y2, _y1) ? _y1 : closest(y1, y2, _y1);//_y1;
                }

                var fractionInSegment = _jg.lineLength([ out.x, out.y ], [ x1, y1 ]);
                out.d = _jg.lineLength([x, y], [out.x, out.y]);
                out.l = fractionInSegment / length;
                return out;
            };
        },

        /*
         Arc Segment. You need to supply:

         r   -   radius
         cx  -   center x for the arc
         cy  -   center y for the arc
         ac  -   whether the arc is anticlockwise or not. default is clockwise.

         and then either:

         startAngle  -   startAngle for the arc.
         endAngle    -   endAngle for the arc.

         or:

         x1          -   x for start point
         y1          -   y for start point
         x2          -   x for end point
         y2          -   y for end point

         */
        Arc: function (params) {
            var _super = _jp.Segments.AbstractSegment.apply(this, arguments),
                _calcAngle = function (_x, _y) {
                    return _jg.theta([params.cx, params.cy], [_x, _y]);
                },
                _calcAngleForLocation = function (segment, location) {
                    if (segment.anticlockwise) {
                        var sa = segment.startAngle < segment.endAngle ? segment.startAngle + TWO_PI : segment.startAngle,
                            s = Math.abs(sa - segment.endAngle);
                        return sa - (s * location);
                    }
                    else {
                        var ea = segment.endAngle < segment.startAngle ? segment.endAngle + TWO_PI : segment.endAngle,
                            ss = Math.abs(ea - segment.startAngle);

                        return segment.startAngle + (ss * location);
                    }
                },
                TWO_PI = 2 * Math.PI;

            this.radius = params.r;
            this.anticlockwise = params.ac;
            this.type = "Arc";

            if (params.startAngle && params.endAngle) {
                this.startAngle = params.startAngle;
                this.endAngle = params.endAngle;
                this.x1 = params.cx + (this.radius * Math.cos(params.startAngle));
                this.y1 = params.cy + (this.radius * Math.sin(params.startAngle));
                this.x2 = params.cx + (this.radius * Math.cos(params.endAngle));
                this.y2 = params.cy + (this.radius * Math.sin(params.endAngle));
            }
            else {
                this.startAngle = _calcAngle(params.x1, params.y1);
                this.endAngle = _calcAngle(params.x2, params.y2);
                this.x1 = params.x1;
                this.y1 = params.y1;
                this.x2 = params.x2;
                this.y2 = params.y2;
            }

            if (this.endAngle < 0) this.endAngle += TWO_PI;
            if (this.startAngle < 0) this.startAngle += TWO_PI;

            // segment is used by vml     
            //this.segment = _jg.quadrant([this.x1, this.y1], [this.x2, this.y2]);

            // we now have startAngle and endAngle as positive numbers, meaning the
            // absolute difference (|d|) between them is the sweep (s) of this arc, unless the
            // arc is 'anticlockwise' in which case 's' is given by 2PI - |d|.

            var ea = this.endAngle < this.startAngle ? this.endAngle + TWO_PI : this.endAngle;
            this.sweep = Math.abs(ea - this.startAngle);
            if (this.anticlockwise) this.sweep = TWO_PI - this.sweep;
            var circumference = 2 * Math.PI * this.radius,
                frac = this.sweep / TWO_PI,
                length = circumference * frac;

            this.getLength = function () {
                return length;
            };

            this.getBounds = function () {
                return {
                    minX: params.cx - params.r,
                    maxX: params.cx + params.r,
                    minY: params.cy - params.r,
                    maxY: params.cy + params.r
                };
            };

            var VERY_SMALL_VALUE = 0.0000000001,
                gentleRound = function (n) {
                    var f = Math.floor(n), r = Math.ceil(n);
                    if (n - f < VERY_SMALL_VALUE)
                        return f;
                    else if (r - n < VERY_SMALL_VALUE)
                        return r;
                    return n;
                };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive.
             */
            this.pointOnPath = function (location, absolute) {

                if (location === 0) {
                    return { x: this.x1, y: this.y1, theta: this.startAngle };
                }
                else if (location == 1) {
                    return { x: this.x2, y: this.y2, theta: this.endAngle };
                }

                if (absolute) {
                    location = location / length;
                }

                var angle = _calcAngleForLocation(this, location),
                    _x = params.cx + (params.r * Math.cos(angle)),
                    _y = params.cy + (params.r * Math.sin(angle));

                return { x: gentleRound(_x), y: gentleRound(_y), theta: angle };
            };

            /**
             * returns the gradient of the segment at the given point.
             */
            this.gradientAtPoint = function (location, absolute) {
                var p = this.pointOnPath(location, absolute);
                var m = _jg.normal([ params.cx, params.cy ], [p.x, p.y ]);
                if (!this.anticlockwise && (m == Infinity || m == -Infinity)) m *= -1;
                return m;
            };

            this.pointAlongPathFrom = function (location, distance, absolute) {
                var p = this.pointOnPath(location, absolute),
                    arcSpan = distance / circumference * 2 * Math.PI,
                    dir = this.anticlockwise ? -1 : 1,
                    startAngle = p.theta + (dir * arcSpan),
                    startX = params.cx + (this.radius * Math.cos(startAngle)),
                    startY = params.cy + (this.radius * Math.sin(startAngle));

                return {x: startX, y: startY};
            };
        },

        Bezier: function (params) {
            this.curve = [
                { x: params.x1, y: params.y1},
                { x: params.cp1x, y: params.cp1y },
                { x: params.cp2x, y: params.cp2y },
                { x: params.x2, y: params.y2 }
            ];

            var _super = _jp.Segments.AbstractSegment.apply(this, arguments);
            // although this is not a strictly rigorous determination of bounds
            // of a bezier curve, it works for the types of curves that this segment
            // type produces.
            this.bounds = {
                minX: Math.min(params.x1, params.x2, params.cp1x, params.cp2x),
                minY: Math.min(params.y1, params.y2, params.cp1y, params.cp2y),
                maxX: Math.max(params.x1, params.x2, params.cp1x, params.cp2x),
                maxY: Math.max(params.y1, params.y2, params.cp1y, params.cp2y)
            };

            this.type = "Bezier";

            var _translateLocation = function (_curve, location, absolute) {
                if (absolute)
                    location = root.jsBezier.locationAlongCurveFrom(_curve, location > 0 ? 0 : 1, location);

                return location;
            };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive.
             */
            this.pointOnPath = function (location, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.pointOnCurve(this.curve, location);
            };

            /**
             * returns the gradient of the segment at the given point.
             */
            this.gradientAtPoint = function (location, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.gradientAtPoint(this.curve, location);
            };

            this.pointAlongPathFrom = function (location, distance, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.pointAlongCurveFrom(this.curve, location, distance);
            };

            this.getLength = function () {
                return root.jsBezier.getLength(this.curve);
            };

            this.getBounds = function () {
                return this.bounds;
            };
        }
    };

    /*
     Class: AbstractComponent
     Superclass for AbstractConnector and AbstractEndpoint.
     */
    var AbstractComponent = function () {
        this.resetBounds = function () {
            this.bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
        };
        this.resetBounds();
    };

    /*
     * Class: AbstractConnector
     * Superclass for all Connectors; here is where Segments are managed.  This is exposed on jsPlumb just so it
     * can be accessed from other files. You should not try to instantiate one of these directly.
     *
     * When this class is asked for a pointOnPath, or gradient etc, it must first figure out which segment to dispatch
     * that request to. This is done by keeping track of the total connector length as segments are added, and also
     * their cumulative ratios to the total length.  Then when the right segment is found it is a simple case of dispatching
     * the request to it (and adjusting 'location' so that it is relative to the beginning of that segment.)
     */
    _jp.Connectors.AbstractConnector = function (params) {

        AbstractComponent.apply(this, arguments);

        var segments = [],
            totalLength = 0,
            segmentProportions = [],
            segmentProportionalLengths = [],
            stub = params.stub || 0,
            sourceStub = _ju.isArray(stub) ? stub[0] : stub,
            targetStub = _ju.isArray(stub) ? stub[1] : stub,
            gap = params.gap || 0,
            sourceGap = _ju.isArray(gap) ? gap[0] : gap,
            targetGap = _ju.isArray(gap) ? gap[1] : gap,
            userProvidedSegments = null,
            edited = false,
            paintInfo = null,
            geometry = null,
            editable = params.editable !== false && jsPlumb.ConnectorEditors != null && jsPlumb.ConnectorEditors[this.type] != null;

        var _setGeometry = this.setGeometry = function(g, internallyComputed) {
            edited = (!internallyComputed);
            geometry = g;
        };
        var _getGeometry = this.getGeometry = function() {
            return geometry;
        };

        this.hasBeenEdited = function() { return edited; };
        this.isEditing = function() { return this.editor != null && this.editor.isActive(); };
        this.setEditable = function(e) {
            // if this connector has an editor already, or
            // if an editor for this connector's type is available, or
            // if the child declares an overrideSetEditable and it does not return false, editable is true.
            if (e && jsPlumb.ConnectorEditors != null && jsPlumb.ConnectorEditors[this.type] != null && (this.overrideSetEditable == null || this.overrideSetEditable())) {
                editable = e;
            } else {
                editable = false;
            }
            return editable;
        };
        this.isEditable = function() { return editable; };

        /**
         * Function: findSegmentForPoint
         * Returns the segment that is closest to the given [x,y],
         * null if nothing found.  This function returns a JS
         * object with:
         *
         *   d   -   distance from segment
         *   l   -   proportional location in segment
         *   x   -   x point on the segment
         *   y   -   y point on the segment
         *   s   -   the segment itself.
         */
        this.findSegmentForPoint = function (x, y) {
            var out = { d: Infinity, s: null, x: null, y: null, l: null };
            for (var i = 0; i < segments.length; i++) {
                var _s = segments[i].findClosestPointOnPath(x, y);
                if (_s.d < out.d) {
                    out.d = _s.d;
                    out.l = _s.l;
                    out.x = _s.x;
                    out.y = _s.y;
                    out.s = segments[i];
                    out.x1 = _s.x1;
                    out.x2 = _s.x2;
                    out.y1 = _s.y1;
                    out.y2 = _s.y2;
                    out.index = i;
                }
            }

            return out;
        };

        var _updateSegmentProportions = function () {
                var curLoc = 0;
                for (var i = 0; i < segments.length; i++) {
                    var sl = segments[i].getLength();
                    segmentProportionalLengths[i] = sl / totalLength;
                    segmentProportions[i] = [curLoc, (curLoc += (sl / totalLength)) ];
                }
            },

            /**
             * returns [segment, proportion of travel in segment, segment index] for the segment
             * that contains the point which is 'location' distance along the entire path, where
             * 'location' is a decimal between 0 and 1 inclusive. in this connector type, paths
             * are made up of a list of segments, each of which contributes some fraction to
             * the total length.
             * From 1.3.10 this also supports the 'absolute' property, which lets us specify a location
             * as the absolute distance in pixels, rather than a proportion of the total path.
             */
            _findSegmentForLocation = function (location, absolute) {
                if (absolute) {
                    location = location > 0 ? location / totalLength : (totalLength + location) / totalLength;
                }
                var idx = segmentProportions.length - 1, inSegmentProportion = 1;
                for (var i = 0; i < segmentProportions.length; i++) {
                    if (segmentProportions[i][1] >= location) {
                        idx = i;
                        // todo is this correct for all connector path types?
                        inSegmentProportion = location == 1 ? 1 : location === 0 ? 0 : (location - segmentProportions[i][0]) / segmentProportionalLengths[i];
                        break;
                    }
                }
                return { segment: segments[idx], proportion: inSegmentProportion, index: idx };
            },
            _addSegment = function (conn, type, params) {
                if (params.x1 == params.x2 && params.y1 == params.y2) return;
                var s = new _jp.Segments[type](params);
                segments.push(s);
                totalLength += s.getLength();
                conn.updateBounds(s);
            },
            _clearSegments = function () {
                totalLength = segments.length = segmentProportions.length = segmentProportionalLengths.length = 0;
            };

        this.setSegments = function (_segs) {
            userProvidedSegments = [];
            totalLength = 0;
            for (var i = 0; i < _segs.length; i++) {
                userProvidedSegments.push(_segs[i]);
                totalLength += _segs[i].getLength();
            }
        };

        this.getLength = function() {
            return totalLength;
        };

        var _prepareCompute = function (params) {
            this.lineWidth = params.lineWidth;
            var segment = _jg.quadrant(params.sourcePos, params.targetPos),
                swapX = params.targetPos[0] < params.sourcePos[0],
                swapY = params.targetPos[1] < params.sourcePos[1],
                lw = params.lineWidth || 1,
                so = params.sourceEndpoint.anchor.getOrientation(params.sourceEndpoint),
                to = params.targetEndpoint.anchor.getOrientation(params.targetEndpoint),
                x = swapX ? params.targetPos[0] : params.sourcePos[0],
                y = swapY ? params.targetPos[1] : params.sourcePos[1],
                w = Math.abs(params.targetPos[0] - params.sourcePos[0]),
                h = Math.abs(params.targetPos[1] - params.sourcePos[1]);

            // if either anchor does not have an orientation set, we derive one from their relative
            // positions.  we fix the axis to be the one in which the two elements are further apart, and
            // point each anchor at the other element.  this is also used when dragging a new connection.
            if (so[0] === 0 && so[1] === 0 || to[0] === 0 && to[1] === 0) {
                var index = w > h ? 0 : 1, oIndex = [1, 0][index];
                so = [];
                to = [];
                so[index] = params.sourcePos[index] > params.targetPos[index] ? -1 : 1;
                to[index] = params.sourcePos[index] > params.targetPos[index] ? 1 : -1;
                so[oIndex] = 0;
                to[oIndex] = 0;
            }

            var sx = swapX ? w + (sourceGap * so[0]) : sourceGap * so[0],
                sy = swapY ? h + (sourceGap * so[1]) : sourceGap * so[1],
                tx = swapX ? targetGap * to[0] : w + (targetGap * to[0]),
                ty = swapY ? targetGap * to[1] : h + (targetGap * to[1]),
                oProduct = ((so[0] * to[0]) + (so[1] * to[1]));

            var result = {
                sx: sx, sy: sy, tx: tx, ty: ty, lw: lw,
                xSpan: Math.abs(tx - sx),
                ySpan: Math.abs(ty - sy),
                mx: (sx + tx) / 2,
                my: (sy + ty) / 2,
                so: so, to: to, x: x, y: y, w: w, h: h,
                segment: segment,
                startStubX: sx + (so[0] * sourceStub),
                startStubY: sy + (so[1] * sourceStub),
                endStubX: tx + (to[0] * targetStub),
                endStubY: ty + (to[1] * targetStub),
                isXGreaterThanStubTimes2: Math.abs(sx - tx) > (sourceStub + targetStub),
                isYGreaterThanStubTimes2: Math.abs(sy - ty) > (sourceStub + targetStub),
                opposite: oProduct == -1,
                perpendicular: oProduct === 0,
                orthogonal: oProduct == 1,
                sourceAxis: so[0] === 0 ? "y" : "x",
                points: [x, y, w, h, sx, sy, tx, ty ]
            };
            result.anchorOrientation = result.opposite ? "opposite" : result.orthogonal ? "orthogonal" : "perpendicular";
            return result;
        };

        this.getSegments = function () {
            return segments;
        };

        this.updateBounds = function (segment) {
            var segBounds = segment.getBounds();
            this.bounds.minX = Math.min(this.bounds.minX, segBounds.minX);
            this.bounds.maxX = Math.max(this.bounds.maxX, segBounds.maxX);
            this.bounds.minY = Math.min(this.bounds.minY, segBounds.minY);
            this.bounds.maxY = Math.max(this.bounds.maxY, segBounds.maxY);
        };

        var dumpSegmentsToConsole = function () {
            console.log("SEGMENTS:");
            for (var i = 0; i < segments.length; i++) {
                console.log(segments[i].type, segments[i].getLength(), segmentProportions[i]);
            }
        };

        this.pointOnPath = function (location, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            return seg.segment && seg.segment.pointOnPath(seg.proportion, false) || [0, 0];
        };

        this.gradientAtPoint = function (location, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            return seg.segment && seg.segment.gradientAtPoint(seg.proportion, false) || 0;
        };

        this.pointAlongPathFrom = function (location, distance, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            // TODO what happens if this crosses to the next segment?
            return seg.segment && seg.segment.pointAlongPathFrom(seg.proportion, distance, false) || [0, 0];
        };

        this.compute = function (params) {
            paintInfo = _prepareCompute.call(this, params);

            _clearSegments();
            this._compute(paintInfo, params);
            this.x = paintInfo.points[0];
            this.y = paintInfo.points[1];
            this.w = paintInfo.points[2];
            this.h = paintInfo.points[3];
            this.segment = paintInfo.segment;
            _updateSegmentProportions();
        };

        return {
            addSegment: _addSegment,
            prepareCompute: _prepareCompute,
            sourceStub: sourceStub,
            targetStub: targetStub,
            maxStub: Math.max(sourceStub, targetStub),
            sourceGap: sourceGap,
            targetGap: targetGap,
            maxGap: Math.max(sourceGap, targetGap),
            setGeometry:_setGeometry,
            getGeometry:_getGeometry
        };
    };
    _ju.extend(_jp.Connectors.AbstractConnector, AbstractComponent);

    /**
     * Class: Connectors.Straight
     * The Straight connector draws a simple straight line between the two anchor points.  It does not have any constructor parameters.
     */
    var Straight = _jp.Connectors.Straight = function () {
        this.type = "Straight";
        var _super = _jp.Connectors.AbstractConnector.apply(this, arguments);

        this._compute = function (paintInfo, _) {
            _super.addSegment(this, "Straight", {x1: paintInfo.sx, y1: paintInfo.sy, x2: paintInfo.startStubX, y2: paintInfo.startStubY});
            _super.addSegment(this, "Straight", {x1: paintInfo.startStubX, y1: paintInfo.startStubY, x2: paintInfo.endStubX, y2: paintInfo.endStubY});
            _super.addSegment(this, "Straight", {x1: paintInfo.endStubX, y1: paintInfo.endStubY, x2: paintInfo.tx, y2: paintInfo.ty});
        };
    };
    _ju.extend(_jp.Connectors.Straight, _jp.Connectors.AbstractConnector);
    _jp.registerConnectorType(Straight, "Straight");


    // ********************************* END OF CONNECTOR TYPES *******************************************************************

    // ********************************* ENDPOINT TYPES *******************************************************************

    _jp.Endpoints.AbstractEndpoint = function (params) {
        AbstractComponent.apply(this, arguments);
        var compute = this.compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var out = this._compute.apply(this, arguments);
            this.x = out[0];
            this.y = out[1];
            this.w = out[2];
            this.h = out[3];
            this.bounds.minX = this.x;
            this.bounds.minY = this.y;
            this.bounds.maxX = this.x + this.w;
            this.bounds.maxY = this.y + this.h;
            return out;
        };
        return {
            compute: compute,
            cssClass: params.cssClass
        };
    };
    _ju.extend(_jp.Endpoints.AbstractEndpoint, AbstractComponent);

    /**
     * Class: Endpoints.Dot
     * A round endpoint, with default radius 10 pixels.
     */

    /**
     * Function: Constructor
     *
     * Parameters:
     *
     *    radius    -    radius of the endpoint.  defaults to 10 pixels.
     */
    _jp.Endpoints.Dot = function (params) {
        this.type = "Dot";
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {};
        this.radius = params.radius || 10;
        this.defaultOffset = 0.5 * this.radius;
        this.defaultInnerRadius = this.radius / 3;

        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            this.radius = endpointStyle.radius || this.radius;
            var x = anchorPoint[0] - this.radius,
                y = anchorPoint[1] - this.radius,
                w = this.radius * 2,
                h = this.radius * 2;

            if (endpointStyle.strokeStyle) {
                var lw = endpointStyle.lineWidth || 1;
                x -= lw;
                y -= lw;
                w += (lw * 2);
                h += (lw * 2);
            }
            return [ x, y, w, h, this.radius ];
        };
    };
    _ju.extend(_jp.Endpoints.Dot, _jp.Endpoints.AbstractEndpoint);

    _jp.Endpoints.Rectangle = function (params) {
        this.type = "Rectangle";
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {};
        this.width = params.width || 20;
        this.height = params.height || 20;

        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var width = endpointStyle.width || this.width,
                height = endpointStyle.height || this.height,
                x = anchorPoint[0] - (width / 2),
                y = anchorPoint[1] - (height / 2);

            return [ x, y, width, height];
        };
    };
    _ju.extend(_jp.Endpoints.Rectangle, _jp.Endpoints.AbstractEndpoint);

    var DOMElementEndpoint = function (params) {
        _jp.jsPlumbUIComponent.apply(this, arguments);
        this._jsPlumb.displayElements = [];
    };
    _ju.extend(DOMElementEndpoint, _jp.jsPlumbUIComponent, {
        getDisplayElements: function () {
            return this._jsPlumb.displayElements;
        },
        appendDisplayElement: function (el) {
            this._jsPlumb.displayElements.push(el);
        }
    });

    /**
     * Class: Endpoints.Image
     * Draws an image as the Endpoint.
     */
    /**
     * Function: Constructor
     *
     * Parameters:
     *
     *    src    -    location of the image to use.

     TODO: multiple references to self. not sure quite how to get rid of them entirely. perhaps self = null in the cleanup
     function will suffice

     TODO this class still might leak memory.

     */
    _jp.Endpoints.Image = function (params) {

        this.type = "Image";
        DOMElementEndpoint.apply(this, arguments);
        _jp.Endpoints.AbstractEndpoint.apply(this, arguments);

        var _onload = params.onload,
            src = params.src || params.url,
            clazz = params.cssClass ? " " + params.cssClass : "";

        this._jsPlumb.img = new Image();
        this._jsPlumb.ready = false;
        this._jsPlumb.initialized = false;
        this._jsPlumb.deleted = false;
        this._jsPlumb.widthToUse = params.width;
        this._jsPlumb.heightToUse = params.height;
        this._jsPlumb.endpoint = params.endpoint;

        this._jsPlumb.img.onload = function () {
            if (this._jsPlumb != null) {
                this._jsPlumb.ready = true;
                this._jsPlumb.widthToUse = this._jsPlumb.widthToUse || this._jsPlumb.img.width;
                this._jsPlumb.heightToUse = this._jsPlumb.heightToUse || this._jsPlumb.img.height;
                if (_onload) {
                    _onload(this);
                }
            }
        }.bind(this);

        /*
         Function: setImage
         Sets the Image to use in this Endpoint.

         Parameters:
         img         -   may be a URL or an Image object
         onload      -   optional; a callback to execute once the image has loaded.
         */
        this._jsPlumb.endpoint.setImage = function (_img, onload) {
            var s = _img.constructor == String ? _img : _img.src;
            _onload = onload;
            this._jsPlumb.img.src = s;

            if (this.canvas != null)
                this.canvas.setAttribute("src", this._jsPlumb.img.src);
        }.bind(this);

        this._jsPlumb.endpoint.setImage(src, _onload);
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            this.anchorPoint = anchorPoint;
            if (this._jsPlumb.ready) return [anchorPoint[0] - this._jsPlumb.widthToUse / 2, anchorPoint[1] - this._jsPlumb.heightToUse / 2,
                this._jsPlumb.widthToUse, this._jsPlumb.heightToUse];
            else return [0, 0, 0, 0];
        };

        this.canvas = jsPlumb.createElement("img", {
            position:"absolute",
            margin:0,
            padding:0,
            outline:0
        }, this._jsPlumb.instance.endpointClass + clazz);

        if (this._jsPlumb.widthToUse) this.canvas.setAttribute("width", this._jsPlumb.widthToUse);
        if (this._jsPlumb.heightToUse) this.canvas.setAttribute("height", this._jsPlumb.heightToUse);
        this._jsPlumb.instance.appendElement(this.canvas);

        this.actuallyPaint = function (d, style, anchor) {
            if (!this._jsPlumb.deleted) {
                if (!this._jsPlumb.initialized) {
                    this.canvas.setAttribute("src", this._jsPlumb.img.src);
                    this.appendDisplayElement(this.canvas);
                    this._jsPlumb.initialized = true;
                }
                var x = this.anchorPoint[0] - (this._jsPlumb.widthToUse / 2),
                    y = this.anchorPoint[1] - (this._jsPlumb.heightToUse / 2);
                _ju.sizeElement(this.canvas, x, y, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse);
            }
        };

        this.paint = function (style, anchor) {
            if (this._jsPlumb != null) {  // may have been deleted
                if (this._jsPlumb.ready) {
                    this.actuallyPaint(style, anchor);
                }
                else {
                    root.setTimeout(function () {
                        this.paint(style, anchor);
                    }.bind(this), 200);
                }
            }
        };
    };
    _ju.extend(_jp.Endpoints.Image, [ DOMElementEndpoint, _jp.Endpoints.AbstractEndpoint ], {
        cleanup: function (force) {
            if (force) {
                this._jsPlumb.deleted = true;
                if (this.canvas) this.canvas.parentNode.removeChild(this.canvas);
                this.canvas = null;
            }
        }
    });

    /*
     * Class: Endpoints.Blank
     * An Endpoint that paints nothing (visible) on the screen.  Supports cssClass and hoverClass parameters like all Endpoints.
     */
    _jp.Endpoints.Blank = function (params) {
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        this.type = "Blank";
        DOMElementEndpoint.apply(this, arguments);
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            return [anchorPoint[0], anchorPoint[1], 10, 0];
        };

        var clazz = params.cssClass ? " " + params.cssClass : "";

        this.canvas = jsPlumb.createElement("div", {
            display: "block",
            width: "1px",
            height: "1px",
            background: "transparent",
            position: "absolute"
        }, this._jsPlumb.instance.endpointClass + clazz);

        this._jsPlumb.instance.appendElement(this.canvas);

        this.paint = function (style, anchor) {
            _ju.sizeElement(this.canvas, this.x, this.y, this.w, this.h);
        };
    };
    _ju.extend(_jp.Endpoints.Blank, [_jp.Endpoints.AbstractEndpoint, DOMElementEndpoint], {
        cleanup: function () {
            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
        }
    });

    /*
     * Class: Endpoints.Triangle
     * A triangular Endpoint.
     */
    /*
     * Function: Constructor
     *
     * Parameters:
     *
     * 	width	-	width of the triangle's base.  defaults to 55 pixels.
     * 	height	-	height of the triangle from base to apex.  defaults to 55 pixels.
     */
    _jp.Endpoints.Triangle = function (params) {
        this.type = "Triangle";
        _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {  };
        params.width = params.width || 55;
        params.height = params.height || 55;
        this.width = params.width;
        this.height = params.height;
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var width = endpointStyle.width || self.width,
                height = endpointStyle.height || self.height,
                x = anchorPoint[0] - (width / 2),
                y = anchorPoint[1] - (height / 2);
            return [ x, y, width, height ];
        };
    };
// ********************************* END OF ENDPOINT TYPES *******************************************************************


// ********************************* OVERLAY DEFINITIONS ***********************************************************************    

    var AbstractOverlay = _jp.Overlays.AbstractOverlay = function (params) {
        this.visible = true;
        this.isAppendedAtTopLevel = true;
        this.component = params.component;
        this.loc = params.location == null ? 0.5 : params.location;
        this.endpointLoc = params.endpointLocation == null ? [ 0.5, 0.5] : params.endpointLocation;
        this.visible = params.visible !== false;
    };
    AbstractOverlay.prototype = {
        cleanup: function (force) {
            if (force) {
                this.component = null;
                this.canvas = null;
                this.endpointLoc = null;
            }
        },
        reattach:function(instance) {

        },
        setVisible: function (val) {
            this.visible = val;
            this.component.repaint();
        },
        isVisible: function () {
            return this.visible;
        },
        hide: function () {
            this.setVisible(false);
        },
        show: function () {
            this.setVisible(true);
        },
        incrementLocation: function (amount) {
            this.loc += amount;
            this.component.repaint();
        },
        setLocation: function (l) {
            this.loc = l;
            this.component.repaint();
        },
        getLocation: function () {
            return this.loc;
        },
        updateFrom:function() { }
    };


    /*
     * Class: Overlays.Arrow
     *
     * An arrow overlay, defined by four points: the head, the two sides of the tail, and a 'foldback' point at some distance along the length
     * of the arrow that lines from each tail point converge into.  The foldback point is defined using a decimal that indicates some fraction
     * of the length of the arrow and has a default value of 0.623.  A foldback point value of 1 would mean that the arrow had a straight line
     * across the tail.
     */
    /*
     * Function: Constructor
     *
     * Parameters:
     *
     * 	length - distance in pixels from head to tail baseline. default 20.
     * 	width - width in pixels of the tail baseline. default 20.
     * 	fillStyle - style to use when filling the arrow.  defaults to "black".
     * 	strokeStyle - style to use when stroking the arrow. defaults to null, which means the arrow is not stroked.
     * 	lineWidth - line width to use when stroking the arrow. defaults to 1, but only used if strokeStyle is not null.
     * 	foldback - distance (as a decimal from 0 to 1 inclusive) along the length of the arrow marking the point the tail points should fold back to.  defaults to 0.623.
     * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the arrow should sit on the connector. defaults to 0.5.
     * 	direction - indicates the direction the arrow points in. valid values are -1 and 1; 1 is default.
     */
    _jp.Overlays.Arrow = function (params) {
        this.type = "Arrow";
        AbstractOverlay.apply(this, arguments);
        this.isAppendedAtTopLevel = false;
        params = params || {};

        this.length = params.length || 20;
        this.width = params.width || 20;
        this.id = params.id;
        var direction = (params.direction || 1) < 0 ? -1 : 1,
            paintStyle = params.paintStyle || { lineWidth: 1 },
        // how far along the arrow the lines folding back in come to. default is 62.3%.
            foldback = params.foldback || 0.623;

        this.computeMaxSize = function () {
            return self.width * 1.5;
        };

        this.elementCreated = function(p, component) {
            this.path = p;
            if (params.events) {
                for (var i in params.events) {
                    jsPlumb.on(p, i, params.events[i]);
                }
            }
        };

        this.draw = function (component, currentConnectionPaintStyle) {

            var hxy, mid, txy, tail, cxy;
            if (component.pointAlongPathFrom) {

                if (_ju.isString(this.loc) || this.loc > 1 || this.loc < 0) {
                    var l = parseInt(this.loc, 10),
                        fromLoc = this.loc < 0 ? 1 : 0;
                    hxy = component.pointAlongPathFrom(fromLoc, l, false);
                    mid = component.pointAlongPathFrom(fromLoc, l - (direction * this.length / 2), false);
                    txy = _jg.pointOnLine(hxy, mid, this.length);
                }
                else if (this.loc == 1) {
                    hxy = component.pointOnPath(this.loc);
                    mid = component.pointAlongPathFrom(this.loc, -(this.length));
                    txy = _jg.pointOnLine(hxy, mid, this.length);

                    if (direction == -1) {
                        var _ = txy;
                        txy = hxy;
                        hxy = _;
                    }
                }
                else if (this.loc === 0) {
                    txy = component.pointOnPath(this.loc);
                    mid = component.pointAlongPathFrom(this.loc, this.length);
                    hxy = _jg.pointOnLine(txy, mid, this.length);
                    if (direction == -1) {
                        var __ = txy;
                        txy = hxy;
                        hxy = __;
                    }
                }
                else {
                    hxy = component.pointAlongPathFrom(this.loc, direction * this.length / 2);
                    mid = component.pointOnPath(this.loc);
                    txy = _jg.pointOnLine(hxy, mid, this.length);
                }

                tail = _jg.perpendicularLineTo(hxy, txy, this.width);
                cxy = _jg.pointOnLine(hxy, txy, foldback * this.length);

                var d = { hxy: hxy, tail: tail, cxy: cxy },
                    strokeStyle = paintStyle.strokeStyle || currentConnectionPaintStyle.strokeStyle,
                    fillStyle = paintStyle.fillStyle || currentConnectionPaintStyle.strokeStyle,
                    lineWidth = paintStyle.lineWidth || currentConnectionPaintStyle.lineWidth;

                return {
                    component: component,
                    d: d,
                    lineWidth: lineWidth,
                    strokeStyle: strokeStyle,
                    fillStyle: fillStyle,
                    minX: Math.min(hxy.x, tail[0].x, tail[1].x),
                    maxX: Math.max(hxy.x, tail[0].x, tail[1].x),
                    minY: Math.min(hxy.y, tail[0].y, tail[1].y),
                    maxY: Math.max(hxy.y, tail[0].y, tail[1].y)
                };
            }
            else return {component: component, minX: 0, maxX: 0, minY: 0, maxY: 0};
        };
    };
    _ju.extend(_jp.Overlays.Arrow, AbstractOverlay, {
        updateFrom:function(d) {
            this.length = d.length || this.length;
            this.width = d.width|| this.width;
            this.direction = d.direction != null ? d.direction : this.direction;
            this.foldback = d.foldback|| this.foldback;
        }
    });

    /*
     * Class: Overlays.PlainArrow
     *
     * A basic arrow.  This is in fact just one instance of the more generic case in which the tail folds back on itself to some
     * point along the length of the arrow: in this case, that foldback point is the full length of the arrow.  so it just does
     * a 'call' to Arrow with foldback set appropriately.
     */
    /*
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    _jp.Overlays.PlainArrow = function (params) {
        params = params || {};
        var p = _jp.extend(params, {foldback: 1});
        _jp.Overlays.Arrow.call(this, p);
        this.type = "PlainArrow";
    };
    _ju.extend(_jp.Overlays.PlainArrow, _jp.Overlays.Arrow);

    /*
     * Class: Overlays.Diamond
     * 
     * A diamond. Like PlainArrow, this is a concrete case of the more generic case of the tail points converging on some point...it just
     * happens that in this case, that point is greater than the length of the the arrow.
     *
     *      this could probably do with some help with positioning...due to the way it reuses the Arrow paint code, what Arrow thinks is the
     *      center is actually 1/4 of the way along for this guy.  but we don't have any knowledge of pixels at this point, so we're kind of
     *      stuck when it comes to helping out the Arrow class. possibly we could pass in a 'transpose' parameter or something. the value
     *      would be -l/4 in this case - move along one quarter of the total length.
     */
    /*
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    _jp.Overlays.Diamond = function (params) {
        params = params || {};
        var l = params.length || 40,
            p = jsPlumb.extend(params, {length: l / 2, foldback: 2});
        _jp.Overlays.Arrow.call(this, p);
        this.type = "Diamond";
    };
    _ju.extend(_jp.Overlays.Diamond, _jp.Overlays.Arrow);

    var _getDimensions = function (component, forceRefresh) {
        if (component._jsPlumb.cachedDimensions == null || forceRefresh)
            component._jsPlumb.cachedDimensions = component.getDimensions();
        return component._jsPlumb.cachedDimensions;
    };

    // abstract superclass for overlays that add an element to the DOM.
    var AbstractDOMOverlay = function (params) {
        _jp.jsPlumbUIComponent.apply(this, arguments);
        AbstractOverlay.apply(this, arguments);

        // hand off fired events to associated component.
        var _f = this.fire;
        this.fire = function () {
            _f.apply(this, arguments);
            if (this.component) this.component.fire.apply(this.component, arguments);
        };

        this.detached=false;
        this.id = params.id;
        this._jsPlumb.div = null;
        this._jsPlumb.initialised = false;
        this._jsPlumb.component = params.component;
        this._jsPlumb.cachedDimensions = null;
        this._jsPlumb.create = params.create;
        this._jsPlumb.initiallyInvisible = params.visible === false;

        this.getElement = function () {
            if (this._jsPlumb.div == null) {
                var div = this._jsPlumb.div = jsPlumb.getElement(this._jsPlumb.create(this._jsPlumb.component));
                div.style.position = "absolute";
                div.className = this._jsPlumb.instance.overlayClass + " " +
                    (this.cssClass ? this.cssClass :
                        params.cssClass ? params.cssClass : "");
                this._jsPlumb.instance.appendElement(div);
                this._jsPlumb.instance.getId(div);
                this.canvas = div;

                // in IE the top left corner is what it placed at the desired location.  This will not
                // be fixed. IE8 is not going to be supported for much longer.
                var ts = "translate(-50%, -50%)";
                div.style.webkitTransform = ts;
                div.style.mozTransform = ts;
                div.style.msTransform = ts;
                div.style.oTransform = ts;
                div.style.transform = ts;

                // write the related component into the created element
                div._jsPlumb = this;

                if (params.visible === false)
                    div.style.display = "none";
            }
            return this._jsPlumb.div;
        };

        this.draw = function (component, currentConnectionPaintStyle, absolutePosition) {
            var td = _getDimensions(this);
            if (td != null && td.length == 2) {
                var cxy = { x: 0, y: 0 };

                // absolutePosition would have been set by a call to connection.setAbsoluteOverlayPosition.
                if (absolutePosition) {
                    cxy = { x: absolutePosition[0], y: absolutePosition[1] };
                }
                else if (component.pointOnPath) {
                    var loc = this.loc, absolute = false;
                    if (_ju.isString(this.loc) || this.loc < 0 || this.loc > 1) {
                        loc = parseInt(this.loc, 10);
                        absolute = true;
                    }
                    cxy = component.pointOnPath(loc, absolute);  // a connection
                }
                else {
                    var locToUse = this.loc.constructor == Array ? this.loc : this.endpointLoc;
                    cxy = { x: locToUse[0] * component.w,
                        y: locToUse[1] * component.h };
                }

                var minx = cxy.x - (td[0] / 2),
                    miny = cxy.y - (td[1] / 2);

                return {
                    component: component,
                    d: { minx: minx, miny: miny, td: td, cxy: cxy },
                    minX: minx,
                    maxX: minx + td[0],
                    minY: miny,
                    maxY: miny + td[1]
                };
            }
            else return {minX: 0, maxX: 0, minY: 0, maxY: 0};
        };
    };
    _ju.extend(AbstractDOMOverlay, [_jp.jsPlumbUIComponent, AbstractOverlay], {
        getDimensions: function () {
            return [1,1];
        },
        setVisible: function (state) {
            if (this._jsPlumb.div) {
                this._jsPlumb.div.style.display = state ? "block" : "none";
                // if initially invisible, dimensions are 0,0 and never get updated
                if (state && this._jsPlumb.initiallyInvisible) {
                    _getDimensions(this, true);
                    this.component.repaint();
                    this._jsPlumb.initiallyInvisible = false;
                }
            }
        },
        /*
         * Function: clearCachedDimensions
         * Clears the cached dimensions for the label. As a performance enhancement, label dimensions are
         * cached from 1.3.12 onwards. The cache is cleared when you change the label text, of course, but
         * there are other reasons why the text dimensions might change - if you make a change through CSS, for
         * example, you might change the font size.  in that case you should explicitly call this method.
         */
        clearCachedDimensions: function () {
            this._jsPlumb.cachedDimensions = null;
        },
        cleanup: function (force) {
            if (force) {
                if (this._jsPlumb.div != null) {
                    this._jsPlumb.div._jsPlumb = null;
                    this._jsPlumb.instance.removeElement(this._jsPlumb.div);
                }
            }
            else {
                // if not a forced cleanup, just detach child from parent for now.
                if (this._jsPlumb && this._jsPlumb.div && this._jsPlumb.div.parentNode)
                    this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);
                this.detached = true;
            }

        },
        reattach:function(instance) {
            if (this._jsPlumb.div != null) instance.getContainer().appendChild(this._jsPlumb.div);
            this.detached = false;
        },
        computeMaxSize: function () {
            var td = _getDimensions(this);
            return Math.max(td[0], td[1]);
        },
        paint: function (p, containerExtents) {
            if (!this._jsPlumb.initialised) {
                this.getElement();
                p.component.appendDisplayElement(this._jsPlumb.div);
                this._jsPlumb.initialised = true;
                if (this.detached) this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);
            }
            this._jsPlumb.div.style.left = (p.component.x + p.d.minx) + "px";
            this._jsPlumb.div.style.top = (p.component.y + p.d.miny) + "px";
        }
    });

    /*
     * Class: Overlays.Custom
     * A Custom overlay. You supply a 'create' function which returns some DOM element, and jsPlumb positions it.
     * The 'create' function is passed a Connection or Endpoint.
     */
    /*
     * Function: Constructor
     * 
     * Parameters:
     * 	create - function for jsPlumb to call that returns a DOM element.
     * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.
     * 	id - optional id to use for later retrieval of this overlay.
     * 	
     */
    _jp.Overlays.Custom = function (params) {
        this.type = "Custom";
        AbstractDOMOverlay.apply(this, arguments);
    };
    _ju.extend(_jp.Overlays.Custom, AbstractDOMOverlay);

    _jp.Overlays.GuideLines = function () {
        var self = this;
        self.length = 50;
        self.lineWidth = 5;
        this.type = "GuideLines";
        AbstractOverlay.apply(this, arguments);
        _jp.jsPlumbUIComponent.apply(this, arguments);
        this.draw = function (connector, currentConnectionPaintStyle) {

            var head = connector.pointAlongPathFrom(self.loc, self.length / 2),
                mid = connector.pointOnPath(self.loc),
                tail = _jg.pointOnLine(head, mid, self.length),
                tailLine = _jg.perpendicularLineTo(head, tail, 40),
                headLine = _jg.perpendicularLineTo(tail, head, 20);

            return {
                connector: connector,
                head: head,
                tail: tail,
                headLine: headLine,
                tailLine: tailLine,
                minX: Math.min(head.x, tail.x, headLine[0].x, headLine[1].x),
                minY: Math.min(head.y, tail.y, headLine[0].y, headLine[1].y),
                maxX: Math.max(head.x, tail.x, headLine[0].x, headLine[1].x),
                maxY: Math.max(head.y, tail.y, headLine[0].y, headLine[1].y)
            };
        };

        // this.cleanup = function() { };  // nothing to clean up for GuideLines
    };

    /*
     * Class: Overlays.Label

     */
    /*
     * Function: Constructor
     * 
     * Parameters:
     * 	cssClass - optional css class string to append to css class. This string is appended "as-is", so you can of course have multiple classes
     *             defined.  This parameter is preferred to using labelStyle, borderWidth and borderStyle.
     * 	label - the label to paint.  May be a string or a function that returns a string.  Nothing will be painted if your label is null or your
     *         label function returns null.  empty strings _will_ be painted.
     * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.
     * 	id - optional id to use for later retrieval of this overlay.
     * 
     * 	
     */
    _jp.Overlays.Label = function (params) {
        this.labelStyle = params.labelStyle;

        var labelWidth = null, labelHeight = null, labelText = null, labelPadding = null;
        this.cssClass = this.labelStyle != null ? this.labelStyle.cssClass : null;
        var p = _jp.extend({
            create: function () {
                return jsPlumb.createElement("div");
            }}, params);
        _jp.Overlays.Custom.call(this, p);
        this.type = "Label";
        this.label = params.label || "";
        this.labelText = null;
        if (this.labelStyle) {
            var el = this.getElement();
            this.labelStyle.font = this.labelStyle.font || "12px sans-serif";
            el.style.font = this.labelStyle.font;
            el.style.color = this.labelStyle.color || "black";
            if (this.labelStyle.fillStyle) el.style.background = this.labelStyle.fillStyle;
            if (this.labelStyle.borderWidth > 0) {
                var dStyle = this.labelStyle.borderStyle ? this.labelStyle.borderStyle : "black";
                el.style.border = this.labelStyle.borderWidth + "px solid " + dStyle;
            }
            if (this.labelStyle.padding) el.style.padding = this.labelStyle.padding;
        }

    };
    _ju.extend(_jp.Overlays.Label, _jp.Overlays.Custom, {
        cleanup: function (force) {
            if (force) {
                this.div = null;
                this.label = null;
                this.labelText = null;
                this.cssClass = null;
                this.labelStyle = null;
            }
        },
        getLabel: function () {
            return this.label;
        },
        /*
         * Function: setLabel
         * sets the label's, um, label.  you would think i'd call this function
         * 'setText', but you can pass either a Function or a String to this, so
         * it makes more sense as 'setLabel'. This uses innerHTML on the label div, so keep
         * that in mind if you need escaped HTML.
         */
        setLabel: function (l) {
            this.label = l;
            this.labelText = null;
            this.clearCachedDimensions();
            this.update();
            this.component.repaint();
        },
        getDimensions: function () {
            this.update();
            return AbstractDOMOverlay.prototype.getDimensions.apply(this, arguments);
        },
        update: function () {
            if (typeof this.label == "function") {
                var lt = this.label(this);
                this.getElement().innerHTML = lt.replace(/\r\n/g, "<br/>");
            }
            else {
                if (this.labelText == null) {
                    this.labelText = this.label;
                    this.getElement().innerHTML = this.labelText.replace(/\r\n/g, "<br/>");
                }
            }
        },
        updateFrom:function(d) {
            if(d.label) this.setLabel(d.label);
        }
    });

    // ********************************* END OF OVERLAY DEFINITIONS ***********************************************************************

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.1.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the base class for library adapters.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {
    "use strict";
    var root = this,
        _jp = root.jsPlumb;

    var _getEventManager = function(instance) {
        var e = instance._mottle;
        if (!e) {
            e = instance._mottle = new root.Mottle();
        }
        return e;
    };

    _jp.extend(root.jsPlumbInstance.prototype, {
        getEventManager:function() {
            return _getEventManager(this);
        },
        on : function(el, event, callback) {
            // TODO: here we would like to map the tap event if we know its
            // an internal bind to a click. we have to know its internal because only
            // then can we be sure that the UP event wont be consumed (tap is a synthesized
            // event from a mousedown followed by a mouseup).
            //event = { "click":"tap", "dblclick":"dbltap"}[event] || event;
            this.getEventManager().on.apply(this, arguments);
            return this;
        },
        off : function(el, event, callback) {
            this.getEventManager().off.apply(this, arguments);
            return this;
        }
    });


}).call(typeof window !== 'undefined' ? window : this);
;(function() {
    "use strict";

    var root = this,
        _ju = root.jsPlumbUtil,
        _jpi = root.jsPlumbInstance;

    var GROUP_COLLAPSED_CLASS = "jsplumb-group-collapsed";
    var GROUP_EXPANDED_CLASS = "jsplumb-group-expanded";
    var GROUP_CONTAINER_SELECTOR = "[jsplumb-group-content]";
    var ELEMENT_DRAGGABLE_EVENT = "elementDraggable";
    var STOP = "stop";
    var REVERT = "revert";
    var GROUP_MANAGER = "_groupManager";
    var GROUP = "_jsPlumbGroup";
    var GROUP_DRAG_SCOPE = "_jsPlumbGroupDrag";
    var EVT_CHILD_ADDED = "group:addMember";
    var EVT_CHILD_REMOVED = "group:removeMember";
    var EVT_GROUP_ADDED = "group:add";
    var EVT_GROUP_REMOVED = "group:remove";
    var EVT_EXPAND = "group:expand";
    var EVT_COLLAPSE = "group:collapse";

    var GroupManager = function(_jsPlumb) {
        var _managedGroups = {}, _connectionSourceMap = {}, _connectionTargetMap = {}, self = this;

        _jsPlumb.bind("connection", function(p) {
            if (p.source[GROUP] != null && p.target[GROUP] != null && p.source[GROUP] === p.target[GROUP]) {
                _connectionSourceMap[p.connection.id] = p.source[GROUP];
                _connectionTargetMap[p.connection.id] = p.source[GROUP];
            }
            else {
                if (p.source[GROUP] != null) {
                    _ju.suggest(p.source[GROUP].connections.source, p.connection);
                    _connectionSourceMap[p.connection.id] = p.source[GROUP];
                }
                if (p.target[GROUP] != null) {
                    _ju.suggest(p.target[GROUP].connections.target, p.connection);
                    _connectionTargetMap[p.connection.id] = p.target[GROUP];
                }
            }
        });

        function _cleanupDetachedConnection(conn) {
            delete conn.proxies;
            var group = _connectionSourceMap[conn.id], f;
            if (group != null) {
                f = function(c) { return c.id === conn.id; };
                _ju.removeWithFunction(group.connections.source, f);
                _ju.removeWithFunction(group.connections.target, f);
                delete _connectionSourceMap[conn.id];
            }

            group = _connectionTargetMap[conn.id];
            if (group != null) {
                f = function(c) { return c.id === conn.id; };
                _ju.removeWithFunction(group.connections.source, f);
                _ju.removeWithFunction(group.connections.target, f);
                delete _connectionTargetMap[conn.id];
            }
        }

        _jsPlumb.bind("connectionDetached", function(p) {
            _cleanupDetachedConnection(p.connection);
        });

        _jsPlumb.bind("connectionMoved", function(p) {
            var connMap = p.index === 0 ? _connectionSourceMap : _connectionTargetMap;
            var group = connMap[p.connection.id];
            if (group) {
                var list = group.connections[p.index === 0 ? "source" : "target"];
                var idx = list.indexOf(p.connection);
                if (idx != -1) {
                    list.splice(idx, 1);
                }
            }
        });

        this.addGroup = function(group) {
            _jsPlumb.addClass(group.el, GROUP_EXPANDED_CLASS);
            _managedGroups[group.id] = group;
            group.manager = this;
            _updateConnectionsForGroup(group);
            _jsPlumb.fire(EVT_GROUP_ADDED, { group:group });
        };

        this.addToGroup = function(group, el, doNotFireEvent) {
            group = this.getGroup(group);
            if (group) {
                group.add(el, doNotFireEvent);
            }
        };

        this.removeFromGroup = function(group, el, doNotFireEvent) {
            group = this.getGroup(group);
            if (group) {
                group.remove(el, null, doNotFireEvent);
            }
        };

        this.getGroup = function(groupId) {
            var group = groupId;
            if (_ju.isString(groupId)) {
                group = _managedGroups[groupId];
                if (group == null) throw new TypeError("No such group [" + groupId + "]");
            }
            return group;
        };

        this.removeGroup = function(group, deleteMembers) {
            group = this.getGroup(group);
            this.expandGroup(group, true); // this reinstates any original connections and removes all proxies, but does not fire an event.
            group[deleteMembers ? "removeAll" : "orphanAll"]();
            _jsPlumb.remove(group.getEl());
            delete _managedGroups[group.id];
            delete _jsPlumb._groups[group.id];
            _jsPlumb.fire(EVT_GROUP_REMOVED, { group:group });
        };

        this.removeAllGroups = function(deleteMembers) {
            for (var g in _managedGroups) {
                this.removeGroup(_managedGroups[g], deleteMembers);
            }
        };

        function _setVisible(group, state) {
            var m = group.getMembers();
            for (var i = 0; i < m.length; i++) {
                _jsPlumb[state ? "show" : "hide"](m[i], true);
            }
        }

        var _collapseConnection = this.collapseConnection = function(c, index, group) {

            var proxyEp, groupEl = group.getEl(), groupElId = _jsPlumb.getId(groupEl),
                originalElementId = c.endpoints[index].elementId;

            c.proxies = c.proxies || [];
            if(c.proxies[index]) {
                proxyEp = c.proxies[index].ep;
            }else {
                proxyEp = _jsPlumb.addEndpoint(groupEl, {
                    endpoint:group.getEndpoint(c, index),
                    anchor:group.getAnchor(c, index),
                    parameters:{
                        isProxyEndpoint:true
                    }
                });
                proxyEp._forceDeleteOnDetach = true;
            }
            // for this index, stash proxy info: the new EP, the original EP.
            c.proxies[index] = { ep:proxyEp, originalEp: c.endpoints[index] };

            // and advise the anchor manager
            if (index === 0) {
                // TODO why are there two differently named methods? Why is there not one method that says "some end of this
                // connection changed (you give the index), and here's the new element and element id."
                _jsPlumb.anchorManager.sourceChanged(originalElementId, groupElId, c, groupEl);
            }
            else {
                _jsPlumb.anchorManager.updateOtherEndpoint(c.endpoints[0].elementId, originalElementId, groupElId, c);
                c.target = groupEl;
                c.targetId = groupElId;
            }


            // detach the original EP from the connection.
            c.proxies[index].originalEp.detachFromConnection(c, null, true);

            // set the proxy as the new ep
            proxyEp.connections = [ c ];
            c.endpoints[index] = proxyEp;

            c.setVisible(true);
        };

        this.collapseGroup = function(group) {
            group = this.getGroup(group);
            if (group == null || group.collapsed) return;
            var groupEl = group.getEl();

            // todo remove old proxy endpoints first, just in case?
            //group.proxies.length = 0;

            // hide all connections
            _setVisible(group, false);

            if (group.shouldProxy()) {
                // collapses all connections in a group.
                var _collapseSet = function (conns, index) {
                    for (var i = 0; i < conns.length; i++) {
                        var c = conns[i];
                        _collapseConnection(c, index, group);
                    }
                };

                // setup proxies for sources and targets
                _collapseSet(group.connections.source, 0);
                _collapseSet(group.connections.target, 1);
            }

            group.collapsed = true;
            _jsPlumb.removeClass(groupEl, GROUP_EXPANDED_CLASS);
            _jsPlumb.addClass(groupEl, GROUP_COLLAPSED_CLASS);
            _jsPlumb.revalidate(groupEl);
            _jsPlumb.fire(EVT_COLLAPSE, { group:group  });
        };

        var _expandConnection = this.expandConnection = function(c, index, group) {

            // if no proxies or none for this end of the connection, abort.
            if (c.proxies == null || c.proxies[index] == null) return;

            var groupElId = _jsPlumb.getId(group.getEl()),
                originalElement = c.proxies[index].originalEp.element,
                originalElementId = c.proxies[index].originalEp.elementId;

            c.endpoints[index] = c.proxies[index].originalEp;
            // and advise the anchor manager
            if (index === 0) {
                // TODO why are there two differently named methods? Why is there not one method that says "some end of this
                // connection changed (you give the index), and here's the new element and element id."
                _jsPlumb.anchorManager.sourceChanged(groupElId, originalElementId, c, originalElement);
            }
            else {
                _jsPlumb.anchorManager.updateOtherEndpoint(c.endpoints[0].elementId, groupElId, originalElementId, c);
                c.target = originalElement;
                c.targetId = originalElementId;
            }

            // detach the proxy EP from the connection.
            c.proxies[index].ep.detachFromConnection(c, null, true);


            c.proxies[index].originalEp.addConnection(c);

            // cleanup
            delete c.proxies[index];
        };

        this.expandGroup = function(group, doNotFireEvent) {

            group = this.getGroup(group);

            if (group == null || !group.collapsed) return;
            var groupEl = group.getEl();

            _setVisible(group, true);

            if (group.shouldProxy()) {
                // collapses all connections in a group.
                var _expandSet = function (conns, index) {
                    for (var i = 0; i < conns.length; i++) {
                        var c = conns[i];
                        _expandConnection(c, index, group);
                    }
                };

                // setup proxies for sources and targets
                _expandSet(group.connections.source, 0);
                _expandSet(group.connections.target, 1);
            }

            group.collapsed = false;
            _jsPlumb.addClass(groupEl, GROUP_EXPANDED_CLASS);
            _jsPlumb.removeClass(groupEl, GROUP_COLLAPSED_CLASS);
            _jsPlumb.revalidate(groupEl);
            this.repaintGroup(group);
            if (!doNotFireEvent) {
                _jsPlumb.fire(EVT_EXPAND, { group: group});
            }
        };

        this.repaintGroup = function(group) {
            group = this.getGroup(group);
            var m = group.getMembers();
            for (var i = 0; i < m.length; i++) {
                _jsPlumb.revalidate(m[i]);
            }
        };

        // TODO refactor this with the code that responds to `connection` events.
        function _updateConnectionsForGroup(group) {
            var members = group.getMembers();
            var c1 = _jsPlumb.getConnections({source:members}, true);
            var c2 = _jsPlumb.getConnections({target:members}, true);
            var processed = {};
            group.connections.source.length = 0;
            group.connections.target.length = 0;
            var oneSet = function(c) {
                for (var i = 0; i < c.length; i++) {
                    if (processed[c[i].id]) continue;
                    processed[c[i].id] = true;
                    if (c[i].source._jsPlumbGroup === group) {
                        if (c[i].target._jsPlumbGroup !== group) {
                            group.connections.source.push(c[i]);
                        }
                        _connectionSourceMap[c[i].id] = group;
                    }
                    else if (c[i].target._jsPlumbGroup === group) {
                        group.connections.target.push(c[i]);
                        _connectionTargetMap[c[i].id] = group;
                    }
                }
            };
            oneSet(c1); oneSet(c2);
        }

        this.updateConnectionsForGroup = _updateConnectionsForGroup;
        this.refreshAllGroups = function() {
            for (var g in _managedGroups) {
                _updateConnectionsForGroup(_managedGroups[g]);
                _jsPlumb.dragManager.updateOffsets(_jsPlumb.getId(_managedGroups[g].el));
            }
        };
    };

    /**
     *
     * @param {jsPlumbInstance} _jsPlumb Associated jsPlumb instance.
     * @param {Object} params
     * @param {Element} params.el The DOM element representing the Group.
     * @param {String} [params.id] Optional ID for the Group. A UUID will be assigned as the Group's ID if you do not provide one.
     * @param {Boolean} [params.constrain=false] If true, child elements will not be able to be dragged outside of the Group container.
     * @param {Boolean} [params.revert=true] By default, child elements revert to the container if dragged outside. You can change this by setting `revert:false`. This behaviour is also overridden if you set `orphan` or `prune`.
     * @param {Boolean} [params.orphan=false] If true, child elements dropped outside of the Group container will be removed from the Group (but not from the DOM).
     * @param {Boolean} [params.prune=false] If true, child elements dropped outside of the Group container will be removed from the Group and also from the DOM.
     * @param {Boolean} [params.dropOverride=false] If true, a child element that has been dropped onto some other Group will not be subject to the controls imposed by `prune`, `revert` or `orphan`.
     * @constructor
     */
    var Group = function(_jsPlumb, params) {
        var self = this;
        var el = params.el;
        this.getEl = function() { return el; };
        this.id = params.id || _ju.uuid();
        el._isJsPlumbGroup = true;
        var da = _jsPlumb.getSelector(el, GROUP_CONTAINER_SELECTOR);
        var dragArea = da && da.length > 0 ? da[0] : el;
        var ghost = params.ghost === true;
        var constrain = ghost || (params.constrain === true);
        var revert = params.revert !== false;
        var orphan = params.orphan === true;
        var prune = params.prune === true;
        var dropOverride = params.dropOverride === true;
        var proxied = params.proxied !== false;
        var elements = [];
        this.connections = { source:[], target:[], internal:[] };

        // this function, and getEndpoint below, are stubs for a future setup in which we can choose endpoint
        // and anchor based upon the connection and the index (source/target) of the endpoint to be proxied.
        this.getAnchor = function(conn, endpointIndex) {
            return params.anchor || "Continuous";
        };

        this.getEndpoint = function(conn, endpointIndex) {
            return params.endpoint || [ "Dot", { radius:10 }];
        };

        this.collapsed = false;
        if (params.draggable !== false) {
            var opts = {
                stop:function(params) {
                    _jsPlumb.fire("groupDragStop", jsPlumb.extend(params, {group:self}));
                },
                scope:GROUP_DRAG_SCOPE
            };
            if (params.dragOptions) {
                root.jsPlumb.extend(opts, params.dragOptions);
            }
            _jsPlumb.draggable(params.el, opts);
        }
        if (params.droppable !== false) {
            _jsPlumb.droppable(params.el, {
                drop:function(p) {
                    var groupManager = _jsPlumb.getGroupManager();
                    var _el = p.drag.el;
                    if (_el._isJsPlumbGroup) return;
                    var currentGroup = _el._jsPlumbGroup;
                    // if already a member of this group, do nothing
                    if (currentGroup !== self) {
                        var elpos = _jsPlumb.getOffset(_el, true);
                        var cpos = self.collapsed ? _jsPlumb.getOffset(el, true) : _jsPlumb.getOffset(dragArea, true);

                        // otherwise, transfer to this group.
                        if (currentGroup != null) {
                            if (currentGroup.overrideDrop(_el, self)) {
                                return;
                            }
                            currentGroup.remove(_el, true);
                            groupManager.updateConnectionsForGroup(currentGroup);
                        }
                        self.add(_el, true);

                        var handleDroppedConnections = function(list, index) {
                            var oidx = index == 0 ? 1 : 0;
                            list.each(function(c) {
                                c.setVisible(false);
                                if (c.endpoints[oidx].element._jsPlumbGroup === self) {
                                    c.endpoints[oidx].setVisible(false);
                                    groupManager.expandConnection(c, oidx, self);
                                }
                                else {
                                    c.endpoints[index].setVisible(false);
                                    groupManager.collapseConnection(c, index, self);
                                }
                            });
                        };

                        if (self.collapsed) {
                            handleDroppedConnections(_jsPlumb.select({source: _el}), 0);
                            handleDroppedConnections(_jsPlumb.select({target: _el}), 1);
                        }

                        var elId = _jsPlumb.getId(_el);
                        _jsPlumb.dragManager.setParent(_el, elId, el, _jsPlumb.getId(el), elpos);
                        _jsPlumb.setPosition(_el, {left:elpos.left - cpos.left, top:elpos.top - cpos.top});
                        _jsPlumb.dragManager.revalidateParent(_el, elId, elpos);

                        groupManager.updateConnectionsForGroup(self);

                        setTimeout(function() {
                            _jsPlumb.fire(EVT_CHILD_ADDED, {group: self, el: _el});
                        }, 0);
                    }
                }
            });
        }
        var _each = function(_el, fn) {
            var els = _el.nodeType == null ?  _el : [ _el ];
            for (var i = 0; i < els.length; i++) {
                fn(els[i]);
            }
        };

        this.overrideDrop = function(_el, targetGroup) {
            return dropOverride && (revert || prune || orphan);
        };

        this.add = function(_el, doNotFireEvent) {
            _each(_el, function(__el) {
                __el._jsPlumbGroup = self;
                elements.push(_el);
                // test if draggable and add handlers if so.
                if (_jsPlumb.isAlreadyDraggable(__el)) {
                    _bindDragHandlers(__el);
                }

                if (__el.parentNode != dragArea) {
                    dragArea.appendChild(__el);
                }

                if (!doNotFireEvent) {
                    _jsPlumb.fire(EVT_CHILD_ADDED, {group: self, el: __el});
                }
            });
        };
        this.remove = function(el, manipulateDOM, doNotFireEvent) {
            _each(el, function(__el) {
                delete __el._jsPlumbGroup;
                _ju.removeWithFunction(elements, function(e) {
                    return e === __el;
                });
                if (manipulateDOM) {
                    try { self.el.removeChild(__el); }
                    catch (e) {
                        console.log(e);
                    }
                }
                _unbindDragHandlers(__el);
                if (!doNotFireEvent) {
                    _jsPlumb.fire(EVT_CHILD_REMOVED, {group: self, el: __el});
                }
            });
        };
        this.removeAll = function() {
            for (var i = 0; i < elements.length; i++) {
                _jsPlumb.remove(elements[i]);
            }
            elements.length = 0;
        };
        this.orphanAll = function() {
            for (var i = 0; i < elements.length; i++) {
                _orphan(elements[i]);
            }
            elements.length = 0;
        };
        this.getMembers = function() { return elements; };

        el[GROUP] = this;

        _jsPlumb.bind(ELEMENT_DRAGGABLE_EVENT, function(dragParams) {
            // if its for the current group,
            if (dragParams.el._jsPlumbGroup == this) {
                _bindDragHandlers(dragParams.el);
            }
        }.bind(this));

        function _findParent(_el) {
            return _el.offsetParent;
        }

        function _isInsideParent(_el, pos) {
            var p = _findParent(_el),
                s = _jsPlumb.getSize(p),
                ss = _jsPlumb.getSize(_el),
                leftEdge = pos[0],
                rightEdge = leftEdge + ss[0],
                topEdge = pos[1],
                bottomEdge = topEdge + ss[1];

            return rightEdge > 0 && leftEdge < s[0] && bottomEdge > 0 && topEdge < s[1];
        }

        //
        // orphaning an element means taking it out of the group and adding it to the main jsplumb container.
        //
        function _orphan(_el) {
            var id = _jsPlumb.getId(_el);
            var pos = _jsPlumb.getOffset(_el);
            _el.parentNode.removeChild(_el);
            _jsPlumb.getContainer().appendChild(_el);
            _jsPlumb.setPosition(_el, pos);
            delete _el._jsPlumbGroup;
            _unbindDragHandlers(_el);
            _jsPlumb.dragManager.clearParent(_el, id);
        }

        //
        // remove an element from the group, then either prune it from the jsplumb instance, or just orphan it.
        //
        function _pruneOrOrphan(p) {
            if (!_isInsideParent(p.el, p.pos)) {
                p.el._jsPlumbGroup.remove(p.el);
                if (prune) {
                    _jsPlumb.remove(p.el);
                } else {
                    _orphan(p.el);
                }
            }
        }

        //
        // redraws the element
        //
        function _revalidate(_el) {
            var id = _jsPlumb.getId(_el);
            _jsPlumb.revalidate(_el);
            _jsPlumb.dragManager.revalidateParent(_el, id);
        }

        //
        // unbind the group specific drag/revert handlers.
        //
        function _unbindDragHandlers(_el) {
            if (prune || orphan) {
                _el._katavorioDrag.off(STOP, _pruneOrOrphan);
            }
            if (!prune && !orphan && revert) {
                _el._katavorioDrag.off(REVERT, _revalidate);
                _el._katavorioDrag.setRevert(null);
            }
        }

        function _bindDragHandlers(_el) {
            if (prune || orphan) {
                _el._katavorioDrag.on(STOP, _pruneOrOrphan);
            }

            if (constrain) {
                _el._katavorioDrag.setConstrain(true);
            }

            if (ghost) {
                _el._katavorioDrag.setUseGhostProxy(true);
            }

            if (!prune && !orphan && revert) {
                _el._katavorioDrag.on(REVERT, _revalidate);
                _el._katavorioDrag.setRevert(function(__el, pos) {
                    return !_isInsideParent(__el, pos);
                });
            }
        }

        this.shouldProxy = function() {
            return proxied;
        };

        _jsPlumb.getGroupManager().addGroup(this);
    };

    /**
     * Adds a group to the jsPlumb instance.
     * @method addGroup
     * @param {Object} params
     * @return {Group} The newly created Group.
     */
    _jpi.prototype.addGroup = function(params) {
        var j = this;
        j._groups = j._groups || {};
        if (j._groups[params.id] != null) {
            throw new TypeError("cannot create Group [" + params.id + "]; a Group with that ID exists");
        }
        if (params.el[GROUP] != null) {
            throw new TypeError("cannot create Group [" + params.id + "]; the given element is already a Group");
        }
        var group = new Group(j, params);
        j._groups[group.id] = group;
        return group;
    };

    /**
     * Add an element to a group.
     * @method addToGroup
     * @param {String} group Group, or ID of the group, to add the element to.
     * @param {Element} el Element to add to the group.
     */
    _jpi.prototype.addToGroup = function(group, el, doNotFireEvent) {
        this.getGroupManager().addToGroup(group, el, doNotFireEvent);
    };

    /**
     * Remove an element from a group.
     * @method removeFromGroup
     * @param {String} group Group, or ID of the group, to remove the element from.
     * @param {Element} el Element to add to the group.
     */
    _jpi.prototype.removeFromGroup = function(group, el, doNotFireEvent) {
        this.getGroupManager().removeFromGroup(group, el, doNotFireEvent);
    };

    /**
     * Remove a group, and optionally remove its members from the jsPlumb instance.
     * @method removeGroup
     * @param {String|Group} group Group to delete, or ID of Grrup to delete.
     * @param {Boolean} [deleteMembers=false] If true, group members will be removed along with the group. Otherwise they will
     * just be 'orphaned' (returned to the main container).
     */
    _jpi.prototype.removeGroup = function(group, deleteMembers) {
        this.getGroupManager().removeGroup(group, deleteMembers);
    };

    /**
     * Remove all groups, and optionally remove their members from the jsPlumb instance.
     * @method removeAllGroup
     * @param {Boolean} [deleteMembers=false] If true, group members will be removed along with the groups. Otherwise they will
     * just be 'orphaned' (returned to the main container).
     */
    _jpi.prototype.removeAllGroups = function(deleteMembers) {
        this.getGroupManager().removeAllGroups(deleteMembers);
    };

    /**
     * Get a group
     * @method getGroup
     * @param {String} groupId ID of the group to get
     */
    _jpi.prototype.getGroup = function(groupId) {
        return this.getGroupManager().getGroup(groupId);
    };

    /**
     * Expands a group element. jsPlumb doesn't do "everything" for you here, because what it means to expand a Group
     * will vary from application to application. jsPlumb does these things:
     *
     * - Hides any connections that are internal to the group (connections between members, and connections from member of
     * the group to the group itself)
     * - Proxies all connections for which the source or target is a member of the group.
     * - Hides the proxied connections.
     * - Adds the jsplumb-group-expanded class to the group's element
     * - Removes the jsplumb-group-collapsed class from the group's element.
     *
     * @method expandGroup
     * @param {String|Group} group Group to expand, or ID of Group to expand.
     */
    _jpi.prototype.expandGroup = function(group) {
        this.getGroupManager().expandGroup(group);
    };

    /**
     * Collapses a group element. jsPlumb doesn't do "everything" for you here, because what it means to collapse a Group
     * will vary from application to application. jsPlumb does these things:
     *
     * - Shows any connections that are internal to the group (connections between members, and connections from member of
     * the group to the group itself)
     * - Removes proxies for all connections for which the source or target is a member of the group.
     * - Shows the previously proxied connections.
     * - Adds the jsplumb-group-collapsed class to the group's element
     * - Removes the jsplumb-group-expanded class from the group's element.
     *
     * @method expandGroup
     * @param {String|Group} group Group to expand, or ID of Group to expand.
     */
    _jpi.prototype.collapseGroup = function(groupId) {
        this.getGroupManager().collapseGroup(groupId);
    };


    _jpi.prototype.repaintGroup = function(group) {
        this.getGroupManager().repaintGroup(group);
    };

    /**
     * Collapses or expands a group element depending on its current state. See notes in the collapseGroup and expandGroup method.
     *
     * @method toggleGroup
     * @param {String|Group} group Group to expand/collapse, or ID of Group to expand/collapse.
     */
    _jpi.prototype.toggleGroup = function(group) {
        group = this.getGroupManager().getGroup(group);
        if (group != null) {
            this.getGroupManager()[group.collapsed ? "expandGroup" : "collapseGroup"](group);
        }
    };

    //
    // lazy init a group manager for the given jsplumb instance.
    //
    _jpi.prototype.getGroupManager = function() {
        var mgr = this[GROUP_MANAGER];
        if (mgr == null) {
            mgr = this[GROUP_MANAGER] = new GroupManager(this);
        }
        return mgr;
    };

    _jpi.prototype.removeGroupManager = function() {
        delete this[GROUP_MANAGER];
    };

    /**
     * Gets the Group that the given element belongs to, null if none.
     * @method getGroupFor
     * @param {String|Element} el Element, or element ID.
     * @returns {Group} A Group, if found, or null.
     */
    _jpi.prototype.getGroupFor = function(el) {
        el = this.getElement(el);
        if (el) {
            return el[GROUP];
        }
    };

}).call(typeof window !== 'undefined' ? window : this);


/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.1.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the 'flowchart' connectors, consisting of vertical and horizontal line segments.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var Flowchart = function (params) {
        this.type = "Flowchart";
        params = params || {};
        params.stub = params.stub == null ? 30 : params.stub;
        var segments,
            _super = _jp.Connectors.AbstractConnector.apply(this, arguments),
            midpoint = params.midpoint == null ? 0.5 : params.midpoint,
            alwaysRespectStubs = params.alwaysRespectStubs === true,
            lastx = null, lasty = null, lastOrientation,
            cornerRadius = params.cornerRadius != null ? params.cornerRadius : 0,

            // TODO now common between this and AbstractBezierEditor; refactor into superclass?
            loopbackRadius = params.loopbackRadius || 25,
            isLoopbackCurrently = false,

            sgn = function (n) {
                return n < 0 ? -1 : n === 0 ? 0 : 1;
            },
            /**
             * helper method to add a segment.
             */
            addSegment = function (segments, x, y, paintInfo) {
                if (lastx == x && lasty == y) return;
                var lx = lastx == null ? paintInfo.sx : lastx,
                    ly = lasty == null ? paintInfo.sy : lasty,
                    o = lx == x ? "v" : "h",
                    sgnx = sgn(x - lx),
                    sgny = sgn(y - ly);

                lastx = x;
                lasty = y;
                segments.push([lx, ly, x, y, o, sgnx, sgny]);
            },
            segLength = function (s) {
                return Math.sqrt(Math.pow(s[0] - s[2], 2) + Math.pow(s[1] - s[3], 2));
            },
            _cloneArray = function (a) {
                var _a = [];
                _a.push.apply(_a, a);
                return _a;
            },
            writeSegments = function (conn, segments, paintInfo) {
                var current = null, next;
                for (var i = 0; i < segments.length - 1; i++) {

                    current = current || _cloneArray(segments[i]);
                    next = _cloneArray(segments[i + 1]);
                    if (cornerRadius > 0 && current[4] != next[4]) {
                        var radiusToUse = Math.min(cornerRadius, segLength(current), segLength(next));
                        // right angle. adjust current segment's end point, and next segment's start point.
                        current[2] -= current[5] * radiusToUse;
                        current[3] -= current[6] * radiusToUse;
                        next[0] += next[5] * radiusToUse;
                        next[1] += next[6] * radiusToUse;
                        var ac = (current[6] == next[5] && next[5] == 1) ||
                                ((current[6] == next[5] && next[5] === 0) && current[5] != next[6]) ||
                                (current[6] == next[5] && next[5] == -1),
                            sgny = next[1] > current[3] ? 1 : -1,
                            sgnx = next[0] > current[2] ? 1 : -1,
                            sgnEqual = sgny == sgnx,
                            cx = (sgnEqual && ac || (!sgnEqual && !ac)) ? next[0] : current[2],
                            cy = (sgnEqual && ac || (!sgnEqual && !ac)) ? current[3] : next[1];

                        _super.addSegment(conn, "Straight", {
                            x1: current[0], y1: current[1], x2: current[2], y2: current[3]
                        });

                        _super.addSegment(conn, "Arc", {
                            r: radiusToUse,
                            x1: current[2],
                            y1: current[3],
                            x2: next[0],
                            y2: next[1],
                            cx: cx,
                            cy: cy,
                            ac: ac
                        });
                    }
                    else {
                        // dx + dy are used to adjust for line width.
                        var dx = (current[2] == current[0]) ? 0 : (current[2] > current[0]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2),
                            dy = (current[3] == current[1]) ? 0 : (current[3] > current[1]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2);
                        _super.addSegment(conn, "Straight", {
                            x1: current[0] - dx, y1: current[1] - dy, x2: current[2] + dx, y2: current[3] + dy
                        });
                    }
                    current = next;
                }
                if (next != null) {
                    // last segment
                    _super.addSegment(conn, "Straight", {
                        x1: next[0], y1: next[1], x2: next[2], y2: next[3]
                    });
                }
            };

        this._compute = function (paintInfo, params) {

            segments = [];
            lastx = null;
            lasty = null;
            lastOrientation = null;

            var commonStubCalculator = function () {
                return [ paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY ];
            },
                stubCalculators = {
                    perpendicular: commonStubCalculator,
                    orthogonal: commonStubCalculator,
                    opposite: function (axis) {
                        var pi = paintInfo,
                            idx = axis == "x" ? 0 : 1,
                            areInProximity = {
                                "x": function () {
                                    return ( (pi.so[idx] == 1 && (
                                        ( (pi.startStubX > pi.endStubX) && (pi.tx > pi.startStubX) ) ||
                                        ( (pi.sx > pi.endStubX) && (pi.tx > pi.sx))))) ||

                                        ( (pi.so[idx] == -1 && (
                                            ( (pi.startStubX < pi.endStubX) && (pi.tx < pi.startStubX) ) ||
                                            ( (pi.sx < pi.endStubX) && (pi.tx < pi.sx)))));
                                },
                                "y": function () {
                                    return ( (pi.so[idx] == 1 && (
                                        ( (pi.startStubY > pi.endStubY) && (pi.ty > pi.startStubY) ) ||
                                        ( (pi.sy > pi.endStubY) && (pi.ty > pi.sy))))) ||

                                        ( (pi.so[idx] == -1 && (
                                            ( (pi.startStubY < pi.endStubY) && (pi.ty < pi.startStubY) ) ||
                                            ( (pi.sy < pi.endStubY) && (pi.ty < pi.sy)))));
                                }
                            };

                        if (!alwaysRespectStubs && areInProximity[axis]()) {
                            return {
                                "x": [(paintInfo.sx + paintInfo.tx) / 2, paintInfo.startStubY, (paintInfo.sx + paintInfo.tx) / 2, paintInfo.endStubY],
                                "y": [paintInfo.startStubX, (paintInfo.sy + paintInfo.ty) / 2, paintInfo.endStubX, (paintInfo.sy + paintInfo.ty) / 2]
                            }[axis];
                        }
                        else {
                            return [ paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY ];
                        }
                    }
                };

            // calculate Stubs.
            var stubs = stubCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis),
                idx = paintInfo.sourceAxis == "x" ? 0 : 1,
                oidx = paintInfo.sourceAxis == "x" ? 1 : 0,
                ss = stubs[idx],
                oss = stubs[oidx],
                es = stubs[idx + 2],
                oes = stubs[oidx + 2];

            // add the start stub segment. use stubs for loopback as it will look better, with the loop spaced
            // away from the element.
            addSegment(segments, stubs[0], stubs[1], paintInfo);

            // if its a loopback and we should treat it differently.
            if (false &&params.sourcePos[0] == params.targetPos[0] && params.sourcePos[1] == params.targetPos[1]) {

                // we use loopbackRadius here, as statemachine connectors do.
                // so we go radius to the left from stubs[0], then upwards by 2*radius, to the right by 2*radius,
                // down by 2*radius, left by radius.
                addSegment(segments, stubs[0] - loopbackRadius, stubs[1], paintInfo);
                addSegment(segments, stubs[0] - loopbackRadius, stubs[1] - (2 * loopbackRadius), paintInfo);
                addSegment(segments, stubs[0] + loopbackRadius, stubs[1] - (2 * loopbackRadius), paintInfo);
                addSegment(segments, stubs[0] + loopbackRadius, stubs[1], paintInfo);
                addSegment(segments, stubs[0], stubs[1], paintInfo);

            }
            else {


                var midx = paintInfo.startStubX + ((paintInfo.endStubX - paintInfo.startStubX) * midpoint),
                    midy = paintInfo.startStubY + ((paintInfo.endStubY - paintInfo.startStubY) * midpoint);

                var orientations = { x: [ 0, 1 ], y: [ 1, 0 ] },
                    lineCalculators = {
                        perpendicular: function (axis) {
                            var pi = paintInfo,
                                sis = {
                                    x: [
                                        [ [ 1, 2, 3, 4 ], null, [ 2, 1, 4, 3 ] ],
                                        null,
                                        [ [ 4, 3, 2, 1 ], null, [ 3, 4, 1, 2 ] ]
                                    ],
                                    y: [
                                        [ [ 3, 2, 1, 4 ], null, [ 2, 3, 4, 1 ] ],
                                        null,
                                        [ [ 4, 1, 2, 3 ], null, [ 1, 4, 3, 2 ] ]
                                    ]
                                },
                                stubs = {
                                    x: [ [ pi.startStubX, pi.endStubX ], null, [ pi.endStubX, pi.startStubX ] ],
                                    y: [ [ pi.startStubY, pi.endStubY ], null, [ pi.endStubY, pi.startStubY ] ]
                                },
                                midLines = {
                                    x: [ [ midx, pi.startStubY ], [ midx, pi.endStubY ] ],
                                    y: [ [ pi.startStubX, midy ], [ pi.endStubX, midy ] ]
                                },
                                linesToEnd = {
                                    x: [ [ pi.endStubX, pi.startStubY ] ],
                                    y: [ [ pi.startStubX, pi.endStubY ] ]
                                },
                                startToEnd = {
                                    x: [ [ pi.startStubX, pi.endStubY ], [ pi.endStubX, pi.endStubY ] ],
                                    y: [ [ pi.endStubX, pi.startStubY ], [ pi.endStubX, pi.endStubY ] ]
                                },
                                startToMidToEnd = {
                                    x: [ [ pi.startStubX, midy ], [ pi.endStubX, midy ], [ pi.endStubX, pi.endStubY ] ],
                                    y: [ [ midx, pi.startStubY ], [ midx, pi.endStubY ], [ pi.endStubX, pi.endStubY ] ]
                                },
                                otherStubs = {
                                    x: [ pi.startStubY, pi.endStubY ],
                                    y: [ pi.startStubX, pi.endStubX ]
                                },
                                soIdx = orientations[axis][0], toIdx = orientations[axis][1],
                                _so = pi.so[soIdx] + 1,
                                _to = pi.to[toIdx] + 1,
                                otherFlipped = (pi.to[toIdx] == -1 && (otherStubs[axis][1] < otherStubs[axis][0])) || (pi.to[toIdx] == 1 && (otherStubs[axis][1] > otherStubs[axis][0])),
                                stub1 = stubs[axis][_so][0],
                                stub2 = stubs[axis][_so][1],
                                segmentIndexes = sis[axis][_so][_to];

                            if (pi.segment == segmentIndexes[3] || (pi.segment == segmentIndexes[2] && otherFlipped)) {
                                return midLines[axis];
                            }
                            else if (pi.segment == segmentIndexes[2] && stub2 < stub1) {
                                return linesToEnd[axis];
                            }
                            else if ((pi.segment == segmentIndexes[2] && stub2 >= stub1) || (pi.segment == segmentIndexes[1] && !otherFlipped)) {
                                return startToMidToEnd[axis];
                            }
                            else if (pi.segment == segmentIndexes[0] || (pi.segment == segmentIndexes[1] && otherFlipped)) {
                                return startToEnd[axis];
                            }
                        },
                        orthogonal: function (axis, startStub, otherStartStub, endStub, otherEndStub) {
                            var pi = paintInfo,
                                extent = {
                                    "x": pi.so[0] == -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub),
                                    "y": pi.so[1] == -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)
                                }[axis];

                            return {
                                "x": [
                                    [ extent, otherStartStub ],
                                    [ extent, otherEndStub ],
                                    [ endStub, otherEndStub ]
                                ],
                                "y": [
                                    [ otherStartStub, extent ],
                                    [ otherEndStub, extent ],
                                    [ otherEndStub, endStub ]
                                ]
                            }[axis];
                        },
                        opposite: function (axis, ss, oss, es) {
                            var pi = paintInfo,
                                otherAxis = {"x": "y", "y": "x"}[axis],
                                dim = {"x": "height", "y": "width"}[axis],
                                comparator = pi["is" + axis.toUpperCase() + "GreaterThanStubTimes2"];

                            if (params.sourceEndpoint.elementId == params.targetEndpoint.elementId) {
                                var _val = oss + ((1 - params.sourceEndpoint.anchor[otherAxis]) * params.sourceInfo[dim]) + _super.maxStub;
                                return {
                                    "x": [
                                        [ ss, _val ],
                                        [ es, _val ]
                                    ],
                                    "y": [
                                        [ _val, ss ],
                                        [ _val, es ]
                                    ]
                                }[axis];

                            }
                            else if (!comparator || (pi.so[idx] == 1 && ss > es) || (pi.so[idx] == -1 && ss < es)) {
                                return {
                                    "x": [
                                        [ ss, midy ],
                                        [ es, midy ]
                                    ],
                                    "y": [
                                        [ midx, ss ],
                                        [ midx, es ]
                                    ]
                                }[axis];
                            }
                            else if ((pi.so[idx] == 1 && ss < es) || (pi.so[idx] == -1 && ss > es)) {
                                return {
                                    "x": [
                                        [ midx, pi.sy ],
                                        [ midx, pi.ty ]
                                    ],
                                    "y": [
                                        [ pi.sx, midy ],
                                        [ pi.tx, midy ]
                                    ]
                                }[axis];
                            }
                        }
                    };

                // compute the rest of the line
                var p = lineCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis, ss, oss, es, oes);
                if (p) {
                    for (var i = 0; i < p.length; i++) {
                        addSegment(segments, p[i][0], p[i][1], paintInfo);
                    }
                }

                // line to end stub
                addSegment(segments, stubs[2], stubs[3], paintInfo);

            }

            // end stub to end (common)
            addSegment(segments, paintInfo.tx, paintInfo.ty, paintInfo);

            // write out the segments.
            writeSegments(this, segments, paintInfo);
        };

        /*this.getPath = function () {
            var _last = null, _lastAxis = null, s = [], segs = segments;
            for (var i = 0; i < segs.length; i++) {
                var seg = segs[i], axis = seg[4], axisIndex = (axis == "v" ? 3 : 2);
                if (_last != null && _lastAxis === axis) {
                    _last[axisIndex] = seg[axisIndex];
                }
                else {
                    if (seg[0] != seg[2] || seg[1] != seg[3]) {
                        s.push({
                            start: [ seg[0], seg[1] ],
                            end: [ seg[2], seg[3] ]
                        });
                        _last = seg;
                        _lastAxis = seg[4];
                    }
                }
            }
            return s;
        };*/
    };

    _ju.extend(Flowchart, _jp.Connectors.AbstractConnector);
    _jp.registerConnectorType(Flowchart, "Flowchart");
}).call(typeof window !== 'undefined' ? window : this);
/*
 * This file contains the code for the Bezier connector type.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * https://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    _jp.Connectors.AbstractBezierConnector = function(params) {
        params = params || {};
        var showLoopback = params.showLoopback !== false,
            curviness = params.curviness || 10,
            margin = params.margin || 5,
            proximityLimit = params.proximityLimit || 80,
            clockwise = params.orientation && params.orientation === "clockwise",
            loopbackRadius = params.loopbackRadius || 25,
            isLoopbackCurrently = false,
            _super;

        this.overrideSetEditable = function() { return !isLoopbackCurrently; };

        this._compute = function (paintInfo, p) {

            var sp = p.sourcePos,
                tp = p.targetPos,
                _w = Math.abs(sp[0] - tp[0]),
                _h = Math.abs(sp[1] - tp[1]);

            if (!showLoopback || (p.sourceEndpoint.elementId !== p.targetEndpoint.elementId)) {
                isLoopbackCurrently = false;
                this._computeBezier(paintInfo, p, sp, tp, _w, _h);
            } else {
                isLoopbackCurrently = true;
                // a loopback connector.  draw an arc from one anchor to the other.
                var x1 = p.sourcePos[0], y1 = p.sourcePos[1] - margin,
                    cx = x1, cy = y1 - loopbackRadius,
                // canvas sizing stuff, to ensure the whole painted area is visible.
                    _x = cx - loopbackRadius,
                    _y = cy - loopbackRadius;

                _w = 2 * loopbackRadius;
                _h = 2 * loopbackRadius;

                paintInfo.points[0] = _x;
                paintInfo.points[1] = _y;
                paintInfo.points[2] = _w;
                paintInfo.points[3] = _h;

                // ADD AN ARC SEGMENT.
                _super.addSegment(this, "Arc", {
                    loopback: true,
                    x1: (x1 - _x) + 4,
                    y1: y1 - _y,
                    startAngle: 0,
                    endAngle: 2 * Math.PI,
                    r: loopbackRadius,
                    ac: !clockwise,
                    x2: (x1 - _x) - 4,
                    y2: y1 - _y,
                    cx: cx - _x,
                    cy: cy - _y
                });
            }
        };

        _super = _jp.Connectors.AbstractConnector.apply(this, arguments);
        return _super;
    };
    _ju.extend(_jp.Connectors.AbstractBezierConnector, _jp.Connectors.AbstractConnector);

    var Bezier = function (params) {
        params = params || {};
        this.type = "Bezier";

        var _super = _jp.Connectors.AbstractBezierConnector.apply(this, arguments),
            majorAnchor = params.curviness || 150,
            minorAnchor = 10;

        this.getCurviness = function () {
            return majorAnchor;
        };

        this._findControlPoint = function (point, sourceAnchorPosition, targetAnchorPosition, sourceEndpoint, targetEndpoint, soo, too) {
            // determine if the two anchors are perpendicular to each other in their orientation.  we swap the control
            // points around if so (code could be tightened up)
            var perpendicular = soo[0] != too[0] || soo[1] == too[1],
                p = [];

            if (!perpendicular) {
                if (soo[0] === 0) // X
                    p.push(sourceAnchorPosition[0] < targetAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
                else p.push(point[0] - (majorAnchor * soo[0]));

                if (soo[1] === 0) // Y
                    p.push(sourceAnchorPosition[1] < targetAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
                else p.push(point[1] + (majorAnchor * too[1]));
            }
            else {
                if (too[0] === 0) // X
                    p.push(targetAnchorPosition[0] < sourceAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
                else p.push(point[0] + (majorAnchor * too[0]));

                if (too[1] === 0) // Y
                    p.push(targetAnchorPosition[1] < sourceAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
                else p.push(point[1] + (majorAnchor * soo[1]));
            }

            return p;
        };

        this._computeBezier = function (paintInfo, p, sp, tp, _w, _h) {

            var geometry = this.getGeometry(), _CP, _CP2,
                _sx = sp[0] < tp[0] ? _w : 0,
                _sy = sp[1] < tp[1] ? _h : 0,
                _tx = sp[0] < tp[0] ? 0 : _w,
                _ty = sp[1] < tp[1] ? 0 : _h;

            if ((this.hasBeenEdited() || this.isEditing()) && geometry != null && geometry.controlPoints != null && geometry.controlPoints[0] != null && geometry.controlPoints[1] != null) {
                _CP = geometry.controlPoints[0];
                _CP2 = geometry.controlPoints[1];
            }
            else {
                _CP = this._findControlPoint([_sx, _sy], sp, tp, p.sourceEndpoint, p.targetEndpoint, paintInfo.so, paintInfo.to);
                _CP2 = this._findControlPoint([_tx, _ty], tp, sp, p.targetEndpoint, p.sourceEndpoint, paintInfo.to, paintInfo.so);
            }

            _super.setGeometry({controlPoints:[_CP, _CP2]}, true);

            _super.addSegment(this, "Bezier", {
                x1: _sx, y1: _sy, x2: _tx, y2: _ty,
                cp1x: _CP[0], cp1y: _CP[1], cp2x: _CP2[0], cp2y: _CP2[1]
            });
        };


    };

    _ju.extend(Bezier, _jp.Connectors.AbstractBezierConnector);
    _jp.registerConnectorType(Bezier, "Bezier");

}).call(typeof window !== 'undefined' ? window : this);
/*
 * This file contains the state machine connectors, which extend AbstractBezierConnector.
 *
 * Copyright (c) 2010 - 2015 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * https://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var _segment = function (x1, y1, x2, y2) {
            if (x1 <= x2 && y2 <= y1) return 1;
            else if (x1 <= x2 && y1 <= y2) return 2;
            else if (x2 <= x1 && y2 >= y1) return 3;
            return 4;
        },

    // the control point we will use depends on the faces to which each end of the connection is assigned, specifically whether or not the
    // two faces are parallel or perpendicular.  if they are parallel then the control point lies on the midpoint of the axis in which they
    // are parellel and varies only in the other axis; this variation is proportional to the distance that the anchor points lie from the
    // center of that face.  if the two faces are perpendicular then the control point is at some distance from both the midpoints; the amount and
    // direction are dependent on the orientation of the two elements. 'seg', passed in to this method, tells you which segment the target element
    // lies in with respect to the source: 1 is top right, 2 is bottom right, 3 is bottom left, 4 is top left.
    //
    // sourcePos and targetPos are arrays of info about where on the source and target each anchor is located.  their contents are:
    //
    // 0 - absolute x
    // 1 - absolute y
    // 2 - proportional x in element (0 is left edge, 1 is right edge)
    // 3 - proportional y in element (0 is top edge, 1 is bottom edge)
    //
        _findControlPoint = function (midx, midy, segment, sourceEdge, targetEdge, dx, dy, distance, proximityLimit) {
            // TODO (maybe)
            // - if anchor pos is 0.5, make the control point take into account the relative position of the elements.
            if (distance <= proximityLimit) return [midx, midy];

            if (segment === 1) {
                if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + (-1 * dx) , midy + (-1 * dy) ];
            }
            else if (segment === 2) {
                if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + dx, midy + (-1 * dy) ];
            }
            else if (segment === 3) {
                if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + (-1 * dx) , midy + (-1 * dy) ];
            }
            else if (segment === 4) {
                if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + dx , midy + (-1 * dy) ];
            }

        };

    var StateMachine = function (params) {
        params = params || {};
        this.type = "StateMachine";

        var _super = _jp.Connectors.AbstractBezierConnector.apply(this, arguments),
            curviness = params.curviness || 10,
            margin = params.margin || 5,
            proximityLimit = params.proximityLimit || 80,
            clockwise = params.orientation && params.orientation === "clockwise",
            _controlPoint;

        this._computeBezier = function(paintInfo, params, sp, tp, w, h) {
            var _sx = params.sourcePos[0] < params.targetPos[0] ? 0 : w,
                _sy = params.sourcePos[1] < params.targetPos[1] ? 0 : h,
                _tx = params.sourcePos[0] < params.targetPos[0] ? w : 0,
                _ty = params.sourcePos[1] < params.targetPos[1] ? h : 0;

            // now adjust for the margin
            if (params.sourcePos[2] === 0) _sx -= margin;
            if (params.sourcePos[2] === 1) _sx += margin;
            if (params.sourcePos[3] === 0) _sy -= margin;
            if (params.sourcePos[3] === 1) _sy += margin;
            if (params.targetPos[2] === 0) _tx -= margin;
            if (params.targetPos[2] === 1) _tx += margin;
            if (params.targetPos[3] === 0) _ty -= margin;
            if (params.targetPos[3] === 1) _ty += margin;

            //
            // these connectors are quadratic bezier curves, having a single control point. if both anchors
            // are located at 0.5 on their respective faces, the control point is set to the midpoint and you
            // get a straight line.  this is also the case if the two anchors are within 'proximityLimit', since
            // it seems to make good aesthetic sense to do that. outside of that, the control point is positioned
            // at 'curviness' pixels away along the normal to the straight line connecting the two anchors.
            //
            // there may be two improvements to this.  firstly, we might actually support the notion of avoiding nodes
            // in the UI, or at least making a good effort at doing so.  if a connection would pass underneath some node,
            // for example, we might increase the distance the control point is away from the midpoint in a bid to
            // steer it around that node.  this will work within limits, but i think those limits would also be the likely
            // limits for, once again, aesthetic good sense in the layout of a chart using these connectors.
            //
            // the second possible change is actually two possible changes: firstly, it is possible we should gradually
            // decrease the 'curviness' as the distance between the anchors decreases; start tailing it off to 0 at some
            // point (which should be configurable).  secondly, we might slightly increase the 'curviness' for connectors
            // with respect to how far their anchor is from the center of its respective face. this could either look cool,
            // or stupid, and may indeed work only in a way that is so subtle as to have been a waste of time.
            //

            var _midx = (_sx + _tx) / 2,
                _midy = (_sy + _ty) / 2,
                segment = _segment(_sx, _sy, _tx, _ty),
                distance = Math.sqrt(Math.pow(_tx - _sx, 2) + Math.pow(_ty - _sy, 2)),
                cp1x, cp2x, cp1y, cp2y,
                geometry = _super.getGeometry();

            if ((this.hasBeenEdited() || this.isEditing()) && geometry != null) {
                cp1x = geometry.controlPoints[0][0];
                cp1y = geometry.controlPoints[0][1];
                cp2x = geometry.controlPoints[1][0];
                cp2y = geometry.controlPoints[1][1];
            }
            else {
                // calculate the control point.  this code will be where we'll put in a rudimentary element avoidance scheme; it
                // will work by extending the control point to force the curve to be, um, curvier.
                _controlPoint = _findControlPoint(_midx,
                    _midy,
                    segment,
                    params.sourcePos,
                    params.targetPos,
                    curviness, curviness,
                    distance,
                    proximityLimit);

                cp1x = _controlPoint[0];
                cp2x = _controlPoint[0];
                cp1y = _controlPoint[1];
                cp2y = _controlPoint[1];

                _super.setGeometry({controlPoints:[_controlPoint, _controlPoint]}, true);
            }

            _super.addSegment(this, "Bezier", {
                x1: _tx, y1: _ty, x2: _sx, y2: _sy,
                cp1x: cp1x, cp1y: cp1y,
                cp2x: cp2x, cp2y: cp2y
            });
        };
    };

    _ju.extend(StateMachine, _jp.Connectors.AbstractBezierConnector);
    _jp.registerConnectorType(StateMachine, "StateMachine");

}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.1.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the SVG renderers.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

// ************************** SVG utility methods ********************************************	

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var svgAttributeMap = {
            "stroke-linejoin": "stroke-linejoin",
            "stroke-dashoffset": "stroke-dashoffset",
            "stroke-linecap": "stroke-linecap"
        },
        STROKE_DASHARRAY = "stroke-dasharray",
        DASHSTYLE = "dashstyle",
        LINEAR_GRADIENT = "linearGradient",
        RADIAL_GRADIENT = "radialGradient",
        DEFS = "defs",
        FILL = "fill",
        STOP = "stop",
        STROKE = "stroke",
        STROKE_WIDTH = "stroke-width",
        STYLE = "style",
        NONE = "none",
        JSPLUMB_GRADIENT = "jsplumb_gradient_",
        LINE_WIDTH = "lineWidth",
        ns = {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml"
        },
        _attr = function (node, attributes) {
            for (var i in attributes)
                node.setAttribute(i, "" + attributes[i]);
        },
        _node = function (name, attributes) {
            attributes = attributes || {};
            attributes.version = "1.1";
            attributes.xmlns = ns.xhtml;
            return jsPlumb.createElementNS(ns.svg, name, null, null, attributes);
        },
        _pos = function (d) {
            return "position:absolute;left:" + d[0] + "px;top:" + d[1] + "px";
        },
        _clearGradient = function (parent) {
            var els = parent.querySelectorAll(" defs,linearGradient,radialGradient");
            for (var i = 0; i < els.length; i++)
                els[i].parentNode.removeChild(els[i]);
        },
        _updateGradient = function (parent, node, style, dimensions, uiComponent) {
            var id = JSPLUMB_GRADIENT + uiComponent._jsPlumb.instance.idstamp();
            // first clear out any existing gradient
            _clearGradient(parent);
            // this checks for an 'offset' property in the gradient, and in the absence of it, assumes
            // we want a linear gradient. if it's there, we create a radial gradient.
            // it is possible that a more explicit means of defining the gradient type would be
            // better. relying on 'offset' means that we can never have a radial gradient that uses
            // some default offset, for instance.
            // issue 244 suggested the 'gradientUnits' attribute; without this, straight/flowchart connectors with gradients would
            // not show gradients when the line was perfectly horizontal or vertical.
            var g;
            if (!style.gradient.offset)
                g = _node(LINEAR_GRADIENT, {id: id, gradientUnits: "userSpaceOnUse"});
            else
                g = _node(RADIAL_GRADIENT, { id: id });

            var defs = _node(DEFS);
            parent.appendChild(defs);
            defs.appendChild(g);

            // the svg radial gradient seems to treat stops in the reverse
            // order to how canvas does it.  so we want to keep all the maths the same, but
            // iterate the actual style declarations in reverse order, if the x indexes are not in order.
            for (var i = 0; i < style.gradient.stops.length; i++) {
                var styleToUse = uiComponent.segment == 1 || uiComponent.segment == 2 ? i : style.gradient.stops.length - 1 - i,
                    //stopColor = _ju.convertStyle(style.gradient.stops[styleToUse][1], true),
                    stopColor = style.gradient.stops[styleToUse][1],
                    s = _node(STOP, {"offset": Math.floor(style.gradient.stops[i][0] * 100) + "%", "stop-color": stopColor});

                g.appendChild(s);
            }
            var applyGradientTo = style.strokeStyle ? STROKE : FILL;
            node.setAttribute(applyGradientTo, "url(#" + id + ")");
        },
        _applyStyles = function (parent, node, style, dimensions, uiComponent) {

            node.setAttribute(FILL, style.fillStyle ? style.fillStyle : NONE);
            node.setAttribute(STROKE, style.strokeStyle ? style.strokeStyle : NONE);

            if (style.gradient) {
                _updateGradient(parent, node, style, dimensions, uiComponent);
            }
            else {
                // make sure we clear any existing gradient
                _clearGradient(parent);
                node.setAttribute(STYLE, "");
            }

            if (style.lineWidth) {
                node.setAttribute(STROKE_WIDTH, style.lineWidth);
            }

            // in SVG there is a stroke-dasharray attribute we can set, and its syntax looks like
            // the syntax in VML but is actually kind of nasty: values are given in the pixel
            // coordinate space, whereas in VML they are multiples of the width of the stroked
            // line, which makes a lot more sense.  for that reason, jsPlumb is supporting both
            // the native svg 'stroke-dasharray' attribute, and also the 'dashstyle' concept from
            // VML, which will be the preferred method.  the code below this converts a dashstyle
            // attribute given in terms of stroke width into a pixel representation, by using the
            // stroke's lineWidth.
            if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {
                var sep = style[DASHSTYLE].indexOf(",") == -1 ? " " : ",",
                    parts = style[DASHSTYLE].split(sep),
                    styleToUse = "";
                parts.forEach(function (p) {
                    styleToUse += (Math.floor(p * style.lineWidth) + sep);
                });
                node.setAttribute(STROKE_DASHARRAY, styleToUse);
            }
            else if (style[STROKE_DASHARRAY]) {
                node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);
            }

            // extra attributes such as join type, dash offset.
            for (var i in svgAttributeMap) {
                if (style[i]) {
                    node.setAttribute(svgAttributeMap[i], style[i]);
                }
            }
        },
        _appendAtIndex = function (svg, path, idx) {
            if (svg.childNodes.length > idx) {
                svg.insertBefore(path, svg.childNodes[idx]);
            }
            else svg.appendChild(path);
        };

    /**
     utility methods for other objects to use.
     */
    _ju.svg = {
        node: _node,
        attr: _attr,
        pos: _pos
    };

    // ************************** / SVG utility methods ********************************************

    /*
     * Base class for SVG components.
     */
    var SvgComponent = function (params) {
        var pointerEventsSpec = params.pointerEventsSpec || "all", renderer = {};

        _jp.jsPlumbUIComponent.apply(this, params.originalArgs);
        this.canvas = null;
        this.path = null;
        this.svg = null;
        this.bgCanvas = null;

        var clazz = params.cssClass + " " + (params.originalArgs[0].cssClass || ""),
            svgParams = {
                "style": "",
                "width": 0,
                "height": 0,
                "pointer-events": pointerEventsSpec,
                "position": "absolute"
            };

        this.svg = _node("svg", svgParams);

        if (params.useDivWrapper) {
            this.canvas = jsPlumb.createElement("div", { position : "absolute" });
            _ju.sizeElement(this.canvas, 0, 0, 1, 1);
            this.canvas.className = clazz;
        }
        else {
            _attr(this.svg, { "class": clazz });
            this.canvas = this.svg;
        }

        params._jsPlumb.appendElement(this.canvas, params.originalArgs[0].parent);
        if (params.useDivWrapper) this.canvas.appendChild(this.svg);

        var displayElements = [ this.canvas ];
        this.getDisplayElements = function () {
            return displayElements;
        };

        this.appendDisplayElement = function (el) {
            displayElements.push(el);
        };

        this.paint = function (style, anchor, extents) {
            if (style != null) {

                var xy = [ this.x, this.y ], wh = [ this.w, this.h ], p;
                if (extents != null) {
                    if (extents.xmin < 0) xy[0] += extents.xmin;
                    if (extents.ymin < 0) xy[1] += extents.ymin;
                    wh[0] = extents.xmax + ((extents.xmin < 0) ? -extents.xmin : 0);
                    wh[1] = extents.ymax + ((extents.ymin < 0) ? -extents.ymin : 0);
                }

                if (params.useDivWrapper) {
                    _ju.sizeElement(this.canvas, xy[0], xy[1], wh[0], wh[1]);
                    xy[0] = 0;
                    xy[1] = 0;
                    p = _pos([ 0, 0 ]);
                }
                else
                    p = _pos([ xy[0], xy[1] ]);

                renderer.paint.apply(this, arguments);

                _attr(this.svg, {
                    "style": p,
                    "width": wh[0] || 0,
                    "height": wh[1] || 0
                });
            }
        };

        return {
            renderer: renderer
        };
    };

    _ju.extend(SvgComponent, _jp.jsPlumbUIComponent, {
        cleanup: function (force) {
            if (force || this.typeId == null) {
                if (this.canvas) this.canvas._jsPlumb = null;
                if (this.svg) this.svg._jsPlumb = null;
                if (this.bgCanvas) this.bgCanvas._jsPlumb = null;

                if (this.canvas && this.canvas.parentNode)
                    this.canvas.parentNode.removeChild(this.canvas);
                if (this.bgCanvas && this.bgCanvas.parentNode)
                    this.canvas.parentNode.removeChild(this.canvas);

                this.svg = null;
                this.canvas = null;
                this.path = null;
                this.group = null;
            }
            else {
                // if not a forced cleanup, just detach from DOM for now.
                if (this.canvas && this.canvas.parentNode) this.canvas.parentNode.removeChild(this.canvas);
                if (this.bgCanvas && this.bgCanvas.parentNode) this.bgCanvas.parentNode.removeChild(this.bgCanvas);
            }
        },
        reattach:function(instance) {
            var c = instance.getContainer();
            if (this.canvas && this.canvas.parentNode == null) c.appendChild(this.canvas);
            if (this.bgCanvas && this.bgCanvas.parentNode == null) c.appendChild(this.bgCanvas);
        },
        setVisible: function (v) {
            if (this.canvas) {
                this.canvas.style.display = v ? "block" : "none";
            }
        }
    });

    /*
     * Base class for SVG connectors.
     */
    _jp.ConnectorRenderers.svg = function (params) {
        var self = this,
            _super = SvgComponent.apply(this, [
                {
                    cssClass: params._jsPlumb.connectorClass + (this.isEditable() ? " " + params._jsPlumb.editableConnectorClass : ""),
                    originalArgs: arguments,
                    pointerEventsSpec: "none",
                    _jsPlumb: params._jsPlumb
                }
            ]);

        var _superSetEditable = this.setEditable;
        this.setEditable = function(e) {
            var result = _superSetEditable.apply(this, [e]);
            jsPlumb[result ? "addClass" : "removeClass"](this.canvas, this._jsPlumb.instance.editableConnectorClass);
        };

        _super.renderer.paint = function (style, anchor, extents) {

            var segments = self.getSegments(), p = "", offset = [0, 0];
            if (extents.xmin < 0) offset[0] = -extents.xmin;
            if (extents.ymin < 0) offset[1] = -extents.ymin;

            if (segments.length > 0) {

                // create path from segments.
                for (var i = 0; i < segments.length; i++) {
                    p += _jp.Segments.svg.SegmentRenderer.getPath(segments[i]);
                    p += " ";
                }

                var a = {
                        d: p,
                        transform: "translate(" + offset[0] + "," + offset[1] + ")",
                        "pointer-events": params["pointer-events"] || "visibleStroke"
                    },
                    outlineStyle = null,
                    d = [self.x, self.y, self.w, self.h];

                // outline style.  actually means drawing an svg object underneath the main one.
                if (style.outlineColor) {
                    var outlineWidth = style.outlineWidth || 1,
                        outlineStrokeWidth = style.lineWidth + (2 * outlineWidth);
                    outlineStyle = _jp.extend({}, style);
                    delete outlineStyle.gradient;
                    outlineStyle.strokeStyle = style.outlineColor;
                    outlineStyle.lineWidth = outlineStrokeWidth;

                    if (self.bgPath == null) {
                        self.bgPath = _node("path", a);
                        _jp.addClass(self.bgPath, _jp.connectorOutlineClass);
                        _appendAtIndex(self.svg, self.bgPath, 0);
                    }
                    else {
                        _attr(self.bgPath, a);
                    }

                    _applyStyles(self.svg, self.bgPath, outlineStyle, d, self);
                }

                if (self.path == null) {
                    self.path = _node("path", a);
                    _appendAtIndex(self.svg, self.path, style.outlineColor ? 1 : 0);
                }
                else {
                    _attr(self.path, a);
                }

                _applyStyles(self.svg, self.path, style, d, self);
            }
        };
    };
    _ju.extend(_jp.ConnectorRenderers.svg, SvgComponent);

// ******************************* svg segment renderer *****************************************************	

    _jp.Segments.svg = {
        SegmentRenderer: {
            getPath: function (segment) {
                return ({
                    "Straight": function () {
                        var d = segment.getCoordinates();
                        return "M " + d.x1 + " " + d.y1 + " L " + d.x2 + " " + d.y2;
                    },
                    "Bezier": function () {
                        var d = segment.params;
                        return "M " + d.x1 + " " + d.y1 +
                            " C " + d.cp1x + " " + d.cp1y + " " + d.cp2x + " " + d.cp2y + " " + d.x2 + " " + d.y2;
                    },
                    "Arc": function () {
                        var d = segment.params,
                            laf = segment.sweep > Math.PI ? 1 : 0,
                            sf = segment.anticlockwise ? 0 : 1;

                        return "M" + segment.x1 + " " + segment.y1 + " A " + segment.radius + " " + d.r + " 0 " + laf + "," + sf + " " + segment.x2 + " " + segment.y2;
                    }
                })[segment.type]();
            }
        }
    };

// ******************************* /svg segments *****************************************************

    /*
     * Base class for SVG endpoints.
     */
    var SvgEndpoint = _jp.SvgEndpoint = function (params) {
        var _super = SvgComponent.apply(this, [
            {
                cssClass: params._jsPlumb.endpointClass,
                originalArgs: arguments,
                pointerEventsSpec: "all",
                useDivWrapper: true,
                _jsPlumb: params._jsPlumb
            }
        ]);

        _super.renderer.paint = function (style) {
            var s = _jp.extend({}, style);
            if (s.outlineColor) {
                s.strokeWidth = s.outlineWidth;
                s.strokeStyle = s.outlineColor;
            }

            if (this.node == null) {
                this.node = this.makeNode(s);
                this.svg.appendChild(this.node);
            }
            else if (this.updateNode != null) {
                this.updateNode(this.node);
            }
            _applyStyles(this.svg, this.node, s, [ this.x, this.y, this.w, this.h ], this);
            _pos(this.node, [ this.x, this.y ]);
        }.bind(this);

    };
    _ju.extend(SvgEndpoint, SvgComponent);

    /*
     * SVG Dot Endpoint
     */
    _jp.Endpoints.svg.Dot = function () {
        _jp.Endpoints.Dot.apply(this, arguments);
        SvgEndpoint.apply(this, arguments);
        this.makeNode = function (style) {
            return _node("circle", {
                "cx": this.w / 2,
                "cy": this.h / 2,
                "r": this.radius
            });
        };
        this.updateNode = function (node) {
            _attr(node, {
                "cx": this.w / 2,
                "cy": this.h / 2,
                "r": this.radius
            });
        };
    };
    _ju.extend(_jp.Endpoints.svg.Dot, [_jp.Endpoints.Dot, SvgEndpoint]);

    /*
     * SVG Rectangle Endpoint
     */
    _jp.Endpoints.svg.Rectangle = function () {
        _jp.Endpoints.Rectangle.apply(this, arguments);
        SvgEndpoint.apply(this, arguments);
        this.makeNode = function (style) {
            return _node("rect", {
                "width": this.w,
                "height": this.h
            });
        };
        this.updateNode = function (node) {
            _attr(node, {
                "width": this.w,
                "height": this.h
            });
        };
    };
    _ju.extend(_jp.Endpoints.svg.Rectangle, [_jp.Endpoints.Rectangle, SvgEndpoint]);

    /*
     * SVG Image Endpoint is the default image endpoint.
     */
    _jp.Endpoints.svg.Image = _jp.Endpoints.Image;
    /*
     * Blank endpoint in svg renderer is the default Blank endpoint.
     */
    _jp.Endpoints.svg.Blank = _jp.Endpoints.Blank;
    /*
     * Label overlay in svg renderer is the default Label overlay.
     */
    _jp.Overlays.svg.Label = _jp.Overlays.Label;
    /*
     * Custom overlay in svg renderer is the default Custom overlay.
     */
    _jp.Overlays.svg.Custom = _jp.Overlays.Custom;

    var AbstractSvgArrowOverlay = function (superclass, originalArgs) {
        superclass.apply(this, originalArgs);
        _jp.jsPlumbUIComponent.apply(this, originalArgs);
        this.isAppendedAtTopLevel = false;
        var self = this;
        this.path = null;
        this.paint = function (params, containerExtents) {
            // only draws on connections, not endpoints.
            if (params.component.svg && containerExtents) {
                if (this.path == null) {
                    this.path = _node("path", {
                        "pointer-events": "all"
                    });
                    params.component.svg.appendChild(this.path);
                    if (this.elementCreated) {
                        this.elementCreated(this.path, params.component);
                    }

                    this.canvas = params.component.svg; // for the sake of completeness; this behaves the same as other overlays
                }
                var clazz = originalArgs && (originalArgs.length == 1) ? (originalArgs[0].cssClass || "") : "",
                    offset = [0, 0];

                if (containerExtents.xmin < 0) offset[0] = -containerExtents.xmin;
                if (containerExtents.ymin < 0) offset[1] = -containerExtents.ymin;

                _attr(this.path, {
                    "d": makePath(params.d),
                    "class": clazz,
                    stroke: params.strokeStyle ? params.strokeStyle : null,
                    fill: params.fillStyle ? params.fillStyle : null,
                    transform: "translate(" + offset[0] + "," + offset[1] + ")"
                });
            }
        };
        var makePath = function (d) {
            return (isNaN(d.cxy.x) || isNaN(d.cxy.y)) ? "" : "M" + d.hxy.x + "," + d.hxy.y +
                " L" + d.tail[0].x + "," + d.tail[0].y +
                " L" + d.cxy.x + "," + d.cxy.y +
                " L" + d.tail[1].x + "," + d.tail[1].y +
                " L" + d.hxy.x + "," + d.hxy.y;
        };
        this.transfer = function(target) {
            if (target.canvas && this.path && this.path.parentNode) {
                this.path.parentNode.removeChild(this.path);
                target.canvas.appendChild(this.path);
            }
        };
    };
    _ju.extend(AbstractSvgArrowOverlay, [_jp.jsPlumbUIComponent, _jp.Overlays.AbstractOverlay], {
        cleanup: function (force) {
            if (this.path != null) {
                if (force)
                    this._jsPlumb.instance.removeElement(this.path);
                else
                    if (this.path.parentNode)
                        this.path.parentNode.removeChild(this.path);
            }
        },
        reattach:function(instance) {
            if (this.path && this.canvas && this.path.parentNode == null)
                this.canvas.appendChild(this.path);
        },
        setVisible: function (v) {
            if (this.path != null) (this.path.style.display = (v ? "block" : "none"));
        }
    });

    _jp.Overlays.svg.Arrow = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.Arrow, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.Arrow, [ _jp.Overlays.Arrow, AbstractSvgArrowOverlay ]);

    _jp.Overlays.svg.PlainArrow = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.PlainArrow, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.PlainArrow, [ _jp.Overlays.PlainArrow, AbstractSvgArrowOverlay ]);

    _jp.Overlays.svg.Diamond = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.Diamond, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.Diamond, [ _jp.Overlays.Diamond, AbstractSvgArrowOverlay ]);

    // a test
    _jp.Overlays.svg.GuideLines = function () {
        var path = null, self = this, p1_1, p1_2;
        _jp.Overlays.GuideLines.apply(this, arguments);
        this.paint = function (params, containerExtents) {
            if (path == null) {
                path = _node("path");
                params.connector.svg.appendChild(path);
                self.attachListeners(path, params.connector);
                self.attachListeners(path, self);

                p1_1 = _node("path");
                params.connector.svg.appendChild(p1_1);
                self.attachListeners(p1_1, params.connector);
                self.attachListeners(p1_1, self);

                p1_2 = _node("path");
                params.connector.svg.appendChild(p1_2);
                self.attachListeners(p1_2, params.connector);
                self.attachListeners(p1_2, self);
            }

            var offset = [0, 0];
            if (containerExtents.xmin < 0) offset[0] = -containerExtents.xmin;
            if (containerExtents.ymin < 0) offset[1] = -containerExtents.ymin;

            _attr(path, {
                "d": makePath(params.head, params.tail),
                stroke: "red",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });

            _attr(p1_1, {
                "d": makePath(params.tailLine[0], params.tailLine[1]),
                stroke: "blue",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });

            _attr(p1_2, {
                "d": makePath(params.headLine[0], params.headLine[1]),
                stroke: "green",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });
        };

        var makePath = function (d1, d2) {
            return "M " + d1.x + "," + d1.y +
                " L" + d2.x + "," + d2.y;
        };
    };
    _ju.extend(_jp.Overlays.svg.GuideLines, _jp.Overlays.GuideLines);
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.1.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the 'vanilla' adapter - having no external dependencies other than bundled libs.
 *
 * Copyright (c) 2010 - 2016 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil,
        _jk = root.Katavorio, _jg = root.Biltong;

    var _getDragManager = function (instance, category) {

        category = category || "main";
        var key = "_katavorio_" + category;
        var k = instance[key],
            e = instance.getEventManager();

        if (!k) {
            k = new _jk({
                bind: e.on,
                unbind: e.off,
                getSize: jsPlumb.getSize,
                getPosition: function (el, relativeToRoot) {
                    // if this is a nested draggable then compute the offset against its own offsetParent, otherwise
                    // compute against the Container's origin. see also the getUIPosition method below.
                    var o = instance.getOffset(el, relativeToRoot, el._katavorioDrag ? el.offsetParent : null);
                    return [o.left, o.top];
                },
                setPosition: function (el, xy) {
                    el.style.left = xy[0] + "px";
                    el.style.top = xy[1] + "px";
                },
                addClass: jsPlumb.addClass,
                removeClass: jsPlumb.removeClass,
                intersects: _jg.intersects,
                indexOf: function(l, i) { return l.indexOf(i); },
                css: {
                    noSelect: instance.dragSelectClass,
                    droppable: "jsplumb-droppable",
                    draggable: "jsplumb-draggable",
                    drag: "jsplumb-drag",
                    selected: "jsplumb-drag-selected",
                    active: "jsplumb-drag-active",
                    hover: "jsplumb-drag-hover",
                    ghostProxy:"jsplumb-ghost-proxy"
                }
            });
            instance[key] = k;
            instance.bind("zoom", k.setZoom);
        }
        return k;
    };

    var _animProps = function (o, p) {
        var _one = function (pName) {
            if (p[pName] != null) {
                if (_ju.isString(p[pName])) {
                    var m = p[pName].match(/-=/) ? -1 : 1,
                        v = p[pName].substring(2);
                    return o[pName] + (m * v);
                }
                else return p[pName];
            }
            else
                return o[pName];
        };
        return [ _one("left"), _one("top") ];
    };

    _jp.extend(root.jsPlumbInstance.prototype, {

        animationSupported:true,
        getElement: function (el) {
            if (el == null) return null;
            // here we pluck the first entry if el was a list of entries.
            // this is not my favourite thing to do, but previous versions of
            // jsplumb supported jquery selectors, and it is possible a selector
            // will be passed in here.
            el = typeof el === "string" ? el : el.length != null && el.enctype == null ? el[0] : el;
            return typeof el === "string" ? document.getElementById(el) : el;
        },
        removeElement: function (element) {
            _getDragManager(this).elementRemoved(element);
            this.getEventManager().remove(element);
        },
        //
        // this adapter supports a rudimentary animation function. no easing is supported.  only
        // left/top properties are supported. property delta args are expected to be in the form
        //
        // +=x.xxxx
        //
        // or
        //
        // -=x.xxxx
        //
        doAnimate: function (el, properties, options) {
            options = options || {};
            var o = this.getOffset(el),
                ap = _animProps(o, properties),
                ldist = ap[0] - o.left,
                tdist = ap[1] - o.top,
                d = options.duration || 250,
                step = 15, steps = d / step,
                linc = (step / d) * ldist,
                tinc = (step / d) * tdist,
                idx = 0,
                _int = setInterval(function () {
                    jsPlumb.setPosition(el, {
                        left: o.left + (linc * (idx + 1)),
                        top: o.top + (tinc * (idx + 1))
                    });
                    if (options.step != null) options.step(idx, Math.ceil(steps));
                    idx++;
                    if (idx >= steps) {
                        window.clearInterval(_int);
                        if (options.complete != null) options.complete();
                    }
                }, step);
        },
        // DRAG/DROP
        destroyDraggable: function (el, category) {
            _getDragManager(this, category).destroyDraggable(el);
        },
        destroyDroppable: function (el, category) {
            _getDragManager(this, category).destroyDroppable(el);
        },
        initDraggable: function (el, options, category) {
            _getDragManager(this, category).draggable(el, options);
        },
        initDroppable: function (el, options, category) {
            _getDragManager(this, category).droppable(el, options);
        },
        isAlreadyDraggable: function (el) {
            return el._katavorioDrag != null;
        },
        isDragSupported: function (el, options) {
            return true;
        },
        isDropSupported: function (el, options) {
            return true;
        },
        isElementDraggable: function (el) {
            el = jsPlumb.getElement(el);
            return el._katavorioDrag && el._katavorioDrag.isEnabled();
        },
        getDragObject: function (eventArgs) {
            return eventArgs[0].drag.getDragElement();
        },
        getDragScope: function (el) {
            return el._katavorioDrag && el._katavorioDrag.scopes.join(" ") || "";
        },
        getDropEvent: function (args) {
            return args[0].e;
        },
        getUIPosition: function (eventArgs, zoom) {
            // here the position reported to us by Katavorio is relative to the element's offsetParent. For top
            // level nodes that is fine, but if we have a nested draggable then its offsetParent is actually
            // not going to be the jsplumb container; it's going to be some child of that element. In that case
            // we want to adjust the UI position to account for the offsetParent's position relative to the Container
            // origin.
            var el = eventArgs[0].el;
            if (el.offsetParent == null) {
                return null;
            }
            var finalPos = eventArgs[0].finalPos || eventArgs[0].pos;
            var p = { left:finalPos[0], top:finalPos[1] };
            if (el._katavorioDrag && el.offsetParent !== this.getContainer()) {
                var oc = this.getOffset(el.offsetParent);
                p.left += oc.left;
                p.top += oc.top;
            }
            return p;
        },
        setDragFilter: function (el, filter, _exclude) {
            if (el._katavorioDrag) {
                el._katavorioDrag.setFilter(filter, _exclude);
            }
        },
        setElementDraggable: function (el, draggable) {
            el = jsPlumb.getElement(el);
            if (el._katavorioDrag)
                el._katavorioDrag.setEnabled(draggable);
        },
        setDragScope: function (el, scope) {
            if (el._katavorioDrag)
                el._katavorioDrag.k.setDragScope(el, scope);
        },
        setDropScope:function(el, scope) {
            if (el._katavorioDrop && el._katavorioDrop.length > 0) {
                el._katavorioDrop[0].k.setDropScope(el, scope);
            }
        },
        addToPosse:function(el, spec) {
            var specs = Array.prototype.slice.call(arguments, 1);
            var dm = _getDragManager(this);
            jsPlumb.each(el, function(_el) {
                _el = [ jsPlumb.getElement(_el) ];
                _el.push.apply(_el, specs );
                dm.addToPosse.apply(dm, _el);
            });
        },
        setPosse:function(el, spec) {
            var specs = Array.prototype.slice.call(arguments, 1);
            var dm = _getDragManager(this);
            jsPlumb.each(el, function(_el) {
                _el = [ jsPlumb.getElement(_el) ];
                _el.push.apply(_el, specs );
                dm.setPosse.apply(dm, _el);
            });
        },
        removeFromPosse:function(el, posseId) {
            var specs = Array.prototype.slice.call(arguments, 1);
            var dm = _getDragManager(this);
            jsPlumb.each(el, function(_el) {
                _el = [ jsPlumb.getElement(_el) ];
                _el.push.apply(_el, specs );
                dm.removeFromPosse.apply(dm, _el);
            });
        },
        removeFromAllPosses:function(el) {
            var dm = _getDragManager(this);
            jsPlumb.each(el, function(_el) { dm.removeFromAllPosses(jsPlumb.getElement(_el)); });
        },
        setPosseState:function(el, posseId, state) {
            var dm = _getDragManager(this);
            jsPlumb.each(el, function(_el) { dm.setPosseState(jsPlumb.getElement(_el), posseId, state); });
        },
        dragEvents: {
            'start': 'start', 'stop': 'stop', 'drag': 'drag', 'step': 'step',
            'over': 'over', 'out': 'out', 'drop': 'drop', 'complete': 'complete',
            'beforeStart':'beforeStart'
        },
        animEvents: {
            'step': "step", 'complete': 'complete'
        },
        stopDrag: function (el) {
            if (el._katavorioDrag)
                el._katavorioDrag.abort();
        },
        addToDragSelection: function (spec) {
            _getDragManager(this).select(spec);
        },
        removeFromDragSelection: function (spec) {
            _getDragManager(this).deselect(spec);
        },
        clearDragSelection: function () {
            _getDragManager(this).deselectAll();
        },
        trigger: function (el, event, originalEvent, payload) {
            this.getEventManager().trigger(el, event, originalEvent, payload);
        },
        doReset:function() {
            // look for katavorio instances and reset each one if found.
            for (var key in this) {
                if (key.indexOf("_katavorio_") === 0) {
                    this[key].reset();
                }
            }
        }
    });

    var ready = function (f) {
        var _do = function () {
            if (/complete|loaded|interactive/.test(document.readyState) && typeof(document.body) != "undefined" && document.body != null)
                f();
            else
                setTimeout(_do, 9);
        };

        _do();
    };
    ready(_jp.init);

}).call(typeof window !== 'undefined' ? window : this);

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbnB1dC5qcyIsIm5vZGVfbW9kdWxlcy9qc3BsdW1iL2Rpc3QvanMvanNQbHVtYi0yLjEuMC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIganNQbHVtYiA9IHJlcXVpcmUoJ2pzcGx1bWInKTtcbmpzUGx1bWIucmVhZHkoZnVuY3Rpb24oKSB7XG4gIGFsZXJ0KFwiaGlcIik7XG4gIHZhciBqc3AgPSBqc1BsdW1iLmdldEluc3RhbmNlKCk7XG4gIGpzcC5jb25uZWN0KHtzb3VyY2U6XCJvbmVcIiwgdGFyZ2V0OlwidHdvXCJ9KTtcbiAganNwLmRyYWdnYWJsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiZGl2XCIpKTtcbn0pO1xuXG4iLCIvKipcbiAqIGpzQmV6aWVyLTAuOFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTYganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxuICpcbiAqIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqXG4gKiBhIHNldCBvZiBCZXppZXIgY3VydmUgZnVuY3Rpb25zIHRoYXQgZGVhbCB3aXRoIEJlemllcnMsIHVzZWQgYnkganNQbHVtYiwgYW5kIHBlcmhhcHMgdXNlZnVsIGZvciBvdGhlciBwZW9wbGUuICBUaGVzZSBmdW5jdGlvbnMgd29yayB3aXRoIEJlemllclxuICogY3VydmVzIG9mIGFyYml0cmFyeSBkZWdyZWUuXG4gKlxuICogLSBmdW5jdGlvbnMgYXJlIGFsbCBpbiB0aGUgJ2pzQmV6aWVyJyBuYW1lc3BhY2UuXG4gKlxuICogLSBhbGwgaW5wdXQgcG9pbnRzIHNob3VsZCBiZSBpbiB0aGUgZm9ybWF0IHt4Oi4uLCB5Oi4ufS4gYWxsIG91dHB1dCBwb2ludHMgYXJlIGluIHRoaXMgZm9ybWF0IHRvby5cbiAqXG4gKiAtIGFsbCBpbnB1dCBjdXJ2ZXMgc2hvdWxkIGJlIGluIHRoZSBmb3JtYXQgWyB7eDouLiwgeTouLn0sIHt4Oi4uLCB5Oi4ufSwge3g6Li4sIHk6Li59LCB7eDouLiwgeTouLn0gXVxuICpcbiAqIC0gJ2xvY2F0aW9uJyBhcyB1c2VkIGFzIGFuIGlucHV0IGhlcmUgcmVmZXJzIHRvIGEgZGVjaW1hbCBpbiB0aGUgcmFuZ2UgMC0xIGluY2x1c2l2ZSwgd2hpY2ggaW5kaWNhdGVzIGEgcG9pbnQgc29tZSBwcm9wb3J0aW9uIGFsb25nIHRoZSBsZW5ndGhcbiAqIG9mIHRoZSBjdXJ2ZS4gIGxvY2F0aW9uIGFzIG91dHB1dCBoYXMgdGhlIHNhbWUgZm9ybWF0IGFuZCBtZWFuaW5nLlxuICpcbiAqXG4gKiBGdW5jdGlvbiBMaXN0OlxuICogLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBkaXN0YW5jZUZyb21DdXJ2ZShwb2ludCwgY3VydmUpXG4gKlxuICogXHRDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSB0aGF0IHRoZSBnaXZlbiBwb2ludCBsaWVzIGZyb20gdGhlIGdpdmVuIEJlemllci4gIE5vdGUgdGhhdCBpdCBpcyBjb21wdXRlZCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIHRoZSBCZXppZXIsXG4gKiBzbyBpZiB5b3UgaGF2ZSBzdHJva2VkIHRoZSBjdXJ2ZSB3aXRoIGEgd2lkZSBwZW4geW91IG1heSB3aXNoIHRvIHRha2UgdGhhdCBpbnRvIGFjY291bnQhICBUaGUgZGlzdGFuY2UgcmV0dXJuZWQgaXMgcmVsYXRpdmUgdG8gdGhlIHZhbHVlc1xuICogb2YgdGhlIGN1cnZlIGFuZCB0aGUgcG9pbnQgLSBpdCB3aWxsIG1vc3QgbGlrZWx5IGJlIHBpeGVscy5cbiAqXG4gKiBncmFkaWVudEF0UG9pbnQoY3VydmUsIGxvY2F0aW9uKVxuICpcbiAqIFx0Q2FsY3VsYXRlcyB0aGUgZ3JhZGllbnQgdG8gdGhlIGN1cnZlIGF0IHRoZSBnaXZlbiBsb2NhdGlvbiwgYXMgYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmUuXG4gKlxuICogZ3JhZGllbnRBdFBvaW50QWxvbmdDdXJ2ZUZyb20gKGN1cnZlLCBsb2NhdGlvbilcbiAqXG4gKlx0Q2FsY3VsYXRlcyB0aGUgZ3JhZGllbnQgYXQgdGhlIHBvaW50IG9uIHRoZSBnaXZlbiBjdXJ2ZSB0aGF0IGlzICdkaXN0YW5jZScgdW5pdHMgZnJvbSBsb2NhdGlvbi5cbiAqXG4gKiBuZWFyZXN0UG9pbnRPbkN1cnZlKHBvaW50LCBjdXJ2ZSlcbiAqXG4gKlx0Q2FsY3VsYXRlcyB0aGUgbmVhcmVzdCBwb2ludCB0byB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGdpdmVuIGN1cnZlLiAgVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGlzIGEgSlMgb2JqZWN0IGxpdGVyYWwsIGNvbnRhaW5pbmcgYm90aCB0aGVcbiAqcG9pbnQncyBjb29yZGluYXRlcyBhbmQgYWxzbyB0aGUgJ2xvY2F0aW9uJyBvZiB0aGUgcG9pbnQgKHNlZSBhYm92ZSksIGZvciBleGFtcGxlOiAgeyBwb2ludDp7eDo1NTEseToxNTB9LCBsb2NhdGlvbjowLjI2MzM2NSB9LlxuICpcbiAqIHBvaW50T25DdXJ2ZShjdXJ2ZSwgbG9jYXRpb24pXG4gKlxuICogXHRDYWxjdWxhdGVzIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgb24gdGhlIGdpdmVuIEJlemllciBjdXJ2ZSBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uXG4gKlxuICogcG9pbnRBbG9uZ0N1cnZlRnJvbShjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKVxuICpcbiAqIFx0Q2FsY3VsYXRlcyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IG9uIHRoZSBnaXZlbiBjdXJ2ZSB0aGF0IGlzICdkaXN0YW5jZScgdW5pdHMgZnJvbSBsb2NhdGlvbi4gICdkaXN0YW5jZScgc2hvdWxkIGJlIGluIHRoZSBzYW1lIGNvb3JkaW5hdGVcbiAqIHNwYWNlIGFzIHRoYXQgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIEJlemllciBjdXJ2ZS4gIEZvciBhbiBIVE1MIENhbnZhcyB1c2FnZSwgZm9yIGV4YW1wbGUsIGRpc3RhbmNlIHdvdWxkIGJlIGEgbWVhc3VyZSBvZiBwaXhlbHMuXG4gKlxuICogbG9jYXRpb25BbG9uZ0N1cnZlRnJvbShjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKVxuICpcbiAqIFx0Q2FsY3VsYXRlcyB0aGUgbG9jYXRpb24gb24gdGhlIGdpdmVuIGN1cnZlIHRoYXQgaXMgJ2Rpc3RhbmNlJyB1bml0cyBmcm9tIGxvY2F0aW9uLiAgJ2Rpc3RhbmNlJyBzaG91bGQgYmUgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZVxuICogc3BhY2UgYXMgdGhhdCB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgQmV6aWVyIGN1cnZlLiAgRm9yIGFuIEhUTUwgQ2FudmFzIHVzYWdlLCBmb3IgZXhhbXBsZSwgZGlzdGFuY2Ugd291bGQgYmUgYSBtZWFzdXJlIG9mIHBpeGVscy5cbiAqXG4gKiBwZXJwZW5kaWN1bGFyVG9DdXJ2ZUF0KGN1cnZlLCBsb2NhdGlvbiwgbGVuZ3RoLCBkaXN0YW5jZSlcbiAqXG4gKiBcdENhbGN1bGF0ZXMgdGhlIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGdpdmVuIGN1cnZlIGF0IHRoZSBnaXZlbiBsb2NhdGlvbi4gIGxlbmd0aCBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIHlvdSB3aXNoIGZvciAoaXQgd2lsbCBiZSBjZW50ZXJlZFxuICogb24gdGhlIHBvaW50IGF0ICdsb2NhdGlvbicpLiBkaXN0YW5jZSBpcyBvcHRpb25hbCwgYW5kIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBhIHBvaW50IGFsb25nIHRoZSBwYXRoIGZyb20gdGhlIGdpdmVuIGxvY2F0aW9uIGFzIHRoZSBjZW50ZXIgb2ZcbiAqIHRoZSBwZXJwZW5kaWN1bGFyIHJldHVybmVkLiAgVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGlzIGFuIGFycmF5IG9mIHR3byBwb2ludHM6IFsge3g6Li4uLHk6Li4ufSwge3g6Li4uLHk6Li4ufSBdLlxuICpcbiAqXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gICAgaWYodHlwZW9mIE1hdGguc2duID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgTWF0aC5zZ24gPSBmdW5jdGlvbih4KSB7IHJldHVybiB4ID09IDAgPyAwIDogeCA+IDAgPyAxIDotMTsgfTtcbiAgICB9XG5cbiAgICB2YXIgVmVjdG9ycyA9IHtcbiAgICAgICAgICAgIHN1YnRyYWN0IFx0OiBcdGZ1bmN0aW9uKHYxLCB2MikgeyByZXR1cm4ge3g6djEueCAtIHYyLngsIHk6djEueSAtIHYyLnkgfTsgfSxcbiAgICAgICAgICAgIGRvdFByb2R1Y3RcdDogXHRmdW5jdGlvbih2MSwgdjIpIHsgcmV0dXJuICh2MS54ICogdjIueCkgICsgKHYxLnkgKiB2Mi55KTsgfSxcbiAgICAgICAgICAgIHNxdWFyZVx0XHQ6XHRmdW5jdGlvbih2KSB7IHJldHVybiBNYXRoLnNxcnQoKHYueCAqIHYueCkgKyAodi55ICogdi55KSk7IH0sXG4gICAgICAgICAgICBzY2FsZVx0XHQ6XHRmdW5jdGlvbih2LCBzKSB7IHJldHVybiB7eDp2LnggKiBzLCB5OnYueSAqIHMgfTsgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heFJlY3Vyc2lvbiA9IDY0LFxuICAgICAgICBmbGF0bmVzc1RvbGVyYW5jZSA9IE1hdGgucG93KDIuMCwtbWF4UmVjdXJzaW9uLTEpO1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgdGhhdCB0aGUgcG9pbnQgbGllcyBmcm9tIHRoZSBjdXJ2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2ludCBhIHBvaW50IGluIHRoZSBmb3JtIHt4OjU2NywgeTozMzQyfVxuICAgICAqIEBwYXJhbSBjdXJ2ZSBhIEJlemllciBjdXJ2ZSBpbiB0aGUgZm9ybSBbe3g6Li4uLCB5Oi4uLn0sIHt4Oi4uLiwgeTouLi59LCB7eDouLi4sIHk6Li4ufSwge3g6Li4uLCB5Oi4uLn1dLiAgbm90ZSB0aGF0IHRoaXMgaXMgY3VycmVudGx5XG4gICAgICogaGFyZGNvZGVkIHRvIGFzc3VtZSBjdWJpeiBiZXppZXJzLCBidXQgd291bGQgYmUgYmV0dGVyIG9mZiBzdXBwb3J0aW5nIGFueSBkZWdyZWUuXG4gICAgICogQHJldHVybiBhIEpTIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgbG9jYXRpb24gYW5kIGRpc3RhbmNlLCBmb3IgZXhhbXBsZToge2xvY2F0aW9uOjAuMzUsIGRpc3RhbmNlOjEwfS4gIExvY2F0aW9uIGlzIGFuYWxvZ291cyB0byB0aGUgbG9jYXRpb25cbiAgICAgKiBhcmd1bWVudCB5b3UgcGFzcyB0byB0aGUgcG9pbnRPblBhdGggZnVuY3Rpb246IGl0IGlzIGEgcmF0aW8gb2YgZGlzdGFuY2UgdHJhdmVsbGVkIGFsb25nIHRoZSBjdXJ2ZS4gIERpc3RhbmNlIGlzIHRoZSBkaXN0YW5jZSBpbiBwaXhlbHMgZnJvbVxuICAgICAqIHRoZSBwb2ludCB0byB0aGUgY3VydmUuXG4gICAgICovXG4gICAgdmFyIF9kaXN0YW5jZUZyb21DdXJ2ZSA9IGZ1bmN0aW9uKHBvaW50LCBjdXJ2ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IFtdLFxuICAgICAgICAgICAgdyA9IF9jb252ZXJ0VG9CZXppZXIocG9pbnQsIGN1cnZlKSxcbiAgICAgICAgICAgIGRlZ3JlZSA9IGN1cnZlLmxlbmd0aCAtIDEsIGhpZ2hlckRlZ3JlZSA9ICgyICogZGVncmVlKSAtIDEsXG4gICAgICAgICAgICBudW1Tb2x1dGlvbnMgPSBfZmluZFJvb3RzKHcsIGhpZ2hlckRlZ3JlZSwgY2FuZGlkYXRlcywgMCksXG4gICAgICAgICAgICB2ID0gVmVjdG9ycy5zdWJ0cmFjdChwb2ludCwgY3VydmVbMF0pLCBkaXN0ID0gVmVjdG9ycy5zcXVhcmUodiksIHQgPSAwLjA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Tb2x1dGlvbnM7IGkrKykge1xuICAgICAgICAgICAgdiA9IFZlY3RvcnMuc3VidHJhY3QocG9pbnQsIF9iZXppZXIoY3VydmUsIGRlZ3JlZSwgY2FuZGlkYXRlc1tpXSwgbnVsbCwgbnVsbCkpO1xuICAgICAgICAgICAgdmFyIG5ld0Rpc3QgPSBWZWN0b3JzLnNxdWFyZSh2KTtcbiAgICAgICAgICAgIGlmIChuZXdEaXN0IDwgZGlzdCkge1xuICAgICAgICAgICAgICAgIGRpc3QgPSBuZXdEaXN0O1xuICAgICAgICAgICAgICAgIHQgPSBjYW5kaWRhdGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHYgPSBWZWN0b3JzLnN1YnRyYWN0KHBvaW50LCBjdXJ2ZVtkZWdyZWVdKTtcbiAgICAgICAgbmV3RGlzdCA9IFZlY3RvcnMuc3F1YXJlKHYpO1xuICAgICAgICBpZiAobmV3RGlzdCA8IGRpc3QpIHtcbiAgICAgICAgICAgIGRpc3QgPSBuZXdEaXN0O1xuICAgICAgICAgICAgdCA9IDEuMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2xvY2F0aW9uOnQsIGRpc3RhbmNlOmRpc3R9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZmluZHMgdGhlIG5lYXJlc3QgcG9pbnQgb24gdGhlIGN1cnZlIHRvIHRoZSBnaXZlbiBwb2ludC5cbiAgICAgKi9cbiAgICB2YXIgX25lYXJlc3RQb2ludE9uQ3VydmUgPSBmdW5jdGlvbihwb2ludCwgY3VydmUpIHtcbiAgICAgICAgdmFyIHRkID0gX2Rpc3RhbmNlRnJvbUN1cnZlKHBvaW50LCBjdXJ2ZSk7XG4gICAgICAgIHJldHVybiB7cG9pbnQ6X2JlemllcihjdXJ2ZSwgY3VydmUubGVuZ3RoIC0gMSwgdGQubG9jYXRpb24sIG51bGwsIG51bGwpLCBsb2NhdGlvbjp0ZC5sb2NhdGlvbn07XG4gICAgfTtcbiAgICB2YXIgX2NvbnZlcnRUb0JlemllciA9IGZ1bmN0aW9uKHBvaW50LCBjdXJ2ZSkge1xuICAgICAgICB2YXIgZGVncmVlID0gY3VydmUubGVuZ3RoIC0gMSwgaGlnaGVyRGVncmVlID0gKDIgKiBkZWdyZWUpIC0gMSxcbiAgICAgICAgICAgIGMgPSBbXSwgZCA9IFtdLCBjZFRhYmxlID0gW10sIHcgPSBbXSxcbiAgICAgICAgICAgIHogPSBbIFsxLjAsIDAuNiwgMC4zLCAwLjFdLCBbMC40LCAwLjYsIDAuNiwgMC40XSwgWzAuMSwgMC4zLCAwLjYsIDEuMF0gXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBkZWdyZWU7IGkrKykgY1tpXSA9IFZlY3RvcnMuc3VidHJhY3QoY3VydmVbaV0sIHBvaW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZGVncmVlIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBkW2ldID0gVmVjdG9ycy5zdWJ0cmFjdChjdXJ2ZVtpKzFdLCBjdXJ2ZVtpXSk7XG4gICAgICAgICAgICBkW2ldID0gVmVjdG9ycy5zY2FsZShkW2ldLCAzLjApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8PSBkZWdyZWUgLSAxOyByb3crKykge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDw9IGRlZ3JlZTsgY29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNkVGFibGVbcm93XSkgY2RUYWJsZVtyb3ddID0gW107XG4gICAgICAgICAgICAgICAgY2RUYWJsZVtyb3ddW2NvbHVtbl0gPSBWZWN0b3JzLmRvdFByb2R1Y3QoZFtyb3ddLCBjW2NvbHVtbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gaGlnaGVyRGVncmVlOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghd1tpXSkgd1tpXSA9IFtdO1xuICAgICAgICAgICAgd1tpXS55ID0gMC4wO1xuICAgICAgICAgICAgd1tpXS54ID0gcGFyc2VGbG9hdChpKSAvIGhpZ2hlckRlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IGRlZ3JlZSwgbSA9IGRlZ3JlZS0xO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8PSBuICsgbTsgaysrKSB7XG4gICAgICAgICAgICB2YXIgbGIgPSBNYXRoLm1heCgwLCBrIC0gbSksXG4gICAgICAgICAgICAgICAgdWIgPSBNYXRoLm1pbihrLCBuKTtcbiAgICAgICAgICAgIGZvciAoaSA9IGxiOyBpIDw9IHViOyBpKyspIHtcbiAgICAgICAgICAgICAgICBqID0gayAtIGk7XG4gICAgICAgICAgICAgICAgd1tpK2pdLnkgKz0gY2RUYWJsZVtqXVtpXSAqIHpbal1baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjb3VudHMgaG93IG1hbnkgcm9vdHMgdGhlcmUgYXJlLlxuICAgICAqL1xuICAgIHZhciBfZmluZFJvb3RzID0gZnVuY3Rpb24odywgZGVncmVlLCB0LCBkZXB0aCkge1xuICAgICAgICB2YXIgbGVmdCA9IFtdLCByaWdodCA9IFtdLFxuICAgICAgICAgICAgbGVmdF9jb3VudCwgcmlnaHRfY291bnQsXG4gICAgICAgICAgICBsZWZ0X3QgPSBbXSwgcmlnaHRfdCA9IFtdO1xuXG4gICAgICAgIHN3aXRjaCAoX2dldENyb3NzaW5nQ291bnQodywgZGVncmVlKSkge1xuICAgICAgICAgICAgY2FzZSAwIDoge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxIDoge1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA+PSBtYXhSZWN1cnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdFswXSA9ICh3WzBdLnggKyB3W2RlZ3JlZV0ueCkgLyAyLjA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX2lzRmxhdEVub3VnaCh3LCBkZWdyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRbMF0gPSBfY29tcHV0ZVhJbnRlcmNlcHQodywgZGVncmVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9iZXppZXIodywgZGVncmVlLCAwLjUsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgbGVmdF9jb3VudCAgPSBfZmluZFJvb3RzKGxlZnQsICBkZWdyZWUsIGxlZnRfdCwgZGVwdGgrMSk7XG4gICAgICAgIHJpZ2h0X2NvdW50ID0gX2ZpbmRSb290cyhyaWdodCwgZGVncmVlLCByaWdodF90LCBkZXB0aCsxKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0X2NvdW50OyBpKyspIHRbaV0gPSBsZWZ0X3RbaV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmlnaHRfY291bnQ7IGkrKykgdFtpK2xlZnRfY291bnRdID0gcmlnaHRfdFtpXTtcbiAgICAgICAgcmV0dXJuIChsZWZ0X2NvdW50K3JpZ2h0X2NvdW50KTtcbiAgICB9O1xuICAgIHZhciBfZ2V0Q3Jvc3NpbmdDb3VudCA9IGZ1bmN0aW9uKGN1cnZlLCBkZWdyZWUpIHtcbiAgICAgICAgdmFyIG5fY3Jvc3NpbmdzID0gMCwgc2lnbiwgb2xkX3NpZ247XG4gICAgICAgIHNpZ24gPSBvbGRfc2lnbiA9IE1hdGguc2duKGN1cnZlWzBdLnkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBkZWdyZWU7IGkrKykge1xuICAgICAgICAgICAgc2lnbiA9IE1hdGguc2duKGN1cnZlW2ldLnkpO1xuICAgICAgICAgICAgaWYgKHNpZ24gIT0gb2xkX3NpZ24pIG5fY3Jvc3NpbmdzKys7XG4gICAgICAgICAgICBvbGRfc2lnbiA9IHNpZ247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5fY3Jvc3NpbmdzO1xuICAgIH07XG4gICAgdmFyIF9pc0ZsYXRFbm91Z2ggPSBmdW5jdGlvbihjdXJ2ZSwgZGVncmVlKSB7XG4gICAgICAgIHZhciAgZXJyb3IsXG4gICAgICAgICAgICBpbnRlcmNlcHRfMSwgaW50ZXJjZXB0XzIsIGxlZnRfaW50ZXJjZXB0LCByaWdodF9pbnRlcmNlcHQsXG4gICAgICAgICAgICBhLCBiLCBjLCBkZXQsIGRJbnYsIGExLCBiMSwgYzEsIGEyLCBiMiwgYzI7XG4gICAgICAgIGEgPSBjdXJ2ZVswXS55IC0gY3VydmVbZGVncmVlXS55O1xuICAgICAgICBiID0gY3VydmVbZGVncmVlXS54IC0gY3VydmVbMF0ueDtcbiAgICAgICAgYyA9IGN1cnZlWzBdLnggKiBjdXJ2ZVtkZWdyZWVdLnkgLSBjdXJ2ZVtkZWdyZWVdLnggKiBjdXJ2ZVswXS55O1xuXG4gICAgICAgIHZhciBtYXhfZGlzdGFuY2VfYWJvdmUgPSBtYXhfZGlzdGFuY2VfYmVsb3cgPSAwLjA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBkZWdyZWU7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYSAqIGN1cnZlW2ldLnggKyBiICogY3VydmVbaV0ueSArIGM7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBtYXhfZGlzdGFuY2VfYWJvdmUpXG4gICAgICAgICAgICAgICAgbWF4X2Rpc3RhbmNlX2Fib3ZlID0gdmFsdWU7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IG1heF9kaXN0YW5jZV9iZWxvdylcbiAgICAgICAgICAgICAgICBtYXhfZGlzdGFuY2VfYmVsb3cgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGExID0gMC4wOyBiMSA9IDEuMDsgYzEgPSAwLjA7IGEyID0gYTsgYjIgPSBiO1xuICAgICAgICBjMiA9IGMgLSBtYXhfZGlzdGFuY2VfYWJvdmU7XG4gICAgICAgIGRldCA9IGExICogYjIgLSBhMiAqIGIxO1xuICAgICAgICBkSW52ID0gMS4wL2RldDtcbiAgICAgICAgaW50ZXJjZXB0XzEgPSAoYjEgKiBjMiAtIGIyICogYzEpICogZEludjtcbiAgICAgICAgYTIgPSBhOyBiMiA9IGI7IGMyID0gYyAtIG1heF9kaXN0YW5jZV9iZWxvdztcbiAgICAgICAgZGV0ID0gYTEgKiBiMiAtIGEyICogYjE7XG4gICAgICAgIGRJbnYgPSAxLjAvZGV0O1xuICAgICAgICBpbnRlcmNlcHRfMiA9IChiMSAqIGMyIC0gYjIgKiBjMSkgKiBkSW52O1xuICAgICAgICBsZWZ0X2ludGVyY2VwdCA9IE1hdGgubWluKGludGVyY2VwdF8xLCBpbnRlcmNlcHRfMik7XG4gICAgICAgIHJpZ2h0X2ludGVyY2VwdCA9IE1hdGgubWF4KGludGVyY2VwdF8xLCBpbnRlcmNlcHRfMik7XG4gICAgICAgIGVycm9yID0gcmlnaHRfaW50ZXJjZXB0IC0gbGVmdF9pbnRlcmNlcHQ7XG4gICAgICAgIHJldHVybiAoZXJyb3IgPCBmbGF0bmVzc1RvbGVyYW5jZSk/IDEgOiAwO1xuICAgIH07XG4gICAgdmFyIF9jb21wdXRlWEludGVyY2VwdCA9IGZ1bmN0aW9uKGN1cnZlLCBkZWdyZWUpIHtcbiAgICAgICAgdmFyIFhMSyA9IDEuMCwgWUxLID0gMC4wLFxuICAgICAgICAgICAgWE5NID0gY3VydmVbZGVncmVlXS54IC0gY3VydmVbMF0ueCwgWU5NID0gY3VydmVbZGVncmVlXS55IC0gY3VydmVbMF0ueSxcbiAgICAgICAgICAgIFhNSyA9IGN1cnZlWzBdLnggLSAwLjAsIFlNSyA9IGN1cnZlWzBdLnkgLSAwLjAsXG4gICAgICAgICAgICBkZXQgPSBYTk0qWUxLIC0gWU5NKlhMSywgZGV0SW52ID0gMS4wL2RldCxcbiAgICAgICAgICAgIFMgPSAoWE5NKllNSyAtIFlOTSpYTUspICogZGV0SW52O1xuICAgICAgICByZXR1cm4gMC4wICsgWExLICogUztcbiAgICB9O1xuICAgIHZhciBfYmV6aWVyID0gZnVuY3Rpb24oY3VydmUsIGRlZ3JlZSwgdCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBbW11dO1xuICAgICAgICBmb3IgKHZhciBqID0wOyBqIDw9IGRlZ3JlZTsgaisrKSB0ZW1wWzBdW2pdID0gY3VydmVbal07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGRlZ3JlZTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0wIDsgaiA8PSBkZWdyZWUgLSBpOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRlbXBbaV0pIHRlbXBbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRlbXBbaV1bal0pIHRlbXBbaV1bal0gPSB7fTtcbiAgICAgICAgICAgICAgICB0ZW1wW2ldW2pdLnggPSAoMS4wIC0gdCkgKiB0ZW1wW2ktMV1bal0ueCArIHQgKiB0ZW1wW2ktMV1baisxXS54O1xuICAgICAgICAgICAgICAgIHRlbXBbaV1bal0ueSA9ICgxLjAgLSB0KSAqIHRlbXBbaS0xXVtqXS55ICsgdCAqIHRlbXBbaS0xXVtqKzFdLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQgIT0gbnVsbClcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPD0gZGVncmVlOyBqKyspIGxlZnRbal0gID0gdGVtcFtqXVswXTtcbiAgICAgICAgaWYgKHJpZ2h0ICE9IG51bGwpXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDw9IGRlZ3JlZTsgaisrKSByaWdodFtqXSA9IHRlbXBbZGVncmVlLWpdW2pdO1xuXG4gICAgICAgIHJldHVybiAodGVtcFtkZWdyZWVdWzBdKTtcbiAgICB9O1xuXG4gICAgdmFyIF9jdXJ2ZUZ1bmN0aW9uQ2FjaGUgPSB7fTtcbiAgICB2YXIgX2dldEN1cnZlRnVuY3Rpb25zID0gZnVuY3Rpb24ob3JkZXIpIHtcbiAgICAgICAgdmFyIGZucyA9IF9jdXJ2ZUZ1bmN0aW9uQ2FjaGVbb3JkZXJdO1xuICAgICAgICBpZiAoIWZucykge1xuICAgICAgICAgICAgZm5zID0gW107XG4gICAgICAgICAgICB2YXIgZl90ZXJtID0gZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jdGlvbih0KSB7IHJldHVybiBNYXRoLnBvdyh0LCBvcmRlcik7IH07IH0sXG4gICAgICAgICAgICAgICAgbF90ZXJtID0gZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jdGlvbih0KSB7IHJldHVybiBNYXRoLnBvdygoMS10KSwgb3JkZXIpOyB9OyB9LFxuICAgICAgICAgICAgICAgIGNfdGVybSA9IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIGM7IH07IH0sXG4gICAgICAgICAgICAgICAgdF90ZXJtID0gZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jdGlvbih0KSB7IHJldHVybiB0OyB9OyB9LFxuICAgICAgICAgICAgICAgIG9uZV9taW51c190X3Rlcm0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIDEtdDsgfTsgfSxcbiAgICAgICAgICAgICAgICBfdGVybUZ1bmMgPSBmdW5jdGlvbih0ZXJtcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXJtcy5sZW5ndGg7IGkrKykgcCA9IHAgKiB0ZXJtc1tpXSh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZucy5wdXNoKG5ldyBmX3Rlcm0oKSk7ICAvLyBmaXJzdCBpcyB0IHRvIHRoZSBwb3dlciBvZiB0aGUgY3VydmUgb3JkZXJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgb3JkZXI7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtcyA9IFtuZXcgY190ZXJtKG9yZGVyKV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAgOyBqIDwgKG9yZGVyIC0gaSk7IGorKykgdGVybXMucHVzaChuZXcgdF90ZXJtKCkpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwIDsgaiA8IGk7IGorKykgdGVybXMucHVzaChuZXcgb25lX21pbnVzX3RfdGVybSgpKTtcbiAgICAgICAgICAgICAgICBmbnMucHVzaChuZXcgX3Rlcm1GdW5jKHRlcm1zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbnMucHVzaChuZXcgbF90ZXJtKCkpOyAgLy8gbGFzdCBpcyAoMS10KSB0byB0aGUgcG93ZXIgb2YgdGhlIGN1cnZlIG9yZGVyXG5cbiAgICAgICAgICAgIF9jdXJ2ZUZ1bmN0aW9uQ2FjaGVbb3JkZXJdID0gZm5zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZucztcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVzIGEgcG9pbnQgb24gdGhlIGN1cnZlLCBmb3IgYSBCZXppZXIgb2YgYXJiaXRyYXJ5IG9yZGVyLlxuICAgICAqIEBwYXJhbSBjdXJ2ZSBhbiBhcnJheSBvZiBjb250cm9sIHBvaW50cywgZWcgW3t4OjEwLHk6MjB9LCB7eDo1MCx5OjUwfSwge3g6MTAwLHk6MTAwfSwge3g6MTIwLHk6MTAwfV0uICBGb3IgYSBjdWJpYyBiZXppZXIgdGhpcyBzaG91bGQgaGF2ZSBmb3VyIHBvaW50cy5cbiAgICAgKiBAcGFyYW0gbG9jYXRpb24gYSBkZWNpbWFsIGluZGljYXRpbmcgdGhlIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZSB0aGUgcG9pbnQgc2hvdWxkIGJlIGxvY2F0ZWQgYXQuICB0aGlzIGlzIHRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUgYXMgaXQgdHJhdmVscywgdGFraW5nIHRoZSB3YXkgaXQgYmVuZHMgaW50byBhY2NvdW50LiAgc2hvdWxkIGJlIGEgbnVtYmVyIGZyb20gMCB0byAxLCBpbmNsdXNpdmUuXG4gICAgICovXG4gICAgdmFyIF9wb2ludE9uUGF0aCA9IGZ1bmN0aW9uKGN1cnZlLCBsb2NhdGlvbikge1xuICAgICAgICB2YXIgY2MgPSBfZ2V0Q3VydmVGdW5jdGlvbnMoY3VydmUubGVuZ3RoIC0gMSksXG4gICAgICAgICAgICBfeCA9IDAsIF95ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZS5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIF94ID0gX3ggKyAoY3VydmVbaV0ueCAqIGNjW2ldKGxvY2F0aW9uKSk7XG4gICAgICAgICAgICBfeSA9IF95ICsgKGN1cnZlW2ldLnkgKiBjY1tpXShsb2NhdGlvbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHt4Ol94LCB5Ol95fTtcbiAgICB9O1xuXG4gICAgdmFyIF9kaXN0ID0gZnVuY3Rpb24ocDEscDIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMS54IC0gcDIueCwgMikgKyBNYXRoLnBvdyhwMS55IC0gcDIueSwgMikpO1xuICAgIH07XG5cbiAgICB2YXIgX2lzUG9pbnQgPSBmdW5jdGlvbihjdXJ2ZSkge1xuICAgICAgICByZXR1cm4gY3VydmVbMF0ueCA9PSBjdXJ2ZVsxXS54ICYmIGN1cnZlWzBdLnkgPT0gY3VydmVbMV0ueTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZmluZHMgdGhlIHBvaW50IHRoYXQgaXMgJ2Rpc3RhbmNlJyBhbG9uZyB0aGUgcGF0aCBmcm9tICdsb2NhdGlvbicuICB0aGlzIG1ldGhvZCByZXR1cm5zIGJvdGggdGhlIHgseSBsb2NhdGlvbiBvZiB0aGUgcG9pbnQgYW5kIGFsc29cbiAgICAgKiBpdHMgJ2xvY2F0aW9uJyAocHJvcG9ydGlvbiBvZiB0cmF2ZWwgYWxvbmcgdGhlIHBhdGgpOyB0aGUgbWV0aG9kIGJlbG93IC0gX3BvaW50QWxvbmdQYXRoRnJvbSAtIGNhbGxzIHRoaXMgbWV0aG9kIGFuZCBqdXN0IHJldHVybnMgdGhlXG4gICAgICogcG9pbnQuXG4gICAgICovXG4gICAgdmFyIF9wb2ludEFsb25nUGF0aCA9IGZ1bmN0aW9uKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpIHtcblxuICAgICAgICBpZiAoX2lzUG9pbnQoY3VydmUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvaW50OmN1cnZlWzBdLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOmxvY2F0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZXYgPSBfcG9pbnRPblBhdGgoY3VydmUsIGxvY2F0aW9uKSxcbiAgICAgICAgICAgIHRhbGx5ID0gMCxcbiAgICAgICAgICAgIGN1ckxvYyA9IGxvY2F0aW9uLFxuICAgICAgICAgICAgZGlyZWN0aW9uID0gZGlzdGFuY2UgPiAwID8gMSA6IC0xLFxuICAgICAgICAgICAgY3VyID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAodGFsbHkgPCBNYXRoLmFicyhkaXN0YW5jZSkpIHtcbiAgICAgICAgICAgIGN1ckxvYyArPSAoMC4wMDUgKiBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgY3VyID0gX3BvaW50T25QYXRoKGN1cnZlLCBjdXJMb2MpO1xuICAgICAgICAgICAgdGFsbHkgKz0gX2Rpc3QoY3VyLCBwcmV2KTtcbiAgICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtwb2ludDpjdXIsIGxvY2F0aW9uOmN1ckxvY307XG4gICAgfTtcblxuICAgIHZhciBfbGVuZ3RoID0gZnVuY3Rpb24oY3VydmUpIHtcbiAgICAgICAgaWYgKF9pc1BvaW50KGN1cnZlKSkgcmV0dXJuIDA7XG5cbiAgICAgICAgdmFyIHByZXYgPSBfcG9pbnRPblBhdGgoY3VydmUsIDApLFxuICAgICAgICAgICAgdGFsbHkgPSAwLFxuICAgICAgICAgICAgY3VyTG9jID0gMCxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IDEsXG4gICAgICAgICAgICBjdXIgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChjdXJMb2MgPCAxKSB7XG4gICAgICAgICAgICBjdXJMb2MgKz0gKDAuMDA1ICogZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGN1ciA9IF9wb2ludE9uUGF0aChjdXJ2ZSwgY3VyTG9jKTtcbiAgICAgICAgICAgIHRhbGx5ICs9IF9kaXN0KGN1ciwgcHJldik7XG4gICAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWxseTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZmluZHMgdGhlIHBvaW50IHRoYXQgaXMgJ2Rpc3RhbmNlJyBhbG9uZyB0aGUgcGF0aCBmcm9tICdsb2NhdGlvbicuXG4gICAgICovXG4gICAgdmFyIF9wb2ludEFsb25nUGF0aEZyb20gPSBmdW5jdGlvbihjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBfcG9pbnRBbG9uZ1BhdGgoY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSkucG9pbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGZpbmRzIHRoZSBsb2NhdGlvbiB0aGF0IGlzICdkaXN0YW5jZScgYWxvbmcgdGhlIHBhdGggZnJvbSAnbG9jYXRpb24nLlxuICAgICAqL1xuICAgIHZhciBfbG9jYXRpb25BbG9uZ1BhdGhGcm9tID0gZnVuY3Rpb24oY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gX3BvaW50QWxvbmdQYXRoKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpLmxvY2F0aW9uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBncmFkaWVudCBvZiB0aGUgY3VydmUgYXQgdGhlIGdpdmVuIGxvY2F0aW9uLCB3aGljaCBpcyBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxIGluY2x1c2l2ZS5cbiAgICAgKlxuICAgICAqIHRoYW5rcyAvLyBodHRwOi8vYmltaXh1YWwub3JnL0FuaW1hdGlvbkxpYnJhcnkvYmV6aWVydGFuZ2VudHMuaHRtbFxuICAgICAqL1xuICAgIHZhciBfZ3JhZGllbnRBdFBvaW50ID0gZnVuY3Rpb24oY3VydmUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBwMSA9IF9wb2ludE9uUGF0aChjdXJ2ZSwgbG9jYXRpb24pLFxuICAgICAgICAgICAgcDIgPSBfcG9pbnRPblBhdGgoY3VydmUuc2xpY2UoMCwgY3VydmUubGVuZ3RoIC0gMSksIGxvY2F0aW9uKSxcbiAgICAgICAgICAgIGR5ID0gcDIueSAtIHAxLnksIGR4ID0gcDIueCAtIHAxLng7XG4gICAgICAgIHJldHVybiBkeSA9PSAwID8gSW5maW5pdHkgOiBNYXRoLmF0YW4oZHkgLyBkeCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICByZXR1cm5zIHRoZSBncmFkaWVudCBvZiB0aGUgY3VydmUgYXQgdGhlIHBvaW50IHdoaWNoIGlzICdkaXN0YW5jZScgZnJvbSB0aGUgZ2l2ZW4gbG9jYXRpb24uXG4gICAgIGlmIHRoaXMgcG9pbnQgaXMgZ3JlYXRlciB0aGFuIGxvY2F0aW9uIDEsIHRoZSBncmFkaWVudCBhdCBsb2NhdGlvbiAxIGlzIHJldHVybmVkLlxuICAgICBpZiB0aGlzIHBvaW50IGlzIGxlc3MgdGhhbiBsb2NhdGlvbiAwLCB0aGUgZ3JhZGllbnQgYXQgbG9jYXRpb24gMCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICB2YXIgX2dyYWRpZW50QXRQb2ludEFsb25nUGF0aEZyb20gPSBmdW5jdGlvbihjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKSB7XG4gICAgICAgIHZhciBwID0gX3BvaW50QWxvbmdQYXRoKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpO1xuICAgICAgICBpZiAocC5sb2NhdGlvbiA+IDEpIHAubG9jYXRpb24gPSAxO1xuICAgICAgICBpZiAocC5sb2NhdGlvbiA8IDApIHAubG9jYXRpb24gPSAwO1xuICAgICAgICByZXR1cm4gX2dyYWRpZW50QXRQb2ludChjdXJ2ZSwgcC5sb2NhdGlvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZXMgYSBsaW5lIHRoYXQgaXMgJ2xlbmd0aCcgcGl4ZWxzIGxvbmcsIHBlcnBlbmRpY3VsYXIgdG8sIGFuZCBjZW50ZXJlZCBvbiwgdGhlIHBhdGggYXQgJ2Rpc3RhbmNlJyBwaXhlbHMgZnJvbSB0aGUgZ2l2ZW4gbG9jYXRpb24uXG4gICAgICogaWYgZGlzdGFuY2UgaXMgbm90IHN1cHBsaWVkLCB0aGUgcGVycGVuZGljdWxhciBmb3IgdGhlIGdpdmVuIGxvY2F0aW9uIGlzIGNvbXB1dGVkIChpZS4gd2Ugc2V0IGRpc3RhbmNlIHRvIHplcm8pLlxuICAgICAqL1xuICAgIHZhciBfcGVycGVuZGljdWxhclRvUGF0aEF0ID0gZnVuY3Rpb24oY3VydmUsIGxvY2F0aW9uLCBsZW5ndGgsIGRpc3RhbmNlKSB7XG4gICAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2UgPT0gbnVsbCA/IDAgOiBkaXN0YW5jZTtcbiAgICAgICAgdmFyIHAgPSBfcG9pbnRBbG9uZ1BhdGgoY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSksXG4gICAgICAgICAgICBtID0gX2dyYWRpZW50QXRQb2ludChjdXJ2ZSwgcC5sb2NhdGlvbiksXG4gICAgICAgICAgICBfdGhldGEyID0gTWF0aC5hdGFuKC0xIC8gbSksXG4gICAgICAgICAgICB5ID0gIGxlbmd0aCAvIDIgKiBNYXRoLnNpbihfdGhldGEyKSxcbiAgICAgICAgICAgIHggPSAgbGVuZ3RoIC8gMiAqIE1hdGguY29zKF90aGV0YTIpO1xuICAgICAgICByZXR1cm4gW3t4OnAucG9pbnQueCArIHgsIHk6cC5wb2ludC55ICsgeX0sIHt4OnAucG9pbnQueCAtIHgsIHk6cC5wb2ludC55IC0geX1dO1xuICAgIH07XG5cbiAgICB0aGlzLmpzQmV6aWVyID0ge1xuICAgICAgICBkaXN0YW5jZUZyb21DdXJ2ZSA6IF9kaXN0YW5jZUZyb21DdXJ2ZSxcbiAgICAgICAgZ3JhZGllbnRBdFBvaW50IDogX2dyYWRpZW50QXRQb2ludCxcbiAgICAgICAgZ3JhZGllbnRBdFBvaW50QWxvbmdDdXJ2ZUZyb20gOiBfZ3JhZGllbnRBdFBvaW50QWxvbmdQYXRoRnJvbSxcbiAgICAgICAgbmVhcmVzdFBvaW50T25DdXJ2ZSA6IF9uZWFyZXN0UG9pbnRPbkN1cnZlLFxuICAgICAgICBwb2ludE9uQ3VydmUgOiBfcG9pbnRPblBhdGgsXG4gICAgICAgIHBvaW50QWxvbmdDdXJ2ZUZyb20gOiBfcG9pbnRBbG9uZ1BhdGhGcm9tLFxuICAgICAgICBwZXJwZW5kaWN1bGFyVG9DdXJ2ZUF0IDogX3BlcnBlbmRpY3VsYXJUb1BhdGhBdCxcbiAgICAgICAgbG9jYXRpb25BbG9uZ0N1cnZlRnJvbTpfbG9jYXRpb25BbG9uZ1BhdGhGcm9tLFxuICAgICAgICBnZXRMZW5ndGg6X2xlbmd0aFxuICAgIH07XG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qKlxuICogQmlsdG9uZyB2MC4zXG4gKlxuICogVmFyaW91cyBnZW9tZXRyeSBmdW5jdGlvbnMgd3JpdHRlbiBhcyBwYXJ0IG9mIGpzUGx1bWIgYW5kIHBlcmhhcHMgdXNlZnVsIGZvciBvdGhlcnMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IGpzUGx1bWJcbiAqIGh0dHBzOi8vanNwbHVtYnRvb2xraXQuY29tXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciByb290ID0gdGhpcztcblxuICAgIHZhciBCaWx0b25nID0gcm9vdC5CaWx0b25nID0ge307XG5cbiAgICB2YXIgX2lzYSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiOyB9LFxuICAgICAgICBfcG9pbnRIZWxwZXIgPSBmdW5jdGlvbihwMSwgcDIsIGZuKSB7XG4gICAgICAgICAgICBwMSA9IF9pc2EocDEpID8gcDEgOiBbcDEueCwgcDEueV07XG4gICAgICAgICAgICBwMiA9IF9pc2EocDIpID8gcDIgOiBbcDIueCwgcDIueV07XG4gICAgICAgICAgICByZXR1cm4gZm4ocDEsIHAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIEJpbHRvbmcuZ3JhZGllbnRcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZXMgdGhlIGdyYWRpZW50IG9mIGEgbGluZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMSBGaXJzdCBwb2ludCwgZWl0aGVyIGFzIGEgMiBlbnRyeSBhcnJheSBvciBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAyIFNlY29uZCBwb2ludCwgZWl0aGVyIGFzIGEgMiBlbnRyeSBhcnJheSBvciBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEByZXR1cm4ge0Zsb2F0fSBUaGUgZ3JhZGllbnQgb2YgYSBsaW5lIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXG4gICAgICAgICAqL1xuICAgICAgICBfZ3JhZGllbnQgPSBCaWx0b25nLmdyYWRpZW50ID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3BvaW50SGVscGVyKHAxLCBwMiwgZnVuY3Rpb24oX3AxLCBfcDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3AyWzBdID09IF9wMVswXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wMlsxXSA+IF9wMVsxXSA/IEluZmluaXR5IDogLUluZmluaXR5O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9wMlsxXSA9PSBfcDFbMV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcDJbMF0gPiBfcDFbMF0gPyAwIDogLTA7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9wMlsxXSAtIF9wMVsxXSkgLyAoX3AyWzBdIC0gX3AxWzBdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgQmlsdG9uZy5ub3JtYWxcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZXMgdGhlIGdyYWRpZW50IG9mIGEgbm9ybWFsIHRvIGEgbGluZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMSBGaXJzdCBwb2ludCwgZWl0aGVyIGFzIGEgMiBlbnRyeSBhcnJheSBvciBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAyIFNlY29uZCBwb2ludCwgZWl0aGVyIGFzIGEgMiBlbnRyeSBhcnJheSBvciBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEByZXR1cm4ge0Zsb2F0fSBUaGUgZ3JhZGllbnQgb2YgYSBub3JtYWwgdG8gYSBsaW5lIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXG4gICAgICAgICAqL1xuICAgICAgICBfbm9ybWFsID0gQmlsdG9uZy5ub3JtYWwgPSBmdW5jdGlvbihwMSwgcDIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMSAvIF9ncmFkaWVudChwMSwgcDIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgQmlsdG9uZy5saW5lTGVuZ3RoXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAZGVzYyBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBsaW5lIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAxIEZpcnN0IHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDIgU2Vjb25kIHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHJldHVybiB7RmxvYXR9IFRoZSBsZW5ndGggb2YgYSBsaW5lIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXG4gICAgICAgICAqL1xuICAgICAgICBfbGluZUxlbmd0aCA9IEJpbHRvbmcubGluZUxlbmd0aCA9IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgICAgICAgICAgcmV0dXJuIF9wb2ludEhlbHBlcihwMSwgcDIsIGZ1bmN0aW9uKF9wMSwgX3AyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhfcDJbMV0gLSBfcDFbMV0sIDIpICsgTWF0aC5wb3coX3AyWzBdIC0gX3AxWzBdLCAyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIEJpbHRvbmcucXVhZHJhbnRcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZXMgdGhlIHF1YWRyYW50IGluIHdoaWNoIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzIGxpZXMuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAxIEZpcnN0IHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDIgU2Vjb25kIHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHJldHVybiB7SW50ZWdlcn0gVGhlIHF1YWRyYW50IC0gMSBmb3IgdXBwZXIgcmlnaHQsIDIgZm9yIGxvd2VyIHJpZ2h0LCAzIGZvciBsb3dlciBsZWZ0LCA0IGZvciB1cHBlciBsZWZ0LlxuICAgICAgICAgKi9cbiAgICAgICAgX3F1YWRyYW50ID0gQmlsdG9uZy5xdWFkcmFudCA9IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgICAgICAgICAgcmV0dXJuIF9wb2ludEhlbHBlcihwMSwgcDIsIGZ1bmN0aW9uKF9wMSwgX3AyKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9wMlswXSA+IF9wMVswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9wMlsxXSA+IF9wMVsxXSkgPyAyIDogMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX3AyWzBdID09IF9wMVswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3AyWzFdID4gX3AxWzFdID8gMiA6IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9wMlsxXSA+IF9wMVsxXSkgPyAzIDogNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIEJpbHRvbmcudGhldGFcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZXMgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAxIEZpcnN0IHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDIgU2Vjb25kIHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHJldHVybiB7RmxvYXR9IFRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoZXRhID0gQmlsdG9uZy50aGV0YSA9IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgICAgICAgICAgcmV0dXJuIF9wb2ludEhlbHBlcihwMSwgcDIsIGZ1bmN0aW9uKF9wMSwgX3AyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBfZ3JhZGllbnQoX3AxLCBfcDIpLFxuICAgICAgICAgICAgICAgICAgICB0ID0gTWF0aC5hdGFuKG0pLFxuICAgICAgICAgICAgICAgICAgICBzID0gX3F1YWRyYW50KF9wMSwgX3AyKTtcbiAgICAgICAgICAgICAgICBpZiAoKHMgPT0gNCB8fCBzPT0gMykpIHQgKz0gTWF0aC5QSTtcbiAgICAgICAgICAgICAgICBpZiAodCA8IDApIHQgKz0gKDIgKiBNYXRoLlBJKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBCaWx0b25nLmludGVyc2VjdHNcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZXMgd2hldGhlciBvciBub3QgdGhlIHR3byByZWN0YW5nbGVzIGludGVyc2VjdC5cbiAgICAgICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHIxIEZpcnN0IHJlY3RhbmdsZSwgYXMgYSBqcyBvYmplY3QgaW4gdGhlIGZvcm0gYHt4Oi4uLCB5Oi4uLCB3Oi4uLCBoOi4ufWBcbiAgICAgICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHIyIFNlY29uZCByZWN0YW5nbGUsIGFzIGEganMgb2JqZWN0IGluIHRoZSBmb3JtIGB7eDouLiwgeTouLiwgdzouLiwgaDouLn1gXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgaW50ZXJzZWN0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBfaW50ZXJzZWN0cyA9IEJpbHRvbmcuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHIxLCByMikge1xuICAgICAgICAgICAgdmFyIHgxID0gcjEueCwgeDIgPSByMS54ICsgcjEudywgeTEgPSByMS55LCB5MiA9IHIxLnkgKyByMS5oLFxuICAgICAgICAgICAgICAgIGExID0gcjIueCwgYTIgPSByMi54ICsgcjIudywgYjEgPSByMi55LCBiMiA9IHIyLnkgKyByMi5oO1xuXG4gICAgICAgICAgICByZXR1cm4gICggKHgxIDw9IGExICYmIGExIDw9IHgyKSAmJiAoeTEgPD0gYjEgJiYgYjEgPD0geTIpICkgfHxcbiAgICAgICAgICAgICAgICAoICh4MSA8PSBhMiAmJiBhMiA8PSB4MikgJiYgKHkxIDw9IGIxICYmIGIxIDw9IHkyKSApIHx8XG4gICAgICAgICAgICAgICAgKCAoeDEgPD0gYTEgJiYgYTEgPD0geDIpICYmICh5MSA8PSBiMiAmJiBiMiA8PSB5MikgKSB8fFxuICAgICAgICAgICAgICAgICggKHgxIDw9IGEyICYmIGExIDw9IHgyKSAmJiAoeTEgPD0gYjIgJiYgYjIgPD0geTIpICkgfHxcbiAgICAgICAgICAgICAgICAoIChhMSA8PSB4MSAmJiB4MSA8PSBhMikgJiYgKGIxIDw9IHkxICYmIHkxIDw9IGIyKSApIHx8XG4gICAgICAgICAgICAgICAgKCAoYTEgPD0geDIgJiYgeDIgPD0gYTIpICYmIChiMSA8PSB5MSAmJiB5MSA8PSBiMikgKSB8fFxuICAgICAgICAgICAgICAgICggKGExIDw9IHgxICYmIHgxIDw9IGEyKSAmJiAoYjEgPD0geTIgJiYgeTIgPD0gYjIpICkgfHxcbiAgICAgICAgICAgICAgICAoIChhMSA8PSB4MiAmJiB4MSA8PSBhMikgJiYgKGIxIDw9IHkyICYmIHkyIDw9IGIyKSApO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgQmlsdG9uZy5lbmNsb3Nlc1xuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlcyB3aGV0aGVyIG9yIG5vdCByMiBpcyBjb21wbGV0ZWx5IGVuY2xvc2VkIGJ5IHIxLlxuICAgICAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcjEgRmlyc3QgcmVjdGFuZ2xlLCBhcyBhIGpzIG9iamVjdCBpbiB0aGUgZm9ybSBge3g6Li4sIHk6Li4sIHc6Li4sIGg6Li59YFxuICAgICAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcjIgU2Vjb25kIHJlY3RhbmdsZSwgYXMgYSBqcyBvYmplY3QgaW4gdGhlIGZvcm0gYHt4Oi4uLCB5Oi4uLCB3Oi4uLCBoOi4ufWBcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbYWxsb3dTaGFyZWRFZGdlcz1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGNvbmNlcHQgb2YgZW5jbG9zdXJlIGFsbG93cyBmb3Igb25lIG9yIG1vcmUgZWRnZXMgdG8gYmUgc2hhcmVkIGJ5IHRoZSB0d28gcmVjdGFuZ2xlcy5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiByMSBlbmNsb3NlcyByMiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgX2VuY2xvc2VzID0gQmlsdG9uZy5lbmNsb3NlcyA9IGZ1bmN0aW9uKHIxLCByMiwgYWxsb3dTaGFyZWRFZGdlcykge1xuICAgICAgICAgICAgdmFyIHgxID0gcjEueCwgeDIgPSByMS54ICsgcjEudywgeTEgPSByMS55LCB5MiA9IHIxLnkgKyByMS5oLFxuICAgICAgICAgICAgICAgIGExID0gcjIueCwgYTIgPSByMi54ICsgcjIudywgYjEgPSByMi55LCBiMiA9IHIyLnkgKyByMi5oLFxuICAgICAgICAgICAgICAgIGMgPSBmdW5jdGlvbih2MSwgdjIsIHYzLCB2NCkgeyByZXR1cm4gYWxsb3dTaGFyZWRFZGdlcyA/IHYxIDw9IHYyICYmIHYzPj0gdjQgOiB2MSA8IHYyICYmIHYzID4gdjQ7IH07XG5cbiAgICAgICAgICAgIHJldHVybiBjKHgxLGExLHgyLGEyKSAmJiBjKHkxLGIxLHkyLGIyKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NlZ21lbnRNdWx0aXBsaWVycyA9IFtudWxsLCBbMSwgLTFdLCBbMSwgMV0sIFstMSwgMV0sIFstMSwgLTFdIF0sXG4gICAgICAgIF9pbnZlcnNlU2VnbWVudE11bHRpcGxpZXJzID0gW251bGwsIFstMSwgLTFdLCBbLTEsIDFdLCBbMSwgMV0sIFsxLCAtMV0gXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIEJpbHRvbmcucG9pbnRPbkxpbmVcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZXMgYSBwb2ludCBvbiB0aGUgbGluZSBmcm9tIGBmcm9tUG9pbnRgIHRvIGB0b1BvaW50YCB0aGF0IGlzIGBkaXN0YW5jZWAgdW5pdHMgYWxvbmcgdGhlIGxlbmd0aCBvZiB0aGUgbGluZS5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDEgRmlyc3QgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMiBTZWNvbmQgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQgb24gdGhlIGxpbmUsIGluIHRoZSBmb3JtIGB7IHg6Li4uLCB5Oi4uLiB9YC5cbiAgICAgICAgICovXG4gICAgICAgIF9wb2ludE9uTGluZSA9IEJpbHRvbmcucG9pbnRPbkxpbmUgPSBmdW5jdGlvbihmcm9tUG9pbnQsIHRvUG9pbnQsIGRpc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgbSA9IF9ncmFkaWVudChmcm9tUG9pbnQsIHRvUG9pbnQpLFxuICAgICAgICAgICAgICAgIHMgPSBfcXVhZHJhbnQoZnJvbVBvaW50LCB0b1BvaW50KSxcbiAgICAgICAgICAgICAgICBzZWdtZW50TXVsdGlwbGllciA9IGRpc3RhbmNlID4gMCA/IF9zZWdtZW50TXVsdGlwbGllcnNbc10gOiBfaW52ZXJzZVNlZ21lbnRNdWx0aXBsaWVyc1tzXSxcbiAgICAgICAgICAgICAgICB0aGV0YSA9IE1hdGguYXRhbihtKSxcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5hYnMoZGlzdGFuY2UgKiBNYXRoLnNpbih0aGV0YSkpICogc2VnbWVudE11bHRpcGxpZXJbMV0sXG4gICAgICAgICAgICAgICAgeCA9ICBNYXRoLmFicyhkaXN0YW5jZSAqIE1hdGguY29zKHRoZXRhKSkgKiBzZWdtZW50TXVsdGlwbGllclswXTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6ZnJvbVBvaW50LnggKyB4LCB5OmZyb21Qb2ludC55ICsgeSB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgQmlsdG9uZy5wZXJwZW5kaWN1bGFyTGluZVRvXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAZGVzYyBDYWxjdWxhdGVzIGEgbGluZSBvZiBsZW5ndGggYGxlbmd0aGAgdGhhdCBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBsaW5lIGZyb20gYGZyb21Qb2ludGAgdG8gYHRvUG9pbnRgIGFuZCBwYXNzZXMgdGhyb3VnaCBgdG9Qb2ludGAuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAxIEZpcnN0IHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDIgU2Vjb25kIHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHJldHVybiB7TGluZX0gUGVycGVuZGljdWxhciBsaW5lLCBpbiB0aGUgZm9ybSBgWyB7IHg6Li4uLCB5Oi4uLiB9LCB7IHg6Li4uLCB5Oi4uLiB9IF1gLlxuICAgICAgICAgKi9cbiAgICAgICAgX3BlcnBlbmRpY3VsYXJMaW5lVG8gPSBCaWx0b25nLnBlcnBlbmRpY3VsYXJMaW5lVG8gPSBmdW5jdGlvbihmcm9tUG9pbnQsIHRvUG9pbnQsIGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG0gPSBfZ3JhZGllbnQoZnJvbVBvaW50LCB0b1BvaW50KSxcbiAgICAgICAgICAgICAgICB0aGV0YTIgPSBNYXRoLmF0YW4oLTEgLyBtKSxcbiAgICAgICAgICAgICAgICB5ID0gIGxlbmd0aCAvIDIgKiBNYXRoLnNpbih0aGV0YTIpLFxuICAgICAgICAgICAgICAgIHggPSAgbGVuZ3RoIC8gMiAqIE1hdGguY29zKHRoZXRhMik7XG4gICAgICAgICAgICByZXR1cm4gW3t4OnRvUG9pbnQueCArIHgsIHk6dG9Qb2ludC55ICsgeX0sIHt4OnRvUG9pbnQueCAtIHgsIHk6dG9Qb2ludC55IC0geX1dO1xuICAgICAgICB9O1xufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuO1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHJvb3QgPSB0aGlzLFxuICAgICAgICBTbmlmZiA9IHtcbiAgICAgICAgICAgIGFuZHJvaWQ6IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYW5kcm9pZFwiKSA+IC0xXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IsIGN0eCkge1xuICAgICAgICAgICAgY3R4ID0gY3R4IHx8IGVsLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB2YXIgcG9zc2libGVzID0gY3R4LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVzW2ldID09PSBlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZWwgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGVsID09IFwic3RyaW5nXCIgfHwgZWwuY29uc3RydWN0b3IgPT09IFN0cmluZykgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbCkgOiBlbDtcbiAgICAgICAgfSxcbiAgICAgICAgX3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuc3JjRWxlbWVudCB8fCBlLnRhcmdldDtcbiAgICAgICAgfSxcbiAgICAvL1xuICAgIC8vIGdldHMgcGF0aCBpbmZvIGZvciB0aGUgZ2l2ZW4gZXZlbnQgLSB0aGUgcGF0aCBmcm9tIHRhcmdldCB0byBvYmosIGluIHRoZSBldmVudCdzIGJ1YmJsZSBjaGFpbi4gaWYgZG9Db21wdXRlXG4gICAgLy8gaXMgZmFsc2Ugd2UganVzdCByZXR1cm4gdGFyZ2V0IGZvciB0aGUgcGF0aC5cbiAgICAvL1xuICAgICAgICBfcGkgPSBmdW5jdGlvbihlLCB0YXJnZXQsIG9iaiwgZG9Db21wdXRlKSB7XG4gICAgICAgICAgICBpZiAoIWRvQ29tcHV0ZSkgcmV0dXJuIHsgcGF0aDpbdGFyZ2V0XSwgZW5kOjEgfTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlLnBhdGggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwYXRoOiBlLnBhdGgsIGVuZDogZS5wYXRoLmluZGV4T2Yob2JqKSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0geyBwYXRoOltdLCBlbmQ6LTEgfSwgX29uZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wYXRoLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwgPT09IG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmVuZCA9IG91dC5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWwucGFyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfb25lKGVsLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9vbmUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZCA9IGZ1bmN0aW9uIChsLCBmbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBsLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsW2ldID09IGZuKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgbC5sZW5ndGgpIGwuc3BsaWNlKGksIDEpO1xuICAgICAgICB9LFxuICAgICAgICBndWlkID0gMSxcbiAgICAvL1xuICAgIC8vIHRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIGEgZ3VpZCBmb3IgZXZlcnkgaGFuZGxlciwgc2V0cyBpdCBvbiB0aGUgaGFuZGxlciwgdGhlbiBhZGRzXG4gICAgLy8gaXQgdG8gdGhlIGFzc29jaWF0ZWQgb2JqZWN0J3MgbWFwIG9mIGhhbmRsZXJzIGZvciB0aGUgZ2l2ZW4gZXZlbnQuIHRoaXMgaXMgd2hhdCBlbmFibGVzIHVzXG4gICAgLy8gdG8gdW5iaW5kIGFsbCBldmVudHMgb2Ygc29tZSB0eXBlLCBvciBhbGwgZXZlbnRzICh0aGUgc2Vjb25kIG9mIHdoaWNoIGNhbiBiZSByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIsXG4gICAgLy8gYnV0IGl0IGFsc28gdXNlZCBieSBNb3R0bGUgd2hlbiBhbiBlbGVtZW50IGlzIHJlbW92ZWQuKVxuICAgICAgICBfc3RvcmUgPSBmdW5jdGlvbiAob2JqLCBldmVudCwgZm4pIHtcbiAgICAgICAgICAgIHZhciBnID0gZ3VpZCsrO1xuICAgICAgICAgICAgb2JqLl9fdGEgPSBvYmouX190YSB8fCB7fTtcbiAgICAgICAgICAgIG9iai5fX3RhW2V2ZW50XSA9IG9iai5fX3RhW2V2ZW50XSB8fCB7fTtcbiAgICAgICAgICAgIC8vIHN0b3JlIGVhY2ggaGFuZGxlciB3aXRoIGEgdW5pcXVlIGd1aWQuXG4gICAgICAgICAgICBvYmouX190YVtldmVudF1bZ10gPSBmbjtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgZ3VpZCBvbiB0aGUgaGFuZGxlci5cbiAgICAgICAgICAgIGZuLl9fdGF1aWQgPSBnO1xuICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgIH0sXG4gICAgICAgIF91bnN0b3JlID0gZnVuY3Rpb24gKG9iaiwgZXZlbnQsIGZuKSB7XG4gICAgICAgICAgICBvYmouX190YSAmJiBvYmouX190YVtldmVudF0gJiYgZGVsZXRlIG9iai5fX3RhW2V2ZW50XVtmbi5fX3RhdWlkXTtcbiAgICAgICAgICAgIC8vIGEgaGFuZGxlciBtaWdodCBoYXZlIGF0dGFjaGVkIGV4dHJhIGZ1bmN0aW9ucywgc28gd2UgdW5iaW5kIHRob3NlIHRvby5cbiAgICAgICAgICAgIGlmIChmbi5fX3RhRXh0cmEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZuLl9fdGFFeHRyYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfdW5iaW5kKG9iaiwgZm4uX190YUV4dHJhW2ldWzBdLCBmbi5fX3RhRXh0cmFbaV1bMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbi5fX3RhRXh0cmEubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGEgaGFuZGxlciBtaWdodCBoYXZlIGF0dGFjaGVkIGFuIHVuc3RvcmUgY2FsbGJhY2tcbiAgICAgICAgICAgIGZuLl9fdGFVbnN0b3JlICYmIGZuLl9fdGFVbnN0b3JlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jdXJyeUNoaWxkRmlsdGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBvYmosIGZuLCBldnQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiA9PSBudWxsKSByZXR1cm4gZm47XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGNoaWxkcmVuLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICAgICAgICAgICAgX2ZuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbi5fX3RhdWlkID0gZm4uX190YXVpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gX3QoZSksIHRhcmdldCA9IHQ7ICAvLyB0IGlzIHRoZSB0YXJnZXQgZWxlbWVudCBvbiB3aGljaCB0aGUgZXZlbnQgb2NjdXJyZWQuIGl0IGlzIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCB3ZSB3aWxsIHdpc2ggdG8gcGFzcyB0byBhbnkgY2FsbGJhY2tzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhJbmZvID0gX3BpKGUsIHQsIG9iaiwgY2hpbGRyZW4gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoSW5mby5lbmQgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhdGhJbmZvLmVuZDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHBhdGhJbmZvLnBhdGhbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNTZWxlY3Rvcih0YXJnZXQsIGNbaV0sIG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJFeHRyYUZ1bmN0aW9uKGZuLCBldnQsIF9mbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAvL1xuICAgIC8vIHJlZ2lzdGVycyBhbiAnZXh0cmEnIGZ1bmN0aW9uIG9uIHNvbWUgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gd2Ugd2VyZSBnaXZlbiAtIGEgZnVuY3Rpb24gdGhhdCB3ZVxuICAgIC8vIGNyZWF0ZWQgYW5kIGJvdW5kIHRvIHRoZSBlbGVtZW50IGFzIHBhcnQgb2Ygb3VyIGhvdXNla2VlcGluZywgYW5kIHdoaWNoIHdlIHdhbnQgdG8gdW5iaW5kIGFuZCByZW1vdmVcbiAgICAvLyB3aGVuZXZlciB0aGUgZ2l2ZW4gZnVuY3Rpb24gaXMgdW5ib3VuZC5cbiAgICAgICAgcmVnaXN0ZXJFeHRyYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGZuLCBldnQsIG5ld0ZuKSB7XG4gICAgICAgICAgICBmbi5fX3RhRXh0cmEgPSBmbi5fX3RhRXh0cmEgfHwgW107XG4gICAgICAgICAgICBmbi5fX3RhRXh0cmEucHVzaChbZXZ0LCBuZXdGbl0pO1xuICAgICAgICB9LFxuICAgICAgICBEZWZhdWx0SGFuZGxlciA9IGZ1bmN0aW9uIChvYmosIGV2dCwgZm4sIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoaXNUb3VjaERldmljZSAmJiB0b3VjaE1hcFtldnRdKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRmbiA9IF9jdXJyeUNoaWxkRmlsdGVyKGNoaWxkcmVuLCBvYmosIGZuLCB0b3VjaE1hcFtldnRdKTtcbiAgICAgICAgICAgICAgICBfYmluZChvYmosIHRvdWNoTWFwW2V2dF0sIHRmbiAsIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldnQgPT09IFwiZm9jdXNcIiAmJiBvYmouZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYmluZChvYmosIGV2dCwgX2N1cnJ5Q2hpbGRGaWx0ZXIoY2hpbGRyZW4sIG9iaiwgZm4sIGV2dCksIGZuKTtcbiAgICAgICAgfSxcbiAgICAgICAgU21hcnRDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAob2JqLCBldnQsIGZuLCBjaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG9iai5fX3RhU21hcnRDbGlja3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5fX3RhZCA9IF9wYWdlTG9jYXRpb24oZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5fX3RhdSA9IF9wYWdlTG9jYXRpb24oZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouX190YWQgJiYgb2JqLl9fdGF1ICYmIG9iai5fX3RhZFswXSA9PT0gb2JqLl9fdGF1WzBdICYmIG9iai5fX3RhZFsxXSA9PT0gb2JqLl9fdGF1WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmouX190YVNtYXJ0Q2xpY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouX190YVNtYXJ0Q2xpY2tzW2ldLmFwcGx5KF90KGUpLCBbIGUgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRGVmYXVsdEhhbmRsZXIob2JqLCBcIm1vdXNlZG93blwiLCBkb3duLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgRGVmYXVsdEhhbmRsZXIob2JqLCBcIm1vdXNldXBcIiwgdXAsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBEZWZhdWx0SGFuZGxlcihvYmosIFwiY2xpY2tcIiwgY2xpY2ssIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBvYmouX190YVNtYXJ0Q2xpY2tzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIGluIHRoZSBsaXN0IG9mIGNhbGxiYWNrc1xuICAgICAgICAgICAgb2JqLl9fdGFTbWFydENsaWNrcy5wdXNoKGZuKTtcbiAgICAgICAgICAgIC8vIHRoZSB1bnN0b3JlIGZ1bmN0aW9uIHJlbW92ZXMgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBvYmplY3QncyBsaXN0ZW5lciBsaXN0IGZvciB0aGlzIHR5cGUuXG4gICAgICAgICAgICBmbi5fX3RhVW5zdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfZChvYmouX190YVNtYXJ0Q2xpY2tzLCBmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBfdGFwUHJvZmlsZXMgPSB7XG4gICAgICAgICAgICBcInRhcFwiOiB7dG91Y2hlczogMSwgdGFwczogMX0sXG4gICAgICAgICAgICBcImRibHRhcFwiOiB7dG91Y2hlczogMSwgdGFwczogMn0sXG4gICAgICAgICAgICBcImNvbnRleHRtZW51XCI6IHt0b3VjaGVzOiAyLCB0YXBzOiAxfVxuICAgICAgICB9LFxuICAgICAgICBUYXBIYW5kbGVyID0gZnVuY3Rpb24gKGNsaWNrVGhyZXNob2xkLCBkYmxDbGlja1RocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGV2dCwgZm4sIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZXZlbnQgaXMgY29udGV4dG1lbnUsIGZvciBkZXZpY2VzIHdoaWNoIGFyZSBtb3VzZSBvbmx5LCB3ZSB3YW50IHRvXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBkZWZhdWx0IGJpbmQuXG4gICAgICAgICAgICAgICAgaWYgKGV2dCA9PSBcImNvbnRleHRtZW51XCIgJiYgaXNNb3VzZURldmljZSlcbiAgICAgICAgICAgICAgICAgICAgRGVmYXVsdEhhbmRsZXIob2JqLCBldnQsIGZuLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpc3N1ZSBoZXJlIGlzIHRoYXQgdGhpcyBkb3duIGhhbmRsZXIgZ2V0cyByZWdpc3RlcmVkIG9ubHkgZm9yIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGlsZCBub2RlcyBpbiB0aGUgZmlyc3QgcmVnaXN0cmF0aW9uLiBpbiBmYWN0IGl0IHNob3VsZCBiZSByZWdpc3RlcmVkIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gY2hpbGQgc2VsZWN0b3IgYW5kIHRoZW4gb24gZG93biB3ZSBzaG91bGQgY3ljbGUgdGhyb3VnaCB0aGUgcmVnaXN0ZXJlZFxuICAgICAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbnMgdG8gc2VlIGlmIG9uZSBvZiB0aGVtIG1hdGNoZXMuIG9uIG1vdXNldXAgd2Ugc2hvdWxkIGV4ZWN1dGUgQUxMIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmdW5jdGlvbnMgd2hvc2UgY2hpbGRyZW4gYXJlIGVpdGhlciBudWxsIG9yIG1hdGNoIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLl9fdGFUYXBIYW5kbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0dCA9IG9iai5fX3RhVGFwSGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRibHRhcDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dG1lbnU6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcHM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG93blNlbGVjdG9yczogW11cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfdChlKSwgcGF0aEluZm8gPSBfcGkoZSwgdGFyZ2V0LCBvYmosIGNoaWxkcmVuICE9IG51bGwpLCBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhdGhJbmZvLmVuZDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHBhdGhJbmZvLnBhdGhbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR0LmRvd25TZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHQuZG93blNlbGVjdG9yc1tpXSA9PSBudWxsIHx8IG1hdGNoZXNTZWxlY3Rvcih0YXJnZXQsIHR0LmRvd25TZWxlY3RvcnNbaV0sIG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHQuZG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2xlYXJTaW5nbGUsIGNsaWNrVGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhckRvdWJsZSwgZGJsQ2xpY2tUaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB3ZSBvbmx5IG5lZWQgb25lIG1hdGNoIG9uIG1vdXNlZG93blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHQuZG93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IF90KGUpLCBwYXRoSW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR0LnRhcHMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YyA9IF90b3VjaENvdW50KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRJZCBpbiBfdGFwUHJvZmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RhcFByb2ZpbGVzLmhhc093blByb3BlcnR5KGV2ZW50SWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gX3RhcFByb2ZpbGVzW2V2ZW50SWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocC50b3VjaGVzID09PSB0YyAmJiAocC50YXBzID09PSAxIHx8IHAudGFwcyA9PT0gdHQudGFwcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHRbZXZlbnRJZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoSW5mbyA9IF9waShlLCB0YXJnZXQsIG9iaiwgdHRbZXZlbnRJZF1baV1bMV0gIT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcExvb3AgPSAwOyBwTG9vcCA8IHBhdGhJbmZvLmVuZDsgcExvb3ArKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBwYXRoSW5mby5wYXRoW3BMb29wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNpbmdsZSBldmVudCByZWdpc3RyYXRpb24gaGFuZGxlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR0W2V2ZW50SWRdW2ldWzFdID09IG51bGwgfHwgbWF0Y2hlc1NlbGVjdG9yKHRhcmdldCwgdHRbZXZlbnRJZF1baV1bMV0sIG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR0W2V2ZW50SWRdW2ldWzBdLmFwcGx5KHRhcmdldCwgWyBlIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyU2luZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dC5kb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckRvdWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHQudGFwcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdEhhbmRsZXIob2JqLCBcIm1vdXNlZG93blwiLCBkb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRIYW5kbGVyKG9iaiwgXCJtb3VzZXVwXCIsIHVwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhpcyBjaGlsZCBzZWxlY3RvciAoaXQgY2FuIGJlIG51bGwsIHRoYXQncyBmaW5lKS5cbiAgICAgICAgICAgICAgICAgICAgb2JqLl9fdGFUYXBIYW5kbGVyLmRvd25TZWxlY3RvcnMucHVzaChjaGlsZHJlbik7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLl9fdGFUYXBIYW5kbGVyW2V2dF0ucHVzaChbZm4sIGNoaWxkcmVuXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB1bnN0b3JlIGZ1bmN0aW9uIHJlbW92ZXMgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBvYmplY3QncyBsaXN0ZW5lciBsaXN0IGZvciB0aGlzIHR5cGUuXG4gICAgICAgICAgICAgICAgICAgIGZuLl9fdGFVbnN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Qob2JqLl9fdGFUYXBIYW5kbGVyW2V2dF0sIGZuKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBtZWVIZWxwZXIgPSBmdW5jdGlvbiAodHlwZSwgZXZ0LCBvYmosIHRhcmdldCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmouX190YW1lZVt0eXBlXSkge1xuICAgICAgICAgICAgICAgIGlmIChvYmouX190YW1lZVt0eXBlXS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouX190YW1lZVt0eXBlXVtpXS5hcHBseSh0YXJnZXQsIFsgZXZ0IF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgTW91c2VFbnRlckV4aXRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnRzID0gW107XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZXZ0LCBmbiwgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5fX3RhbWVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIF9fdGFtZWUgaG9sZHMgYSBmbGFnIHNheWluZyB3aGV0aGVyIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgXCJpblwiIHRoZSBlbGVtZW50LCBhbmQgYSBsaXN0IG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdGggbW91c2VlbnRlciBhbmQgbW91c2VleGl0IGZ1bmN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgb2JqLl9fdGFtZWUgPSB7IG92ZXI6IGZhbHNlLCBtb3VzZWVudGVyOiBbXSwgbW91c2VleGl0OiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBvdmVyIGFuZCBvdXQgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IF90KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY2hpbGRyZW4gPT0gbnVsbCAmJiAodCA9PSBvYmogJiYgIW9iai5fX3RhbWVlLm92ZXIpKSB8fCAobWF0Y2hlc1NlbGVjdG9yKHQsIGNoaWxkcmVuLCBvYmopICYmICh0Ll9fdGFtZWUgPT0gbnVsbCB8fCAhdC5fX3RhbWVlLm92ZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWVIZWxwZXIoXCJtb3VzZWVudGVyXCIsIGUsIG9iaiwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuX190YW1lZSA9IHQuX190YW1lZSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5fX3RhbWVlLm92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50cy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gX3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhlIGN1cnJlbnQgdGFyZ2V0IG9uZSBvZiB0aGUgYWN0aXZlRWxlbWVudHM/IGFuZCBpcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWxhdGVkIHRhcmdldCBOT1QgYSBkZXNjZW5kYW50IG9mIGl0P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aXZlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT0gYWN0aXZlRWxlbWVudHNbaV0gJiYgIW1hdGNoZXNTZWxlY3RvcigoZS5yZWxhdGVkVGFyZ2V0IHx8IGUudG9FbGVtZW50KSwgXCIqXCIsIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Ll9fdGFtZWUub3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVlSGVscGVyKFwibW91c2VleGl0XCIsIGUsIG9iaiwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIF9iaW5kKG9iaiwgXCJtb3VzZW92ZXJcIiwgX2N1cnJ5Q2hpbGRGaWx0ZXIoY2hpbGRyZW4sIG9iaiwgb3ZlciwgXCJtb3VzZW92ZXJcIiksIG92ZXIpO1xuICAgICAgICAgICAgICAgICAgICBfYmluZChvYmosIFwibW91c2VvdXRcIiwgX2N1cnJ5Q2hpbGRGaWx0ZXIoY2hpbGRyZW4sIG9iaiwgb3V0LCBcIm1vdXNlb3V0XCIpLCBvdXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZuLl9fdGFVbnN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqLl9fdGFtZWVbZXZ0XVtmbi5fX3RhdWlkXTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgX3N0b3JlKG9iaiwgZXZ0LCBmbik7XG4gICAgICAgICAgICAgICAgb2JqLl9fdGFtZWVbZXZ0XVtmbi5fX3RhdWlkXSA9IGZuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNUb3VjaERldmljZSA9IFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBpc01vdXNlRGV2aWNlID0gXCJvbm1vdXNlZG93blwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgdG91Y2hNYXAgPSB7IFwibW91c2Vkb3duXCI6IFwidG91Y2hzdGFydFwiLCBcIm1vdXNldXBcIjogXCJ0b3VjaGVuZFwiLCBcIm1vdXNlbW92ZVwiOiBcInRvdWNobW92ZVwiIH0sXG4gICAgICAgIHRvdWNoc3RhcnQgPSBcInRvdWNoc3RhcnRcIiwgdG91Y2hlbmQgPSBcInRvdWNoZW5kXCIsIHRvdWNobW92ZSA9IFwidG91Y2htb3ZlXCIsXG4gICAgICAgIGlldiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcnYgPSAtMTtcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IuYXBwTmFtZSA9PSAnTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyJykge1xuICAgICAgICAgICAgICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChcIk1TSUUgKFswLTldezEsfVtcXC4wLTldezAsfSlcIik7XG4gICAgICAgICAgICAgICAgaWYgKHJlLmV4ZWModWEpICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJ2ID0gcGFyc2VGbG9hdChSZWdFeHAuJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9KSgpLFxuICAgICAgICBpc0lFTFQ5ID0gaWV2ID4gLTEgJiYgaWV2IDwgOSxcbiAgICAgICAgX2dlbkxvYyA9IGZ1bmN0aW9uIChlLCBwcmVmaXgpIHtcbiAgICAgICAgICAgIGlmIChlID09IG51bGwpIHJldHVybiBbIDAsIDAgXTtcbiAgICAgICAgICAgIHZhciB0cyA9IF90b3VjaGVzKGUpLCB0ID0gX2dldFRvdWNoKHRzLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBbdFtwcmVmaXggKyBcIlhcIl0sIHRbcHJlZml4ICsgXCJZXCJdXTtcbiAgICAgICAgfSxcbiAgICAgICAgX3BhZ2VMb2NhdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZSA9PSBudWxsKSByZXR1cm4gWyAwLCAwIF07XG4gICAgICAgICAgICBpZiAoaXNJRUxUOSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIGUuY2xpZW50WCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LCBlLmNsaWVudFkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dlbkxvYyhlLCBcInBhZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9zY3JlZW5Mb2NhdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dlbkxvYyhlLCBcInNjcmVlblwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2NsaWVudExvY2F0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2VuTG9jKGUsIFwiY2xpZW50XCIpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0VG91Y2ggPSBmdW5jdGlvbiAodG91Y2hlcywgaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdG91Y2hlcy5pdGVtID8gdG91Y2hlcy5pdGVtKGlkeCkgOiB0b3VjaGVzW2lkeF07XG4gICAgICAgIH0sXG4gICAgICAgIF90b3VjaGVzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDAgPyBlLnRvdWNoZXMgOlxuICAgICAgICAgICAgICAgICAgICBlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMCA/IGUuY2hhbmdlZFRvdWNoZXMgOlxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDAgPyBlLnRhcmdldFRvdWNoZXMgOlxuICAgICAgICAgICAgICAgIFsgZSBdO1xuICAgICAgICB9LFxuICAgICAgICBfdG91Y2hDb3VudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RvdWNoZXMoZSkubGVuZ3RoO1xuICAgICAgICB9LFxuICAgIC8vaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDUvMTAvX2FuZF90aGVfd2lubmVyXzEuaHRtbFxuICAgICAgICBfYmluZCA9IGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuLCBvcmlnaW5hbEZuKSB7XG4gICAgICAgICAgICBfc3RvcmUob2JqLCB0eXBlLCBmbik7XG4gICAgICAgICAgICBvcmlnaW5hbEZuLl9fdGF1aWQgPSBmbi5fX3RhdWlkO1xuICAgICAgICAgICAgaWYgKG9iai5hZGRFdmVudExpc3RlbmVyKVxuICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChvYmouYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdHlwZSArIGZuLl9fdGF1aWQ7XG4gICAgICAgICAgICAgICAgb2JqW1wiZVwiICsga2V5XSA9IGZuO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gbG9vayBhdCByZXBsYWNpbmcgd2l0aCAuY2FsbCguLilcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW1wiZVwiICsga2V5XSAmJiBvYmpbXCJlXCIgKyBrZXldKHdpbmRvdy5ldmVudCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvYmouYXR0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgb2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfdW5iaW5kID0gZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4pIHtcbiAgICAgICAgICAgIGlmIChmbiA9PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICBfZWFjaChvYmosIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VsID0gX2dlbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBfdW5zdG9yZShfZWwsIHR5cGUsIGZuKTtcbiAgICAgICAgICAgICAgICAvLyBpdCBoYXMgYmVlbiBib3VuZCBpZiB0aGVyZSBpcyBhIHRhdWlkLiBvdGhlcndpc2UgaXQgd2FzIG5vdCBib3VuZCBhbmQgd2UgY2FuIGlnbm9yZSBpdC5cbiAgICAgICAgICAgICAgICBpZiAoZm4uX190YXVpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RvdWNoRGV2aWNlICYmIHRvdWNoTWFwW3R5cGVdKSBfZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaE1hcFt0eXBlXSwgZm4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmRldGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdHlwZSArIGZuLl9fdGF1aWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWxba2V5XSAmJiBfZWwuZGV0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgX2VsW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VsW2tleV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VsW1wiZVwiICsga2V5XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBhIHRvdWNoIGV2ZW50IHdhcyBhbHNvIHJlZ2lzdGVyZWQsIGRlcmVnaXN0ZXIgbm93LlxuICAgICAgICAgICAgICAgIGlmIChmbi5fX3RhVG91Y2hQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICBfdW5iaW5kKG9iaiwgZm4uX190YVRvdWNoUHJveHlbMV0sIGZuLl9fdGFUb3VjaFByb3h5WzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgX2VhY2ggPSBmdW5jdGlvbiAob2JqLCBmbikge1xuICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICAvLyBpZiBhIGxpc3QgKG9yIGxpc3QtbGlrZSksIHVzZSBpdC4gaWYgYSBzdHJpbmcsIGdldCBhIGxpc3RcbiAgICAgICAgICAgIC8vIGJ5IHJ1bm5pbmcgdGhlIHN0cmluZyB0aHJvdWdoIHF1ZXJ5U2VsZWN0b3JBbGwuIGVsc2UsIGFzc3VtZVxuICAgICAgICAgICAgLy8gaXQncyBhbiBFbGVtZW50LlxuICAgICAgICAgICAgLy8gb2JqLnRvcCBpcyBcInVua25vd25cIiBpbiBJRTguXG4gICAgICAgICAgICBvYmogPSAodHlwZW9mIFdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAodHlwZW9mIG9iai50b3AgIT09IFwidW5rbm93blwiICYmIG9iaiA9PSBvYmoudG9wKSkgPyBbIG9iaiBdIDpcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBvYmogIT09IFwic3RyaW5nXCIpICYmIChvYmoudGFnTmFtZSA9PSBudWxsICYmIG9iai5sZW5ndGggIT0gbnVsbCkgPyBvYmogOlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChvYmopXG4gICAgICAgICAgICAgICAgOiBbIG9iaiBdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBmbi5hcHBseShvYmpbaV0pO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW90dGxlIG9mZmVycyBzdXBwb3J0IGZvciBhYnN0cmFjdGluZyBvdXQgdGhlIGRpZmZlcmVuY2VzXG4gICAgICogYmV0d2VlbiB0b3VjaCBhbmQgbW91c2UgZGV2aWNlcywgcGx1cyBcInNtYXJ0IGNsaWNrXCIgZnVuY3Rpb25hbGl0eVxuICAgICAqIChkb24ndCBmaXJlIGNsaWNrIGlmIHRoZSBtb3VzZSBoYXMgbW92ZWQgYmV0d2VlbiBtb3VzZWRvd24gYW5kIG1vdXNldXApLFxuICAgICAqIGFuZCBzeW50aGVzaXplZCBjbGljay90YXAgZXZlbnRzLlxuICAgICAqIEBjbGFzcyBNb3R0bGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbnN0cnVjdG9yIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLmNsaWNrVGhyZXNob2xkPTI1MF0gVGhyZXNob2xkLCBpbiBtaWxsaXNlY29uZHMgYmV5b25kIHdoaWNoIGEgdG91Y2hzdGFydCBmb2xsb3dlZCBieSBhIHRvdWNoZW5kIGlzIG5vdCBjb25zaWRlcmVkIHRvIGJlIGEgY2xpY2suXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuZGJsQ2xpY2tUaHJlc2hvbGQ9NDUwXSBUaHJlc2hvbGQsIGluIG1pbGxpc2Vjb25kcyBiZXlvbmQgd2hpY2ggdHdvIHN1Y2Nlc3NpdmUgdGFwIGV2ZW50cyBhcmUgbm90IGNvbnNpZGVyZWQgdG8gYmUgYSBjbGljay5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuc21hcnRDbGlja3M9ZmFsc2VdIElmIHRydWUsIHdvbid0IGZpcmUgY2xpY2sgZXZlbnRzIGlmIHRoZSBtb3VzZSBoYXMgbW92ZWQgYmV0d2VlbiBtb3VzZWRvd24gYW5kIG1vdXNldXAuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uYWxpdHlcbiAgICAgKiByZXF1aXJlcyB0aGF0IE1vdHRsZSBjb25zdW1lIHRoZSBtb3VzZWRvd24gZXZlbnQsIGFuZCBzbyBtYXkgbm90IGJlIHZpYWJsZSBpbiBhbGwgdXNlIGNhc2VzLlxuICAgICAqL1xuICAgIHJvb3QuTW90dGxlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHZhciBjbGlja1RocmVzaG9sZCA9IHBhcmFtcy5jbGlja1RocmVzaG9sZCB8fCAyNTAsXG4gICAgICAgICAgICBkYmxDbGlja1RocmVzaG9sZCA9IHBhcmFtcy5kYmxDbGlja1RocmVzaG9sZCB8fCA0NTAsXG4gICAgICAgICAgICBtb3VzZUVudGVyRXhpdEhhbmRsZXIgPSBuZXcgTW91c2VFbnRlckV4aXRIYW5kbGVyKCksXG4gICAgICAgICAgICB0YXBIYW5kbGVyID0gbmV3IFRhcEhhbmRsZXIoY2xpY2tUaHJlc2hvbGQsIGRibENsaWNrVGhyZXNob2xkKSxcbiAgICAgICAgICAgIF9zbWFydENsaWNrcyA9IHBhcmFtcy5zbWFydENsaWNrcyxcbiAgICAgICAgICAgIF9kb0JpbmQgPSBmdW5jdGlvbiAob2JqLCBldnQsIGZuLCBjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChmbiA9PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICAgICAgX2VhY2gob2JqLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZWwgPSBfZ2VsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3NtYXJ0Q2xpY2tzICYmIGV2dCA9PT0gXCJjbGlja1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgU21hcnRDbGlja0hhbmRsZXIoX2VsLCBldnQsIGZuLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2dCA9PT0gXCJ0YXBcIiB8fCBldnQgPT09IFwiZGJsdGFwXCIgfHwgZXZ0ID09PSBcImNvbnRleHRtZW51XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcEhhbmRsZXIoX2VsLCBldnQsIGZuLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZ0ID09PSBcIm1vdXNlZW50ZXJcIiB8fCBldnQgPT0gXCJtb3VzZWV4aXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRW50ZXJFeGl0SGFuZGxlcihfZWwsIGV2dCwgZm4sIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdEhhbmRsZXIoX2VsLCBldnQsIGZuLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgRE9NLCBhbmQgZGVyZWdpc3RlcnMgYWxsIGV2ZW50IGhhbmRsZXJzIGZvciBpdC4gWW91IHNob3VsZCB1c2UgdGhpc1xuICAgICAgICAgKiB0byBlbnN1cmUgeW91IGRvbid0IGxlYWsgbWVtb3J5LlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbCBFbGVtZW50LCBvciBpZCBvZiB0aGUgZWxlbWVudCwgdG8gcmVtb3ZlLlxuICAgICAgICAgKiBAcmV0dXJuIHtNb3R0bGV9IFRoZSBjdXJyZW50IE1vdHRsZSBpbnN0YW5jZTsgeW91IGNhbiBjaGFpbiB0aGlzIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBfZWFjaChlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfZWwgPSBfZ2VsKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChfZWwuX190YSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBldnQgaW4gX2VsLl9fdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZWwuX190YS5oYXNPd25Qcm9wZXJ0eShldnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaCBpbiBfZWwuX190YVtldnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZWwuX190YVtldnRdLmhhc093blByb3BlcnR5KGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3VuYmluZChfZWwsIGV2dCwgX2VsLl9fdGFbZXZ0XVtoXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9lbC5wYXJlbnROb2RlICYmIF9lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9lbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhbiBldmVudCBoYW5kbGVyLCBvcHRpb25hbGx5IGFzIGEgZGVsZWdhdGUgZm9yIHNvbWUgc2V0IG9mIGRlc2NlbmRhbnQgZWxlbWVudHMuIE5vdGVcbiAgICAgICAgICogdGhhdCB0aGlzIG1ldGhvZCB0YWtlcyBlaXRoZXIgMyBvciA0IGFyZ3VtZW50cyAtIGlmIHlvdSBzdXBwbHkgMyBhcmd1bWVudHMgaXQgaXMgYXNzdW1lZCB5b3UgaGF2ZVxuICAgICAgICAgKiBvbWl0dGVkIHRoZSBgY2hpbGRyZW5gIHBhcmFtZXRlciwgYW5kIHRoYXQgdGhlIGV2ZW50IGhhbmRsZXIgc2hvdWxkIGJlIGJvdW5kIGRpcmVjdGx5IHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAgICAgKiBAbWV0aG9kIG9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudFtdfEVsZW1lbnR8U3RyaW5nfSBlbCBFaXRoZXIgYW4gRWxlbWVudCwgb3IgYSBDU1Mgc3BlYyBmb3IgYSBsaXN0IG9mIGVsZW1lbnRzLCBvciBhbiBhcnJheSBvZiBFbGVtZW50cy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGlsZHJlbl0gQ29tbWEtZGVsaW1pdGVkIGxpc3Qgb2Ygc2VsZWN0b3JzIGlkZW50aWZ5aW5nIGFsbG93ZWQgY2hpbGRyZW4uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBFdmVudCBJRC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7TW90dGxlfSBUaGUgY3VycmVudCBNb3R0bGUgaW5zdGFuY2U7IHlvdSBjYW4gY2hhaW4gdGhpcyBtZXRob2QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uID0gZnVuY3Rpb24gKGVsLCBldmVudCwgY2hpbGRyZW4sIGZuKSB7XG4gICAgICAgICAgICB2YXIgX2VsID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgICAgIF9jID0gYXJndW1lbnRzLmxlbmd0aCA9PSA0ID8gYXJndW1lbnRzWzJdIDogbnVsbCxcbiAgICAgICAgICAgICAgICBfZSA9IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgICAgICBfZiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIF9kb0JpbmQoX2VsLCBfZSwgX2YsIF9jKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW5jZWwgZGVsZWdhdGUgZXZlbnQgaGFuZGxpbmcgZm9yIHRoZSBnaXZlbiBmdW5jdGlvbi4gTm90ZSB0aGF0IHVubGlrZSB3aXRoICdvbicgeW91IGRvIG5vdCBzdXBwbHlcbiAgICAgICAgICogYSBsaXN0IG9mIGNoaWxkIHNlbGVjdG9ycyBoZXJlOiBpdCByZW1vdmVzIGV2ZW50IGRlbGVnYXRpb24gZnJvbSBhbGwgb2YgdGhlIGNoaWxkIHNlbGVjdG9ycyBmb3Igd2hpY2ggdGhlXG4gICAgICAgICAqIGdpdmVuIGZ1bmN0aW9uIHdhcyByZWdpc3RlcmVkIChpZiBhbnkpLlxuICAgICAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnRbXXxFbGVtZW50fFN0cmluZ30gZWwgRWxlbWVudCAtIG9yIElEIG9mIGVsZW1lbnQgLSBmcm9tIHdoaWNoIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IEV2ZW50IElELlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtNb3R0bGV9IFRoZSBjdXJyZW50IE1vdHRsZSBpbnN0YW5jZTsgeW91IGNhbiBjaGFpbiB0aGlzIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2ZmID0gZnVuY3Rpb24gKGVsLCBldmVudCwgZm4pIHtcbiAgICAgICAgICAgIF91bmJpbmQoZWwsIGV2ZW50LCBmbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlcnMgc29tZSBldmVudCBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgICAgICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byB0cmlnZ2VyIHRoZSBldmVudC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IEV2ZW50IElELlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBvcmlnaW5hbEV2ZW50IFRoZSBvcmlnaW5hbCBldmVudC4gU2hvdWxkIGJlIG9wdGlvbmFsIG9mIGNvdXJzZSwgYnV0IGN1cnJlbnRseSBpcyBub3QsIGR1ZVxuICAgICAgICAgKiB0byB0aGUganNQbHVtYiB1c2UgY2FzZSB0aGF0IGNhdXNlZCB0aGlzIG1ldGhvZCB0byBiZSBhZGRlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXlsb2FkXSBPcHRpb25hbCBvYmplY3QgdG8gc2V0IGFzIGBwYXlsb2FkYCBvbiB0aGUgZ2VuZXJhdGVkIGV2ZW50OyB1c2VmdWwgZm9yIG1lc3NhZ2UgcGFzc2luZy5cbiAgICAgICAgICogQHJldHVybiB7TW90dGxlfSBUaGUgY3VycmVudCBNb3R0bGUgaW5zdGFuY2U7IHlvdSBjYW4gY2hhaW4gdGhpcyBtZXRob2QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbiAoZWwsIGV2ZW50LCBvcmlnaW5hbEV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAvLyBNb3VzZUV2ZW50IHVuZGVmaW5lZCBpbiBvbGQgSUU7IHRoYXQncyBob3cgd2Uga25vdyBpdCdzIGEgbW91c2UgZXZlbnQuICBBIGZpbmUgTWljcm9zb2Z0IHBhcmFkb3guXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxJc01vdXNlID0gaXNNb3VzZURldmljZSAmJiAodHlwZW9mIE1vdXNlRXZlbnQgPT09IFwidW5kZWZpbmVkXCIgfHwgb3JpZ2luYWxFdmVudCA9PSBudWxsIHx8IG9yaWdpbmFsRXZlbnQuY29uc3RydWN0b3IgPT09IE1vdXNlRXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgZXZlbnRUb0JpbmQgPSAoaXNUb3VjaERldmljZSAmJiAhaXNNb3VzZURldmljZSAmJiB0b3VjaE1hcFtldmVudF0pID8gdG91Y2hNYXBbZXZlbnRdIDogZXZlbnQsXG4gICAgICAgICAgICAgICAgYmluZGluZ0FNb3VzZUV2ZW50ID0gIShpc1RvdWNoRGV2aWNlICYmICFpc01vdXNlRGV2aWNlICYmIHRvdWNoTWFwW2V2ZW50XSk7XG5cbiAgICAgICAgICAgIHZhciBwbCA9IF9wYWdlTG9jYXRpb24ob3JpZ2luYWxFdmVudCksIHNsID0gX3NjcmVlbkxvY2F0aW9uKG9yaWdpbmFsRXZlbnQpLCBjbCA9IF9jbGllbnRMb2NhdGlvbihvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIF9lYWNoKGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbCA9IF9nZWwodGhpcyksIGV2dDtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudCB8fCB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblg6IHNsWzBdLFxuICAgICAgICAgICAgICAgICAgICBzY3JlZW5ZOiBzbFsxXSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogY2xbMF0sXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGNsWzFdXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBfZGVjb3JhdGUgPSBmdW5jdGlvbiAoX2V2dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZCkgX2V2dC5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50R2VuZXJhdG9ycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJUb3VjaEV2ZW50XCI6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3VjaCA9IGRvY3VtZW50LmNyZWF0ZVRvdWNoKHdpbmRvdywgX2VsLCAwLCBwbFswXSwgcGxbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xbMF0sIHNsWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsWzBdLCBjbFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc3N0ZXBoZW5zb24vNDQ4ODA4XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG91Y2hlcyA9IGRvY3VtZW50LmNyZWF0ZVRvdWNoTGlzdCh0b3VjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VG91Y2hlcyA9IGRvY3VtZW50LmNyZWF0ZVRvdWNoTGlzdCh0b3VjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSBkb2N1bWVudC5jcmVhdGVUb3VjaExpc3QodG91Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZ0LmluaXRUb3VjaEV2ZW50KGV2ZW50VG9CaW5kLCB0cnVlLCB0cnVlLCB3aW5kb3csIG51bGwsIHNsWzBdLCBzbFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbFswXSwgY2xbMV0sIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoZXMsIHRhcmdldFRvdWNoZXMsIGNoYW5nZWRUb3VjaGVzLCAxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJNb3VzZUV2ZW50c1wiOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoZXZlbnRUb0JpbmQsIHRydWUsIHRydWUsIHdpbmRvdywgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbFswXSwgc2xbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xbMF0sIGNsWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAxLCBfZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoU25pZmYuYW5kcm9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZHJvaWQncyB0b3VjaCBldmVudHMgYXJlIG5vdCBzdGFuZGFyZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZVRvdWNoKHdpbmRvdywgX2VsLCAwLCBwbFswXSwgcGxbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsWzBdLCBzbFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xbMF0sIGNsWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2dC50b3VjaGVzID0gZXZ0LnRhcmdldFRvdWNoZXMgPSBldnQuY2hhbmdlZFRvdWNoZXMgPSBkb2N1bWVudC5jcmVhdGVUb3VjaExpc3QodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZSA9ICFiaW5kaW5nQU1vdXNlRXZlbnQgJiYgIW9yaWdpbmFsSXNNb3VzZSAmJiAoaXNUb3VjaERldmljZSAmJiB0b3VjaE1hcFtldmVudF0gJiYgIVNuaWZmLmFuZHJvaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZ0TmFtZSA9IGl0ZSA/IFwiVG91Y2hFdmVudFwiIDogXCJNb3VzZUV2ZW50c1wiO1xuXG4gICAgICAgICAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KGV2dE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBldmVudEdlbmVyYXRvcnNbZXZ0TmFtZV0oZXZ0KTtcbiAgICAgICAgICAgICAgICAgICAgX2RlY29yYXRlKGV2dCk7XG4gICAgICAgICAgICAgICAgICAgIF9lbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5ldmVudFR5cGUgPSBldnQuZXZlbnROYW1lID0gZXZlbnRUb0JpbmQ7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5zY3JlZW5YID0gc2xbMF07XG4gICAgICAgICAgICAgICAgICAgIGV2dC5zY3JlZW5ZID0gc2xbMV07XG4gICAgICAgICAgICAgICAgICAgIGV2dC5jbGllbnRYID0gY2xbMF07XG4gICAgICAgICAgICAgICAgICAgIGV2dC5jbGllbnRZID0gY2xbMV07XG4gICAgICAgICAgICAgICAgICAgIF9kZWNvcmF0ZShldnQpO1xuICAgICAgICAgICAgICAgICAgICBfZWwuZmlyZUV2ZW50KCdvbicgKyBldmVudFRvQmluZCwgZXZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gYXNzaXN0IGluICdjb25zdW1pbmcnIGFuIGVsZW1lbnQ6IHVzZXMgYHN0b3BQcm9wYWdhdGlvbmAgd2hlcmUgYXZhaWxhYmxlLCBvciBzZXRzXG4gICAgICogYGUucmV0dXJuVmFsdWU9ZmFsc2VgIHdoZXJlIGl0IGlzIG5vdC5cbiAgICAgKiBAbWV0aG9kIE1vdHRsZS5jb25zdW1lXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCB0byBjb25zdW1lXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZG9Ob3RQcmV2ZW50RGVmYXVsdD1mYWxzZV0gSWYgdHJ1ZSwgZG9lcyBub3QgY2FsbCBgcHJldmVudERlZmF1bHQoKWAgb24gdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHJvb3QuTW90dGxlLmNvbnN1bWUgPSBmdW5jdGlvbiAoZSwgZG9Ob3RQcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFkb05vdFByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhZ2UgbG9jYXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gZXZlbnQuIEZvciB0b3VjaCBldmVudHMgdGhpcyBtZWFucyBnZXQgdGhlIHBhZ2UgbG9jYXRpb24gb2YgdGhlIGZpcnN0IHRvdWNoLlxuICAgICAqIEBtZXRob2QgTW90dGxlLnBhZ2VMb2NhdGlvblxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgdG8gZ2V0IHBhZ2UgbG9jYXRpb24gZm9yLlxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSBbbGVmdCwgdG9wXSBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgICAqL1xuICAgIHJvb3QuTW90dGxlLnBhZ2VMb2NhdGlvbiA9IF9wYWdlTG9jYXRpb247XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdG91Y2ggZXZlbnRzIHRvIGJlIHR1cm5lZCBcIm9uXCIuIFVzZWZ1bCBmb3IgdGVzdGluZzogZXZlbiBpZiB5b3UgZG9uJ3QgaGF2ZSBhIHRvdWNoIGRldmljZSwgeW91IGNhbiBzdGlsbFxuICAgICAqIHRyaWdnZXIgYSB0b3VjaCBldmVudCB3aGVuIHRoaXMgaXMgc3dpdGNoZWQgb24gYW5kIGl0IHdpbGwgYmUgY2FwdHVyZWQgYW5kIGFjdGVkIG9uLlxuICAgICAqIEBtZXRob2Qgc2V0Rm9yY2VUb3VjaEV2ZW50c1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgSWYgdHJ1ZSwgZm9yY2UgdG91Y2ggZXZlbnRzIHRvIGJlIG9uLlxuICAgICAqL1xuICAgIHJvb3QuTW90dGxlLnNldEZvcmNlVG91Y2hFdmVudHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaXNUb3VjaERldmljZSA9IHZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgbW91c2UgZXZlbnRzIHRvIGJlIHR1cm5lZCBcIm9uXCIuIFVzZWZ1bCBmb3IgdGVzdGluZzogZXZlbiBpZiB5b3UgZG9uJ3QgaGF2ZSBhIG1vdXNlLCB5b3UgY2FuIHN0aWxsXG4gICAgICogdHJpZ2dlciBhIG1vdXNlIGV2ZW50IHdoZW4gdGhpcyBpcyBzd2l0Y2hlZCBvbiBhbmQgaXQgd2lsbCBiZSBjYXB0dXJlZCBhbmQgYWN0ZWQgb24uXG4gICAgICogQG1ldGhvZCBzZXRGb3JjZU1vdXNlRXZlbnRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBJZiB0cnVlLCBmb3JjZSBtb3VzZSBldmVudHMgdG8gYmUgb24uXG4gICAgICovXG4gICAgcm9vdC5Nb3R0bGUuc2V0Rm9yY2VNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpc01vdXNlRGV2aWNlID0gdmFsdWU7XG4gICAgfTtcblxufSkuY2FsbCh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IHdpbmRvdyk7XG5cbi8qKlxuIGRyYWcvZHJvcCBmdW5jdGlvbmFsaXR5IGZvciB1c2Ugd2l0aCBqc1BsdW1iIGJ1dCB3aXRoXG4gbm8ga25vd2xlZGdlIG9mIGpzUGx1bWIuIHN1cHBvcnRzIG11bHRpcGxlIHNjb3BlcyAoc2VwYXJhdGVkIGJ5IHdoaXRlc3BhY2UpLCBkcmFnZ2luZ1xuIG11bHRpcGxlIGVsZW1lbnRzLCBjb25zdHJhaW4gdG8gcGFyZW50LCBkcm9wIGZpbHRlcnMsIGRyYWcgc3RhcnQgZmlsdGVycywgY3VzdG9tXG4gY3NzIGNsYXNzZXMuXG5cbiBhIGxvdCBvZiB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGlzIHNjcmlwdCBpcyBleHBlY3RlZCB0byBiZSBwbHVnZ2VkIGluOlxuXG4gYWRkQ2xhc3NcbiByZW1vdmVDbGFzc1xuXG4gYWRkRXZlbnRcbiByZW1vdmVFdmVudFxuXG4gZ2V0UG9zaXRpb25cbiBzZXRQb3NpdGlvblxuIGdldFNpemVcblxuIGluZGV4T2ZcbiBpbnRlcnNlY3RzXG5cbiB0aGUgbmFtZSBjYW1lIGZyb20gaGVyZTpcblxuIGh0dHA6Ly9tcnNoYXJwb2JsdW50by5naXRodWIuaW8vZm9zd2lnLmpzL1xuXG4gY29weXJpZ2h0IDIwMTYganNQbHVtYlxuICovXG5cbjsoZnVuY3Rpb24oKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgICB2YXIgX3N1Z2dlc3QgPSBmdW5jdGlvbihsaXN0LCBpdGVtLCBoZWFkKSB7XG4gICAgICAgIGlmIChsaXN0LmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgICAgICBoZWFkID8gbGlzdC51bnNoaWZ0KGl0ZW0pIDogbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgX3ZhbnF1aXNoID0gZnVuY3Rpb24obGlzdCwgaXRlbSkge1xuICAgICAgICB2YXIgaWR4ID0gbGlzdC5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpZiAoaWR4ICE9IC0xKSBsaXN0LnNwbGljZShpZHgsIDEpO1xuICAgIH07XG5cbiAgICB2YXIgX2RpZmZlcmVuY2UgPSBmdW5jdGlvbihsMSwgbDIpIHtcbiAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGwyLmluZGV4T2YobDFbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGQucHVzaChsMVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIHZhciBfaXNTdHJpbmcgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmID09IG51bGwgPyBmYWxzZSA6ICh0eXBlb2YgZiA9PT0gXCJzdHJpbmdcIiB8fCBmLmNvbnN0cnVjdG9yID09IFN0cmluZyk7XG4gICAgfTtcblxuICAgIHZhciBnZXRPZmZzZXRSZWN0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgLy8gKDEpXG4gICAgICAgIHZhciBib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgYm9keSA9IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAvLyAoMilcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgLy8gKDMpXG4gICAgICAgICAgICBjbGllbnRUb3AgPSBkb2NFbGVtLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwLFxuICAgICAgICAgICAgY2xpZW50TGVmdCA9IGRvY0VsZW0uY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCxcbiAgICAgICAgLy8gKDQpXG4gICAgICAgICAgICB0b3AgID0gYm94LnRvcCArICBzY3JvbGxUb3AgLSBjbGllbnRUb3AsXG4gICAgICAgICAgICBsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcblxuICAgICAgICByZXR1cm4geyB0b3A6IE1hdGgucm91bmQodG9wKSwgbGVmdDogTWF0aC5yb3VuZChsZWZ0KSB9O1xuICAgIH07XG5cbiAgICB2YXIgbWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oZWwsIHNlbGVjdG9yLCBjdHgpIHtcbiAgICAgICAgY3R4ID0gY3R4IHx8IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIHZhciBwb3NzaWJsZXMgPSBjdHgucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocG9zc2libGVzW2ldID09PSBlbClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBpZXYgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcnYgPSAtMTtcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IuYXBwTmFtZSA9PSAnTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyJykge1xuICAgICAgICAgICAgICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChcIk1TSUUgKFswLTldezEsfVtcXC4wLTldezAsfSlcIik7XG4gICAgICAgICAgICAgICAgaWYgKHJlLmV4ZWModWEpICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJ2ID0gcGFyc2VGbG9hdChSZWdFeHAuJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9KSgpLFxuICAgICAgICBERUZBVUxUX0dSSURfWCA9IDUwLFxuICAgICAgICBERUZBVUxUX0dSSURfWSA9IDUwLFxuICAgICAgICBpc0lFTFQ5ID0gaWV2ID4gLTEgJiYgaWV2IDwgOSxcbiAgICAgICAgaXNJRTkgPSBpZXYgPT0gOSxcbiAgICAgICAgX3BsID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGlzSUVMVDkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyBlLmNsaWVudFggKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCwgZS5jbGllbnRZICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRzID0gX3RvdWNoZXMoZSksIHQgPSBfZ2V0VG91Y2godHMsIDApO1xuICAgICAgICAgICAgICAgIC8vIGZvciBJRTkgcGFnZVggbWlnaHQgYmUgbnVsbCBpZiB0aGUgZXZlbnQgd2FzIHN5bnRoZXNpemVkLiBXZSB0cnkgZm9yIHBhZ2VYL3BhZ2VZIGZpcnN0LFxuICAgICAgICAgICAgICAgIC8vIGZhbGxpbmcgYmFjayB0byBjbGllbnRYL2NsaWVudFkgaWYgbmVjZXNzYXJ5LiBJbiBldmVyeSBvdGhlciBicm93c2VyIHdlIHdhbnQgdG8gdXNlIHBhZ2VYL3BhZ2VZLlxuICAgICAgICAgICAgICAgIHJldHVybiBpc0lFOSA/IFt0LnBhZ2VYIHx8IHQuY2xpZW50WCwgdC5wYWdlWSB8fCB0LmNsaWVudFldIDogW3QucGFnZVgsIHQucGFnZVldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZ2V0VG91Y2ggPSBmdW5jdGlvbih0b3VjaGVzLCBpZHgpIHsgcmV0dXJuIHRvdWNoZXMuaXRlbSA/IHRvdWNoZXMuaXRlbShpZHgpIDogdG91Y2hlc1tpZHhdOyB9LFxuICAgICAgICBfdG91Y2hlcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDAgPyBlLnRvdWNoZXMgOlxuICAgICAgICAgICAgICAgICAgICBlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMCA/IGUuY2hhbmdlZFRvdWNoZXMgOlxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDAgPyBlLnRhcmdldFRvdWNoZXMgOlxuICAgICAgICAgICAgICAgIFsgZSBdO1xuICAgICAgICB9LFxuICAgICAgICBfY2xhc3NlcyA9IHtcbiAgICAgICAgICAgIGRyYWdnYWJsZTpcImthdGF2b3Jpby1kcmFnZ2FibGVcIiwgICAgLy8gZHJhZ2dhYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICBkcm9wcGFibGU6XCJrYXRhdm9yaW8tZHJvcHBhYmxlXCIsICAgIC8vIGRyb3BwYWJsZSBlbGVtZW50c1xuICAgICAgICAgICAgZHJhZyA6IFwia2F0YXZvcmlvLWRyYWdcIiwgICAgICAgICAgICAvLyBlbGVtZW50cyBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZFxuICAgICAgICAgICAgc2VsZWN0ZWQ6XCJrYXRhdm9yaW8tZHJhZy1zZWxlY3RlZFwiLCAvLyBlbGVtZW50cyBpbiBjdXJyZW50IGRyYWcgc2VsZWN0aW9uXG4gICAgICAgICAgICBhY3RpdmUgOiBcImthdGF2b3Jpby1kcmFnLWFjdGl2ZVwiLCAgIC8vIGRyb3BwYWJsZXMgdGhhdCBhcmUgdGFyZ2V0cyBvZiBhIGN1cnJlbnRseSBkcmFnZ2VkIGVsZW1lbnRcbiAgICAgICAgICAgIGhvdmVyIDogXCJrYXRhdm9yaW8tZHJhZy1ob3ZlclwiLCAgICAgLy8gZHJvcHBhYmxlcyBvdmVyIHdoaWNoIGEgbWF0Y2hpbmcgZHJhZyBlbGVtZW50IGlzIGhvdmVyaW5nXG4gICAgICAgICAgICBub1NlbGVjdCA6IFwia2F0YXZvcmlvLWRyYWctbm8tc2VsZWN0XCIsIC8vIGFkZGVkIHRvIHRoZSBib2R5IHRvIHByb3ZpZGUgYSBob29rIHRvIHN1cHByZXNzIHRleHQgc2VsZWN0aW9uXG4gICAgICAgICAgICBnaG9zdFByb3h5Olwia2F0YXZvcmlvLWdob3N0LXByb3h5XCIgIC8vIGFkZGVkIHRvIGEgZ2hvc3QgcHJveHkgZWxlbWVudCBpbiB1c2Ugd2hlbiBhIGRyYWcgaGFzIGV4aXRlZCB0aGUgYm91bmRzIG9mIGl0cyBwYXJlbnQuXG4gICAgICAgIH0sXG4gICAgICAgIF9kZWZhdWx0U2NvcGUgPSBcImthdGF2b3Jpby1kcmFnLXNjb3BlXCIsXG4gICAgICAgIF9ldmVudHMgPSBbIFwic3RvcFwiLCBcInN0YXJ0XCIsIFwiZHJhZ1wiLCBcImRyb3BcIiwgXCJvdmVyXCIsIFwib3V0XCIsIFwiYmVmb3JlU3RhcnRcIiBdLFxuICAgICAgICBfZGV2TnVsbCA9IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIF90cnVlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICBfZm9yZWFjaCA9IGZ1bmN0aW9uKGwsIGZuLCBmcm9tKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobFtpXSAhPSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICBmbihsW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3NldERyb3BwYWJsZXNBY3RpdmUgPSBmdW5jdGlvbihkZCwgdmFsLCBhbmRIb3ZlciwgZHJhZykge1xuICAgICAgICAgICAgX2ZvcmVhY2goZGQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlLnNldEFjdGl2ZSh2YWwpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwpIGUudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5kSG92ZXIpIGUuc2V0SG92ZXIoZHJhZywgdmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBfZWFjaCA9IGZ1bmN0aW9uKG9iaiwgZm4pIHtcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgb2JqID0gIV9pc1N0cmluZyhvYmopICYmIChvYmoudGFnTmFtZSA9PSBudWxsICYmIG9iai5sZW5ndGggIT0gbnVsbCkgPyBvYmogOiBbIG9iaiBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgZm4uYXBwbHkob2JqW2ldLCBbIG9ialtpXSBdKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2NvbnN1bWUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2RlZmF1bHRJbnB1dEZpbHRlclNlbGVjdG9yID0gXCJpbnB1dCx0ZXh0YXJlYSxzZWxlY3QsYnV0dG9uLG9wdGlvblwiLFxuICAgIC8vXG4gICAgLy8gZmlsdGVycyBvdXQgZXZlbnRzIG9uIGFsbCBpbnB1dCBlbGVtZW50cywgbGlrZSB0ZXh0YXJlYSwgY2hlY2tib3gsIGlucHV0LCBzZWxlY3QuXG4gICAgICAgIF9pbnB1dEZpbHRlciA9IGZ1bmN0aW9uKGUsIGVsLCBfa2F0YXZvcmlvKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGUuc3JjRWxlbWVudCB8fCBlLnRhcmdldDtcbiAgICAgICAgICAgIHJldHVybiAhbWF0Y2hlc1NlbGVjdG9yKHQsIF9rYXRhdm9yaW8uZ2V0SW5wdXRGaWx0ZXJTZWxlY3RvcigpLCBlbCk7XG4gICAgICAgIH07XG5cbiAgICB2YXIgU3VwZXIgPSBmdW5jdGlvbihlbCwgcGFyYW1zLCBjc3MsIHNjb3BlKSB7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMucGFyYW1zLmFkZENsYXNzKHRoaXMuZWwsIHRoaXMuX2NsYXNzKTtcbiAgICAgICAgdGhpcy51dWlkID0gX3V1aWQoKTtcbiAgICAgICAgdmFyIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldEVuYWJsZWQgPSBmdW5jdGlvbihlKSB7IGVuYWJsZWQgPSBlOyB9O1xuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZW5hYmxlZDsgfTtcbiAgICAgICAgdGhpcy50b2dnbGVFbmFibGVkID0gZnVuY3Rpb24oKSB7IGVuYWJsZWQgPSAhZW5hYmxlZDsgfTtcbiAgICAgICAgdGhpcy5zZXRTY29wZSA9IGZ1bmN0aW9uKHNjb3Blcykge1xuICAgICAgICAgICAgdGhpcy5zY29wZXMgPSBzY29wZXMgPyBzY29wZXMuc3BsaXQoL1xccysvKSA6IFsgc2NvcGUgXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRTY29wZSA9IGZ1bmN0aW9uKHNjb3Blcykge1xuICAgICAgICAgICAgdmFyIG0gPSB7fTtcbiAgICAgICAgICAgIF9lYWNoKHRoaXMuc2NvcGVzLCBmdW5jdGlvbihzKSB7IG1bc10gPSB0cnVlO30pO1xuICAgICAgICAgICAgX2VhY2goc2NvcGVzID8gc2NvcGVzLnNwbGl0KC9cXHMrLykgOiBbXSwgZnVuY3Rpb24ocykgeyBtW3NdID0gdHJ1ZTt9KTtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG0pIHRoaXMuc2NvcGVzLnB1c2goaSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVtb3ZlU2NvcGUgPSBmdW5jdGlvbihzY29wZXMpIHtcbiAgICAgICAgICAgIHZhciBtID0ge307XG4gICAgICAgICAgICBfZWFjaCh0aGlzLnNjb3BlcywgZnVuY3Rpb24ocykgeyBtW3NdID0gdHJ1ZTt9KTtcbiAgICAgICAgICAgIF9lYWNoKHNjb3BlcyA/IHNjb3Blcy5zcGxpdCgvXFxzKy8pIDogW10sIGZ1bmN0aW9uKHMpIHsgZGVsZXRlIG1bc107fSk7XG4gICAgICAgICAgICB0aGlzLnNjb3BlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBtKSB0aGlzLnNjb3Blcy5wdXNoKGkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvZ2dsZVNjb3BlID0gZnVuY3Rpb24oc2NvcGVzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHt9O1xuICAgICAgICAgICAgX2VhY2godGhpcy5zY29wZXMsIGZ1bmN0aW9uKHMpIHsgbVtzXSA9IHRydWU7fSk7XG4gICAgICAgICAgICBfZWFjaChzY29wZXMgPyBzY29wZXMuc3BsaXQoL1xccysvKSA6IFtdLCBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1bc10pIGRlbGV0ZSBtW3NdO1xuICAgICAgICAgICAgICAgIGVsc2UgbVtzXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG0pIHRoaXMuc2NvcGVzLnB1c2goaSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0U2NvcGUocGFyYW1zLnNjb3BlKTtcbiAgICAgICAgdGhpcy5rID0gcGFyYW1zLmthdGF2b3JpbztcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5rYXRhdm9yaW87XG4gICAgfTtcblxuICAgIHZhciBUUlVFID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIHZhciBGQUxTRSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbiAgICB2YXIgRHJhZyA9IGZ1bmN0aW9uKGVsLCBwYXJhbXMsIGNzcywgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5fY2xhc3MgPSBjc3MuZHJhZ2dhYmxlO1xuICAgICAgICB2YXIgayA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmlnaHRCdXR0b25DYW5EcmFnID0gdGhpcy5wYXJhbXMucmlnaHRCdXR0b25DYW5EcmFnO1xuICAgICAgICB2YXIgZG93bkF0ID0gWzAsMF0sIHBvc0F0RG93biA9IG51bGwsIHBhZ2VQb3NBdERvd24gPSBudWxsLCBwYWdlRGVsdGEgPSBbMCwwXSwgbW92aW5nID0gZmFsc2UsXG4gICAgICAgICAgICBjb25zdW1lU3RhcnRFdmVudCA9IHRoaXMucGFyYW1zLmNvbnN1bWVTdGFydEV2ZW50ICE9PSBmYWxzZSxcbiAgICAgICAgICAgIGRyYWdFbCA9IHRoaXMuZWwsXG4gICAgICAgICAgICBjbG9uZSA9IHRoaXMucGFyYW1zLmNsb25lLFxuICAgICAgICAgICAgc2Nyb2xsID0gdGhpcy5wYXJhbXMuc2Nyb2xsLFxuICAgICAgICAgICAgX211bHRpcGxlRHJvcCA9IHBhcmFtcy5tdWx0aXBsZURyb3AgIT09IGZhbHNlLFxuICAgICAgICAgICAgaXNDb25zdHJhaW5lZCA9IGZhbHNlLFxuICAgICAgICAgICAgdXNlR2hvc3RQcm94eSA9IHBhcmFtcy5naG9zdFByb3h5ID09PSB0cnVlID8gVFJVRSA6IHBhcmFtcy5naG9zdFByb3h5ICYmIHR5cGVvZiBwYXJhbXMuZ2hvc3RQcm94eSA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmdob3N0UHJveHkgOiBGQUxTRSxcbiAgICAgICAgICAgIGdob3N0UHJveHkgPSBmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwuY2xvbmVOb2RlKHRydWUpOyB9O1xuXG4gICAgICAgIHZhciBzbmFwVGhyZXNob2xkID0gcGFyYW1zLnNuYXBUaHJlc2hvbGQgfHwgNSxcbiAgICAgICAgICAgIF9zbmFwID0gZnVuY3Rpb24ocG9zLCB4LCB5LCB0aHJlc2hvbGRYLCB0aHJlc2hvbGRZKSB7XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkWCA9IHRocmVzaG9sZFggfHwgc25hcFRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGRZID0gdGhyZXNob2xkWSB8fCBzbmFwVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIHZhciBfZHggPSBNYXRoLmZsb29yKHBvc1swXSAvIHgpLFxuICAgICAgICAgICAgICAgICAgICBfZHhsID0geCAqIF9keCxcbiAgICAgICAgICAgICAgICAgICAgX2R4dCA9IF9keGwgKyB4LFxuICAgICAgICAgICAgICAgICAgICBfeCA9IE1hdGguYWJzKHBvc1swXSAtIF9keGwpIDw9IHRocmVzaG9sZFggPyBfZHhsIDogTWF0aC5hYnMoX2R4dCAtIHBvc1swXSkgPD0gdGhyZXNob2xkWCA/IF9keHQgOiBwb3NbMF07XG5cbiAgICAgICAgICAgICAgICB2YXIgX2R5ID0gTWF0aC5mbG9vcihwb3NbMV0gLyB5KSxcbiAgICAgICAgICAgICAgICAgICAgX2R5bCA9IHkgKiBfZHksXG4gICAgICAgICAgICAgICAgICAgIF9keXQgPSBfZHlsICsgeSxcbiAgICAgICAgICAgICAgICAgICAgX3kgPSBNYXRoLmFicyhwb3NbMV0gLSBfZHlsKSA8PSB0aHJlc2hvbGRZID8gX2R5bCA6IE1hdGguYWJzKF9keXQgLSBwb3NbMV0pIDw9IHRocmVzaG9sZFkgPyBfZHl0IDogcG9zWzFdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgX3gsIF95XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wb3NzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wb3NzZVJvbGVzID0ge307XG5cbiAgICAgICAgdGhpcy50b0dyaWQgPSBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtcy5ncmlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zbmFwKHBvcywgdGhpcy5wYXJhbXMuZ3JpZFswXSwgdGhpcy5wYXJhbXMuZ3JpZFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zbmFwID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgaWYgKGRyYWdFbCA9PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICB4ID0geCB8fCAodGhpcy5wYXJhbXMuZ3JpZCA/IHRoaXMucGFyYW1zLmdyaWRbMF0gOiBERUZBVUxUX0dSSURfWCk7XG4gICAgICAgICAgICB5ID0geSB8fCAodGhpcy5wYXJhbXMuZ3JpZCA/IHRoaXMucGFyYW1zLmdyaWRbMV0gOiBERUZBVUxUX0dSSURfWSk7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMucGFyYW1zLmdldFBvc2l0aW9uKGRyYWdFbCk7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5zZXRQb3NpdGlvbihkcmFnRWwsIF9zbmFwKHAsIHgsIHksIHgsIHkpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldFVzZUdob3N0UHJveHkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHVzZUdob3N0UHJveHkgPSB2YWwgPyBUUlVFIDogRkFMU0U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNvbnN0cmFpbjtcbiAgICAgICAgdmFyIG5lZ2F0aXZlRmlsdGVyID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gKHBhcmFtcy5hbGxvd05lZ2F0aXZlID09PSBmYWxzZSkgPyBbIE1hdGgubWF4ICgwLCBwb3NbMF0pLCBNYXRoLm1heCgwLCBwb3NbMV0pIF0gOiBwb3M7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9zZXRDb25zdHJhaW4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3RyYWluID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZSA6IHZhbHVlID8gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlRmlsdGVyKFtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgTWF0aC5taW4oY29uc3RyYWluUmVjdC53IC0gdGhpcy5zaXplWzBdLCBwb3NbMF0pKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgTWF0aC5taW4oY29uc3RyYWluUmVjdC5oIC0gdGhpcy5zaXplWzFdLCBwb3NbMV0pKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpIDogZnVuY3Rpb24ocG9zKSB7IHJldHVybiBuZWdhdGl2ZUZpbHRlcihwb3MpOyB9O1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgX3NldENvbnN0cmFpbih0eXBlb2YgdGhpcy5wYXJhbXMuY29uc3RyYWluID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLnBhcmFtcy5jb25zdHJhaW4gIDogKHRoaXMucGFyYW1zLmNvbnN0cmFpbiB8fCB0aGlzLnBhcmFtcy5jb250YWlubWVudCkpO1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIERyYWcgaXMgY29uc3RyYWluZWQuIEEgdmFsdWUgb2YgJ3RydWUnIG1lYW5zIGNvbnN0cmFpbiB0byBwYXJlbnQgYm91bmRzOyBhIGZ1bmN0aW9uXG4gICAgICAgICAqIHdpbGwgYmUgZXhlY3V0ZWQgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gaXMgYWxsb3dlZC5cbiAgICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldENvbnN0cmFpbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBfc2V0Q29uc3RyYWluKHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmV2ZXJ0RnVuY3Rpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGEgZnVuY3Rpb24gdG8gY2FsbCBvbiBkcmFnIHN0b3AsIHdoaWNoLCBpZiBpdCByZXR1cm5zIHRydWUsIGluZGljYXRlcyB0aGF0IHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZFxuICAgICAgICAgKiByZXZlcnQgdG8gaXRzIHBvc2l0aW9uIGJlZm9yZSB0aGUgcHJldmlvdXMgZHJhZy5cbiAgICAgICAgICogQHBhcmFtIGZuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFJldmVydCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICByZXZlcnRGdW5jdGlvbiA9IGZuO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfYXNzaWduSWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLl9rYXRhdm9yaW9JZCA9IF91dWlkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmouX2thdGF2b3Jpb0lkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgLy8gYSBtYXAgb2YgeyBzcGVjIC0+IFsgZm4sIGV4Y2x1c2lvbiBdIH0gZW50cmllcy5cbiAgICAgICAgICAgIF9maWx0ZXJzID0ge30sXG4gICAgICAgICAgICBfdGVzdEZpbHRlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX2ZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBfZmlsdGVyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSBmWzBdKGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZlsxXSkgcnYgPSAhcnY7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcnYpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NldEZpbHRlciA9IHRoaXMuc2V0RmlsdGVyID0gZnVuY3Rpb24oZiwgX2V4Y2x1ZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2Fzc2lnbklkKGYpO1xuICAgICAgICAgICAgICAgICAgICBfZmlsdGVyc1trZXldID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5zcmNFbGVtZW50IHx8IGUudGFyZ2V0LCBtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNTdHJpbmcoZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IG1hdGNoZXNTZWxlY3Rvcih0LCBmLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IGYoZSwgZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V4Y2x1ZGUgIT09IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2FkZEZpbHRlciA9IHRoaXMuYWRkRmlsdGVyID0gX3NldEZpbHRlcixcbiAgICAgICAgICAgIF9yZW1vdmVGaWx0ZXIgPSB0aGlzLnJlbW92ZUZpbHRlciA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdHlwZW9mIGYgPT0gXCJmdW5jdGlvblwiID8gZi5fa2F0YXZvcmlvSWQgOiBmO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfZmlsdGVyc1trZXldO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNsZWFyQWxsRmlsdGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX2ZpbHRlcnMgPSB7fTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNhbkRyYWcgPSB0aGlzLnBhcmFtcy5jYW5EcmFnIHx8IF90cnVlO1xuXG4gICAgICAgIHZhciBjb25zdHJhaW5SZWN0LFxuICAgICAgICAgICAgbWF0Y2hpbmdEcm9wcGFibGVzID0gW10sIGludGVyc2VjdGluZ0Ryb3BwYWJsZXMgPSBbXTtcblxuICAgICAgICB0aGlzLmRvd25MaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBpc05vdFJpZ2h0Q2xpY2sgPSB0aGlzLnJpZ2h0QnV0dG9uQ2FuRHJhZyB8fCAoZS53aGljaCAhPT0gMyAmJiBlLmJ1dHRvbiAhPT0gMik7XG4gICAgICAgICAgICBpZiAoaXNOb3RSaWdodENsaWNrICYmIHRoaXMuaXNFbmFibGVkKCkgJiYgdGhpcy5jYW5EcmFnKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2YgPSAgX3Rlc3RGaWx0ZXIoZSkgJiYgX2lucHV0RmlsdGVyKGUsIHRoaXMuZWwsIHRoaXMuayk7XG4gICAgICAgICAgICAgICAgaWYgKF9mKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnRWwgPSB0aGlzLmVsO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdFbCA9IHRoaXMuZWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0VsLnNldEF0dHJpYnV0ZShcImlkXCIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0VsLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNsb25lIG5vZGUgaXMgYWRkZWQgdG8gdGhlIGJvZHk7IGdldE9mZnNldFJlY3QgZ2l2ZXMgdXMgYSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGdldE9mZnNldFJlY3QodGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnRWwuc3R5bGUubGVmdCA9IGIubGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdFbC5zdHlsZS50b3AgPSBiLnRvcCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdW1lU3RhcnRFdmVudCAmJiBfY29uc3VtZShlKTtcbiAgICAgICAgICAgICAgICAgICAgZG93bkF0ID0gX3BsKGUpO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcy5iaW5kKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLmJpbmQoZG9jdW1lbnQsIFwibW91c2V1cFwiLCB0aGlzLnVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICBrLm1hcmtTZWxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGsubWFya1Bvc3Nlcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgY3NzLm5vU2VsZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgX2Rpc3BhdGNoKFwiYmVmb3JlU3RhcnRcIiwge2VsOnRoaXMuZWwsIHBvczpwb3NBdERvd24sIGU6ZSwgZHJhZzp0aGlzfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGFyYW1zLmNvbnN1bWVGaWx0ZXJlZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBfY29uc3VtZShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLm1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChkb3duQXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1vdmluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbnRpbnVlID0gX2Rpc3BhdGNoKFwic3RhcnRcIiwge2VsOnRoaXMuZWwsIHBvczpwb3NBdERvd24sIGU6ZSwgZHJhZzp0aGlzfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfY29udGludWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvd25BdCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIHN0YXJ0IGV2ZW50IGNhdXNlZCB0aGUgZHJhZyB0byBiZSBhYm9ydGVkLiBTbyB3ZSBjaGVja1xuICAgICAgICAgICAgICAgIC8vIGFnYWluIHRoYXQgd2UgYXJlIGN1cnJlbnRseSBkcmFnZ2luZy5cbiAgICAgICAgICAgICAgICBpZiAoZG93bkF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGluZ0Ryb3BwYWJsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IF9wbChlKSwgZHggPSBwb3NbMF0gLSBkb3duQXRbMF0sIGR5ID0gcG9zWzFdIC0gZG93bkF0WzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeiA9IHRoaXMucGFyYW1zLmlnbm9yZVpvb20gPyAxIDogay5nZXRab29tKCk7XG4gICAgICAgICAgICAgICAgICAgIGR4IC89IHo7XG4gICAgICAgICAgICAgICAgICAgIGR5IC89IHo7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUJ5KGR4LCBkeSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGsudXBkYXRlU2VsZWN0aW9uKGR4LCBkeSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGsudXBkYXRlUG9zc2VzKGR4LCBkeSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy51cExpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGRvd25BdCkge1xuICAgICAgICAgICAgICAgIGRvd25BdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMudW5iaW5kKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMudW5iaW5kKGRvY3VtZW50LCBcIm1vdXNldXBcIiwgdGhpcy51cExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcy5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCBjc3Mubm9TZWxlY3QpO1xuICAgICAgICAgICAgICAgIHRoaXMudW5tYXJrKGUpO1xuICAgICAgICAgICAgICAgIGsudW5tYXJrU2VsZWN0aW9uKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIGsudW5tYXJrUG9zc2VzKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcChlKTtcbiAgICAgICAgICAgICAgICBrLm5vdGlmeVNlbGVjdGlvbkRyYWdTdG9wKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIGsubm90aWZ5UG9zc2VEcmFnU3RvcCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBtb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0VsICYmIGRyYWdFbC5wYXJlbnROb2RlICYmIGRyYWdFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJldmVydEZ1bmN0aW9uICYmIHJldmVydEZ1bmN0aW9uKHRoaXMuZWwsIHRoaXMucGFyYW1zLmdldFBvc2l0aW9uKHRoaXMuZWwpKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcy5zZXRQb3NpdGlvbih0aGlzLmVsLCBwb3NBdERvd24pO1xuICAgICAgICAgICAgICAgICAgICBfZGlzcGF0Y2goXCJyZXZlcnRcIiwgdGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5nZXRGaWx0ZXJzID0gZnVuY3Rpb24oKSB7IHJldHVybiBfZmlsdGVyczsgfTtcblxuICAgICAgICB0aGlzLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZG93bkF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy51cExpc3RlbmVyKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXREcmFnRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWdFbCB8fCB0aGlzLmVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB7XCJzdGFydFwiOltdLCBcImRyYWdcIjpbXSwgXCJzdG9wXCI6W10sIFwib3ZlclwiOltdLCBcIm91dFwiOltdLCBcImJlZm9yZVN0YXJ0XCI6W10sIFwicmV2ZXJ0XCI6W10gfTtcbiAgICAgICAgaWYgKHBhcmFtcy5ldmVudHMuc3RhcnQpIGxpc3RlbmVycy5zdGFydC5wdXNoKHBhcmFtcy5ldmVudHMuc3RhcnQpO1xuICAgICAgICBpZiAocGFyYW1zLmV2ZW50cy5iZWZvcmVTdGFydCkgbGlzdGVuZXJzLmJlZm9yZVN0YXJ0LnB1c2gocGFyYW1zLmV2ZW50cy5iZWZvcmVTdGFydCk7XG4gICAgICAgIGlmIChwYXJhbXMuZXZlbnRzLnN0b3ApIGxpc3RlbmVycy5zdG9wLnB1c2gocGFyYW1zLmV2ZW50cy5zdG9wKTtcbiAgICAgICAgaWYgKHBhcmFtcy5ldmVudHMuZHJhZykgbGlzdGVuZXJzLmRyYWcucHVzaChwYXJhbXMuZXZlbnRzLmRyYWcpO1xuICAgICAgICBpZiAocGFyYW1zLmV2ZW50cy5yZXZlcnQpIGxpc3RlbmVycy5yZXZlcnQucHVzaChwYXJhbXMuZXZlbnRzLnJldmVydCk7XG5cbiAgICAgICAgdGhpcy5vbiA9IGZ1bmN0aW9uKGV2dCwgZm4pIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbZXZ0XSkgbGlzdGVuZXJzW2V2dF0ucHVzaChmbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vZmYgPSBmdW5jdGlvbihldnQsIGZuKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2V2dF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzW2V2dF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tldnRdW2ldICE9PSBmbikgbC5wdXNoKGxpc3RlbmVyc1tldnRdW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2V2dF0gPSBsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZGlzcGF0Y2ggPSBmdW5jdGlvbihldnQsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2V2dF0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVyc1tldnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbZXZ0XVtpXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm5vdGlmeVN0YXJ0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgX2Rpc3BhdGNoKFwic3RhcnRcIiwge2VsOnRoaXMuZWwsIHBvczp0aGlzLnBhcmFtcy5nZXRQb3NpdGlvbihkcmFnRWwpLCBlOmUsIGRyYWc6dGhpc30pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3RvcCA9IGZ1bmN0aW9uKGUsIGZvcmNlKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2UgfHwgbW92aW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBzZWwgPSBrLmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICBkUG9zID0gdGhpcy5wYXJhbXMuZ2V0UG9zaXRpb24oZHJhZ0VsKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBhcmFtcy5nZXRQb3NpdGlvbihzZWxbaV0uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goWyBzZWxbaV0uZWwsIHsgbGVmdDogcFswXSwgdG9wOiBwWzFdIH0sIHNlbFtpXSBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goWyBkcmFnRWwsIHtsZWZ0OmRQb3NbMF0sIHRvcDpkUG9zWzFdfSwgdGhpcyBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfZGlzcGF0Y2goXCJzdG9wXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IGRyYWdFbCxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBnaG9zdFByb3h5T2Zmc2V0cyB8fCBkUG9zLFxuICAgICAgICAgICAgICAgICAgICBmaW5hbFBvczpkUG9zLFxuICAgICAgICAgICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgICAgICAgICBkcmFnOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246cG9zaXRpb25zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tYXJrID0gZnVuY3Rpb24oYW5kTm90aWZ5KSB7XG4gICAgICAgICAgICBwb3NBdERvd24gPSB0aGlzLnBhcmFtcy5nZXRQb3NpdGlvbihkcmFnRWwpO1xuICAgICAgICAgICAgcGFnZVBvc0F0RG93biA9IHRoaXMucGFyYW1zLmdldFBvc2l0aW9uKGRyYWdFbCwgdHJ1ZSk7XG4gICAgICAgICAgICBwYWdlRGVsdGEgPSBbcGFnZVBvc0F0RG93blswXSAtIHBvc0F0RG93blswXSwgcGFnZVBvc0F0RG93blsxXSAtIHBvc0F0RG93blsxXV07XG4gICAgICAgICAgICB0aGlzLnNpemUgPSB0aGlzLnBhcmFtcy5nZXRTaXplKGRyYWdFbCk7XG4gICAgICAgICAgICBtYXRjaGluZ0Ryb3BwYWJsZXMgPSBrLmdldE1hdGNoaW5nRHJvcHBhYmxlcyh0aGlzKTtcbiAgICAgICAgICAgIF9zZXREcm9wcGFibGVzQWN0aXZlKG1hdGNoaW5nRHJvcHBhYmxlcywgdHJ1ZSwgZmFsc2UsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMuYWRkQ2xhc3MoZHJhZ0VsLCB0aGlzLnBhcmFtcy5kcmFnQ2xhc3MgfHwgY3NzLmRyYWcpO1xuICAgICAgICAgICAgLy9pZiAodGhpcy5wYXJhbXMuY29uc3RyYWluIHx8IHRoaXMucGFyYW1zLmNvbnRhaW5tZW50KSB7XG4gICAgICAgICAgICB2YXIgY3MgPSB0aGlzLnBhcmFtcy5nZXRTaXplKGRyYWdFbC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0cmFpblJlY3QgPSB7IHc6Y3NbMF0sIGg6Y3NbMV0gfTtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgaWYgKGFuZE5vdGlmeSkge1xuICAgICAgICAgICAgICAgIGsubm90aWZ5U2VsZWN0aW9uRHJhZ1N0YXJ0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2hvc3RQcm94eU9mZnNldHM7XG4gICAgICAgIHRoaXMudW5tYXJrID0gZnVuY3Rpb24oZSwgZG9Ob3RDaGVja0Ryb3BwYWJsZXMpIHtcbiAgICAgICAgICAgIF9zZXREcm9wcGFibGVzQWN0aXZlKG1hdGNoaW5nRHJvcHBhYmxlcywgZmFsc2UsIHRydWUsIHRoaXMpO1xuXG5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cmFpbmVkICYmIHVzZUdob3N0UHJveHkoKSkge1xuICAgICAgICAgICAgICAgIGdob3N0UHJveHlPZmZzZXRzID0gW2RyYWdFbC5vZmZzZXRMZWZ0LCBkcmFnRWwub2Zmc2V0VG9wXTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICAgICAgICBkcmFnRWwgPSB0aGlzLmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2hvc3RQcm94eU9mZnNldHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5yZW1vdmVDbGFzcyhkcmFnRWwsIHRoaXMucGFyYW1zLmRyYWdDbGFzcyB8fCBjc3MuZHJhZyk7XG4gICAgICAgICAgICBtYXRjaGluZ0Ryb3BwYWJsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlzQ29uc3RyYWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghZG9Ob3RDaGVja0Ryb3BwYWJsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW5nRHJvcHBhYmxlcy5sZW5ndGggPiAwICYmIGdob3N0UHJveHlPZmZzZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zZXRQb3NpdGlvbih0aGlzLmVsLCBnaG9zdFByb3h5T2Zmc2V0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJzZWN0aW5nRHJvcHBhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0VmFsID0gaW50ZXJzZWN0aW5nRHJvcHBhYmxlc1tpXS5kcm9wKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0VmFsID09PSB0cnVlKSBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW92ZUJ5ID0gZnVuY3Rpb24oZHgsIGR5LCBlKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3RpbmdEcm9wcGFibGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB2YXIgZGVzaXJlZExvYyA9IHRoaXMudG9HcmlkKFtwb3NBdERvd25bMF0gKyBkeCwgcG9zQXREb3duWzFdICsgZHldKSxcbiAgICAgICAgICAgICAgICBjUG9zID0gY29uc3RyYWluKGRlc2lyZWRMb2MsIGRyYWdFbCk7XG5cbiAgICAgICAgICAgIGlmICh1c2VHaG9zdFByb3h5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVzaXJlZExvY1swXSAhPSBjUG9zWzBdIHx8IGRlc2lyZWRMb2NbMV0gIT0gY1Bvc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ29uc3RyYWluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncCA9IGdob3N0UHJveHkodGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYWRkQ2xhc3MoZ3AsIF9jbGFzc2VzLmdob3N0UHJveHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGdwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdFbCA9IGdwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb25zdHJhaW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY1BvcyA9IGRlc2lyZWRMb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb25zdHJhaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnRWwgPSB0aGlzLmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb25zdHJhaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVjdCA9IHsgeDpjUG9zWzBdLCB5OmNQb3NbMV0sIHc6dGhpcy5zaXplWzBdLCBoOnRoaXMuc2l6ZVsxXX0sXG4gICAgICAgICAgICAgICAgcGFnZVJlY3QgPSB7IHg6cmVjdC54ICsgcGFnZURlbHRhWzBdLCB5OnJlY3QueSArIHBhZ2VEZWx0YVsxXSwgdzpyZWN0LncsIGg6cmVjdC5ofSxcbiAgICAgICAgICAgICAgICBmb2N1c0Ryb3BFbGVtZW50ID0gbnVsbDtcblxuXG5cbiAgICAgICAgICAgIHRoaXMucGFyYW1zLnNldFBvc2l0aW9uKGRyYWdFbCwgY1Bvcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoaW5nRHJvcHBhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByMiA9IHsgeDptYXRjaGluZ0Ryb3BwYWJsZXNbaV0ucGFnZVBvc2l0aW9uWzBdLCB5Om1hdGNoaW5nRHJvcHBhYmxlc1tpXS5wYWdlUG9zaXRpb25bMV0sIHc6bWF0Y2hpbmdEcm9wcGFibGVzW2ldLnNpemVbMF0sIGg6bWF0Y2hpbmdEcm9wcGFibGVzW2ldLnNpemVbMV19O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtcy5pbnRlcnNlY3RzKHBhZ2VSZWN0LCByMikgJiYgKF9tdWx0aXBsZURyb3AgfHwgZm9jdXNEcm9wRWxlbWVudCA9PSBudWxsIHx8IGZvY3VzRHJvcEVsZW1lbnQgPT0gbWF0Y2hpbmdEcm9wcGFibGVzW2ldLmVsKSAmJiBtYXRjaGluZ0Ryb3BwYWJsZXNbaV0uY2FuRHJvcCh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvY3VzRHJvcEVsZW1lbnQpIGZvY3VzRHJvcEVsZW1lbnQgPSBtYXRjaGluZ0Ryb3BwYWJsZXNbaV0uZWw7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGluZ0Ryb3BwYWJsZXMucHVzaChtYXRjaGluZ0Ryb3BwYWJsZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZ0Ryb3BwYWJsZXNbaV0uc2V0SG92ZXIodGhpcywgdHJ1ZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nRHJvcHBhYmxlc1tpXS5pc0hvdmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdEcm9wcGFibGVzW2ldLnNldEhvdmVyKHRoaXMsIGZhbHNlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9kaXNwYXRjaChcImRyYWdcIiwge2VsOnRoaXMuZWwsIHBvczpjUG9zLCBlOmUsIGRyYWc6dGhpc30pO1xuXG4gICAgICAgICAgICAvKiB0ZXN0IHRvIHNlZSBpZiB0aGUgcGFyZW50IG5lZWRzIHRvIGJlIHNjcm9sbGVkIChmdXR1cmUpXG4gICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgIHZhciBwbnNsID0gZHJhZ0VsLnBhcmVudE5vZGUuc2Nyb2xsTGVmdCwgcG5zdCA9IGRyYWdFbC5wYXJlbnROb2RlLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNjcm9sbCFcIiwgcG5zbCwgcG5zdCk7XG4gICAgICAgICAgICAgfSovXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMudW5iaW5kKHRoaXMuZWwsIFwibW91c2Vkb3duXCIsIHRoaXMuZG93bkxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLnVuYmluZChkb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMudW5iaW5kKGRvY3VtZW50LCBcIm1vdXNldXBcIiwgdGhpcy51cExpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuZG93bkxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudXBMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1vdmVMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaW5pdDpyZWdpc3RlciBtb3VzZWRvd24sIGFuZCBwZXJoYXBzIHNldCBhIGZpbHRlclxuICAgICAgICB0aGlzLnBhcmFtcy5iaW5kKHRoaXMuZWwsIFwibW91c2Vkb3duXCIsIHRoaXMuZG93bkxpc3RlbmVyKTtcblxuICAgICAgICAvLyBpZiBoYW5kbGUgcHJvdmRlZCwgdXNlIHRoYXQuICBvdGhlcndpc2UsIHRyeSB0byBzZXQgYSBmaWx0ZXIuXG4gICAgICAgIC8vIG5vdGUgdGhhdCBhIGBoYW5kbGVgIHNlbGVjdG9yIGFsd2F5cyByZXN1bHRzIGluIGZpbHRlckV4Y2x1ZGUgYmVpbmcgc2V0IHRvIGZhbHNlLCBpZS5cbiAgICAgICAgLy8gdGhlIHNlbGVjdG9yIGRlZmluZXMgdGhlIGhhbmRsZSBlbGVtZW50KHMpLlxuICAgICAgICBpZiAodGhpcy5wYXJhbXMuaGFuZGxlKVxuICAgICAgICAgICAgX3NldEZpbHRlcih0aGlzLnBhcmFtcy5oYW5kbGUsIGZhbHNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgX3NldEZpbHRlcih0aGlzLnBhcmFtcy5maWx0ZXIsIHRoaXMucGFyYW1zLmZpbHRlckV4Y2x1ZGUpO1xuICAgIH07XG5cbiAgICB2YXIgRHJvcCA9IGZ1bmN0aW9uKGVsLCBwYXJhbXMsIGNzcywgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5fY2xhc3MgPSBjc3MuZHJvcHBhYmxlO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgdGhpcy5fYWN0aXZlQ2xhc3MgPSB0aGlzLnBhcmFtcy5hY3RpdmVDbGFzcyB8fCBjc3MuYWN0aXZlO1xuICAgICAgICB0aGlzLl9ob3ZlckNsYXNzID0gdGhpcy5wYXJhbXMuaG92ZXJDbGFzcyB8fCBjc3MuaG92ZXI7XG4gICAgICAgIFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBob3ZlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG93TG9vcGJhY2sgPSB0aGlzLnBhcmFtcy5hbGxvd0xvb3BiYWNrICE9PSBmYWxzZTtcblxuICAgICAgICB0aGlzLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJhbXNbdmFsID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiXSh0aGlzLmVsLCB0aGlzLl9hY3RpdmVDbGFzcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucGFyYW1zLmdldFBvc2l0aW9uKHRoaXMuZWwpO1xuICAgICAgICAgICAgdGhpcy5wYWdlUG9zaXRpb24gPSB0aGlzLnBhcmFtcy5nZXRQb3NpdGlvbih0aGlzLmVsLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMucGFyYW1zLmdldFNpemUodGhpcy5lbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jYW5Ecm9wID0gdGhpcy5wYXJhbXMuY2FuRHJvcCB8fCBmdW5jdGlvbihkcmFnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmlzSG92ZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdmVyOyB9O1xuXG4gICAgICAgIHRoaXMuc2V0SG92ZXIgPSBmdW5jdGlvbihkcmFnLCB2YWwsIGUpIHtcbiAgICAgICAgICAgIC8vIGlmIHR1cm5pbmcgb2ZmIGhvdmVyIGJ1dCB0aGlzIHdhcyBub3QgdGhlIGRyYWcgdGhhdCBjYXVzZWQgdGhlIGhvdmVyLCBpZ25vcmUuXG4gICAgICAgICAgICBpZiAodmFsIHx8IHRoaXMuZWwuX2thdGF2b3Jpb0RyYWdIb3ZlciA9PSBudWxsIHx8IHRoaXMuZWwuX2thdGF2b3Jpb0RyYWdIb3ZlciA9PSBkcmFnLmVsLl9rYXRhdm9yaW8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtc1t2YWwgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKHRoaXMuZWwsIHRoaXMuX2hvdmVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5lbC5fa2F0YXZvcmlvRHJhZ0hvdmVyID0gdmFsID8gZHJhZy5lbC5fa2F0YXZvcmlvIDogbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLl9rYXRhdm9yaW9EcmFnSG92ZXIgPSB2YWwgPyBkcmFnLmVsLl9rYXRhdm9yaW8gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChob3ZlciAhPT0gdmFsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcy5ldmVudHNbdmFsID8gXCJvdmVyXCIgOiBcIm91dFwiXSh7ZWw6dGhpcy5lbCwgZTplLCBkcmFnOmRyYWcsIGRyb3A6dGhpc30pO1xuICAgICAgICAgICAgICAgIGhvdmVyID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZHJvcCA9IGZ1bmN0aW9uKGRyYWcsIGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuZXZlbnRzW1wiZHJvcFwiXSh7IGRyYWc6ZHJhZywgZTpldmVudCwgZHJvcDp0aGlzIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY2xhc3MgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlQ2xhc3MgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faG92ZXJDbGFzcyA9IG51bGw7XG4gICAgICAgICAgICAvL3RoaXMucGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgIGhvdmVyID0gbnVsbDtcbiAgICAgICAgICAgIC8vdGhpcy5lbCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfdXVpZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKCd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpKjE2fDAsIHYgPSBjID09ICd4JyA/IHIgOiAociYweDN8MHg4KTtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSkpO1xuICAgIH07XG5cbiAgICB2YXIgX2dlbCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGlmIChlbCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZWwgPSAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiIHx8IGVsLmNvbnN0cnVjdG9yID09IFN0cmluZykgID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwpIDogZWw7XG4gICAgICAgIGlmIChlbCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZWwuX2thdGF2b3JpbyA9IGVsLl9rYXRhdm9yaW8gfHwgX3V1aWQoKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG5cbiAgICByb290LkthdGF2b3JpbyA9IGZ1bmN0aW9uKGthdGF2b3Jpb1BhcmFtcykge1xuXG4gICAgICAgIHZhciBfc2VsZWN0aW9uID0gW10sXG4gICAgICAgICAgICBfc2VsZWN0aW9uTWFwID0ge307XG5cbiAgICAgICAgdGhpcy5fZHJhZ3NCeVNjb3BlID0ge307XG4gICAgICAgIHRoaXMuX2Ryb3BzQnlTY29wZSA9IHt9O1xuICAgICAgICB2YXIgX3pvb20gPSAxLFxuICAgICAgICAgICAgX3JlZyA9IGZ1bmN0aW9uKG9iaiwgbWFwKSB7XG4gICAgICAgICAgICAgICAgX2VhY2gob2JqLCBmdW5jdGlvbihfb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBfb2JqLnNjb3Blcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwW19vYmouc2NvcGVzW2ldXSA9IG1hcFtfb2JqLnNjb3Blc1tpXV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBbX29iai5zY29wZXNbaV1dLnB1c2goX29iaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdW5yZWcgPSBmdW5jdGlvbihvYmosIG1hcCkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgICAgICAgICBfZWFjaChvYmosIGZ1bmN0aW9uKF9vYmopIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IF9vYmouc2NvcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwW19vYmouc2NvcGVzW2ldXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBrYXRhdm9yaW9QYXJhbXMuaW5kZXhPZihtYXBbX29iai5zY29wZXNbaV1dLCBfb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcFtfb2JqLnNjb3Blc1tpXV0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjID4gMCA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldE1hdGNoaW5nRHJvcHBhYmxlcyA9IHRoaXMuZ2V0TWF0Y2hpbmdEcm9wcGFibGVzID0gZnVuY3Rpb24oZHJhZykge1xuICAgICAgICAgICAgICAgIHZhciBkZCA9IFtdLCBfbSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHJhZy5zY29wZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kZCA9IHRoaXMuX2Ryb3BzQnlTY29wZVtkcmFnLnNjb3Blc1tpXV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2RkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kZFtqXS5jYW5Ecm9wKGRyYWcpICYmICAhX21bX2RkW2pdLnV1aWRdICYmIChfZGRbal0uYWxsb3dMb29wYmFjayB8fCBfZGRbal0uZWwgIT09IGRyYWcuZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9tW19kZFtqXS51dWlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRkLnB1c2goX2RkW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wcmVwYXJlUGFyYW1zID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIHAgPSBwIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciBfcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOnt9XG4gICAgICAgICAgICAgICAgfSwgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4ga2F0YXZvcmlvUGFyYW1zKSBfcFtpXSA9IGthdGF2b3Jpb1BhcmFtc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gcCkgX3BbaV0gPSBwW2ldO1xuICAgICAgICAgICAgICAgIC8vIGV2ZW50c1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF9ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX3AuZXZlbnRzW19ldmVudHNbaV1dID0gcFtfZXZlbnRzW2ldXSB8fCBfZGV2TnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3Aua2F0YXZvcmlvID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3A7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfbWlzdGxldG9lID0gZnVuY3Rpb24oZXhpc3RpbmdEcmFnLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtc1tfZXZlbnRzW2ldXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdEcmFnLm9uKF9ldmVudHNbaV0sIHBhcmFtc1tfZXZlbnRzW2ldXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfY3NzID0ge30sXG4gICAgICAgICAgICBvdmVycmlkZUNzcyA9IGthdGF2b3Jpb1BhcmFtcy5jc3MgfHwge30sXG4gICAgICAgICAgICBfc2NvcGUgPSBrYXRhdm9yaW9QYXJhbXMuc2NvcGUgfHwgX2RlZmF1bHRTY29wZTtcblxuICAgICAgICAvLyBwcmVwYXJlIG1hcCBvZiBjc3MgY2xhc3NlcyBiYXNlZCBvbiBkZWZhdWx0cyBmcnN0LCB0aGVuIG9wdGlvbmFsIG92ZXJyaWRlc1xuICAgICAgICBmb3IgKHZhciBpIGluIF9jbGFzc2VzKSBfY3NzW2ldID0gX2NsYXNzZXNbaV07XG4gICAgICAgIGZvciAodmFyIGkgaW4gb3ZlcnJpZGVDc3MpIF9jc3NbaV0gPSBvdmVycmlkZUNzc1tpXTtcblxuICAgICAgICB2YXIgaW5wdXRGaWx0ZXJTZWxlY3RvciA9IGthdGF2b3Jpb1BhcmFtcy5pbnB1dEZpbHRlclNlbGVjdG9yIHx8IF9kZWZhdWx0SW5wdXRGaWx0ZXJTZWxlY3RvcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHNlbGVjdG9yIGlkZW50aWZ5aW5nIHdoaWNoIGlucHV0IGVsZW1lbnRzIHRvIGZpbHRlciBmcm9tIGRyYWcgZXZlbnRzLlxuICAgICAgICAgKiBAbWV0aG9kIGdldElucHV0RmlsdGVyU2VsZWN0b3JcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBDdXJyZW50IGlucHV0IGZpbHRlciBzZWxlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0SW5wdXRGaWx0ZXJTZWxlY3RvciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5wdXRGaWx0ZXJTZWxlY3RvcjsgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc2VsZWN0b3IgaWRlbnRpZnlpbmcgd2hpY2ggaW5wdXQgZWxlbWVudHMgdG8gZmlsdGVyIGZyb20gZHJhZyBldmVudHMuXG4gICAgICAgICAqIEBtZXRob2Qgc2V0SW5wdXRGaWx0ZXJTZWxlY3RvclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgSW5wdXQgZmlsdGVyIHNlbGVjdG9yIHRvIHNldC5cbiAgICAgICAgICogQHJldHVybiB7S2F0YXZvcmlvfSBDdXJyZW50IGluc3RhbmNlOyBtZXRob2QgbWF5IGJlIGNoYWluZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldElucHV0RmlsdGVyU2VsZWN0b3IgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgaW5wdXRGaWx0ZXJTZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmdW5jdGlvbihlbCwgcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgbyA9IFtdO1xuICAgICAgICAgICAgX2VhY2goZWwsIGZ1bmN0aW9uKF9lbCkge1xuICAgICAgICAgICAgICAgIF9lbCA9IF9nZWwoX2VsKTtcbiAgICAgICAgICAgICAgICBpZiAoX2VsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9lbC5fa2F0YXZvcmlvRHJhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IF9wcmVwYXJlUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWwuX2thdGF2b3Jpb0RyYWcgPSBuZXcgRHJhZyhfZWwsIHAsIF9jc3MsIF9zY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVnKF9lbC5fa2F0YXZvcmlvRHJhZywgdGhpcy5fZHJhZ3NCeVNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucHVzaChfZWwuX2thdGF2b3Jpb0RyYWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2F0YXZvcmlvUGFyYW1zLmFkZENsYXNzKF9lbCwgX2Nzcy5kcmFnZ2FibGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX21pc3RsZXRvZShfZWwuX2thdGF2b3Jpb0RyYWcsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIG87XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRyb3BwYWJsZSA9IGZ1bmN0aW9uKGVsLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBvID0gW107XG4gICAgICAgICAgICBfZWFjaChlbCwgZnVuY3Rpb24oX2VsKSB7XG4gICAgICAgICAgICAgICAgX2VsID0gX2dlbChfZWwpO1xuICAgICAgICAgICAgICAgIGlmIChfZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcCA9IG5ldyBEcm9wKF9lbCwgX3ByZXBhcmVQYXJhbXMocGFyYW1zKSwgX2NzcywgX3Njb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgX2VsLl9rYXRhdm9yaW9Ecm9wID0gX2VsLl9rYXRhdm9yaW9Ecm9wIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBfZWwuX2thdGF2b3Jpb0Ryb3AucHVzaChkcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgX3JlZyhkcm9wLCB0aGlzLl9kcm9wc0J5U2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBvLnB1c2goZHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGthdGF2b3Jpb1BhcmFtcy5hZGRDbGFzcyhfZWwsIF9jc3MuZHJvcHBhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIEthdGF2b3JpbyNzZWxlY3RcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBkZXNjIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGZvciBtdWx0aXBsZSBub2RlIGRyYWcpXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IERPTSBlbGVtZW50IC0gb3IgaWQgb2YgdGhlIGVsZW1lbnQgLSB0byBhZGQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBfZWFjaChlbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbCA9IF9nZWwodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKF9lbCAmJiBfZWwuX2thdGF2b3Jpb0RyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfc2VsZWN0aW9uTWFwW19lbC5fa2F0YXZvcmlvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NlbGVjdGlvbi5wdXNoKF9lbC5fa2F0YXZvcmlvRHJhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc2VsZWN0aW9uTWFwW19lbC5fa2F0YXZvcmlvXSA9IFsgX2VsLCBfc2VsZWN0aW9uLmxlbmd0aCAtIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGthdGF2b3Jpb1BhcmFtcy5hZGRDbGFzcyhfZWwsIF9jc3Muc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgS2F0YXZvcmlvI2Rlc2VsZWN0XG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAZGVzYyBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGZvciBtdWx0aXBsZSBub2RlIGRyYWcpXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IERPTSBlbGVtZW50IC0gb3IgaWQgb2YgdGhlIGVsZW1lbnQgLSB0byByZW1vdmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc2VsZWN0ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIF9lYWNoKGVsLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VsID0gX2dlbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoX2VsICYmIF9lbC5fa2F0YXZvcmlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gX3NlbGVjdGlvbk1hcFtfZWwuX2thdGF2b3Jpb107XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3NlbGVjdGlvbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3NlbGVjdGlvbltpXS5lbCAhPT0gX2VsKSBfcy5wdXNoKF9zZWxlY3Rpb25baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NlbGVjdGlvbiA9IF9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9zZWxlY3Rpb25NYXBbX2VsLl9rYXRhdm9yaW9dO1xuICAgICAgICAgICAgICAgICAgICAgICAga2F0YXZvcmlvUGFyYW1zLnJlbW92ZUNsYXNzKF9lbCwgX2Nzcy5zZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGVzZWxlY3RBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gX3NlbGVjdGlvbk1hcCkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gX3NlbGVjdGlvbk1hcFtpXTtcbiAgICAgICAgICAgICAgICBrYXRhdm9yaW9QYXJhbXMucmVtb3ZlQ2xhc3MoZFswXSwgX2Nzcy5zZWxlY3RlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9zZWxlY3Rpb24ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIF9zZWxlY3Rpb25NYXAgPSB7fTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm1hcmtTZWxlY3Rpb24gPSBmdW5jdGlvbihkcmFnKSB7XG4gICAgICAgICAgICBfZm9yZWFjaChfc2VsZWN0aW9uLCBmdW5jdGlvbihlKSB7IGUubWFyaygpOyB9LCBkcmFnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm1hcmtQb3NzZXMgPSBmdW5jdGlvbihkcmFnKSB7XG4gICAgICAgICAgICBpZiAoZHJhZy5wb3NzZXMpIHtcbiAgICAgICAgICAgICAgICBfZWFjaChkcmFnLnBvc3NlcywgZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZy5wb3NzZVJvbGVzW3BdICYmIF9wb3NzZXNbcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mb3JlYWNoKF9wb3NzZXNbcF0ubWVtYmVycywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLm1hcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGRyYWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVubWFya1NlbGVjdGlvbiA9IGZ1bmN0aW9uKGRyYWcsIGV2ZW50KSB7XG4gICAgICAgICAgICBfZm9yZWFjaChfc2VsZWN0aW9uLCBmdW5jdGlvbihlKSB7IGUudW5tYXJrKGV2ZW50KTsgfSwgZHJhZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51bm1hcmtQb3NzZXMgPSBmdW5jdGlvbihkcmFnLCBldmVudCkge1xuICAgICAgICAgICAgaWYgKGRyYWcucG9zc2VzKSB7XG4gICAgICAgICAgICAgICAgX2VhY2goZHJhZy5wb3NzZXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWcucG9zc2VSb2xlc1twXSAmJiBfcG9zc2VzW3BdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZm9yZWFjaChfcG9zc2VzW3BdLm1lbWJlcnMsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC51bm1hcmsoZXZlbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZHJhZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gX3NlbGVjdGlvbi5zbGljZSgwKTsgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKGR4LCBkeSwgZHJhZykge1xuICAgICAgICAgICAgX2ZvcmVhY2goX3NlbGVjdGlvbiwgZnVuY3Rpb24oZSkgeyBlLm1vdmVCeShkeCwgZHkpOyB9LCBkcmFnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX3Bvc3NlQWN0aW9uID0gZnVuY3Rpb24oZm4sIGRyYWcpIHtcbiAgICAgICAgICAgIGlmIChkcmFnLnBvc3Nlcykge1xuICAgICAgICAgICAgICAgIF9lYWNoKGRyYWcucG9zc2VzLCBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnLnBvc3NlUm9sZXNbcF0gJiYgX3Bvc3Nlc1twXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZvcmVhY2goX3Bvc3Nlc1twXS5tZW1iZXJzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZHJhZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVBvc3NlcyA9IGZ1bmN0aW9uKGR4LCBkeSwgZHJhZykge1xuICAgICAgICAgICAgX3Bvc3NlQWN0aW9uKGZ1bmN0aW9uKGUpIHsgZS5tb3ZlQnkoZHgsIGR5KTsgfSwgZHJhZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ub3RpZnlQb3NzZURyYWdTdG9wID0gZnVuY3Rpb24oZHJhZywgZXZ0KSB7XG4gICAgICAgICAgICBfcG9zc2VBY3Rpb24oZnVuY3Rpb24oZSkgeyBlLnN0b3AoZXZ0LCB0cnVlKTsgfSwgZHJhZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ub3RpZnlTZWxlY3Rpb25EcmFnU3RvcCA9IGZ1bmN0aW9uKGRyYWcsIGV2dCkge1xuICAgICAgICAgICAgX2ZvcmVhY2goX3NlbGVjdGlvbiwgZnVuY3Rpb24oZSkgeyBlLnN0b3AoZXZ0LCB0cnVlKTsgfSwgZHJhZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ub3RpZnlTZWxlY3Rpb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnLCBldnQpIHtcbiAgICAgICAgICAgIF9mb3JlYWNoKF9zZWxlY3Rpb24sIGZ1bmN0aW9uKGUpIHsgZS5ub3RpZnlTdGFydChldnQpO30sIGRyYWcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0Wm9vbSA9IGZ1bmN0aW9uKHopIHsgX3pvb20gPSB6OyB9O1xuICAgICAgICB0aGlzLmdldFpvb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIF96b29tOyB9O1xuXG4gICAgICAgIC8vIGRvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgc2NvcGVzXG4gICAgICAgIHZhciBfc2NvcGVNYW5pcCA9IGZ1bmN0aW9uKGtPYmosIHNjb3BlcywgbWFwLCBmbikge1xuICAgICAgICAgICAgX2VhY2goa09iaiwgZnVuY3Rpb24oX2tPYmopIHtcbiAgICAgICAgICAgICAgICBfdW5yZWcoX2tPYmosIG1hcCk7ICAvLyBkZXJlZ2lzdGVyIGV4aXN0aW5nIHNjb3Blc1xuICAgICAgICAgICAgICAgIF9rT2JqW2ZuXShzY29wZXMpOyAvLyBzZXQgc2NvcGVzXG4gICAgICAgICAgICAgICAgX3JlZyhfa09iaiwgbWFwKTsgLy8gcmVnaXN0ZXIgbmV3IG9uZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9lYWNoKFsgXCJzZXRcIiwgXCJhZGRcIiwgXCJyZW1vdmVcIiwgXCJ0b2dnbGVcIl0sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHRoaXNbdiArIFwiU2NvcGVcIl0gPSBmdW5jdGlvbihlbCwgc2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgX3Njb3BlTWFuaXAoZWwuX2thdGF2b3Jpb0RyYWcsIHNjb3BlcywgdGhpcy5fZHJhZ3NCeVNjb3BlLCB2ICsgXCJTY29wZVwiKTtcbiAgICAgICAgICAgICAgICBfc2NvcGVNYW5pcChlbC5fa2F0YXZvcmlvRHJvcCwgc2NvcGVzLCB0aGlzLl9kcm9wc0J5U2NvcGUsIHYgKyBcIlNjb3BlXCIpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpc1t2ICsgXCJEcmFnU2NvcGVcIl0gPSBmdW5jdGlvbihlbCwgc2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgX3Njb3BlTWFuaXAoZWwuY29uc3RydWN0b3IgPT09IERyYWcgPyBlbCA6IGVsLl9rYXRhdm9yaW9EcmFnLCBzY29wZXMsIHRoaXMuX2RyYWdzQnlTY29wZSwgdiArIFwiU2NvcGVcIik7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzW3YgKyBcIkRyb3BTY29wZVwiXSA9IGZ1bmN0aW9uKGVsLCBzY29wZXMpIHtcbiAgICAgICAgICAgICAgICBfc2NvcGVNYW5pcChlbC5jb25zdHJ1Y3RvciA9PT0gRHJvcCA/IGVsIDogZWwuX2thdGF2b3Jpb0Ryb3AsIHNjb3BlcywgdGhpcy5fZHJvcHNCeVNjb3BlLCB2ICsgXCJTY29wZVwiKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLnNuYXBUb0dyaWQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzIGluIHRoaXMuX2RyYWdzQnlTY29wZSkge1xuICAgICAgICAgICAgICAgIF9mb3JlYWNoKHRoaXMuX2RyYWdzQnlTY29wZVtzXSwgZnVuY3Rpb24oZCkgeyBkLnNuYXAoeCwgeSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0RHJhZ3NGb3JTY29wZSA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHRoaXMuX2RyYWdzQnlTY29wZVtzXTsgfTtcbiAgICAgICAgdGhpcy5nZXREcm9wc0ZvclNjb3BlID0gZnVuY3Rpb24ocykgeyByZXR1cm4gdGhpcy5fZHJvcHNCeVNjb3BlW3NdOyB9O1xuXG4gICAgICAgIHZhciBfZGVzdHJveSA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBtYXApIHtcbiAgICAgICAgICAgIGVsID0gX2dlbChlbCk7XG4gICAgICAgICAgICBpZiAoZWxbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoX3VucmVnKGVsW3R5cGVdLCBtYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKGVsW3R5cGVdLCBmdW5jdGlvbihrT2JqKSB7IGtPYmouZGVzdHJveSgpIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbFt0eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmVsZW1lbnRSZW1vdmVkID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveURyYWdnYWJsZShlbCk7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lEcm9wcGFibGUoZWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGVzdHJveURyYWdnYWJsZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBfZGVzdHJveShlbCwgXCJfa2F0YXZvcmlvRHJhZ1wiLCB0aGlzLl9kcmFnc0J5U2NvcGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGVzdHJveURyb3BwYWJsZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBfZGVzdHJveShlbCwgXCJfa2F0YXZvcmlvRHJvcFwiLCB0aGlzLl9kcm9wc0J5U2NvcGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdzQnlTY29wZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fZHJvcHNCeVNjb3BlID0ge307XG4gICAgICAgICAgICBfc2VsZWN0aW9uID0gW107XG4gICAgICAgICAgICBfc2VsZWN0aW9uTWFwID0ge307XG4gICAgICAgICAgICBfcG9zc2VzID0ge307XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gLS0tLS0gZ3JvdXBzXG4gICAgICAgIHZhciBfcG9zc2VzID0ge307XG5cbiAgICAgICAgdmFyIF9wcm9jZXNzT25lU3BlYyA9IGZ1bmN0aW9uKGVsLCBfc3BlYywgZG9udEFkZEV4aXN0aW5nKSB7XG4gICAgICAgICAgICB2YXIgcG9zc2VJZCA9IF9pc1N0cmluZyhfc3BlYykgPyBfc3BlYyA6IF9zcGVjLmlkO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IF9pc1N0cmluZyhfc3BlYykgPyB0cnVlIDogX3NwZWMuYWN0aXZlICE9PSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwb3NzZSA9IF9wb3NzZXNbcG9zc2VJZF0gfHwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBnID0ge25hbWU6cG9zc2VJZCwgbWVtYmVyczpbXX07XG4gICAgICAgICAgICAgICAgX3Bvc3Nlc1twb3NzZUlkXSA9IGc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgX2VhY2goZWwsIGZ1bmN0aW9uKF9lbCkge1xuICAgICAgICAgICAgICAgIGlmIChfZWwuX2thdGF2b3Jpb0RyYWcpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9udEFkZEV4aXN0aW5nICYmIF9lbC5fa2F0YXZvcmlvRHJhZy5wb3NzZVJvbGVzW3Bvc3NlLm5hbWVdICE9IG51bGwpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBfc3VnZ2VzdChwb3NzZS5tZW1iZXJzLCBfZWwuX2thdGF2b3Jpb0RyYWcpO1xuICAgICAgICAgICAgICAgICAgICBfc3VnZ2VzdChfZWwuX2thdGF2b3Jpb0RyYWcucG9zc2VzLCBwb3NzZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgX2VsLl9rYXRhdm9yaW9EcmFnLnBvc3NlUm9sZXNbcG9zc2UubmFtZV0gPSBhY3RpdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcG9zc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCB0aGUgZ2l2ZW4gZWxlbWVudCB0byB0aGUgcG9zc2Ugd2l0aCB0aGUgZ2l2ZW4gaWQsIGNyZWF0aW5nIHRoZSBncm91cCBpZiBpdCBhdCBmaXJzdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICogQG1ldGhvZCBhZGRUb1Bvc3NlXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgRWxlbWVudCB0byBhZGQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nLi4ufE9iamVjdC4uLn0gc3BlYyBWYXJpYWJsZSBhcmdzIHBhcmFtZXRlcnMuIEVhY2ggYXJndW1lbnQgY2FuIGJlIGEgZWl0aGVyIGEgU3RyaW5nLCBpbmRpY2F0aW5nXG4gICAgICAgICAqIHRoZSBJRCBvZiBhIFBvc3NlIHRvIHdoaWNoIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhZGRlZCBhcyBhbiBhY3RpdmUgcGFydGljaXBhbnQsIG9yIGFuIE9iamVjdCBjb250YWluaW5nXG4gICAgICAgICAqIGB7IGlkOlwicG9zc2VJZFwiLCBhY3RpdmU6ZmFsc2UvdHJ1ZX1gLiBJbiB0aGUgbGF0dGVyIGNhc2UsIGlmIGBhY3RpdmVgIGlzIG5vdCBwcm92aWRlZCBpdCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICAgICAqIHRydWUuXG4gICAgICAgICAqIEByZXR1cm5zIHtQb3NzZXxQb3NzZVtdfSBUaGUgUG9zc2UocykgdG8gd2hpY2ggdGhlIGVsZW1lbnQocykgd2FzL3dlcmUgYWRkZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFkZFRvUG9zc2UgPSBmdW5jdGlvbihlbCwgc3BlYykge1xuXG4gICAgICAgICAgICB2YXIgcG9zc2VzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9zc2VzLnB1c2goX3Byb2Nlc3NPbmVTcGVjKGVsLCBhcmd1bWVudHNbaV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBvc3Nlcy5sZW5ndGggPT0gMSA/IHBvc3Nlc1swXSA6IHBvc3NlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgcG9zc2UocykgZm9yIHRoZSBlbGVtZW50IHdpdGggdGhlIGdpdmVuIGlkLCBjcmVhdGluZyB0aG9zZSB0aGF0IGRvIG5vdCB5ZXQgZXhpc3QsIGFuZCByZW1vdmluZyBmcm9tXG4gICAgICAgICAqIHRoZSBlbGVtZW50IGFueSBjdXJyZW50IFBvc3NlcyB0aGF0IGFyZSBub3Qgc3BlY2lmaWVkIGJ5IHRoaXMgbWV0aG9kIGNhbGwuIFRoaXMgbWV0aG9kIHdpbGwgbm90IGNoYW5nZSB0aGVcbiAgICAgICAgICogYWN0aXZlL3Bhc3NpdmUgc3RhdGUgaWYgaXQgaXMgZ2l2ZW4gYSBwb3NzZSBpbiB3aGljaCB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGEgbWVtYmVyLlxuICAgICAgICAgKiBAbWV0aG9kIHNldFBvc3NlXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgRWxlbWVudCB0byBzZXQgcG9zc2Uocykgb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nLi4ufE9iamVjdC4uLn0gc3BlYyBWYXJpYWJsZSBhcmdzIHBhcmFtZXRlcnMuIEVhY2ggYXJndW1lbnQgY2FuIGJlIGEgZWl0aGVyIGEgU3RyaW5nLCBpbmRpY2F0aW5nXG4gICAgICAgICAqIHRoZSBJRCBvZiBhIFBvc3NlIHRvIHdoaWNoIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhZGRlZCBhcyBhbiBhY3RpdmUgcGFydGljaXBhbnQsIG9yIGFuIE9iamVjdCBjb250YWluaW5nXG4gICAgICAgICAqIGB7IGlkOlwicG9zc2VJZFwiLCBhY3RpdmU6ZmFsc2UvdHJ1ZX1gLiBJbiB0aGUgbGF0dGVyIGNhc2UsIGlmIGBhY3RpdmVgIGlzIG5vdCBwcm92aWRlZCBpdCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICAgICAqIHRydWUuXG4gICAgICAgICAqIEByZXR1cm5zIHtQb3NzZXxQb3NzZVtdfSBUaGUgUG9zc2UocykgdG8gd2hpY2ggdGhlIGVsZW1lbnQocykgbm93IGJlbG9uZ3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFBvc3NlID0gZnVuY3Rpb24oZWwsIHNwZWMpIHtcblxuICAgICAgICAgICAgdmFyIHBvc3NlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBvc3Nlcy5wdXNoKF9wcm9jZXNzT25lU3BlYyhlbCwgYXJndW1lbnRzW2ldLCB0cnVlKS5uYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2VhY2goZWwsIGZ1bmN0aW9uKF9lbCkge1xuICAgICAgICAgICAgICAgIGlmIChfZWwuX2thdGF2b3Jpb0RyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBfZGlmZmVyZW5jZShfZWwuX2thdGF2b3Jpb0RyYWcucG9zc2VzLCBwb3NzZXMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShwLCBfZWwuX2thdGF2b3Jpb0RyYWcucG9zc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZyb21Qb3NzZShfZWwsIGRpZmZbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHBvc3Nlcy5sZW5ndGggPT0gMSA/IHBvc3Nlc1swXSA6IHBvc3NlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBlbGVtZW50IGZyb20gdGhlIGdpdmVuIHBvc3NlKHMpLlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUZyb21Qb3NzZVxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIEVsZW1lbnQgdG8gcmVtb3ZlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZy4uLn0gcG9zc2VJZCBWYXJhcmdzIHBhcmFtZXRlcjogb25lIHZhbHVlIGZvciBlYWNoIHBvc3NlIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW1vdmVGcm9tUG9zc2UgPSBmdW5jdGlvbihlbCwgcG9zc2VJZCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gcG9zc2UgaWQgcHJvdmlkZWQgZm9yIHJlbW92ZSBvcGVyYXRpb25cIik7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9zc2VJZCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBfZWFjaChlbCwgZnVuY3Rpb24gKF9lbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2VsLl9rYXRhdm9yaW9EcmFnICYmIF9lbC5fa2F0YXZvcmlvRHJhZy5wb3NzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gX2VsLl9rYXRhdm9yaW9EcmFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VhY2gocG9zc2VJZCwgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmFucXVpc2goX3Bvc3Nlc1twXS5tZW1iZXJzLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmFucXVpc2goZC5wb3NzZXMsIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkLnBvc3NlUm9sZXNbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGVsZW1lbnQgZnJvbSBhbGwgUG9zc2VzIHRvIHdoaWNoIGl0IGJlbG9uZ3MuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlRnJvbUFsbFBvc3Nlc1xuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBlbCBFbGVtZW50IHRvIHJlbW92ZSBmcm9tIFBvc3Nlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbUFsbFBvc3NlcyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBfZWFjaChlbCwgZnVuY3Rpb24oX2VsKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9lbC5fa2F0YXZvcmlvRHJhZyAmJiBfZWwuX2thdGF2b3Jpb0RyYWcucG9zc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gX2VsLl9rYXRhdm9yaW9EcmFnO1xuICAgICAgICAgICAgICAgICAgICBfZWFjaChkLnBvc3NlcywgZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbnF1aXNoKF9wb3NzZXNbcF0ubWVtYmVycywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkLnBvc3Nlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBkLnBvc3NlUm9sZXMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgcGFydGljaXBhdGlvbiBzdGF0ZSBmb3IgdGhlIGVsZW1lbnQgaW4gdGhlIFBvc3NlIHdpdGggdGhlIGdpdmVuIElELlxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBlbCBFbGVtZW50KHMpIHRvIGNoYW5nZSBzdGF0ZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NzZUlkIElEIG9mIHRoZSBQb3NzZSB0byBjaGFuZ2UgZWxlbWVudCBzdGF0ZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdGUgVHJ1ZSB0byBtYWtlIGFjdGl2ZSwgZmFsc2UgdG8gbWFrZSBwYXNzaXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRQb3NzZVN0YXRlID0gZnVuY3Rpb24oZWwsIHBvc3NlSWQsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgcG9zc2UgPSBfcG9zc2VzW3Bvc3NlSWRdO1xuICAgICAgICAgICAgaWYgKHBvc3NlKSB7XG4gICAgICAgICAgICAgICAgX2VhY2goZWwsIGZ1bmN0aW9uKF9lbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2VsLl9rYXRhdm9yaW9EcmFnICYmIF9lbC5fa2F0YXZvcmlvRHJhZy5wb3NzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lbC5fa2F0YXZvcmlvRHJhZy5wb3NzZVJvbGVzW3Bvc3NlLm5hbWVdID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuXG4vKlxuICoganNQbHVtYlxuICpcbiAqIFRpdGxlOmpzUGx1bWIgMi4xLjBcbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byB2aXN1YWxseSBjb25uZWN0IGVsZW1lbnRzIG9uIGFuIEhUTUwgcGFnZSwgdXNpbmcgU1ZHLlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IHJ1biBpbiBib3RoIGJyb3dzZXJzIGFuZCBoZWFkbGVzcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE2IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqXG4gKiBodHRwOi8vanNwbHVtYnRvb2xraXQuY29tXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9zcG9ycml0dC9qc3BsdW1iXG4gKlxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG5cbjtcbihmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgX2lzYSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc251bSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG4pID09PSBcIltvYmplY3QgTnVtYmVyXVwiO1xuICAgICAgICB9LFxuICAgICAgICBfaXNzID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzYiA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHMgPT09IFwiYm9vbGVhblwiO1xuICAgICAgICB9LFxuICAgICAgICBfaXNudWxsID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzID09IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc28gPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgcmV0dXJuIG8gPT0gbnVsbCA/IGZhbHNlIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICAgICAgICB9LFxuICAgICAgICBfaXNkID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiO1xuICAgICAgICB9LFxuICAgICAgICBfaXNmID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIjtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzTmFtZWRGdW5jdGlvbiA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBfaXNmKG8pICYmIG8ubmFtZSAhPSBudWxsICYmIG8ubmFtZS5sZW5ndGggPiAwO1xuICAgICAgICB9LFxuICAgICAgICBfaXNlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbykge1xuICAgICAgICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgIHZhciByb290ID0gdGhpcztcbiAgICB2YXIgZXhwb3J0cyA9IHJvb3QuanNQbHVtYlV0aWwgPSB7XG4gICAgICAgIGlzQXJyYXk6IF9pc2EsXG4gICAgICAgIGlzU3RyaW5nOiBfaXNzLFxuICAgICAgICBpc0Jvb2xlYW46IF9pc2IsXG4gICAgICAgIGlzTnVsbDogX2lzbnVsbCxcbiAgICAgICAgaXNPYmplY3Q6IF9pc28sXG4gICAgICAgIGlzRGF0ZTogX2lzZCxcbiAgICAgICAgaXNGdW5jdGlvbjogX2lzZixcbiAgICAgICAgaXNFbXB0eTogX2lzZSxcbiAgICAgICAgaXNOdW1iZXI6IF9pc251bSxcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBpZiAoX2lzcyhhKSkgcmV0dXJuIFwiXCIgKyBhO1xuICAgICAgICAgICAgZWxzZSBpZiAoX2lzYihhKSkgcmV0dXJuICEhYTtcbiAgICAgICAgICAgIGVsc2UgaWYgKF9pc2QoYSkpIHJldHVybiBuZXcgRGF0ZShhLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChfaXNmKGEpKSByZXR1cm4gYTtcbiAgICAgICAgICAgIGVsc2UgaWYgKF9pc2EoYSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgYi5wdXNoKHRoaXMuY2xvbmUoYVtpXSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2lzbyhhKSkge1xuICAgICAgICAgICAgICAgIHZhciBjID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBhKVxuICAgICAgICAgICAgICAgICAgICBjW2pdID0gdGhpcy5jbG9uZShhW2pdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGE7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmdlOiBmdW5jdGlvbiAoYSwgYiwgY29sbGF0aW9ucykge1xuICAgICAgICAgICAgLy8gZmlyc3QgY2hhbmdlIHRoZSBjb2xsYXRpb25zIGFycmF5IC0gaWYgcHJlc2VudCAtIGludG8gYSBsb29rdXAgdGFibGUsIGJlY2F1c2UgaXRzIGZhc3Rlci5cbiAgICAgICAgICAgIHZhciBjTWFwID0ge30sIGFyLCBpO1xuICAgICAgICAgICAgY29sbGF0aW9ucyA9IGNvbGxhdGlvbnMgfHwgW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sbGF0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBjTWFwW2NvbGxhdGlvbnNbaV1dID0gdHJ1ZTtcblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKGEpO1xuICAgICAgICAgICAgZm9yIChpIGluIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY1tpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNbaV0gPSBiW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfaXNzKGJbaV0pIHx8IF9pc2IoYltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjTWFwW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjW2ldID0gYltpXTsgLy8gaWYgd2UgZG9udCB3YW50IHRvIGNvbGxhdGUsIGp1c3QgY29weSBpdCBpbi5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjJ3Mgb2JqZWN0IGlzIGFsc28gYW4gYXJyYXkgd2UgY2FuIGtlZXAgaXRzIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyLnB1c2guYXBwbHkoYXIsIF9pc2EoY1tpXSkgPyBjW2ldIDogWyBjW2ldIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXIucHVzaC5hcHBseShhciwgX2lzYShiW2ldKSA/IGJbaV0gOiBbIGJbaV0gXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjW2ldID0gYXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNhKGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYydzIG9iamVjdCBpcyBhbHNvIGFuIGFycmF5IHdlIGNhbiBrZWVwIGl0cyB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzYShjW2ldKSkgYXIucHVzaC5hcHBseShhciwgY1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhci5wdXNoLmFwcGx5KGFyLCBiW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNbaV0gPSBhcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfaXNvKGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdmVyd2l0ZSBjJ3MgdmFsdWUgd2l0aCBhbiBvYmplY3QgaWYgaXQgaXMgbm90IGFscmVhZHkgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXNvKGNbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbaV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gYltpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbaV1bal0gPSBiW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfSxcbiAgICAgICAgcmVwbGFjZTogZnVuY3Rpb24gKGluT2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGluT2JqID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBxID0gaW5PYmosIHQgPSBxO1xuICAgICAgICAgICAgcGF0aC5yZXBsYWNlKC8oW15cXC5dKSsvZywgZnVuY3Rpb24gKHRlcm0sIGxjLCBwb3MsIHN0cikge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IHRlcm0ubWF0Y2goLyhbXlxcWzAtOV0rKXsxfShcXFspKFswLTkrXSkvKSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHBvcyArIHRlcm0ubGVuZ3RoID49IHN0ci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIF9nZXRBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0W2FycmF5WzFdXSB8fCAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRbYXJyYXlbMV1dID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRbYXJyYXlbMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCB0ZXJtID0gdmFsdWUgb24gY3VycmVudCB0LCBjcmVhdGluZyB0ZXJtIGFzIGFycmF5IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgX2dldEFycmF5KClbYXJyYXlbM11dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRbdGVybV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCB0byBjdXJyZW50IHRbdGVybV0sIGNyZWF0aW5nIHRbdGVybV0gaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gX2dldEFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gYVthcnJheVszXV0gfHwgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2FycmF5WzNdXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhW2FycmF5WzNdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHRbdGVybV0gfHwgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W3Rlcm1dID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRbdGVybV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gaW5PYmo7XG4gICAgICAgIH0sXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNoYWluIGEgbGlzdCBvZiBmdW5jdGlvbnMsIHN1cHBsaWVkIGJ5IFsgb2JqZWN0LCBtZXRob2QgbmFtZSwgYXJncyBdLCBhbmQgcmV0dXJuIG9uIHRoZSBmaXJzdFxuICAgICAgICAvLyBvbmUgdGhhdCByZXR1cm5zIHRoZSBmYWlsVmFsdWUuIGlmIG5vbmUgcmV0dXJuIHRoZSBmYWlsVmFsdWUsIHJldHVybiB0aGUgc3VjY2Vzc1ZhbHVlLlxuICAgICAgICAvL1xuICAgICAgICBmdW5jdGlvbkNoYWluOiBmdW5jdGlvbiAoc3VjY2Vzc1ZhbHVlLCBmYWlsVmFsdWUsIGZucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IGZuc1tpXVswXVtmbnNbaV1bMV1dLmFwcGx5KGZuc1tpXVswXSwgZm5zW2ldWzJdKTtcbiAgICAgICAgICAgICAgICBpZiAobyA9PT0gZmFpbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzVmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHRha2UgdGhlIGdpdmVuIG1vZGVsIGFuZCBleHBhbmQgb3V0IGFueSBwYXJhbWV0ZXJzLlxuICAgICAgICAvLyAnZnVuY3Rpb25QcmVmaXgnIGlzIG9wdGlvbmFsLCBhbmQgaWYgcHJlc2VudCwgaGVscHMganNwbHVtYiBmaWd1cmUgb3V0IHdoYXQgdG8gZG8gaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uLlxuICAgICAgICAvLyBpZiB5b3UgZG8gbm90IHByb3ZpZGUgaXQsIGpzcGx1bWIgd2lsbCBydW4gdGhlIGdpdmVuIHZhbHVlcyB0aHJvdWdoIGFueSBmdW5jdGlvbnMgaXQgZmluZHMsIGFuZCB1c2UgdGhlIGZ1bmN0aW9uJ3NcbiAgICAgICAgLy8gb3V0cHV0IGFzIHRoZSB2YWx1ZSBpbiB0aGUgcmVzdWx0LiBpZiB5b3UgZG8gcHJvdmlkZSB0aGUgcHJlZml4LCBvbmx5IGZ1bmN0aW9ucyB0aGF0IGFyZSBuYW1lZCBhbmQgaGF2ZSB0aGlzIHByZWZpeFxuICAgICAgICAvLyB3aWxsIGJlIGV4ZWN1dGVkOyBvdGhlciBmdW5jdGlvbnMgd2lsbCBiZSBwYXNzZWQgYXMgdmFsdWVzIHRvIHRoZSBvdXRwdXQuXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiAobW9kZWwsIHZhbHVlcywgZnVuY3Rpb25QcmVmaXgpIHtcbiAgICAgICAgICAgIC8vIGZvciBhIHN0cmluZywgc2VlIGlmIGl0IGhhcyBwYXJhbWV0ZXIgbWF0Y2hlcywgYW5kIGlmIHNvLCB0cnkgdG8gbWFrZSB0aGUgc3Vic3RpdHV0aW9ucy5cbiAgICAgICAgICAgIHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIChmcm9tU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gZnJvbVN0cmluZy5tYXRjaCgvKFxcJHsuKj99KS9nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHZhbHVlc1ttYXRjaGVzW2ldLnN1YnN0cmluZygyLCBtYXRjaGVzW2ldLmxlbmd0aCAtIDEpXSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tU3RyaW5nID0gZnJvbVN0cmluZy5yZXBsYWNlKG1hdGNoZXNbaV0sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwcm9jZXNzIG9uZSBlbnRyeS5cbiAgICAgICAgICAgICAgICBfb25lID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc3MoZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWUoZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfaXNmKGQpICYmIChmdW5jdGlvblByZWZpeCA9PSBudWxsIHx8IChkLm5hbWUgfHwgXCJcIikuaW5kZXhPZihmdW5jdGlvblByZWZpeCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQodmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pc2EoZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5wdXNoKF9vbmUoZFtpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX2lzbyhkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNbal0gPSBfb25lKGRbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIF9vbmUobW9kZWwpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kV2l0aEZ1bmN0aW9uOiBmdW5jdGlvbiAoYSwgZikge1xuICAgICAgICAgICAgaWYgKGEpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSBpZiAoZihhW2ldKSkgcmV0dXJuIGk7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVdpdGhGdW5jdGlvbjogZnVuY3Rpb24gKGEsIGYpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBleHBvcnRzLmZpbmRXaXRoRnVuY3Rpb24oYSwgZik7XG4gICAgICAgICAgICBpZiAoaWR4ID4gLTEpIGEuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gaWR4ICE9IC0xO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChsLCB2KSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gbC5pbmRleE9mKHYpO1xuICAgICAgICAgICAgaWYgKGlkeCA+IC0xKSBsLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIGlkeCAhPSAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IGluc2VydCBpbmRleFxuICAgICAgICBhZGRXaXRoRnVuY3Rpb246IGZ1bmN0aW9uIChsaXN0LCBpdGVtLCBoYXNoRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRzLmZpbmRXaXRoRnVuY3Rpb24obGlzdCwgaGFzaEZ1bmN0aW9uKSA9PSAtMSkgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9LFxuICAgICAgICBhZGRUb0xpc3Q6IGZ1bmN0aW9uIChtYXAsIGtleSwgdmFsdWUsIGluc2VydEF0U3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBsID0gbWFwW2tleV07XG4gICAgICAgICAgICBpZiAobCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbCA9IFtdO1xuICAgICAgICAgICAgICAgIG1hcFtrZXldID0gbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxbaW5zZXJ0QXRTdGFydCA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCJdKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9LFxuICAgICAgICBzdWdnZXN0IDogZnVuY3Rpb24obGlzdCwgaXRlbSwgaW5zZXJ0QXRIZWFkKSB7XG4gICAgICAgICAgICBpZiAobGlzdC5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnRBdEhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGV4dGVuZHMgdGhlIGdpdmVuIG9iaiAod2hpY2ggY2FuIGJlIGFuIGFycmF5KSB3aXRoIHRoZSBnaXZlbiBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcHJvdG90eXBlIGZ1bmN0aW9ucywgYW5kXG4gICAgICAgIC8vIGNsYXNzIG1lbWJlcnMsIGFueSBvZiB3aGljaCBtYXkgYmUgbnVsbC5cbiAgICAgICAgLy9cbiAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCwgX3Byb3RvRm4pIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgcGFyZW50ID0gX2lzYShwYXJlbnQpID8gcGFyZW50IDogWyBwYXJlbnQgXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gcGFyZW50W2ldLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50W2ldLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlW2pdID0gcGFyZW50W2ldLnByb3RvdHlwZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9tYWtlRm4gPSBmdW5jdGlvbiAobmFtZSwgcHJvdG9Gbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRbaV0ucHJvdG90eXBlW25hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFtpXS5wcm90b3R5cGVbbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG9Gbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgX29uZVNldCA9IGZ1bmN0aW9uIChmbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGZucykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5wcm90b3R5cGVba10gPSBfbWFrZUZuKGssIGZuc1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgX29uZVNldChhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH0sXG4gICAgICAgIHV1aWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvZ0VuYWJsZWQ6IHRydWUsXG4gICAgICAgIGxvZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMubG9nRW5hYmxlZCAmJiB0eXBlb2YgY29uc29sZSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcmFwcyBvbmUgZnVuY3Rpb24gd2l0aCBhbm90aGVyLCBjcmVhdGluZyBhIHBsYWNlaG9sZGVyIGZvciB0aGVcbiAgICAgICAgICogd3JhcHBlZCBmdW5jdGlvbiBpZiBpdCB3YXMgbnVsbC4gdGhpcyBpcyB1c2VkIHRvIHdyYXAgdGhlIHZhcmlvdXNcbiAgICAgICAgICogZHJhZy9kcm9wIGV2ZW50IGZ1bmN0aW9ucyAtIHRvIGFsbG93IGpzUGx1bWIgdG8gYmUgbm90aWZpZWQgb2ZcbiAgICAgICAgICogaW1wb3J0YW50IGxpZmVjeWNsZSBldmVudHMgd2l0aG91dCBpbXBvc2luZyBpdHNlbGYgb24gdGhlIHVzZXInc1xuICAgICAgICAgKiBkcmFnL2Ryb3AgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgICogQG1ldGhvZCBqc1BsdW1iVXRpbC53cmFwXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZWRGdW5jdGlvbiBvcmlnaW5hbCBmdW5jdGlvbiB0byB3cmFwOyBtYXkgYmUgbnVsbC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3RnVuY3Rpb24gZnVuY3Rpb24gdG8gd3JhcCB0aGUgb3JpZ2luYWwgd2l0aC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtyZXR1cm5PblRoaXNWYWx1ZV0gT3B0aW9uYWwuIEluZGljYXRlcyB0aGF0IHRoZSB3cmFwcGVkRnVuY3Rpb24gc2hvdWxkXG4gICAgICAgICAqIG5vdCBiZSBleGVjdXRlZCBpZiB0aGUgbmV3RnVuY3Rpb24gcmV0dXJucyBhIHZhbHVlIG1hdGNoaW5nICdyZXR1cm5PblRoaXNWYWx1ZScuXG4gICAgICAgICAqIG5vdGUgdGhhdCB0aGlzIGlzIGEgc2ltcGxlIGNvbXBhcmlzb24gYW5kIG9ubHkgd29ya3MgZm9yIHByaW1pdGl2ZXMgcmlnaHQgbm93LlxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcDogZnVuY3Rpb24gKHdyYXBwZWRGdW5jdGlvbiwgbmV3RnVuY3Rpb24sIHJldHVybk9uVGhpc1ZhbHVlKSB7XG4gICAgICAgICAgICB3cmFwcGVkRnVuY3Rpb24gPSB3cmFwcGVkRnVuY3Rpb24gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5ld0Z1bmN0aW9uID0gbmV3RnVuY3Rpb24gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBuZXdGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5sb2coXCJqc1BsdW1iIGZ1bmN0aW9uIGZhaWxlZCA6IFwiICsgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5PblRoaXNWYWx1ZSA9PSBudWxsIHx8IChyICE9PSByZXR1cm5PblRoaXNWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB3cmFwcGVkRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5sb2coXCJ3cmFwcGVkIGZ1bmN0aW9uIGZhaWxlZCA6IFwiICsgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGV4cG9ydHMuRXZlbnRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfbGlzdGVuZXJzID0ge30sXG4gICAgICAgICAgICBldmVudHNTdXNwZW5kZWQgPSBmYWxzZSxcbiAgICAgICAgLy8gdGhpcyBpcyBhIGxpc3Qgb2YgZXZlbnRzIHRoYXQgc2hvdWxkIHJlLXRocm93IGFueSBlcnJvcnMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlaXIgZGlzcGF0Y2guIGl0IGlzIGN1cnJlbnQgcHJpdmF0ZS5cbiAgICAgICAgICAgIGV2ZW50c1RvRGllT24gPSB7IFwicmVhZHlcIjogdHJ1ZSB9O1xuXG4gICAgICAgIHRoaXMuYmluZCA9IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIsIGluc2VydEF0U3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBfb25lID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5hZGRUb0xpc3QoX2xpc3RlbmVycywgZXZ0LCBsaXN0ZW5lciwgaW5zZXJ0QXRTdGFydCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuX19qc1BsdW1iID0gbGlzdGVuZXIuX19qc1BsdW1iIHx8IHt9O1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLl9fanNQbHVtYltyb290LmpzUGx1bWJVdGlsLnV1aWQoKV0gPSBldnQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSBfb25lKGV2ZW50KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50Lmxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfb25lKGV2ZW50W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZmlyZSA9IGZ1bmN0aW9uIChldmVudCwgdmFsdWUsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghZXZlbnRzU3VzcGVuZGVkICYmIF9saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBfbGlzdGVuZXJzW2V2ZW50XS5sZW5ndGgsIGkgPSAwLCBfZ29uZSA9IGZhbHNlLCByZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRGaXJlRXZlbnQgfHwgdGhpcy5zaG91bGRGaXJlRXZlbnQoZXZlbnQsIHZhbHVlLCBvcmlnaW5hbEV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIV9nb25lICYmIGkgPCBsICYmIHJldCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvaW5nIGl0IHRoaXMgd2F5IHJhdGhlciB0aGFuIGNhdGNoaW5nIGFuZCB0aGVuIHBvc3NpYmx5IHJlLXRocm93aW5nIG1lYW5zIHRoYXQgYW4gZXJyb3IgcHJvcGFnYXRlZCBieSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXRob2Qgd2lsbCBoYXZlIHRoZSB3aG9sZSBjYWxsIHN0YWNrIGF2YWlsYWJsZSBpbiB0aGUgZGVidWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRzVG9EaWVPbltldmVudF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xpc3RlbmVyc1tldmVudF1baV0uYXBwbHkodGhpcywgWyB2YWx1ZSwgb3JpZ2luYWxFdmVudF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gX2xpc3RlbmVyc1tldmVudF1baV0uYXBwbHkodGhpcywgWyB2YWx1ZSwgb3JpZ2luYWxFdmVudCBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHMubG9nKFwianNQbHVtYjogZmlyZSBmYWlsZWQgZm9yIGV2ZW50IFwiICsgZXZlbnQgKyBcIiA6IFwiICsgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9saXN0ZW5lcnMgPT0gbnVsbCB8fCBfbGlzdGVuZXJzW2V2ZW50XSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudW5iaW5kID0gZnVuY3Rpb24gKGV2ZW50T3JMaXN0ZW5lciwgbGlzdGVuZXIpIHtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBfbGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudE9yTGlzdGVuZXIgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfbGlzdGVuZXJzW2V2ZW50T3JMaXN0ZW5lcl07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRPckxpc3RlbmVyLl9fanNQbHVtYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZ0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGV2ZW50T3JMaXN0ZW5lci5fX2pzUGx1bWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dCA9IGV2ZW50T3JMaXN0ZW5lci5fX2pzUGx1bWJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzLnJlbW92ZShfbGlzdGVuZXJzW2V2dF0gfHwgW10sIGV2ZW50T3JMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5yZW1vdmUoX2xpc3RlbmVyc1tldmVudE9yTGlzdGVuZXJdIHx8IFtdLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0TGlzdGVuZXIgPSBmdW5jdGlvbiAoZm9yRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfbGlzdGVuZXJzW2ZvckV2ZW50XTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRTdXNwZW5kRXZlbnRzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgZXZlbnRzU3VzcGVuZGVkID0gdmFsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzU3VzcGVuZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudHNTdXNwZW5kZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2lsZW50bHkgPSBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdXNwZW5kRXZlbnRzKHRydWUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByb290LmpzUGx1bWJVdGlsLmxvZyhcIkNhbm5vdCBleGVjdXRlIHNpbGVudCBmdW5jdGlvbiBcIiArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdXNwZW5kRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhbnVwTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBfbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgX2xpc3RlbmVyc1tpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGV4cG9ydHMuRXZlbnRHZW5lcmF0b3IucHJvdG90eXBlID0ge1xuICAgICAgICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXBMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pLmNhbGwodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzKTtcblxuLypcbiAqIGpzUGx1bWJcbiAqXG4gKiBUaXRsZTpqc1BsdW1iIDIuMS4wXG4gKlxuICogUHJvdmlkZXMgYSB3YXkgdG8gdmlzdWFsbHkgY29ubmVjdCBlbGVtZW50cyBvbiBhbiBIVE1MIHBhZ2UsIHVzaW5nIFNWRy5cbiAqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBydW4gaW4gYnJvd3NlcnMgb25seS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE2IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqXG4gKiBodHRwOi8vanNwbHVtYnRvb2xraXQuY29tXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9zcG9ycml0dC9qc3BsdW1iXG4gKlxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG4gOyhmdW5jdGlvbigpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICAgdmFyIHJvb3QgPSB0aGlzO1xuICAgdmFyIGV4cG9ydHMgPSByb290LmpzUGx1bWJVdGlsO1xuXG4gICBleHBvcnRzLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKGVsLCBzZWxlY3RvciwgY3R4KSB7XG4gICAgICAgY3R4ID0gY3R4IHx8IGVsLnBhcmVudE5vZGU7XG4gICAgICAgdmFyIHBvc3NpYmxlcyA9IGN0eC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3NpYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICBpZiAocG9zc2libGVzW2ldID09PSBlbClcbiAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gZmFsc2U7XG4gICB9O1xuXG4gICBleHBvcnRzLmNvbnN1bWUgPSBmdW5jdGlvbihlLCBkb05vdFByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgIGVsc2VcbiAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgaWYgKCFkb05vdFByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICB9O1xuXG4gICAvKlxuICAgICogRnVuY3Rpb246IHNpemVFbGVtZW50XG4gICAgKiBIZWxwZXIgdG8gc2l6ZSBhbmQgcG9zaXRpb24gYW4gZWxlbWVudC4gWW91IHdvdWxkIHR5cGljYWxseSB1c2VcbiAgICAqIHRoaXMgd2hlbiB3cml0aW5nIHlvdXIgb3duIENvbm5lY3RvciBvciBFbmRwb2ludCBpbXBsZW1lbnRhdGlvbi5cbiAgICAqXG4gICAgKiBQYXJhbWV0ZXJzOlxuICAgICogIHggLSBbaW50XSB4IHBvc2l0aW9uIGZvciB0aGUgZWxlbWVudCBvcmlnaW5cbiAgICAqICB5IC0gW2ludF0geSBwb3NpdGlvbiBmb3IgdGhlIGVsZW1lbnQgb3JpZ2luXG4gICAgKiAgdyAtIFtpbnRdIHdpZHRoIG9mIHRoZSBlbGVtZW50XG4gICAgKiAgaCAtIFtpbnRdIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgICpcbiAgICAqL1xuICAgZXhwb3J0cy5zaXplRWxlbWVudCA9IGZ1bmN0aW9uKGVsLCB4LCB5LCB3LCBoKSB7XG4gICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGggKyBcInB4XCI7XG4gICAgICAgICAgIGVsLmhlaWdodCA9IGg7XG4gICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gdyArIFwicHhcIjtcbiAgICAgICAgICAgZWwud2lkdGggPSB3O1xuICAgICAgICAgICBlbC5zdHlsZS5sZWZ0ID0geCArIFwicHhcIjtcbiAgICAgICAgICAgZWwuc3R5bGUudG9wID0geSArIFwicHhcIjtcbiAgICAgICB9XG4gICB9O1xuXG5cbiB9KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qXG4gKiBqc1BsdW1iXG4gKiBcbiAqIFRpdGxlOmpzUGx1bWIgMi4xLjBcbiAqIFxuICogUHJvdmlkZXMgYSB3YXkgdG8gdmlzdWFsbHkgY29ubmVjdCBlbGVtZW50cyBvbiBhbiBIVE1MIHBhZ2UsIHVzaW5nIFNWRy5cbiAqIFxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBjb3JlIGNvZGUuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNiBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXG4gKiBcbiAqIGh0dHA6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHA6Ly9naXRodWIuY29tL3Nwb3JyaXR0L2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgcm9vdCA9IHRoaXM7XG4gICAgdmFyIGNvbm5lY3RvclR5cGVzID0gW10sIHJlbmRlcmVyVHlwZXM7XG5cbiAgICB2YXIgX2p1ID0gcm9vdC5qc1BsdW1iVXRpbCxcbiAgICAgICAgX2dldE9mZnNldCA9IGZ1bmN0aW9uIChlbCwgX2luc3RhbmNlLCByZWxhdGl2ZVRvUm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIF9pbnN0YW5jZS5nZXRPZmZzZXQoZWwsIHJlbGF0aXZlVG9Sb290KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogY3JlYXRlcyBhIHRpbWVzdGFtcCwgdXNpbmcgbWlsbGlzZWNvbmRzIHNpbmNlIDE5NzAsIGJ1dCBhcyBhIHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIF90aW1lc3RhbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgIH0sXG5cbiAgICAvLyBoZWxwZXIgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgaG92ZXIgc3R5bGUgd2hlbmV2ZXIgaXQsIG9yIHBhaW50U3R5bGUsIGNoYW5nZXMuXG4gICAgLy8gd2UgdXNlIHBhaW50U3R5bGUgYXMgdGhlIGZvdW5kYXRpb24gYW5kIG1lcmdlIGhvdmVyUGFpbnRTdHlsZSBvdmVyIHRoZVxuICAgIC8vIHRvcC5cbiAgICAgICAgX3VwZGF0ZUhvdmVyU3R5bGUgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Ll9qc1BsdW1iLnBhaW50U3R5bGUgJiYgY29tcG9uZW50Ll9qc1BsdW1iLmhvdmVyUGFpbnRTdHlsZSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXJnZWRIb3ZlclN0eWxlID0ge307XG4gICAgICAgICAgICAgICAganNQbHVtYi5leHRlbmQobWVyZ2VkSG92ZXJTdHlsZSwgY29tcG9uZW50Ll9qc1BsdW1iLnBhaW50U3R5bGUpO1xuICAgICAgICAgICAgICAgIGpzUGx1bWIuZXh0ZW5kKG1lcmdlZEhvdmVyU3R5bGUsIGNvbXBvbmVudC5fanNQbHVtYi5ob3ZlclBhaW50U3R5bGUpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnQuX2pzUGx1bWIuaG92ZXJQYWludFN0eWxlO1xuICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdGhlIGZpbGxTdHlsZSBvZiBwYWludFN0eWxlIHRvIG92ZXJyaWRlIGEgZ3JhZGllbnQsIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgIGlmIChtZXJnZWRIb3ZlclN0eWxlLmdyYWRpZW50ICYmIGNvbXBvbmVudC5fanNQbHVtYi5wYWludFN0eWxlLmZpbGxTdHlsZSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lcmdlZEhvdmVyU3R5bGUuZ3JhZGllbnQ7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Ll9qc1BsdW1iLmhvdmVyUGFpbnRTdHlsZSA9IG1lcmdlZEhvdmVyU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50cyA9IFtcInRhcFwiLCBcImRibHRhcFwiLCBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW91dFwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNlZG93blwiLCBcIm1vdXNldXBcIiwgXCJjb250ZXh0bWVudVwiIF0sXG4gICAgICAgIGV2ZW50RmlsdGVycyA9IHsgXCJtb3VzZW91dFwiOiBcIm1vdXNlbGVhdmVcIiwgXCJtb3VzZWV4aXRcIjogXCJtb3VzZWxlYXZlXCIgfSxcbiAgICAgICAgX3VwZGF0ZUF0dGFjaGVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBzdGF0ZSwgdGltZXN0YW1wLCBzb3VyY2VFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRFbGVtZW50cyA9IGNvbXBvbmVudC5nZXRBdHRhY2hlZEVsZW1lbnRzKCk7XG4gICAgICAgICAgICBpZiAoYWZmZWN0ZWRFbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gYWZmZWN0ZWRFbGVtZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VFbGVtZW50IHx8IHNvdXJjZUVsZW1lbnQgIT0gYWZmZWN0ZWRFbGVtZW50c1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRWxlbWVudHNbaV0uc2V0SG92ZXIoc3RhdGUsIHRydWUsIHRpbWVzdGFtcCk7XHRcdFx0Ly8gdGVsbCB0aGUgYXR0YWNoZWQgZWxlbWVudHMgbm90IHRvIGluZm9ybSB0aGVpciBvd24gYXR0YWNoZWQgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfc3BsaXRUeXBlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ID09IG51bGwgPyBudWxsIDogdC5zcGxpdChcIiBcIik7XG4gICAgICAgIH0sXG4gICAgICAgIF9tYXBUeXBlID0gZnVuY3Rpb24obWFwLCBvYmosIHR5cGVJZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopXG4gICAgICAgICAgICAgICAgbWFwW2ldID0gdHlwZUlkO1xuICAgICAgICB9LFxuICAgICAgICBfZWFjaCA9IGZ1bmN0aW9uKGZuLCBvYmopIHtcbiAgICAgICAgICAgIG9iaiA9IF9qdS5pc0FycmF5KG9iaikgfHwgKG9iai5sZW5ndGggIT0gbnVsbCAmJiAhX2p1LmlzU3RyaW5nKG9iaikpID8gb2JqIDogWyBvYmogXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkob2JqW2ldLCBbIG9ialtpXSBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2p1LmxvZyhcIi5lYWNoIGl0ZXJhdGlvbiBmYWlsZWQgOiBcIiArIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2FwcGx5VHlwZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBwYXJhbXMsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5nZXREZWZhdWx0VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZCA9IGNvbXBvbmVudC5nZXRUeXBlRGVzY3JpcHRvcigpLCBtYXAgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmVHlwZSA9IGNvbXBvbmVudC5nZXREZWZhdWx0VHlwZSgpO1xuICAgICAgICAgICAgICAgIHZhciBvID0gX2p1Lm1lcmdlKHt9LCBkZWZUeXBlKTtcbiAgICAgICAgICAgICAgICBfbWFwVHlwZShtYXAsIGRlZlR5cGUsIFwiX19kZWZhdWx0XCIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gY29tcG9uZW50Ll9qc1BsdW1iLnR5cGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGlkID0gY29tcG9uZW50Ll9qc1BsdW1iLnR5cGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlkICE9PSBcIl9fZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3QgPSBjb21wb25lbnQuX2pzUGx1bWIuaW5zdGFuY2UuZ2V0VHlwZSh0aWQsIHRkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IF9qdS5tZXJnZShvLCBfdCwgWyBcImNzc0NsYXNzXCIgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX21hcFR5cGUobWFwLCBfdCwgdGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbyA9IF9qdS5wb3B1bGF0ZShvLCBwYXJhbXMsIFwiX1wiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQuYXBwbHlUeXBlKG8sIGRvTm90UmVwYWludCwgbWFwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvTm90UmVwYWludCkgY29tcG9uZW50LnJlcGFpbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEJFR0lOIGpzUGx1bWJVSUNvbXBvbmVudCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGpzUGx1bWJVSUNvbXBvbmVudCA9IHJvb3QuanNQbHVtYlVJQ29tcG9uZW50ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuXG4gICAgICAgICAgICBfanUuRXZlbnRHZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGEgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgaWRQcmVmaXggPSBzZWxmLmlkUHJlZml4LFxuICAgICAgICAgICAgICAgIGlkID0gaWRQcmVmaXggKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iID0ge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBwYXJhbXMuX2pzUGx1bWIsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogcGFyYW1zLnBhcmFtZXRlcnMgfHwge30sXG4gICAgICAgICAgICAgICAgcGFpbnRTdHlsZTogbnVsbCxcbiAgICAgICAgICAgICAgICBob3ZlclBhaW50U3R5bGU6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFpbnRTdHlsZUluVXNlOiBudWxsLFxuICAgICAgICAgICAgICAgIGhvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBiZWZvcmVEZXRhY2g6IHBhcmFtcy5iZWZvcmVEZXRhY2gsXG4gICAgICAgICAgICAgICAgYmVmb3JlRHJvcDogcGFyYW1zLmJlZm9yZURyb3AsXG4gICAgICAgICAgICAgICAgb3ZlcmxheVBsYWNlbWVudHM6IFtdLFxuICAgICAgICAgICAgICAgIGhvdmVyQ2xhc3M6IHBhcmFtcy5ob3ZlckNsYXNzIHx8IHBhcmFtcy5fanNQbHVtYi5EZWZhdWx0cy5Ib3ZlckNsYXNzLFxuICAgICAgICAgICAgICAgIHR5cGVzOiBbXSxcbiAgICAgICAgICAgICAgICB0eXBlQ2FjaGU6e31cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVUeXBlSXRlbSA9IGZ1bmN0aW9uKGtleSwgaXRlbSwgdHlwZUlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi50eXBlQ2FjaGVbdHlwZUlkXSA9IHRoaXMuX2pzUGx1bWIudHlwZUNhY2hlW3R5cGVJZF0gfHwge307XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi50eXBlQ2FjaGVbdHlwZUlkXVtrZXldID0gaXRlbTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmdldENhY2hlZFR5cGVJdGVtID0gZnVuY3Rpb24oa2V5LCB0eXBlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi50eXBlQ2FjaGVbdHlwZUlkXSA/IHRoaXMuX2pzUGx1bWIudHlwZUNhY2hlW3R5cGVJZF1ba2V5XSA6IG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmdldElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGRlZmF1bHQgdHlwZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgICAgICAgIHZhciBvID0gcGFyYW1zLm92ZXJsYXlzIHx8IFtdLCBvbyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdE92ZXJsYXlLZXlzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRlZmF1bHRPdmVybGF5S2V5cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobywgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5EZWZhdWx0c1t0aGlzLmRlZmF1bHRPdmVybGF5S2V5c1tpXV0gfHwgW10pO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSBzdHJpbmcsIGNvbnZlcnQgdG8gb2JqZWN0IHJlcHJlc2VudGF0aW9uIHNvIHRoYXQgd2UgY2FuIHN0b3JlIHRoZSB0eXBlaWQgb24gaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYXNzaWduIGFuIGlkLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZm8gPSBqc1BsdW1iLmNvbnZlcnRUb0Z1bGxPdmVybGF5U3BlYyhvW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgb29bZm9bMV0uaWRdID0gZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2RlZmF1bHRUeXBlID0ge1xuICAgICAgICAgICAgICAgIG92ZXJsYXlzOm9vLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtcy5wYXJhbWV0ZXJzIHx8IHt9LFxuICAgICAgICAgICAgICAgIHNjb3BlOiBwYXJhbXMuc2NvcGUgfHwgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5nZXREZWZhdWx0U2NvcGUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVmYXVsdFR5cGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2RlZmF1bHRUeXBlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9EZWZhdWx0VHlwZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb2JqKSBfZGVmYXVsdFR5cGVbaV0gPSBvYmpbaV07XG4gICAgICAgICAgICB9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBlbmQgZGVmYXVsdCB0eXBlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8vIGFsbCBjb21wb25lbnRzIGNhbiBnZW5lcmF0ZSBldmVudHNcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gcGFyYW1zLmV2ZW50cylcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5iaW5kKGksIHBhcmFtcy5ldmVudHNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhbGwgY29tcG9uZW50cyBnZXQgdGhpcyBjbG9uZSBmdW5jdGlvbi5cbiAgICAgICAgICAgIC8vIFRPRE8gaXNzdWUgMTE2IHNob3dlZCBhIHByb2JsZW0gd2l0aCB0aGlzIC0gaXQgc2VlbXMgJ2EnIHRoYXQgaXMgaW5cbiAgICAgICAgICAgIC8vIHRoZSBjbG9uZSBmdW5jdGlvbidzIHNjb3BlIGlzIHNoYXJlZCBieSBhbGwgaW52b2NhdGlvbnMgb2YgaXQsIHRoZSBjbGFzc2ljXG4gICAgICAgICAgICAvLyBKUyBjbG9zdXJlIHByb2JsZW0uICBmb3Igbm93LCBqc1BsdW1iIGRvZXMgYSB2ZXJzaW9uIG9mIHRoaXMgaW5saW5lIHdoZXJlXG4gICAgICAgICAgICAvLyBpdCB1c2VkIHRvIGNhbGwgY2xvbmUuICBidXQgaXQgd291bGQgYmUgbmljZSB0byBmaW5kIHNvbWUgdGltZSB0byBsb29rXG4gICAgICAgICAgICAvLyBmdXJ0aGVyIGF0IHRoaXMuXG4gICAgICAgICAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseShvLCBhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgLy8gdXNlciBjYW4gc3VwcGx5IGEgYmVmb3JlRGV0YWNoIGNhbGxiYWNrLCB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZSBhIGRldGFjaFxuICAgICAgICAgICAgLy8gaXMgcGVyZm9ybWVkOyByZXR1cm5pbmcgZmFsc2UgcHJldmVudHMgdGhlIGRldGFjaC5cbiAgICAgICAgICAgIHRoaXMuaXNEZXRhY2hBbGxvd2VkID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuYmVmb3JlRGV0YWNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gdGhpcy5fanNQbHVtYi5iZWZvcmVEZXRhY2goY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qdS5sb2coXCJqc1BsdW1iOiBiZWZvcmVEZXRhY2ggY2FsbGJhY2sgZmFpbGVkXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gdXNlciBjYW4gc3VwcGx5IGEgYmVmb3JlRHJvcCBjYWxsYmFjaywgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBiZWZvcmUgYSBkcm9wcGVkXG4gICAgICAgICAgICAvLyBjb25uZWN0aW9uIGlzIGNvbmZpcm1lZC4gdXNlciBjYW4gcmV0dXJuIGZhbHNlIHRvIHJlamVjdCBjb25uZWN0aW9uLlxuICAgICAgICAgICAgdGhpcy5pc0Ryb3BBbGxvd2VkID0gZnVuY3Rpb24gKHNvdXJjZUlkLCB0YXJnZXRJZCwgc2NvcGUsIGNvbm5lY3Rpb24sIGRyb3BFbmRwb2ludCwgc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuY2hlY2tDb25kaXRpb24oXCJiZWZvcmVEcm9wXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IHNvdXJjZUlkLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZDogdGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZHJvcEVuZHBvaW50OiBkcm9wRW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iLmJlZm9yZURyb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB0aGlzLl9qc1BsdW1iLmJlZm9yZURyb3Aoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBzb3VyY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZDogdGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEVuZHBvaW50OiBkcm9wRW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmxvZyhcImpzUGx1bWI6IGJlZm9yZURyb3AgY2FsbGJhY2sgZmFpbGVkXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGJvdW5kTGlzdGVuZXJzID0gW10sXG4gICAgICAgICAgICAgICAgYmluZEFMaXN0ZW5lciA9IGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kTGlzdGVuZXJzLnB1c2goW29iaiwgdHlwZSwgZm5dKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmJpbmQodHlwZSwgZm4pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZG9tTGlzdGVuZXJzID0gW107XG5cbiAgICAgICAgICAgIC8vIHNldHMgdGhlIGNvbXBvbmVudCBhc3NvY2lhdGVkIHdpdGggbGlzdGVuZXIgZXZlbnRzLiBmb3IgaW5zdGFuY2UsIGFuIG92ZXJsYXkgZGVsZWdhdGVzXG4gICAgICAgICAgICAvLyBpdHMgZXZlbnRzIGJhY2sgdG8gYSBjb25uZWN0b3IuIGJ1dCBpZiB0aGUgY29ubmVjdG9yIGlzIHN3YXBwZWQgb24gdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbixcbiAgICAgICAgICAgIC8vIHRoZW4gdGhpcyBjb21wb25lbnQgbXVzdCBiZSBjaGFuZ2VkLiBUaGlzIGlzIGNhbGxlZCBieSBzZXRDb25uZWN0b3IgaW4gdGhlIENvbm5lY3Rpb24gY2xhc3MuXG4gICAgICAgICAgICB0aGlzLnNldExpc3RlbmVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbUxpc3RlbmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgZG9tTGlzdGVuZXJzW2ldWzNdID0gYztcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICB9O1xuXG4gICAgdmFyIF9yZW1vdmVUeXBlQ3NzSGVscGVyID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdHlwZUluZGV4KSB7XG4gICAgICAgIHZhciB0eXBlSWQgPSBjb21wb25lbnQuX2pzUGx1bWIudHlwZXNbdHlwZUluZGV4XSxcbiAgICAgICAgICAgIHR5cGUgPSBjb21wb25lbnQuX2pzUGx1bWIuaW5zdGFuY2UuZ2V0VHlwZSh0eXBlSWQsIGNvbXBvbmVudC5nZXRUeXBlRGVzY3JpcHRvcigpKTtcblxuICAgICAgICBpZiAodHlwZSAhPSBudWxsKSB7XG5cbiAgICAgICAgICAgIGlmICh0eXBlLmNzc0NsYXNzICYmIGNvbXBvbmVudC5jYW52YXMpXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlLnJlbW92ZUNsYXNzKGNvbXBvbmVudC5jYW52YXMsIHR5cGUuY3NzQ2xhc3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIF9qdS5leHRlbmQocm9vdC5qc1BsdW1iVUlDb21wb25lbnQsIF9qdS5FdmVudEdlbmVyYXRvciwge1xuXG4gICAgICAgIGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLnBhcmFtZXRlcnNbbmFtZV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIucGFyYW1ldGVyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLnBhcmFtZXRlcnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0UGFyYW1ldGVyczogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIucGFyYW1ldGVycyA9IHA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q2xhc3M6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ganNQbHVtYi5nZXRDbGFzcyh0aGlzLmNhbnZhcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzQ2xhc3M6ZnVuY3Rpb24oY2xhenopIHtcbiAgICAgICAgICAgIHJldHVybiBqc1BsdW1iLmhhc0NsYXNzKHRoaXMuY2FudmFzLCBjbGF6eik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICAgICAganNQbHVtYi5hZGRDbGFzcyh0aGlzLmNhbnZhcywgY2xhenopO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgICAgIGpzUGx1bWIucmVtb3ZlQ2xhc3ModGhpcy5jYW52YXMsIGNsYXp6KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVDbGFzc2VzOiBmdW5jdGlvbiAoY2xhc3Nlc1RvQWRkLCBjbGFzc2VzVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIGpzUGx1bWIudXBkYXRlQ2xhc3Nlcyh0aGlzLmNhbnZhcywgY2xhc3Nlc1RvQWRkLCBjbGFzc2VzVG9SZW1vdmUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFR5cGU6IGZ1bmN0aW9uICh0eXBlSWQsIHBhcmFtcywgZG9Ob3RSZXBhaW50KSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVHlwZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIudHlwZXMgPSBfc3BsaXRUeXBlKHR5cGVJZCkgfHwgW107XG4gICAgICAgICAgICBfYXBwbHlUeXBlcyh0aGlzLCBwYXJhbXMsIGRvTm90UmVwYWludCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIudHlwZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhcHBseVR5cGVzOiBmdW5jdGlvbiAocGFyYW1zLCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIF9hcHBseVR5cGVzKHRoaXMsIHBhcmFtcywgZG9Ob3RSZXBhaW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNUeXBlOiBmdW5jdGlvbiAodHlwZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi50eXBlcy5pbmRleE9mKHR5cGVJZCkgIT0gLTE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkVHlwZTogZnVuY3Rpb24gKHR5cGVJZCwgcGFyYW1zLCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIHZhciB0ID0gX3NwbGl0VHlwZSh0eXBlSWQpLCBfY29udCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1R5cGUodFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIudHlwZXMucHVzaCh0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX2NvbnQpIF9hcHBseVR5cGVzKHRoaXMsIHBhcmFtcywgZG9Ob3RSZXBhaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVUeXBlOiBmdW5jdGlvbiAodHlwZUlkLCBwYXJhbXMsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdmFyIHQgPSBfc3BsaXRUeXBlKHR5cGVJZCksIF9jb250ID0gZmFsc2UsIF9vbmUgPSBmdW5jdGlvbiAodHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5fanNQbHVtYi50eXBlcy5pbmRleE9mKHR0KTtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBjc3MgY2xhc3MgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgIF9yZW1vdmVUeXBlQ3NzSGVscGVyKHRoaXMsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIudHlwZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIGlmICh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ID0gX29uZSh0W2ldKSB8fCBfY29udDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9jb250KSBfYXBwbHlUeXBlcyh0aGlzLCBwYXJhbXMsIGRvTm90UmVwYWludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyVHlwZXM6IGZ1bmN0aW9uIChwYXJhbXMsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9qc1BsdW1iLnR5cGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgX3JlbW92ZVR5cGVDc3NIZWxwZXIodGhpcywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi50eXBlcy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYXBwbHlUeXBlcyh0aGlzLCBwYXJhbXMsIGRvTm90UmVwYWludCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlVHlwZTogZnVuY3Rpb24gKHR5cGVJZCwgcGFyYW1zLCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIHZhciB0ID0gX3NwbGl0VHlwZSh0eXBlSWQpO1xuICAgICAgICAgICAgaWYgKHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2pzUGx1bWIudHlwZXMuaW5kZXhPZih0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlbW92ZVR5cGVDc3NIZWxwZXIodGhpcywgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIudHlwZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi50eXBlcy5wdXNoKHRbaV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9hcHBseVR5cGVzKHRoaXMsIHBhcmFtcywgZG9Ob3RSZXBhaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXBwbHlUeXBlOiBmdW5jdGlvbiAodCwgZG9Ob3RSZXBhaW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhaW50U3R5bGUodC5wYWludFN0eWxlLCBkb05vdFJlcGFpbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRIb3ZlclBhaW50U3R5bGUodC5ob3ZlclBhaW50U3R5bGUsIGRvTm90UmVwYWludCk7XG4gICAgICAgICAgICBpZiAodC5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0LnBhcmFtZXRlcnMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKGksIHQucGFyYW1ldGVyc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGVJblVzZSA9IHRoaXMuZ2V0UGFpbnRTdHlsZSgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQYWludFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUsIGRvTm90UmVwYWludCkge1xuLy9cdFx0ICAgIFx0dGhpcy5fanNQbHVtYi5wYWludFN0eWxlID0ganNQbHVtYi5leHRlbmQoe30sIHN0eWxlKTtcbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSB3YW50IGNvbXBvbmVudHMgdG8gY2xvbmUgcGFpbnRTdHlsZSBzbyBhcyBub3QgdG8gc2hhcmUgaXQuXG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIucGFpbnRTdHlsZUluVXNlID0gdGhpcy5fanNQbHVtYi5wYWludFN0eWxlO1xuICAgICAgICAgICAgX3VwZGF0ZUhvdmVyU3R5bGUodGhpcyk7XG4gICAgICAgICAgICBpZiAoIWRvTm90UmVwYWludCkgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBhaW50U3R5bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEhvdmVyUGFpbnRTdHlsZTogZnVuY3Rpb24gKHN0eWxlLCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIC8vdGhpcy5fanNQbHVtYi5ob3ZlclBhaW50U3R5bGUgPSBqc1BsdW1iLmV4dGVuZCh7fSwgc3R5bGUpO1xuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHdhbnQgY29tcG9uZW50cyB0byBjbG9uZSBwYWludFN0eWxlIHNvIGFzIG5vdCB0byBzaGFyZSBpdC5cdFx0ICAgIFx0XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmhvdmVyUGFpbnRTdHlsZSA9IHN0eWxlO1xuICAgICAgICAgICAgX3VwZGF0ZUhvdmVyU3R5bGUodGhpcyk7XG4gICAgICAgICAgICBpZiAoIWRvTm90UmVwYWludCkgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEhvdmVyUGFpbnRTdHlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIuaG92ZXJQYWludFN0eWxlO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSB8fCB0aGlzLnR5cGVJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwTGlzdGVuZXJzKCk7IC8vIHRoaXMgaXMgb24gRXZlbnRHZW5lcmF0b3JcbiAgICAgICAgICAgICAgICB0aGlzLmNsb25lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc0hvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi5ob3ZlcjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRIb3ZlcjogZnVuY3Rpb24gKGhvdmVyLCBpZ25vcmVBdHRhY2hlZEVsZW1lbnRzLCB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIC8vIHdoaWxlIGRyYWdnaW5nLCB3ZSBpZ25vcmUgdGhlc2UgZXZlbnRzLiAgdGhpcyBrZWVwcyB0aGUgVUkgZnJvbSBmbGFzaGluZyBhbmRcbiAgICAgICAgICAgIC8vIHN3aXNoaW5nIGFuZCB3aGF0ZXZlcmluZy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iICYmICF0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmN1cnJlbnRseURyYWdnaW5nICYmICF0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmlzSG92ZXJTdXNwZW5kZWQoKSkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5ob3ZlciA9IGhvdmVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaG92ZXJDbGFzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gaG92ZXIgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlW21ldGhvZF0odGhpcy5jYW52YXMsIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaG92ZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuaG92ZXJDbGFzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlW21ldGhvZF0odGhpcy5jYW52YXMsIHRoaXMuX2pzUGx1bWIuaG92ZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuaG92ZXJQYWludFN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UgPSBob3ZlciA/IHRoaXMuX2pzUGx1bWIuaG92ZXJQYWludFN0eWxlIDogdGhpcy5fanNQbHVtYi5wYWludFN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaXNTdXNwZW5kRHJhd2luZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSB0aW1lc3RhbXAgfHwgX3RpbWVzdGFtcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBhaW50KHt0aW1lc3RhbXA6IHRpbWVzdGFtcCwgcmVjYWxjOiBmYWxzZX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgbGlzdCBvZiBvdGhlciBhZmZlY3RlZCBlbGVtZW50cywgaWYgc3VwcG9ydGVkIGJ5IHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgIC8vIGZvciBhIGNvbm5lY3Rpb24sIGl0cyB0aGUgZW5kcG9pbnRzLiAgZm9yIGFuIGVuZHBvaW50LCBpdHMgdGhlIGNvbm5lY3Rpb25zISBzdXJwcmlzZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRBdHRhY2hlZEVsZW1lbnRzICYmICFpZ25vcmVBdHRhY2hlZEVsZW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICBfdXBkYXRlQXR0YWNoZWRFbGVtZW50cyh0aGlzLCBob3ZlciwgX3RpbWVzdGFtcCgpLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIGpzUGx1bWJVSUNvbXBvbmVudCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIF9qc1BsdW1iSW5zdGFuY2VJbmRleCA9IDAsXG4gICAgICAgIGdldEluc3RhbmNlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSA9IF9qc1BsdW1iSW5zdGFuY2VJbmRleCArIDE7XG4gICAgICAgICAgICBfanNQbHVtYkluc3RhbmNlSW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9O1xuXG4gICAgdmFyIGpzUGx1bWJJbnN0YW5jZSA9IHJvb3QuanNQbHVtYkluc3RhbmNlID0gZnVuY3Rpb24gKF9kZWZhdWx0cykge1xuXG4gICAgICAgIHRoaXMuRGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBBbmNob3I6IFwiQm90dG9tXCIsXG4gICAgICAgICAgICBBbmNob3JzOiBbIG51bGwsIG51bGwgXSxcbiAgICAgICAgICAgIENvbm5lY3Rpb25zRGV0YWNoYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIENvbm5lY3Rpb25PdmVybGF5czogWyBdLFxuICAgICAgICAgICAgQ29ubmVjdG9yOiBcIkJlemllclwiLFxuICAgICAgICAgICAgQ29udGFpbmVyOiBudWxsLFxuICAgICAgICAgICAgRG9Ob3RUaHJvd0Vycm9yczogZmFsc2UsXG4gICAgICAgICAgICBEcmFnT3B0aW9uczogeyB9LFxuICAgICAgICAgICAgRHJvcE9wdGlvbnM6IHsgfSxcbiAgICAgICAgICAgIEVuZHBvaW50OiBcIkRvdFwiLFxuICAgICAgICAgICAgRW5kcG9pbnRPdmVybGF5czogWyBdLFxuICAgICAgICAgICAgRW5kcG9pbnRzOiBbIG51bGwsIG51bGwgXSxcbiAgICAgICAgICAgIEVuZHBvaW50U3R5bGU6IHsgZmlsbFN0eWxlOiBcIiM0NTZcIiB9LFxuICAgICAgICAgICAgRW5kcG9pbnRTdHlsZXM6IFsgbnVsbCwgbnVsbCBdLFxuICAgICAgICAgICAgRW5kcG9pbnRIb3ZlclN0eWxlOiBudWxsLFxuICAgICAgICAgICAgRW5kcG9pbnRIb3ZlclN0eWxlczogWyBudWxsLCBudWxsIF0sXG4gICAgICAgICAgICBIb3ZlclBhaW50U3R5bGU6IG51bGwsXG4gICAgICAgICAgICBMYWJlbFN0eWxlOiB7IGNvbG9yOiBcImJsYWNrXCIgfSxcbiAgICAgICAgICAgIExvZ0VuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgT3ZlcmxheXM6IFsgXSxcbiAgICAgICAgICAgIE1heENvbm5lY3Rpb25zOiAxLFxuICAgICAgICAgICAgUGFpbnRTdHlsZTogeyBsaW5lV2lkdGg6IDQsIHN0cm9rZVN0eWxlOiBcIiM0NTZcIiB9LFxuICAgICAgICAgICAgUmVhdHRhY2hDb25uZWN0aW9uczogZmFsc2UsXG4gICAgICAgICAgICBSZW5kZXJNb2RlOiBcInN2Z1wiLFxuICAgICAgICAgICAgU2NvcGU6IFwianNQbHVtYl9EZWZhdWx0U2NvcGVcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAoX2RlZmF1bHRzKSBqc1BsdW1iLmV4dGVuZCh0aGlzLkRlZmF1bHRzLCBfZGVmYXVsdHMpO1xuXG4gICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IHRoaXMuRGVmYXVsdHMuTG9nRW5hYmxlZDtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblR5cGVzID0ge307XG4gICAgICAgIHRoaXMuX2VuZHBvaW50VHlwZXMgPSB7fTtcblxuICAgICAgICBfanUuRXZlbnRHZW5lcmF0b3IuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgdmFyIF9jdXJyZW50SW5zdGFuY2UgPSB0aGlzLFxuICAgICAgICAgICAgX2luc3RhbmNlSW5kZXggPSBnZXRJbnN0YW5jZUluZGV4KCksXG4gICAgICAgICAgICBfYmIgPSBfY3VycmVudEluc3RhbmNlLmJpbmQsXG4gICAgICAgICAgICBfaW5pdGlhbERlZmF1bHRzID0ge30sXG4gICAgICAgICAgICBfem9vbSA9IDEsXG4gICAgICAgICAgICBfaW5mbyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIGlmIChlbCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbC5ub2RlVHlwZSA9PSAzIHx8IGVsLm5vZGVUeXBlID09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZWw6ZWwsIHRleHQ6dHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9lbCA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0RWxlbWVudChlbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVsOiBfZWwsIGlkOiAoX2p1LmlzU3RyaW5nKGVsKSAmJiBfZWwgPT0gbnVsbCkgPyBlbCA6IF9nZXRJZChfZWwpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldEluc3RhbmNlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2luc3RhbmNlSW5kZXg7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRab29tID0gZnVuY3Rpb24gKHosIHJlcGFpbnRFdmVyeXRoaW5nKSB7XG4gICAgICAgICAgICBfem9vbSA9IHo7XG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmZpcmUoXCJ6b29tXCIsIF96b29tKTtcbiAgICAgICAgICAgIGlmIChyZXBhaW50RXZlcnl0aGluZykgX2N1cnJlbnRJbnN0YW5jZS5yZXBhaW50RXZlcnl0aGluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Wm9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfem9vbTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuRGVmYXVsdHMpXG4gICAgICAgICAgICBfaW5pdGlhbERlZmF1bHRzW2ldID0gdGhpcy5EZWZhdWx0c1tpXTtcblxuICAgICAgICB2YXIgX2NvbnRhaW5lciwgX2NvbnRhaW5lckRlbGVnYXRpb25zID0gW107XG4gICAgICAgIHRoaXMudW5iaW5kQ29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoX2NvbnRhaW5lciAhPSBudWxsICYmIF9jb250YWluZXJEZWxlZ2F0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfY29udGFpbmVyRGVsZWdhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5vZmYoX2NvbnRhaW5lciwgX2NvbnRhaW5lckRlbGVnYXRpb25zW2ldWzBdLCBfY29udGFpbmVyRGVsZWdhdGlvbnNbaV1bMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRDb250YWluZXIgPSBmdW5jdGlvbiAoYykge1xuXG4gICAgICAgICAgICB0aGlzLnVuYmluZENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgICAvLyBnZXQgY29udGFpbmVyIGFzIGRvbSBlbGVtZW50LlxuICAgICAgICAgICAgYyA9IHRoaXMuZ2V0RWxlbWVudChjKTtcbiAgICAgICAgICAgIC8vIG1vdmUgZXhpc3RpbmcgY29ubmVjdGlvbnMgYW5kIGVuZHBvaW50cywgaWYgYW55LlxuICAgICAgICAgICAgdGhpcy5zZWxlY3QoKS5lYWNoKGZ1bmN0aW9uIChjb25uKSB7XG4gICAgICAgICAgICAgICAgY29ubi5tb3ZlUGFyZW50KGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEVuZHBvaW50cygpLmVhY2goZnVuY3Rpb24gKGVwKSB7XG4gICAgICAgICAgICAgICAgZXAubW92ZVBhcmVudChjKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzZXQgY29udGFpbmVyLlxuICAgICAgICAgICAgdmFyIHByZXZpb3VzQ29udGFpbmVyID0gX2NvbnRhaW5lcjtcbiAgICAgICAgICAgIF9jb250YWluZXIgPSBjO1xuICAgICAgICAgICAgX2NvbnRhaW5lckRlbGVnYXRpb25zLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBfb25lRGVsZWdhdGVIYW5kbGVyID0gZnVuY3Rpb24gKGlkLCBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlLnNyY0VsZW1lbnQgfHwgZS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGpwID0gKHQgJiYgdC5wYXJlbnROb2RlID8gdC5wYXJlbnROb2RlLl9qc1BsdW1iIDogbnVsbCkgfHwgKHQgPyB0Ll9qc1BsdW1iIDogbnVsbCkgfHwgKHQgJiYgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5wYXJlbnROb2RlID8gdC5wYXJlbnROb2RlLnBhcmVudE5vZGUuX2pzUGx1bWIgOiBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoanApIHtcbiAgICAgICAgICAgICAgICAgICAganAuZmlyZShpZCwganAsIGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBqc3BsdW1iIGFsc28gZmlyZXMgZXZlcnkgZXZlbnQgY29taW5nIGZyb20gY29tcG9uZW50cy9vdmVybGF5cy4gVGhhdCdzIHdoYXQgdGhlIHRlc3QgZm9yIGBqcC5jb21wb25lbnRgIGlzIGZvci5cbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5maXJlKGlkLCBqcC5jb21wb25lbnQgfHwganAsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBfYWRkT25lRGVsZWdhdGUgPSBmdW5jdGlvbihldmVudElkLCBzZWxlY3RvciwgZm4pIHtcbiAgICAgICAgICAgICAgICBfY29udGFpbmVyRGVsZWdhdGlvbnMucHVzaChbZXZlbnRJZCwgZm5dKTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLm9uKF9jb250YWluZXIsIGV2ZW50SWQsIHNlbGVjdG9yLCBmbik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBkZWxlZ2F0ZSBvbmUgZXZlbnQgb24gdGhlIGNvbnRhaW5lciB0byBqc3BsdW1iIGVsZW1lbnRzLiBpdCBtaWdodCBiZSBwb3NzaWJsZSB0b1xuICAgICAgICAgICAgLy8gYWJzdHJhY3QgdGhpcyBvdXQ6IGVhY2ggb2YgZW5kcG9pbnQsIGNvbm5lY3Rpb24gYW5kIG92ZXJsYXkgY291bGQgcmVnaXN0ZXIgdGhlbXNlbHZlcyB3aXRoXG4gICAgICAgICAgICAvLyBqc3BsdW1iIGFzIFwiY29tcG9uZW50IHR5cGVzXCIgb3Igd2hhdGV2ZXIsIGFuZCBwcm92aWRlIGEgc3VpdGFibGUgc2VsZWN0b3IuIHRoaXMgd291bGQgYmVcbiAgICAgICAgICAgIC8vIGRvbmUgYnkgdGhlIHJlbmRlcmVyIChhbHRob3VnaCBhZG1pdHRlZGx5IGZyb20gMi4wIG9ud2FyZHMgd2UncmUgbm90IHN1cHBvcnRpbmcgdm1sIGFueW1vcmUpXG4gICAgICAgICAgICB2YXIgX29uZURlbGVnYXRlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvbnMuXG4gICAgICAgICAgICAgICAgX2FkZE9uZURlbGVnYXRlKGlkLCBcIi5qc3BsdW1iLWNvbm5lY3RvciA+ICpcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX29uZURlbGVnYXRlSGFuZGxlcihpZCwgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZW5kcG9pbnRzLiBub3RlIHRoZXkgY2FuIGhhdmUgYW4gZW5jbG9zaW5nIGRpdiwgb3Igbm90LlxuICAgICAgICAgICAgICAgIF9hZGRPbmVEZWxlZ2F0ZShpZCwgXCIuanNwbHVtYi1lbmRwb2ludCwgLmpzcGx1bWItZW5kcG9pbnQgPiAqLCAuanNwbHVtYi1lbmRwb2ludCBzdmcgKlwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBfb25lRGVsZWdhdGVIYW5kbGVyKGlkLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBvdmVybGF5c1xuICAgICAgICAgICAgICAgIF9hZGRPbmVEZWxlZ2F0ZShpZCwgXCIuanNwbHVtYi1vdmVybGF5LCAuanNwbHVtYi1vdmVybGF5ICpcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX29uZURlbGVnYXRlSGFuZGxlcihpZCwgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBfb25lRGVsZWdhdGUoZXZlbnRzW2ldKTtcblxuICAgICAgICAgICAgLy8gbWFuYWdlZCBlbGVtZW50c1xuICAgICAgICAgICAgZm9yICh2YXIgZWxJZCBpbiBtYW5hZ2VkRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBtYW5hZ2VkRWxlbWVudHNbZWxJZF0uZWw7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUgPT09IHByZXZpb3VzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ29udGFpbmVyLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb250YWluZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5iaW5kID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICAgICAgaWYgKFwicmVhZHlcIiA9PT0gZXZlbnQgJiYgaW5pdGlhbGl6ZWQpIGZuKCk7XG4gICAgICAgICAgICBlbHNlIF9iYi5hcHBseShfY3VycmVudEluc3RhbmNlLCBbZXZlbnQsIGZuXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5pbXBvcnREZWZhdWx0cyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGQpIHtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLkRlZmF1bHRzW2ldID0gZFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkLkNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnNldENvbnRhaW5lcihkLkNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9jdXJyZW50SW5zdGFuY2UucmVzdG9yZURlZmF1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cyA9IGpzUGx1bWIuZXh0ZW5kKHt9LCBfaW5pdGlhbERlZmF1bHRzKTtcbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsb2cgPSBudWxsLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZSxcbiAgICAgICAgLy8gVE9ETyByZW1vdmUgZnJvbSB3aW5kb3cgc2NvcGVcbiAgICAgICAgICAgIGNvbm5lY3Rpb25zID0gW10sXG4gICAgICAgIC8vIG1hcCBvZiBlbGVtZW50IGlkIC0+IGVuZHBvaW50IGxpc3RzLiBhbiBlbGVtZW50IGNhbiBoYXZlIGFuIGFyYml0cmFyeVxuICAgICAgICAvLyBudW1iZXIgb2YgZW5kcG9pbnRzIG9uIGl0LCBhbmQgbm90IGFsbCBvZiB0aGVtIGhhdmUgdG8gYmUgY29ubmVjdGVkXG4gICAgICAgIC8vIHRvIGFueXRoaW5nLlxuICAgICAgICAgICAgZW5kcG9pbnRzQnlFbGVtZW50ID0ge30sXG4gICAgICAgICAgICBlbmRwb2ludHNCeVVVSUQgPSB7fSxcbiAgICAgICAgICAgIG1hbmFnZWRFbGVtZW50cyA9IHt9LFxuICAgICAgICAgICAgb2Zmc2V0cyA9IHt9LFxuICAgICAgICAgICAgb2Zmc2V0VGltZXN0YW1wcyA9IHt9LFxuICAgICAgICAgICAgZHJhZ2dhYmxlU3RhdGVzID0ge30sXG4gICAgICAgICAgICBjb25uZWN0aW9uQmVpbmdEcmFnZ2VkID0gZmFsc2UsXG4gICAgICAgICAgICBzaXplcyA9IFtdLFxuICAgICAgICAgICAgX3N1c3BlbmREcmF3aW5nID0gZmFsc2UsXG4gICAgICAgICAgICBfc3VzcGVuZGVkQXQgPSBudWxsLFxuICAgICAgICAgICAgREVGQVVMVF9TQ09QRSA9IHRoaXMuRGVmYXVsdHMuU2NvcGUsXG4gICAgICAgICAgICByZW5kZXJNb2RlID0gbnVsbCwgIC8vIHdpbGwgYmUgc2V0IGluIGluaXQoKVxuICAgICAgICAgICAgX2N1cklkU3RhbXAgPSAxLFxuICAgICAgICAgICAgX2lkc3RhbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBfY3VySWRTdGFtcCsrO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAvL1xuICAgICAgICAvLyBhcHBlbmRzIGFuIGVsZW1lbnQgdG8gc29tZSBvdGhlciBlbGVtZW50LCB3aGljaCBpcyBjYWxjdWxhdGVkIGFzIGZvbGxvd3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIGlmIENvbnRhaW5lciBleGlzdHMsIHVzZSB0aGF0IGVsZW1lbnQuXG4gICAgICAgIC8vIDIuIGlmIHRoZSAncGFyZW50JyBwYXJhbWV0ZXIgZXhpc3RzLCB1c2UgdGhhdC5cbiAgICAgICAgLy8gMy4gb3RoZXJ3aXNlIGp1c3QgdXNlIHRoZSByb290IGVsZW1lbnQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vXG4gICAgICAgICAgICBfYXBwZW5kRWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgIF9jb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9Sb290KGVsKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RWxlbWVudChwYXJlbnQpLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcblxuICAgICAgICAvL1xuICAgICAgICAvLyBEcmF3cyBhbiBlbmRwb2ludCBhbmQgaXRzIGNvbm5lY3Rpb25zLiB0aGlzIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IGludG8gZHJhd2luZyBjb25uZWN0aW9ucyBhcyB3ZWxsXG4gICAgICAgIC8vIGFzIGVuZHBvaW50cywgc2luY2UganNQbHVtYiBpcyBlbmRwb2ludC1jZW50cmljIHVuZGVyIHRoZSBob29kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBAcGFyYW0gZWxlbWVudCBlbGVtZW50IHRvIGRyYXcgKG9mIHR5cGUgbGlicmFyeSBzcGVjaWZpYyBlbGVtZW50IG9iamVjdClcbiAgICAgICAgLy8gQHBhcmFtIHVpIFVJIG9iamVjdCBmcm9tIGN1cnJlbnQgbGlicmFyeSdzIGV2ZW50IHN5c3RlbS4gb3B0aW9uYWwuXG4gICAgICAgIC8vIEBwYXJhbSB0aW1lc3RhbXAgdGltZXN0YW1wIGZvciB0aGlzIHBhaW50IGN5Y2xlLiB1c2VkIHRvIHNwZWVkIHRoaW5ncyB1cCBhIGxpdHRsZSBieSBjdXR0aW5nIGRvd24gdGhlIGFtb3VudCBvZiBvZmZzZXQgY2FsY3VsYXRpb25zIHdlIGRvLlxuICAgICAgICAvLyBAcGFyYW0gY2xlYXJFZGl0cyBkZWZhdWx0cyB0byBmYWxzZTsgaW5kaWNhdGVzIHRoYXQgbW91c2UgZWRpdHMgZm9yIGNvbm5lY3RvcnMgc2hvdWxkIGJlIGNsZWFyZWRcbiAgICAgICAgLy8vXG4gICAgICAgICAgICBfZHJhdyA9IGZ1bmN0aW9uIChlbGVtZW50LCB1aSwgdGltZXN0YW1wLCBjbGVhckVkaXRzKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIGlzIGl0IGNvcnJlY3QgdG8gZmlsdGVyIGJ5IGhlYWRsZXNzIGF0IHRoaXMgdG9wIGxldmVsPyBob3cgd291bGQgYSBoZWFkbGVzcyBhZGFwdGVyIGV2ZXIgcmVwYWludD9cbiAgICAgICAgICAgICAgICAvLyBOTy4gaXQgaXMgbm90IGNvcnJlY3QuXG4gICAgICAgICAgICAgICAgaWYgKCFqc1BsdW1iLmhlYWRsZXNzICYmICFfc3VzcGVuZERyYXdpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gX2dldElkKGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwYWludEVscyA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0RHJhZ01hbmFnZXIoKS5nZXRFbGVtZW50c0ZvckRyYWdnYWJsZShpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA9PSBudWxsKSB0aW1lc3RhbXAgPSBfdGltZXN0YW1wKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBvZmZzZXQgb2YgZXZlcnl0aGluZyBfYmVmb3JlXyB3ZSB0cnkgdG8gZHJhdyBhbnl0aGluZy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBfdXBkYXRlT2Zmc2V0KHsgZWxJZDogaWQsIG9mZnNldDogdWksIHJlY2FsYzogZmFsc2UsIHRpbWVzdGFtcDogdGltZXN0YW1wIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBhaW50RWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHJlcGFpbnRFbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxJZDogcmVwYWludEVsc1tpXS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBvLm8ubGVmdCArIHJlcGFpbnRFbHNbaV0ub2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IG8uby50b3AgKyByZXBhaW50RWxzW2ldLm9mZnNldC50b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjYWxjOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5yZWRyYXcoaWQsIHVpLCB0aW1lc3RhbXAsIG51bGwsIGNsZWFyRWRpdHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBhaW50RWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIHJlcGFpbnRFbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmFuY2hvck1hbmFnZXIucmVkcmF3KHJlcGFpbnRFbHNbal0uaWQsIHVpLCB0aW1lc3RhbXAsIHJlcGFpbnRFbHNbal0ub2Zmc2V0LCBjbGVhckVkaXRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gZ2V0cyBhbiBFbmRwb2ludCBieSB1dWlkLlxuICAgICAgICAvL1xuICAgICAgICAgICAgX2dldEVuZHBvaW50ID0gZnVuY3Rpb24gKHV1aWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kcG9pbnRzQnlVVUlEW3V1aWRdO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBpbml0cyBhIGRyYWdnYWJsZSBpZiBpdCdzIG5vdCBhbHJlYWR5IGluaXRpYWxpc2VkLlxuICAgICAgICAgICAgICogVE9ETzogc29tZWhvdyBhYnN0cmFjdCB0aGlzIHRvIHRoZSBhZGFwdGVyLCBiZWNhdXNlIHRoZSBjb25jZXB0IG9mIFwiZHJhZ2dhYmxlXCIgaGFzIG5vXG4gICAgICAgICAgICAgKiBwbGFjZSBvbiB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfaW5pdERyYWdnYWJsZUlmTmVjZXNzYXJ5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGlzRHJhZ2dhYmxlLCBkcmFnT3B0aW9ucywgaWQsIGZpcmVFdmVudCkge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgdG8gRHJhZ01hbmFnZXI/XG4gICAgICAgICAgICAgICAgaWYgKCFqc1BsdW1iLmhlYWRsZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZHJhZ2dhYmxlID0gaXNEcmFnZ2FibGUgPT0gbnVsbCA/IGZhbHNlIDogaXNEcmFnZ2FibGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNQbHVtYi5pc0RyYWdTdXBwb3J0ZWQoZWxlbWVudCwgX2N1cnJlbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGRyYWdPcHRpb25zIHx8IF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuRHJhZ09wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGpzUGx1bWIuZXh0ZW5kKHt9LCBvcHRpb25zKTsgLy8gbWFrZSBhIGNvcHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFqc1BsdW1iLmlzQWxyZWFkeURyYWdnYWJsZShlbGVtZW50LCBfY3VycmVudEluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZ0V2ZW50ID0ganNQbHVtYi5kcmFnRXZlbnRzLmRyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wRXZlbnQgPSBqc1BsdW1iLmRyYWdFdmVudHMuc3RvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RXZlbnQgPSBqc1BsdW1iLmRyYWdFdmVudHMuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVsID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRFbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FuY2VzdG9yID0gX2N1cnJlbnRJbnN0YW5jZS5nZXREcmFnTWFuYWdlcigpLmdldERyYWdBbmNlc3RvcihfZGVsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ub09mZnNldCA9IHtsZWZ0OiAwLCB0b3A6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FuY2VzdG9yT2Zmc2V0ID0gX25vT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbWFuYWdlKGlkLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW3N0YXJ0RXZlbnRdID0gX2p1LndyYXAob3B0aW9uc1tzdGFydEV2ZW50XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FuY2VzdG9yT2Zmc2V0ID0gX2FuY2VzdG9yICE9IG51bGwgPyBfY3VycmVudEluc3RhbmNlLmdldE9mZnNldChfYW5jZXN0b3IpIDogX25vT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZXRIb3ZlclN1c3BlbmRlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2Uuc2VsZWN0KHtzb3VyY2U6IGVsZW1lbnR9KS5hZGRDbGFzcyhfY3VycmVudEluc3RhbmNlLmVsZW1lbnREcmFnZ2luZ0NsYXNzICsgXCIgXCIgKyBfY3VycmVudEluc3RhbmNlLnNvdXJjZUVsZW1lbnREcmFnZ2luZ0NsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2Uuc2VsZWN0KHt0YXJnZXQ6IGVsZW1lbnR9KS5hZGRDbGFzcyhfY3VycmVudEluc3RhbmNlLmVsZW1lbnREcmFnZ2luZ0NsYXNzICsgXCIgXCIgKyBfY3VycmVudEluc3RhbmNlLnRhcmdldEVsZW1lbnREcmFnZ2luZ0NsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2Uuc2V0Q29ubmVjdGlvbkJlaW5nRHJhZ2dlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbkRyYWcpIHJldHVybiBkcmFnT3B0aW9ucy5jYW5EcmFnKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2RyYWdFdmVudF0gPSBfanUud3JhcChvcHRpb25zW2RyYWdFdmVudF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGhlcmUgd2UgY291bGQgYWN0dWFsbHkgdXNlIGdldERyYWdPYmplY3QsIGFuZCB0aGVuIGNvbXB1dGUgaXQgb3Vyc2VsdmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgZXZlcnkgYWRhcHRlciBkb2VzIHRoZSBzYW1lIHRoaW5nLiBidXQgaSdtIG5vdCBzdXJlIHdoeSBZVUkncyBnZXREcmFnT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJzIGZyb20gZ2V0VUlQb3NpdGlvbiBzbyBtdWNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWkgPSBfY3VycmVudEluc3RhbmNlLmdldFVJUG9zaXRpb24oYXJndW1lbnRzLCBfY3VycmVudEluc3RhbmNlLmdldFpvb20oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodWkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCBieSBhbmNlc3RvciBvZmZzZXQgaWYgdGhlcmUgaXMgb25lOiB0aGlzIGlzIGZvciB0aGUgY2FzZSB0aGF0IGEgZHJhZ2dhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgY29udGFpbmVkIGluc2lkZSBzb21lIG90aGVyIGVsZW1lbnQgdGhhdCBpcyBub3QgdGhlIENvbnRhaW5lci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aS5sZWZ0ICs9IF9hbmNlc3Rvck9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpLnRvcCArPSBfYW5jZXN0b3JPZmZzZXQudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kcmF3KGVsZW1lbnQsIHVpLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N0YXJ0ZWQpIF9jdXJyZW50SW5zdGFuY2UuYWRkQ2xhc3MoZWxlbWVudCwgXCJqc3BsdW1iLWRyYWdnZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tzdG9wRXZlbnRdID0gX2p1LndyYXAob3B0aW9uc1tzdG9wRXZlbnRdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBhcmd1bWVudHNbMF0uc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVpcCA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0VUlQb3NpdGlvbihhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG9uZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX29uZSA9IGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1aXAgIT0gbnVsbCkgX2RyYXcoX2VbMF0sIHVpcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5yZW1vdmVDbGFzcyhfZVswXSwgXCJqc3BsdW1iLWRyYWdnZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZWxlY3Qoe3NvdXJjZTogX2VbMF19KS5yZW1vdmVDbGFzcyhfY3VycmVudEluc3RhbmNlLmVsZW1lbnREcmFnZ2luZ0NsYXNzICsgXCIgXCIgKyBfY3VycmVudEluc3RhbmNlLnNvdXJjZUVsZW1lbnREcmFnZ2luZ0NsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnNlbGVjdCh7dGFyZ2V0OiBfZVswXX0pLnJlbW92ZUNsYXNzKF9jdXJyZW50SW5zdGFuY2UuZWxlbWVudERyYWdnaW5nQ2xhc3MgKyBcIiBcIiArIF9jdXJyZW50SW5zdGFuY2UudGFyZ2V0RWxlbWVudERyYWdnaW5nQ2xhc3MsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZ2V0RHJhZ01hbmFnZXIoKS5kcmFnRW5kZWQoX2VbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb25lKGVsZW1lbnRzW2ldKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBjb21tb24gYWNyb3NzIGFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2Uuc2V0SG92ZXJTdXNwZW5kZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZXRDb25uZWN0aW9uQmVpbmdEcmFnZ2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbElkID0gX2dldElkKGVsZW1lbnQpOyAvLyBuZWVkIElEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZVN0YXRlc1tlbElkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcmFnZ2FibGUgPSBkcmFnZ2FibGVTdGF0ZXNbZWxJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGlzYWJsZWQgPSBkcmFnZ2FibGUgPT0gbnVsbCA/IGZhbHNlIDogIWRyYWdnYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5pbml0RHJhZ2dhYmxlKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmdldERyYWdNYW5hZ2VyKCkucmVnaXN0ZXIoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJlRXZlbnQpIF9jdXJyZW50SW5zdGFuY2UuZmlyZShcImVsZW1lbnREcmFnZ2FibGVcIiwge2VsOmVsZW1lbnQsIG9wdGlvbnM6b3B0aW9uc30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBkcmFnZ2FibGUuIGF0dGFjaCBhbnkgc3RhcnQsIGRyYWcgb3Igc3RvcCBsaXN0ZW5lcnMgdG8gdGhlIGN1cnJlbnQgRHJhZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdPcHRpb25zLmZvcmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmluaXREcmFnZ2FibGUoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfc2NvcGVNYXRjaCA9IGZ1bmN0aW9uIChlMSwgZTIpIHtcbiAgICAgICAgICAgICAgICB2YXIgczEgPSBlMS5zY29wZS5zcGxpdCgvXFxzLyksIHMyID0gZTIuc2NvcGUuc3BsaXQoL1xccy8pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczIubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczJbal0gPT0gczFbaV0pIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgKiBwcmVwYXJlcyBhIGZpbmFsIHBhcmFtcyBvYmplY3QgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIF9uZXdDb25uZWN0aW9uLCB0YWtpbmcgaW50byBhY2NvdW50IGRlZmF1bHRzLCBldmVudHMsIGV0Yy5cbiAgICAgICAgICovXG4gICAgICAgICAgICBfcHJlcGFyZUNvbm5lY3Rpb25QYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCByZWZlcmVuY2VQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3AgPSBqc1BsdW1iLmV4dGVuZCh7IH0sIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZVBhcmFtcykganNQbHVtYi5leHRlbmQoX3AsIHJlZmVyZW5jZVBhcmFtcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBob3R3aXJlIGVuZHBvaW50cyBwYXNzZWQgYXMgc291cmNlIG9yIHRhcmdldCB0byBzb3VyY2VFbmRwb2ludC90YXJnZXRFbmRwb2ludCwgcmVzcGVjdGl2ZWx5LlxuICAgICAgICAgICAgICAgIGlmIChfcC5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9wLnNvdXJjZS5lbmRwb2ludClcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wLnNvdXJjZUVuZHBvaW50ID0gX3Auc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBfcC5zb3VyY2UgPSBfY3VycmVudEluc3RhbmNlLmdldEVsZW1lbnQoX3Auc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9wLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3AudGFyZ2V0LmVuZHBvaW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgX3AudGFyZ2V0RW5kcG9pbnQgPSBfcC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wLnRhcmdldCA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0RWxlbWVudChfcC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRlc3QgZm9yIGVuZHBvaW50IHV1aWRzIHRvIGNvbm5lY3RcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnV1aWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wLnNvdXJjZUVuZHBvaW50ID0gX2dldEVuZHBvaW50KHBhcmFtcy51dWlkc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIF9wLnRhcmdldEVuZHBvaW50ID0gX2dldEVuZHBvaW50KHBhcmFtcy51dWlkc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm93IGVuc3VyZSB0aGF0IGlmIHdlIGRvIGhhdmUgRW5kcG9pbnRzIGFscmVhZHksIHRoZXkncmUgbm90IGZ1bGwuXG4gICAgICAgICAgICAgICAgLy8gc291cmNlOlxuICAgICAgICAgICAgICAgIGlmIChfcC5zb3VyY2VFbmRwb2ludCAmJiBfcC5zb3VyY2VFbmRwb2ludC5pc0Z1bGwoKSkge1xuICAgICAgICAgICAgICAgICAgICBfanUubG9nKF9jdXJyZW50SW5zdGFuY2UsIFwiY291bGQgbm90IGFkZCBjb25uZWN0aW9uOyBzb3VyY2UgZW5kcG9pbnQgaXMgZnVsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRhcmdldDpcbiAgICAgICAgICAgICAgICBpZiAoX3AudGFyZ2V0RW5kcG9pbnQgJiYgX3AudGFyZ2V0RW5kcG9pbnQuaXNGdWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2p1LmxvZyhfY3VycmVudEluc3RhbmNlLCBcImNvdWxkIG5vdCBhZGQgY29ubmVjdGlvbjsgdGFyZ2V0IGVuZHBvaW50IGlzIGZ1bGxcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBzb3VyY2UgZW5kcG9pbnQgbWFuZGF0ZXMgY29ubmVjdGlvbiB0eXBlIGFuZCBub3RoaW5nIHNwZWNpZmllZCBpbiBvdXIgcGFyYW1zLCB1c2UgaXQuXG4gICAgICAgICAgICAgICAgaWYgKCFfcC50eXBlICYmIF9wLnNvdXJjZUVuZHBvaW50KVxuICAgICAgICAgICAgICAgICAgICBfcC50eXBlID0gX3Auc291cmNlRW5kcG9pbnQuY29ubmVjdGlvblR5cGU7XG5cbiAgICAgICAgICAgICAgICAvLyBjb3B5IGluIGFueSBjb25uZWN0b3JPdmVybGF5cyB0aGF0IHdlcmUgc3BlY2lmaWVkIG9uIHRoZSBzb3VyY2UgZW5kcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gaXQgZG9lc250IGNvcHkgdGFyZ2V0IGVuZHBvaW50IG92ZXJsYXlzLiAgaSdtIG5vdCBzdXJlIGlmIHdlIHdhbnQgaXQgdG8gb3Igbm90LlxuICAgICAgICAgICAgICAgIGlmIChfcC5zb3VyY2VFbmRwb2ludCAmJiBfcC5zb3VyY2VFbmRwb2ludC5jb25uZWN0b3JPdmVybGF5cykge1xuICAgICAgICAgICAgICAgICAgICBfcC5vdmVybGF5cyA9IF9wLm92ZXJsYXlzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IF9wLnNvdXJjZUVuZHBvaW50LmNvbm5lY3Rvck92ZXJsYXlzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Aub3ZlcmxheXMucHVzaChfcC5zb3VyY2VFbmRwb2ludC5jb25uZWN0b3JPdmVybGF5c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzY29wZVxuICAgICAgICAgICAgICAgIGlmIChfcC5zb3VyY2VFbmRwb2ludCAmJiBfcC5zb3VyY2VFbmRwb2ludC5zY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBfcC5zY29wZSA9IF9wLnNvdXJjZUVuZHBvaW50LnNjb3BlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKCFfcFtcInBvaW50ZXItZXZlbnRzXCJdICYmIF9wLnNvdXJjZUVuZHBvaW50ICYmIF9wLnNvdXJjZUVuZHBvaW50LmNvbm5lY3RvclBvaW50ZXJFdmVudHMpXG4gICAgICAgICAgICAgICAgICAgIF9wW1wicG9pbnRlci1ldmVudHNcIl0gPSBfcC5zb3VyY2VFbmRwb2ludC5jb25uZWN0b3JQb2ludGVyRXZlbnRzO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9tZXJnZU92ZXJyaWRlcyA9IGZ1bmN0aW9uIChkZWYsIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGpzUGx1bWIuZXh0ZW5kKHt9LCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSkgbVtpXSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIF9hZGRFbmRwb2ludCA9IGZ1bmN0aW9uIChlbCwgZGVmLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jdXJyZW50SW5zdGFuY2UuYWRkRW5kcG9pbnQoZWwsIF9tZXJnZU92ZXJyaWRlcyhkZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvcjogX3AuYW5jaG9ycyA/IF9wLmFuY2hvcnNbaWR4XSA6IF9wLmFuY2hvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfcC5lbmRwb2ludHMgPyBfcC5lbmRwb2ludHNbaWR4XSA6IF9wLmVuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpbnRTdHlsZTogX3AuZW5kcG9pbnRTdHlsZXMgPyBfcC5lbmRwb2ludFN0eWxlc1tpZHhdIDogX3AuZW5kcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyUGFpbnRTdHlsZTogX3AuZW5kcG9pbnRIb3ZlclN0eWxlcyA/IF9wLmVuZHBvaW50SG92ZXJTdHlsZXNbaWR4XSA6IF9wLmVuZHBvaW50SG92ZXJTdHlsZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBtYWtlU291cmNlL21ha2VUYXJnZXQgc3BlY3MuXG5cbiAgICAgICAgICAgICAgICB2YXIgX29uZUVsZW1lbnREZWYgPSBmdW5jdGlvbiAodHlwZSwgaWR4LCBkZWZzLCBtYXRjaFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9wW3R5cGVdICYmICFfcFt0eXBlXS5lbmRwb2ludCAmJiAhX3BbdHlwZSArIFwiRW5kcG9pbnRcIl0gJiYgIV9wLm5ld0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aWQgPSBfZ2V0SWQoX3BbdHlwZV0pLCB0ZXAgPSBkZWZzW3RpZF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcCA9IHRlcCA/IHRlcFttYXRjaFR5cGVdIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBlbmFibGVkLCByZXR1cm4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXAuZW5hYmxlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdFbmRwb2ludCA9IHRlcC5lbmRwb2ludCAhPSBudWxsICYmIHRlcC5lbmRwb2ludC5fanNQbHVtYiA/IHRlcC5lbmRwb2ludCA6IF9hZGRFbmRwb2ludChfcFt0eXBlXSwgdGVwLmRlZiwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3RW5kcG9pbnQuaXNGdWxsKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcFt0eXBlICsgXCJFbmRwb2ludFwiXSA9IG5ld0VuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VuZHBvaW50Ll9kb05vdERlbGV0ZU9uRGV0YWNoID0gZmFsc2U7IC8vIHJlc2V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VuZHBvaW50Ll9kZWxldGVPbkRldGFjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlcC51bmlxdWVFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcC5lbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVwLmVuZHBvaW50ID0gbmV3RW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdFbmRwb2ludC5fZGVsZXRlT25EZXRhY2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VuZHBvaW50Ll9kb05vdERlbGV0ZU9uRGV0YWNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdFbmRwb2ludC5maW5hbEVuZHBvaW50ID0gdGVwLmVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoX29uZUVsZW1lbnREZWYoXCJzb3VyY2VcIiwgMCwgdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zLCBfcC50eXBlIHx8IFwiZGVmYXVsdFwiKSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoX29uZUVsZW1lbnREZWYoXCJ0YXJnZXRcIiwgMSwgdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zLCBfcC50eXBlIHx8IFwiZGVmYXVsdFwiKSA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIGxhc3QsIGVuc3VyZSBzY29wZXMgbWF0Y2hcbiAgICAgICAgICAgICAgICBpZiAoX3Auc291cmNlRW5kcG9pbnQgJiYgX3AudGFyZ2V0RW5kcG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3Njb3BlTWF0Y2goX3Auc291cmNlRW5kcG9pbnQsIF9wLnRhcmdldEVuZHBvaW50KSkgX3AgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wO1xuICAgICAgICAgICAgfS5iaW5kKF9jdXJyZW50SW5zdGFuY2UpLFxuXG4gICAgICAgICAgICBfbmV3Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdGlvbkZ1bmMgPSBfY3VycmVudEluc3RhbmNlLkRlZmF1bHRzLkNvbm5lY3Rpb25UeXBlIHx8IF9jdXJyZW50SW5zdGFuY2UuZ2V0RGVmYXVsdENvbm5lY3Rpb25UeXBlKCk7XG5cbiAgICAgICAgICAgICAgICBwYXJhbXMuX2pzUGx1bWIgPSBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5uZXdDb25uZWN0aW9uID0gX25ld0Nvbm5lY3Rpb247XG4gICAgICAgICAgICAgICAgcGFyYW1zLm5ld0VuZHBvaW50ID0gX25ld0VuZHBvaW50O1xuICAgICAgICAgICAgICAgIHBhcmFtcy5lbmRwb2ludHNCeVVVSUQgPSBlbmRwb2ludHNCeVVVSUQ7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmVuZHBvaW50c0J5RWxlbWVudCA9IGVuZHBvaW50c0J5RWxlbWVudDtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZmluYWxpc2VDb25uZWN0aW9uID0gX2ZpbmFsaXNlQ29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICBwYXJhbXMuaWQgPSBcImNvbl9cIiArIF9pZHN0YW1wKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbiA9IG5ldyBjb25uZWN0aW9uRnVuYyhwYXJhbXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvbm5lY3Rpb24gaXMgZHJhZ2dhYmxlLCB0aGVuIG1heWJlIHdlIG5lZWQgdG8gdGVsbCB0aGUgdGFyZ2V0IGVuZHBvaW50IHRvIGluaXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gZHJhZ2dpbmcgY29kZS4gaXQgd29uJ3QgcnVuIGFnYWluIGlmIGl0IGFscmVhZHkgY29uZmlndXJlZCB0byBiZSBkcmFnZ2FibGUuXG4gICAgICAgICAgICAgICAgaWYgKGNvbi5pc0RldGFjaGFibGUoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb24uZW5kcG9pbnRzWzBdLmluaXREcmFnZ2FibGUoXCJfanNQbHVtYlNvdXJjZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uLmVuZHBvaW50c1sxXS5pbml0RHJhZ2dhYmxlKFwiX2pzUGx1bWJUYXJnZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gYWRkcyB0aGUgY29ubmVjdGlvbiB0byB0aGUgYmFja2luZyBtb2RlbCwgZmlyZXMgYW4gZXZlbnQgaWYgbmVjZXNzYXJ5IGFuZCB0aGVuIHJlZHJhd3NcbiAgICAgICAgLy9cbiAgICAgICAgICAgIF9maW5hbGlzZUNvbm5lY3Rpb24gPSBfY3VycmVudEluc3RhbmNlLmZpbmFsaXNlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChqcGMsIHBhcmFtcywgb3JpZ2luYWxFdmVudCwgZG9JbmZvcm1BbmNob3JNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgICAgIC8vIGFkZCB0byBsaXN0IG9mIGNvbm5lY3Rpb25zIChieSBzY29wZSkuXG4gICAgICAgICAgICAgICAgaWYgKCFqcGMuc3VzcGVuZGVkRW5kcG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goanBjKTtcblxuICAgICAgICAgICAgICAgIGpwYy5wZW5kaW5nID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIHR1cm4gb2ZmIGlzVGVtcG9yYXJ5U291cmNlIG9uIHRoZSBzb3VyY2UgZW5kcG9pbnQgKG9ubHkgdmlhYmxlIG9uIGZpcnN0IGRyYXcpXG4gICAgICAgICAgICAgICAganBjLmVuZHBvaW50c1swXS5pc1RlbXBvcmFyeVNvdXJjZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIGluZm9ybSB0aGUgYW5jaG9yIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAvLyBleGNlcHQgdGhhdCBpZiBqcGMgaGFzIGEgc3VzcGVuZGVkIGVuZHBvaW50IGl0J3Mgbm90IHRydWUgdG8gc2F5IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgbmV3OyBpdCBoYXMganVzdCAocG9zc2libHkpIG1vdmVkLiB0aGUgcXVlc3Rpb24gaXMgd2hldGhlclxuICAgICAgICAgICAgICAgIC8vIHRvIG1ha2UgdGhhdCBjYWxsIGhlcmUgb3IgaW4gdGhlIGFuY2hvciBtYW5hZ2VyLiAgaSB0aGluayBwZXJoYXBzIGhlcmUuXG4gICAgICAgICAgICAgICAgaWYgKGRvSW5mb3JtQW5jaG9yTWFuYWdlciAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5uZXdDb25uZWN0aW9uKGpwYyk7XG5cbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBhIHBhaW50XG4gICAgICAgICAgICAgICAgX2RyYXcoanBjLnNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXJlIGFuIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuZG9Ob3RGaXJlQ29ubmVjdGlvbkV2ZW50ICYmIHBhcmFtcy5maXJlRXZlbnQgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IGpwYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZToganBjLnNvdXJjZSwgdGFyZ2V0OiBqcGMudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IGpwYy5zb3VyY2VJZCwgdGFyZ2V0SWQ6IGpwYy50YXJnZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUVuZHBvaW50OiBqcGMuZW5kcG9pbnRzWzBdLCB0YXJnZXRFbmRwb2ludDoganBjLmVuZHBvaW50c1sxXVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZmlyZShcImNvbm5lY3Rpb25cIiwgZXZlbnRBcmdzLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICBmYWN0b3J5IG1ldGhvZCB0byBwcmVwYXJlIGEgbmV3IGVuZHBvaW50LiAgdGhpcyBzaG91bGQgYWx3YXlzIGJlIHVzZWQgaW5zdGVhZCBvZiBjcmVhdGluZyBFbmRwb2ludHNcbiAgICAgICAgIG1hbnVhbGx5LCBzaW5jZSB0aGlzIG1ldGhvZCBhdHRhY2hlcyBldmVudCBsaXN0ZW5lcnMgYW5kIGFuIGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgICAgIF9uZXdFbmRwb2ludCA9IGZ1bmN0aW9uIChwYXJhbXMsIGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZHBvaW50RnVuYyA9IF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuRW5kcG9pbnRUeXBlIHx8IGpzUGx1bWIuRW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgdmFyIF9wID0ganNQbHVtYi5leHRlbmQoe30sIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgX3AuX2pzUGx1bWIgPSBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICAgICAgICAgIF9wLm5ld0Nvbm5lY3Rpb24gPSBfbmV3Q29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICBfcC5uZXdFbmRwb2ludCA9IF9uZXdFbmRwb2ludDtcbiAgICAgICAgICAgICAgICBfcC5lbmRwb2ludHNCeVVVSUQgPSBlbmRwb2ludHNCeVVVSUQ7XG4gICAgICAgICAgICAgICAgX3AuZW5kcG9pbnRzQnlFbGVtZW50ID0gZW5kcG9pbnRzQnlFbGVtZW50O1xuICAgICAgICAgICAgICAgIF9wLmZpcmVEZXRhY2hFdmVudCA9IGZpcmVEZXRhY2hFdmVudDtcbiAgICAgICAgICAgICAgICBfcC5lbGVtZW50SWQgPSBpZCB8fCBfZ2V0SWQoX3Auc291cmNlKTtcbiAgICAgICAgICAgICAgICB2YXIgZXAgPSBuZXcgZW5kcG9pbnRGdW5jKF9wKTtcbiAgICAgICAgICAgICAgICBlcC5pZCA9IFwiZXBfXCIgKyBfaWRzdGFtcCgpO1xuICAgICAgICAgICAgICAgIF9tYW5hZ2UoX3AuZWxlbWVudElkLCBfcC5zb3VyY2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFqc1BsdW1iLmhlYWRsZXNzKVxuICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmdldERyYWdNYW5hZ2VyKCkuZW5kcG9pbnRBZGRlZChfcC5zb3VyY2UsIGlkKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBlcDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICogcGVyZm9ybXMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9wZXJhdGlvbiBvbiBhbGwgdGhlIGNvbm5lY3Rpb25zIGZvdW5kXG4gICAgICAgICAqIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBpZDsgdGhpcyBtZWFucyB3ZSBmaW5kIGFsbCB0aGUgZW5kcG9pbnRzIGZvclxuICAgICAgICAgKiB0aGUgZ2l2ZW4gZWxlbWVudCwgYW5kIHRoZW4gZm9yIGVhY2ggZW5kcG9pbnQgZmluZCB0aGUgY29ubmVjdG9yc1xuICAgICAgICAgKiBjb25uZWN0ZWQgdG8gaXQuIHRoZW4gd2UgcGFzcyBlYWNoIGNvbm5lY3Rpb24gaW4gdG8gdGhlIGdpdmVuXG4gICAgICAgICAqIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vcGVyYXRpb24gPSBmdW5jdGlvbiAoZWxJZCwgZnVuYywgZW5kcG9pbnRGdW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZHBvaW50cyA9IGVuZHBvaW50c0J5RWxlbWVudFtlbElkXTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGVuZHBvaW50c1tpXS5jb25uZWN0aW9ucy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IGZ1bmMoZW5kcG9pbnRzW2ldLmNvbm5lY3Rpb25zW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZnVuY3Rpb24gcGFzc2VkIGluIHJldHVybnMgdHJ1ZSwgd2UgZXhpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3N0IGZ1bmN0aW9ucyByZXR1cm4gZmFsc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldFZhbCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50RnVuYykgZW5kcG9pbnRGdW5jKGVuZHBvaW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfc2V0RHJhZ2dhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdnYWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc1BsdW1iLmVhY2goZWxlbWVudCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfY3VycmVudEluc3RhbmNlLmlzRHJhZ1N1cHBvcnRlZChlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZVN0YXRlc1tfY3VycmVudEluc3RhbmNlLmdldEF0dHJpYnV0ZShlbCwgXCJpZFwiKV0gPSBkcmFnZ2FibGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnNldEVsZW1lbnREcmFnZ2FibGUoZWwsIGRyYWdnYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIC8qXG4gICAgICAgICAqIHByaXZhdGUgbWV0aG9kIHRvIGRvIHRoZSBidXNpbmVzcyBvZiBoaWRpbmcvc2hvd2luZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVsXG4gICAgICAgICAqICAgICAgICAgICAgZWl0aGVyIElkIG9mIHRoZSBlbGVtZW50IGluIHF1ZXN0aW9uIG9yIGEgbGlicmFyeSBzcGVjaWZpY1xuICAgICAgICAgKiAgICAgICAgICAgIG9iamVjdCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSBzdGF0ZVxuICAgICAgICAgKiAgICAgICAgICAgIFN0cmluZyBzcGVjaWZ5aW5nIGEgdmFsdWUgZm9yIHRoZSBjc3MgJ2Rpc3BsYXknIHByb3BlcnR5XG4gICAgICAgICAqICAgICAgICAgICAgKCdibG9jaycgb3IgJ25vbmUnKS5cbiAgICAgICAgICovXG4gICAgICAgICAgICBfc2V0VmlzaWJsZSA9IGZ1bmN0aW9uIChlbCwgc3RhdGUsIGFsc29DaGFuZ2VFbmRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlID09PSBcImJsb2NrXCI7XG4gICAgICAgICAgICAgICAgdmFyIGVuZHBvaW50RnVuYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGFsc29DaGFuZ2VFbmRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRGdW5jID0gZnVuY3Rpb24gKGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcC5zZXRWaXNpYmxlKHN0YXRlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBfaW5mbyhlbCk7XG4gICAgICAgICAgICAgICAgX29wZXJhdGlvbihpbmZvLmlkLCBmdW5jdGlvbiAoanBjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBhbHNvQ2hhbmdlRW5kcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHRlc3QgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhpcyBmdW5jdGlvbmFsaXR5IGlzIG5ldywgYW5kIGkgd2FudGVkIHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBibG9jayB3aWxsIG9ubHkgc2V0IGEgY29ubmVjdGlvbiB0byBiZSB2aXNpYmxlIGlmIHRoZSBvdGhlciBlbmRwb2ludCBpbiB0aGUgY29ubmVjdGlvbiBpcyBhbHNvIHZpc2libGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2lkeCA9IGpwYy5zb3VyY2VJZCA9PT0gaW5mby5pZCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpwYy5lbmRwb2ludHNbb2lkeF0uaXNWaXNpYmxlKCkpIGpwYy5zZXRWaXNpYmxlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgIC8vIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3Igc2hvdywgYW5kIHdoYXQgYWx3YXlzIGhhcHBlbnMgZm9yIGhpZGUsIGlzIHRvIGp1c3Qgc2V0IHRoZSB2aXNpYmlsaXR5IHdpdGhvdXQgZ2V0dGluZyBjbGV2ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuc2V0VmlzaWJsZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSwgZW5kcG9pbnRGdW5jKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIC8qXG4gICAgICAgICAqIHRvZ2dsZXMgdGhlIGRyYWdnYWJsZSBzdGF0ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudChzKS5cbiAgICAgICAgICogZWwgaXMgZWl0aGVyIGFuIGlkLCBvciBhbiBlbGVtZW50IG9iamVjdCwgb3IgYSBsaXN0IG9mIGlkcy9lbGVtZW50IG9iamVjdHMuXG4gICAgICAgICAqL1xuICAgICAgICAgICAgX3RvZ2dsZURyYWdnYWJsZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZTtcbiAgICAgICAgICAgICAgICBqc1BsdW1iLmVhY2goZWwsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxJZCA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0QXR0cmlidXRlKGVsLCBcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGRyYWdnYWJsZVN0YXRlc1tlbElkXSA9PSBudWxsID8gZmFsc2UgOiBkcmFnZ2FibGVTdGF0ZXNbZWxJZF07XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gIXN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGVTdGF0ZXNbZWxJZF0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZXREcmFnZ2FibGUoZWwsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcHJpdmF0ZSBtZXRob2QgdG8gZG8gdGhlIGJ1c2luZXNzIG9mIHRvZ2dsaW5nIGhpZGluZy9zaG93aW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdG9nZ2xlVmlzaWJsZSA9IGZ1bmN0aW9uIChlbElkLCBjaGFuZ2VFbmRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kcG9pbnRGdW5jID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlRW5kcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50RnVuYyA9IGZ1bmN0aW9uIChlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZXAuaXNWaXNpYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcC5zZXRWaXNpYmxlKCFzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9vcGVyYXRpb24oZWxJZCwgZnVuY3Rpb24gKGpwYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBqcGMuaXNWaXNpYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGpwYy5zZXRWaXNpYmxlKCFzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSwgZW5kcG9pbnRGdW5jKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ETyBjb21wYXJpc29uIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICBfZ2V0Q2FjaGVkRGF0YSA9IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSBvZmZzZXRzW2VsSWRdO1xuICAgICAgICAgICAgICAgIGlmICghbylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF91cGRhdGVPZmZzZXQoe2VsSWQ6IGVsSWR9KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7bzogbywgczogc2l6ZXNbZWxJZF19O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBnZXRzIGFuIGlkIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCwgY3JlYXRpbmcgYW5kIHNldHRpbmcgb25lIGlmXG4gICAgICAgICAgICAgKiBuZWNlc3NhcnkuICB0aGUgaWQgaXMgb2YgdGhlIGZvcm1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICBqc1BsdW1iXzxpbnN0YW5jZSBpbmRleD5fPGluZGV4IGluIGluc3RhbmNlPlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIHdoZXJlIFwiaW5kZXggaW4gaW5zdGFuY2VcIiBpcyBhIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBpbnRlZ2VyIHRoYXQgc3RhcnRzIGF0IDAsXG4gICAgICAgICAgICAgKiBmb3IgZWFjaCBpbnN0YW5jZS4gIHRoaXMgbWV0aG9kIGlzIHVzZWQgbm90IG9ubHkgdG8gYXNzaWduIGlkcyB0byBlbGVtZW50cyB0aGF0IGRvIG5vdFxuICAgICAgICAgICAgICogaGF2ZSB0aGVtIGJ1dCBhbHNvIHRvIGNvbm5lY3Rpb25zIGFuZCBlbmRwb2ludHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9nZXRJZCA9IGZ1bmN0aW9uIChlbGVtZW50LCB1dWlkLCBkb05vdENyZWF0ZUlmTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2p1LmlzU3RyaW5nKGVsZW1lbnQpKSByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfY3VycmVudEluc3RhbmNlLmdldEF0dHJpYnV0ZShlbGVtZW50LCBcImlkXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaWQgfHwgaWQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZml4ZWQgdXVpZCBwYXJhbWV0ZXIgaXMgZ2l2ZW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMiAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gdXVpZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxIHx8IChhcmd1bWVudHMubGVuZ3RoID09IDMgJiYgIWFyZ3VtZW50c1syXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IFwianNQbHVtYl9cIiArIF9pbnN0YW5jZUluZGV4ICsgXCJfXCIgKyBfaWRzdGFtcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9Ob3RDcmVhdGVJZk5vdEZvdW5kKSBfY3VycmVudEluc3RhbmNlLnNldEF0dHJpYnV0ZShlbGVtZW50LCBcImlkXCIsIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldENvbm5lY3Rpb25CZWluZ0RyYWdnZWQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgY29ubmVjdGlvbkJlaW5nRHJhZ2dlZCA9IHY7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW9uQmVpbmdEcmFnZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25CZWluZ0RyYWdnZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBtYXAgb2YgYWxsIHRoZSBlbGVtZW50cyB0aGlzIGpzUGx1bWJJbnN0YW5jZSBpcyBjdXJyZW50bHkgbWFuYWdpbmcuXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE1hcCBvZiBbaWQtPiB7ZWwsIGVuZHBvaW50W10sIGNvbm5lY3Rpb24sIHBvc2l0aW9ufV0gaW5mb3JtYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldE1hbmFnZWRFbGVtZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRFbGVtZW50cztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldFJlbmRlck1vZGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwic3ZnXCI7IH07XG5cbiAgICAgICAgdGhpcy5jb25uZWN0b3JDbGFzcyA9IFwianNwbHVtYi1jb25uZWN0b3JcIjtcbiAgICAgICAgdGhpcy5jb25uZWN0b3JPdXRsaW5lQ2xhc3MgPSBcImpzcGx1bWItY29ubmVjdG9yLW91dGxpbmVcIjtcbiAgICAgICAgdGhpcy5lZGl0YWJsZUNvbm5lY3RvckNsYXNzID0gXCJqc3BsdW1iLWNvbm5lY3Rvci1lZGl0YWJsZVwiO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZENsYXNzID0gXCJqc3BsdW1iLWNvbm5lY3RlZFwiO1xuICAgICAgICB0aGlzLmhvdmVyQ2xhc3MgPSBcImpzcGx1bWItaG92ZXJcIjtcbiAgICAgICAgdGhpcy5lbmRwb2ludENsYXNzID0gXCJqc3BsdW1iLWVuZHBvaW50XCI7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRDb25uZWN0ZWRDbGFzcyA9IFwianNwbHVtYi1lbmRwb2ludC1jb25uZWN0ZWRcIjtcbiAgICAgICAgdGhpcy5lbmRwb2ludEZ1bGxDbGFzcyA9IFwianNwbHVtYi1lbmRwb2ludC1mdWxsXCI7XG4gICAgICAgIHRoaXMuZW5kcG9pbnREcm9wQWxsb3dlZENsYXNzID0gXCJqc3BsdW1iLWVuZHBvaW50LWRyb3AtYWxsb3dlZFwiO1xuICAgICAgICB0aGlzLmVuZHBvaW50RHJvcEZvcmJpZGRlbkNsYXNzID0gXCJqc3BsdW1iLWVuZHBvaW50LWRyb3AtZm9yYmlkZGVuXCI7XG4gICAgICAgIHRoaXMub3ZlcmxheUNsYXNzID0gXCJqc3BsdW1iLW92ZXJsYXlcIjtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ0NsYXNzID0gXCJqc3BsdW1iLWRyYWdnaW5nXCI7XG4gICAgICAgIHRoaXMuZWxlbWVudERyYWdnaW5nQ2xhc3MgPSBcImpzcGx1bWItZWxlbWVudC1kcmFnZ2luZ1wiO1xuICAgICAgICB0aGlzLnNvdXJjZUVsZW1lbnREcmFnZ2luZ0NsYXNzID0gXCJqc3BsdW1iLXNvdXJjZS1lbGVtZW50LWRyYWdnaW5nXCI7XG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudERyYWdnaW5nQ2xhc3MgPSBcImpzcGx1bWItdGFyZ2V0LWVsZW1lbnQtZHJhZ2dpbmdcIjtcbiAgICAgICAgdGhpcy5lbmRwb2ludEFuY2hvckNsYXNzUHJlZml4ID0gXCJqc3BsdW1iLWVuZHBvaW50LWFuY2hvclwiO1xuICAgICAgICB0aGlzLmhvdmVyU291cmNlQ2xhc3MgPSBcImpzcGx1bWItc291cmNlLWhvdmVyXCI7XG4gICAgICAgIHRoaXMuaG92ZXJUYXJnZXRDbGFzcyA9IFwianNwbHVtYi10YXJnZXQtaG92ZXJcIjtcbiAgICAgICAgdGhpcy5kcmFnU2VsZWN0Q2xhc3MgPSBcImpzcGx1bWItZHJhZy1zZWxlY3RcIjtcblxuICAgICAgICB0aGlzLkFuY2hvcnMgPSB7fTtcbiAgICAgICAgdGhpcy5Db25uZWN0b3JzID0geyAgXCJzdmdcIjoge30gfTtcbiAgICAgICAgdGhpcy5FbmRwb2ludHMgPSB7IFwic3ZnXCI6IHt9IH07XG4gICAgICAgIHRoaXMuT3ZlcmxheXMgPSB7IFwic3ZnXCI6IHt9IH0gO1xuICAgICAgICB0aGlzLkNvbm5lY3RvclJlbmRlcmVycyA9IHt9O1xuICAgICAgICB0aGlzLlNWRyA9IFwic3ZnXCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBqc1BsdW1iSW5zdGFuY2UgcHVibGljIEFQSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAgIHRoaXMuYWRkRW5kcG9pbnQgPSBmdW5jdGlvbiAoZWwsIHBhcmFtcywgcmVmZXJlbmNlUGFyYW1zKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VQYXJhbXMgPSByZWZlcmVuY2VQYXJhbXMgfHwge307XG4gICAgICAgICAgICB2YXIgcCA9IGpzUGx1bWIuZXh0ZW5kKHt9LCByZWZlcmVuY2VQYXJhbXMpO1xuICAgICAgICAgICAganNQbHVtYi5leHRlbmQocCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHAuZW5kcG9pbnQgPSBwLmVuZHBvaW50IHx8IF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuRW5kcG9pbnQ7XG4gICAgICAgICAgICBwLnBhaW50U3R5bGUgPSBwLnBhaW50U3R5bGUgfHwgX2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5FbmRwb2ludFN0eWxlO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICAgICAgICAgIGlucHV0cyA9IChfanUuaXNBcnJheShlbCkgfHwgKGVsLmxlbmd0aCAhPSBudWxsICYmICFfanUuaXNTdHJpbmcoZWwpKSkgPyBlbCA6IFsgZWwgXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBpbnB1dHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcC5zb3VyY2UgPSBfY3VycmVudEluc3RhbmNlLmdldEVsZW1lbnQoaW5wdXRzW2ldKTtcbiAgICAgICAgICAgICAgICBfZW5zdXJlQ29udGFpbmVyKHAuc291cmNlKTtcblxuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9nZXRJZChwLnNvdXJjZSksIGUgPSBfbmV3RW5kcG9pbnQocCwgaWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gU1AgbmV3LiBoZXJlIHdlIGhhdmUgaW50cm9kdWNlZCBhIGNsYXNzLXdpZGUgZWxlbWVudCBtYW5hZ2VyLCB3aGljaCBpcyByZXNwb25zaWJsZVxuICAgICAgICAgICAgICAgIC8vIGZvciBnZXR0aW5nIG9iamVjdCBkaW1lbnNpb25zIGFuZCB3aWR0aC9oZWlnaHQsIGFuZCBmb3IgdXBkYXRpbmcgdGhlc2UgdmFsdWVzIG9ubHlcbiAgICAgICAgICAgICAgICAvLyB3aGVuIG5lY2Vzc2FyeSAoYWZ0ZXIgYSBkcmFnLCBvciBvbiBhIGZvcmNlZCByZWZyZXNoIGNhbGwpLlxuICAgICAgICAgICAgICAgIHZhciBteU9mZnNldCA9IF9tYW5hZ2UoaWQsIHAuc291cmNlKS5pbmZvLm87XG4gICAgICAgICAgICAgICAgX2p1LmFkZFRvTGlzdChlbmRwb2ludHNCeUVsZW1lbnQsIGlkLCBlKTtcblxuICAgICAgICAgICAgICAgIGlmICghX3N1c3BlbmREcmF3aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucGFpbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yTG9jOiBlLmFuY2hvci5jb21wdXRlKHsgeHk6IFsgbXlPZmZzZXQubGVmdCwgbXlPZmZzZXQudG9wIF0sIHdoOiBzaXplc1tpZF0sIGVsZW1lbnQ6IGUsIHRpbWVzdGFtcDogX3N1c3BlbmRlZEF0IH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBfc3VzcGVuZGVkQXRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIGUuX2RvTm90RGVsZXRlT25EZXRhY2ggPSB0cnVlOyAvLyBtYXJrIHRoaXMgYXMgYmVpbmcgYWRkZWQgdmlhIGFkZEVuZHBvaW50LlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cy5sZW5ndGggPT0gMSA/IHJlc3VsdHNbMF0gOiByZXN1bHRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkRW5kcG9pbnRzID0gZnVuY3Rpb24gKGVsLCBlbmRwb2ludHMsIHJlZmVyZW5jZVBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gZW5kcG9pbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gX2N1cnJlbnRJbnN0YW5jZS5hZGRFbmRwb2ludChlbCwgZW5kcG9pbnRzW2ldLCByZWZlcmVuY2VQYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmIChfanUuaXNBcnJheShlKSlcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0cywgZSk7XG4gICAgICAgICAgICAgICAgZWxzZSByZXN1bHRzLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWwsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbmltYXRpb25TdXBwb3J0ZWQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgZGVsID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRFbGVtZW50KGVsKSxcbiAgICAgICAgICAgICAgICBpZCA9IF9nZXRJZChkZWwpLFxuICAgICAgICAgICAgICAgIHN0ZXBGdW5jdGlvbiA9IGpzUGx1bWIuYW5pbUV2ZW50cy5zdGVwLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlRnVuY3Rpb24gPSBqc1BsdW1iLmFuaW1FdmVudHMuY29tcGxldGU7XG5cbiAgICAgICAgICAgIG9wdGlvbnNbc3RlcEZ1bmN0aW9uXSA9IF9qdS53cmFwKG9wdGlvbnNbc3RlcEZ1bmN0aW9uXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UucmV2YWxpZGF0ZShpZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gb25Db21wbGV0ZSByZXBhaW50cywganVzdCB0byBtYWtlIHN1cmUgZXZlcnl0aGluZyBsb29rcyBnb29kIGF0IHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICAgIG9wdGlvbnNbY29tcGxldGVGdW5jdGlvbl0gPSBfanUud3JhcChvcHRpb25zW2NvbXBsZXRlRnVuY3Rpb25dLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5yZXZhbGlkYXRlKGlkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRvQW5pbWF0ZShkZWwsIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVja3MgZm9yIGEgbGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBjb25kaXRpb24sIGV4ZWN1dGluZyBpdCBpZiBmb3VuZCwgcGFzc2luZyBpbiB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICAgICAqIGNvbmRpdGlvbiBsaXN0ZW5lcnMgd291bGQgaGF2ZSBiZWVuIGF0dGFjaGVkIHVzaW5nIFwiYmluZFwiICh3aGljaCBpcywgeW91IGNvdWxkIGFyZ3VlLCBub3cgb3ZlcmxvYWRlZCwgc2luY2VcbiAgICAgICAgICogZmlyaW5nIGNsaWNrIGV2ZW50cyBldGMgaXMgYSBiaXQgZGlmZmVyZW50IHRvIHdoYXQgdGhpcyBkb2VzKS4gIGkgdGhvdWdodCBhYm91dCBhZGRpbmcgYSBcImJpbmRDb25kaXRpb25cIlxuICAgICAgICAgKiBvciBzb21ldGhpbmcsIGJ1dCBkZWNpZGVkIGFnYWluc3QgaXQsIGZvciB0aGUgc2FrZSBvZiBzaW1wbGljaXR5LiBqc1BsdW1iIHdpbGwgbmV2ZXIgZmlyZSBvbmUgb2YgdGhlc2VcbiAgICAgICAgICogY29uZGl0aW9uIGV2ZW50cyBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uID0gZnVuY3Rpb24gKGNvbmRpdGlvbk5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBsID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRMaXN0ZW5lcihjb25kaXRpb25OYW1lKSxcbiAgICAgICAgICAgICAgICByID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGwgJiYgbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBsLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHIgJiYgbFtpXS5hcHBseShsW2ldLCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qdS5sb2coX2N1cnJlbnRJbnN0YW5jZSwgXCJjYW5ub3QgY2hlY2sgY29uZGl0aW9uIFtcIiArIGNvbmRpdGlvbk5hbWUgKyBcIl1cIiArIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY29ubmVjdCA9IGZ1bmN0aW9uIChwYXJhbXMsIHJlZmVyZW5jZVBhcmFtcykge1xuICAgICAgICAgICAgLy8gcHJlcGFyZSBhIGZpbmFsIHNldCBvZiBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBjb25uZWN0aW9uIHdpdGhcbiAgICAgICAgICAgIHZhciBfcCA9IF9wcmVwYXJlQ29ubmVjdGlvblBhcmFtcyhwYXJhbXMsIHJlZmVyZW5jZVBhcmFtcyksIGpwYztcbiAgICAgICAgICAgIC8vIFRPRE8gcHJvYmFibHkgYSBuaWNlciByZXR1cm4gdmFsdWUgaWYgdGhlIGNvbm5lY3Rpb24gd2FzIG5vdCBtYWRlLiAgX3ByZXBhcmVDb25uZWN0aW9uUGFyYW1zXG4gICAgICAgICAgICAvLyB3aWxsIHJldHVybiBudWxsIChhbmQgbG9nIHNvbWV0aGluZykgaWYgZWl0aGVyIGVuZHBvaW50IHdhcyBmdWxsLiAgd2hhdCB3b3VsZCBiZSBuaWNlciBpcyB0b1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgZGVkaWNhdGVkICdlcnJvcicgb2JqZWN0LlxuICAgICAgICAgICAgaWYgKF9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9wLnNvdXJjZSA9PSBudWxsICYmIF9wLnNvdXJjZUVuZHBvaW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2p1LmxvZyhcIkNhbm5vdCBlc3RhYmxpc2ggY29ubmVjdGlvbiAtIHNvdXJjZSBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3AudGFyZ2V0ID09IG51bGwgJiYgX3AudGFyZ2V0RW5kcG9pbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfanUubG9nKFwiQ2Fubm90IGVzdGFibGlzaCBjb25uZWN0aW9uIC0gdGFyZ2V0IGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9lbnN1cmVDb250YWluZXIoX3Auc291cmNlKTtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGNvbm5lY3Rpb24uICBpdCBpcyBub3QgeWV0IHJlZ2lzdGVyZWRcbiAgICAgICAgICAgICAgICBqcGMgPSBfbmV3Q29ubmVjdGlvbihfcCk7XG4gICAgICAgICAgICAgICAgLy8gbm93IGFkZCBpdCB0aGUgbW9kZWwsIGZpcmUgYW4gZXZlbnQsIGFuZCByZWRyYXdcbiAgICAgICAgICAgICAgICBfZmluYWxpc2VDb25uZWN0aW9uKGpwYywgX3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpwYztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3RUeXBlcyA9IFtcbiAgICAgICAgICAgIHsgZWw6IFwic291cmNlXCIsIGVsSWQ6IFwic291cmNlSWRcIiwgZXBEZWZzOiBcInNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNcIiB9LFxuICAgICAgICAgICAgeyBlbDogXCJ0YXJnZXRcIiwgZWxJZDogXCJ0YXJnZXRJZFwiLCBlcERlZnM6IFwidGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1wiIH1cbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgX3NldCA9IGZ1bmN0aW9uIChjLCBlbCwgaWR4LCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIHZhciBlcCwgX3N0ID0gc3RUeXBlc1tpZHhdLCBjSWQgPSBjW19zdC5lbElkXSwgY0VsID0gY1tfc3QuZWxdLCBzaWQsIHNlcCxcbiAgICAgICAgICAgICAgICBvbGRFbmRwb2ludCA9IGMuZW5kcG9pbnRzW2lkeF07XG5cbiAgICAgICAgICAgIHZhciBldnRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGlkeCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFNvdXJjZUlkOiBpZHggPT09IDAgPyBjSWQgOiBjLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIG5ld1NvdXJjZUlkOiBjLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsVGFyZ2V0SWQ6IGlkeCA9PSAxID8gY0lkIDogYy50YXJnZXRJZCxcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXRJZDogYy50YXJnZXRJZCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBjXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZWwuY29uc3RydWN0b3IgPT0ganNQbHVtYi5FbmRwb2ludCkgeyAvLyBUT0RPIGhlcmUgbWF0Y2ggdGhlIGN1cnJlbnQgZW5kcG9pbnQgY2xhc3M7IHVzZXJzIGNhbiBjaGFuZ2UgaXQge1xuICAgICAgICAgICAgICAgIGVwID0gZWw7XG4gICAgICAgICAgICAgICAgZXAuYWRkQ29ubmVjdGlvbihjKTtcbiAgICAgICAgICAgICAgICBlbCA9IGVwLmVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWQgPSBfZ2V0SWQoZWwpO1xuICAgICAgICAgICAgICAgIHNlcCA9IHRoaXNbX3N0LmVwRGVmc11bc2lkXTtcblxuICAgICAgICAgICAgICAgIGlmIChzaWQgPT09IGNbX3N0LmVsSWRdKVxuICAgICAgICAgICAgICAgICAgICBlcCA9IG51bGw7ICAvLyBkb250IGNoYW5nZSBzb3VyY2UvdGFyZ2V0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgdGhlIG9uZSBnaXZlbi5cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCBpbiBzZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VwW3RdLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwID0gc2VwW3RdLmVuZHBvaW50ICE9IG51bGwgJiYgc2VwW3RdLmVuZHBvaW50Ll9qc1BsdW1iID8gc2VwW3RdLmVuZHBvaW50IDogdGhpcy5hZGRFbmRwb2ludChlbCwgc2VwW3RdLmRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VwW3RdLnVuaXF1ZUVuZHBvaW50KSBzZXBbdF0uZW5kcG9pbnQgPSBlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwLl9kb05vdERlbGV0ZU9uRGV0YWNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcC5fZGVsZXRlT25EZXRhY2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXAuYWRkQ29ubmVjdGlvbihjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXAgPSBjLm1ha2VFbmRwb2ludChpZHggPT09IDAsIGVsLCBzaWQpO1xuICAgICAgICAgICAgICAgICAgICBlcC5fZG9Ob3REZWxldGVPbkRldGFjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlcC5fZGVsZXRlT25EZXRhY2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvbGRFbmRwb2ludC5kZXRhY2hGcm9tQ29ubmVjdGlvbihjKTtcbiAgICAgICAgICAgICAgICBjLmVuZHBvaW50c1tpZHhdID0gZXA7XG4gICAgICAgICAgICAgICAgY1tfc3QuZWxdID0gZXAuZWxlbWVudDtcbiAgICAgICAgICAgICAgICBjW19zdC5lbElkXSA9IGVwLmVsZW1lbnRJZDtcbiAgICAgICAgICAgICAgICBldnRQYXJhbXNbaWR4ID09PSAwID8gXCJuZXdTb3VyY2VJZFwiIDogXCJuZXdUYXJnZXRJZFwiXSA9IGVwLmVsZW1lbnRJZDtcblxuICAgICAgICAgICAgICAgIGZpcmVNb3ZlRXZlbnQoZXZ0UGFyYW1zKTtcblxuICAgICAgICAgICAgICAgIGlmICghZG9Ob3RSZXBhaW50KVxuICAgICAgICAgICAgICAgICAgICBjLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZ0UGFyYW1zLmVsZW1lbnQgPSBlbDtcbiAgICAgICAgICAgIHJldHVybiBldnRQYXJhbXM7XG5cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2V0U291cmNlID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIGVsLCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gX3NldChjb25uZWN0aW9uLCBlbCwgMCwgZG9Ob3RSZXBhaW50KTtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yTWFuYWdlci5zb3VyY2VDaGFuZ2VkKHAub3JpZ2luYWxTb3VyY2VJZCwgcC5uZXdTb3VyY2VJZCwgY29ubmVjdGlvbiwgcC5lbCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0ID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIGVsLCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gX3NldChjb25uZWN0aW9uLCBlbCwgMSwgZG9Ob3RSZXBhaW50KTtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yTWFuYWdlci51cGRhdGVPdGhlckVuZHBvaW50KHAub3JpZ2luYWxTb3VyY2VJZCwgcC5vcmlnaW5hbFRhcmdldElkLCBwLm5ld1RhcmdldElkLCBjb25uZWN0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRlbGV0ZUVuZHBvaW50ID0gZnVuY3Rpb24gKG9iamVjdCwgZG9udFVwZGF0ZUhvdmVyLCBkZWxldGVBdHRhY2hlZE9iamVjdHMpIHtcbiAgICAgICAgICAgIHZhciBlbmRwb2ludCA9ICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiKSA/IGVuZHBvaW50c0J5VVVJRFtvYmplY3RdIDogb2JqZWN0O1xuICAgICAgICAgICAgaWYgKGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5kZWxldGVPYmplY3QoeyBlbmRwb2ludDogZW5kcG9pbnQsIGRvbnRVcGRhdGVIb3ZlcjogZG9udFVwZGF0ZUhvdmVyLCBkZWxldGVBdHRhY2hlZE9iamVjdHM6ZGVsZXRlQXR0YWNoZWRPYmplY3RzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kZWxldGVFdmVyeUVuZHBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9pcyA9IF9jdXJyZW50SW5zdGFuY2Uuc2V0U3VzcGVuZERyYXdpbmcodHJ1ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBlbmRwb2ludHNCeUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kcG9pbnRzID0gZW5kcG9pbnRzQnlFbGVtZW50W2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBlbmRwb2ludHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlbGV0ZUVuZHBvaW50KGVuZHBvaW50c1tpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRwb2ludHNCeUVsZW1lbnQgPSB7fTtcbiAgICAgICAgICAgIC8vIFNQIG5ld1xuICAgICAgICAgICAgbWFuYWdlZEVsZW1lbnRzID0ge307XG4gICAgICAgICAgICBlbmRwb2ludHNCeVVVSUQgPSB7fTtcbiAgICAgICAgICAgIG9mZnNldHMgPSB7fTtcbiAgICAgICAgICAgIG9mZnNldFRpbWVzdGFtcHMgPSB7fTtcbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5yZXNldCgpO1xuICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5nZXREcmFnTWFuYWdlcigpLnJlc2V0KCk7XG4gICAgICAgICAgICBpZiAoIV9pcykgX2N1cnJlbnRJbnN0YW5jZS5zZXRTdXNwZW5kRHJhd2luZyhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZmlyZURldGFjaEV2ZW50ID0gZnVuY3Rpb24gKGpwYywgZG9GaXJlRXZlbnQsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIG1heSBoYXZlIGJlZW4gZ2l2ZW4gYSBjb25uZWN0aW9uLCBvciBpbiBzcGVjaWFsIGNhc2VzLCBhbiBvYmplY3RcbiAgICAgICAgICAgIHZhciBjb25uVHlwZSA9IF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuQ29ubmVjdGlvblR5cGUgfHwgX2N1cnJlbnRJbnN0YW5jZS5nZXREZWZhdWx0Q29ubmVjdGlvblR5cGUoKSxcbiAgICAgICAgICAgICAgICBhcmdJc0Nvbm5lY3Rpb24gPSBqcGMuY29uc3RydWN0b3IgPT0gY29ublR5cGUsXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gYXJnSXNDb25uZWN0aW9uID8ge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBqcGMsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZToganBjLnNvdXJjZSwgdGFyZ2V0OiBqcGMudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZDoganBjLnNvdXJjZUlkLCB0YXJnZXRJZDoganBjLnRhcmdldElkLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VFbmRwb2ludDoganBjLmVuZHBvaW50c1swXSwgdGFyZ2V0RW5kcG9pbnQ6IGpwYy5lbmRwb2ludHNbMV1cbiAgICAgICAgICAgICAgICB9IDoganBjO1xuXG4gICAgICAgICAgICBpZiAoZG9GaXJlRXZlbnQpXG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5maXJlKFwiY29ubmVjdGlvbkRldGFjaGVkXCIsIHBhcmFtcywgb3JpZ2luYWxFdmVudCk7XG5cbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5jb25uZWN0aW9uRGV0YWNoZWQocGFyYW1zKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZmlyZU1vdmVFdmVudCA9IF9jdXJyZW50SW5zdGFuY2UuZmlyZU1vdmVFdmVudCA9IGZ1bmN0aW9uIChwYXJhbXMsIGV2dCkge1xuICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5maXJlKFwiY29ubmVjdGlvbk1vdmVkXCIsIHBhcmFtcywgZXZ0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVucmVnaXN0ZXJFbmRwb2ludCA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgLy9pZiAoZW5kcG9pbnQuX2pzUGx1bWIgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGVuZHBvaW50Ll9qc1BsdW1iLnV1aWQpIGVuZHBvaW50c0J5VVVJRFtlbmRwb2ludC5fanNQbHVtYi51dWlkXSA9IG51bGw7XG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmFuY2hvck1hbmFnZXIuZGVsZXRlRW5kcG9pbnQoZW5kcG9pbnQpO1xuICAgICAgICAgICAgLy8gVE9ETyBhdCBsZWFzdCByZXBsYWNlIHRoaXMgd2l0aCBhIHJlbW92ZVdpdGhGdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgZm9yICh2YXIgZSBpbiBlbmRwb2ludHNCeUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kcG9pbnRzID0gZW5kcG9pbnRzQnlFbGVtZW50W2VdO1xuICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0VuZHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGVuZHBvaW50cy5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnRzW2ldICE9IGVuZHBvaW50KSBuZXdFbmRwb2ludHMucHVzaChlbmRwb2ludHNbaV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50c0J5RWxlbWVudFtlXSA9IG5ld0VuZHBvaW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50c0J5RWxlbWVudFtlXS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbmRwb2ludHNCeUVsZW1lbnRbZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGNvbm5UeXBlID0gX2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5Db25uZWN0aW9uVHlwZSB8fCBfY3VycmVudEluc3RhbmNlLmdldERlZmF1bHRDb25uZWN0aW9uVHlwZSgpLFxuICAgICAgICAgICAgICAgIGZpcnN0QXJnSXNDb25uZWN0aW9uID0gYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yID09IGNvbm5UeXBlLFxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPT0gMiA/IGZpcnN0QXJnSXNDb25uZWN0aW9uID8gKGFyZ3VtZW50c1sxXSB8fCB7fSkgOiBhcmd1bWVudHNbMF0gOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50ID0gKHBhcmFtcy5maXJlRXZlbnQgIT09IGZhbHNlKSxcbiAgICAgICAgICAgICAgICBmb3JjZURldGFjaCA9IHBhcmFtcy5mb3JjZURldGFjaCxcbiAgICAgICAgICAgICAgICBjb25uID0gZmlyc3RBcmdJc0Nvbm5lY3Rpb24gPyBhcmd1bWVudHNbMF0gOiBwYXJhbXMuY29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBkZWxldGVBdHRhY2hlZE9iamVjdHMgPSBmaXJzdEFyZ0lzQ29ubmVjdGlvbiA/IG51bGwgOiBwYXJhbXMuZGVsZXRlQXR0YWNoZWRPYmplY3RzO1xuXG4gICAgICAgICAgICBpZiAoY29ubikge1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZURldGFjaCB8fCBfanUuZnVuY3Rpb25DaGFpbih0cnVlLCBmYWxzZSwgW1xuICAgICAgICAgICAgICAgICAgICBbIGNvbm4uZW5kcG9pbnRzWzBdLCBcImlzRGV0YWNoQWxsb3dlZFwiLCBbIGNvbm4gXSBdLFxuICAgICAgICAgICAgICAgICAgICBbIGNvbm4uZW5kcG9pbnRzWzFdLCBcImlzRGV0YWNoQWxsb3dlZFwiLCBbIGNvbm4gXSBdLFxuICAgICAgICAgICAgICAgICAgICBbIGNvbm4sIFwiaXNEZXRhY2hBbGxvd2VkXCIsIFsgY29ubiBdIF0sXG4gICAgICAgICAgICAgICAgICAgIFsgX2N1cnJlbnRJbnN0YW5jZSwgXCJjaGVja0NvbmRpdGlvblwiLCBbIFwiYmVmb3JlRGV0YWNoXCIsIGNvbm4gXSBdXG4gICAgICAgICAgICAgICAgXSkpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25uLmVuZHBvaW50c1swXS5kZXRhY2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbjpjb25uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlVGFyZ2V0OmZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VEZXRhY2g6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudDpmaXJlRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVBdHRhY2hlZE9iamVjdHM6ZGVsZXRlQXR0YWNoZWRPYmplY3RzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfcCA9IGpzUGx1bWIuZXh0ZW5kKHt9LCBwYXJhbXMpOyAvLyBhIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGhhY2s6IHNvdXJjZSBzaG91bGQgYmUgdGhvdWdodCBvZiBhcyAncGFyYW1zJyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgICAgLy8gdGVzdCBmb3IgZW5kcG9pbnQgdXVpZHMgdG8gZGV0YWNoXG4gICAgICAgICAgICAgICAgaWYgKF9wLnV1aWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIF9nZXRFbmRwb2ludChfcC51dWlkc1swXSkuZGV0YWNoRnJvbShfZ2V0RW5kcG9pbnQoX3AudXVpZHNbMV0pLCBmaXJlRXZlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX3Auc291cmNlRW5kcG9pbnQgJiYgX3AudGFyZ2V0RW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3Auc291cmNlRW5kcG9pbnQuZGV0YWNoRnJvbShfcC50YXJnZXRFbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gX2dldElkKF9jdXJyZW50SW5zdGFuY2UuZ2V0RWxlbWVudChfcC5zb3VyY2UpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldElkID0gX2dldElkKF9jdXJyZW50SW5zdGFuY2UuZ2V0RWxlbWVudChfcC50YXJnZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgX29wZXJhdGlvbihzb3VyY2VJZCwgZnVuY3Rpb24gKGpwYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChqcGMuc291cmNlSWQgPT0gc291cmNlSWQgJiYganBjLnRhcmdldElkID09IHRhcmdldElkKSB8fCAoanBjLnRhcmdldElkID09IHNvdXJjZUlkICYmIGpwYy5zb3VyY2VJZCA9PSB0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2N1cnJlbnRJbnN0YW5jZS5jaGVja0NvbmRpdGlvbihcImJlZm9yZURldGFjaFwiLCBqcGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5lbmRwb2ludHNbMF0uZGV0YWNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246anBjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlVGFyZ2V0OmZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VEZXRhY2g6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudDpmaXJlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kZXRhY2hBbGxDb25uZWN0aW9ucyA9IGZ1bmN0aW9uIChlbCwgcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgICAgICBlbCA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0RWxlbWVudChlbCk7XG4gICAgICAgICAgICB2YXIgaWQgPSBfZ2V0SWQoZWwpLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50cyA9IGVuZHBvaW50c0J5RWxlbWVudFtpZF07XG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGVuZHBvaW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRzW2ldLmRldGFjaEFsbChwYXJhbXMuZmlyZUV2ZW50ICE9PSBmYWxzZSwgcGFyYW1zLmZvcmNlRGV0YWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRldGFjaEV2ZXJ5Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkIGluIGVuZHBvaW50c0J5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kcG9pbnRzID0gZW5kcG9pbnRzQnlFbGVtZW50W2lkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50cyAmJiBlbmRwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGVuZHBvaW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludHNbaV0uZGV0YWNoQWxsKHBhcmFtcy5maXJlRXZlbnQgIT09IGZhbHNlLCBwYXJhbXMuZm9yY2VEZXRhY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vLyBub3QgcHVibGljLiAgYnV0IG9mIGNvdXJzZSBpdHMgZXhwb3NlZC4gaG93IHRvIGNoYW5nZSB0aGlzLlxuICAgICAgICB0aGlzLmRlbGV0ZU9iamVjdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50czoge30sXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRDb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvdW50OiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQgPSBwYXJhbXMuZmlyZUV2ZW50ICE9PSBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZWxldGVBdHRhY2hlZE9iamVjdHMgPSBwYXJhbXMuZGVsZXRlQXR0YWNoZWRPYmplY3RzICE9PSBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIHVucmF2ZWxDb25uZWN0aW9uID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAhPSBudWxsICYmIHJlc3VsdC5jb25uZWN0aW9uc1tjb25uZWN0aW9uLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW1zLmRvbnRVcGRhdGVIb3ZlciAmJiBjb25uZWN0aW9uLl9qc1BsdW1iICE9IG51bGwpIGNvbm5lY3Rpb24uc2V0SG92ZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29ubmVjdGlvbnNbY29ubmVjdGlvbi5pZF0gPSBjb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29ubmVjdGlvbkNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVBdHRhY2hlZE9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29ubmVjdGlvbi5lbmRwb2ludHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5lbmRwb2ludHNbal0uX2RlbGV0ZU9uRGV0YWNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnJhdmVsRW5kcG9pbnQoY29ubmVjdGlvbi5lbmRwb2ludHNbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB1bnJhdmVsRW5kcG9pbnQgPSBmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnQgIT0gbnVsbCAmJiByZXN1bHQuZW5kcG9pbnRzW2VuZHBvaW50LmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW1zLmRvbnRVcGRhdGVIb3ZlciAmJiBlbmRwb2ludC5fanNQbHVtYiAhPSBudWxsKSBlbmRwb2ludC5zZXRIb3ZlcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbmRwb2ludHNbZW5kcG9pbnQuaWRdID0gZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbmRwb2ludENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUF0dGFjaGVkT2JqZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmRwb2ludC5jb25uZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gZW5kcG9pbnQuY29ubmVjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5yYXZlbENvbm5lY3Rpb24oYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmNvbm5lY3Rpb24pXG4gICAgICAgICAgICAgICAgdW5yYXZlbENvbm5lY3Rpb24ocGFyYW1zLmNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgZWxzZSB1bnJhdmVsRW5kcG9pbnQocGFyYW1zLmVuZHBvaW50KTtcblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHJlc3VsdC5jb25uZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gcmVzdWx0LmNvbm5lY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjLl9qc1BsdW1iKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24oY29ubmVjdGlvbnMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuaWQgPT0gX2MuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZpcmVEZXRhY2hFdmVudChjLCBwYXJhbXMuZmlyZUV2ZW50ID09PSBmYWxzZSA/IGZhbHNlIDogIWMucGVuZGluZywgcGFyYW1zLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9Ob3RDbGVhbnVwID0gcGFyYW1zLmRlbGV0ZUF0dGFjaGVkT2JqZWN0cyA9PSBudWxsID8gbnVsbCA6ICFwYXJhbXMuZGVsZXRlQXR0YWNoZWRPYmplY3RzO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNQIEdST1VQUy4gdGhpcyB3b3JrcyBidXQgYmxvd3MgdXAgbG90cyBvZiBvcmlnaW5hbCB0ZXN0c1xuICAgICAgICAgICAgICAgICAgICBjLmVuZHBvaW50c1swXS5kZXRhY2hGcm9tQ29ubmVjdGlvbihjLCBudWxsLCBkb05vdENsZWFudXApO1xuICAgICAgICAgICAgICAgICAgICBjLmVuZHBvaW50c1sxXS5kZXRhY2hGcm9tQ29ubmVjdGlvbihjLCBudWxsLCBkb05vdENsZWFudXApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNQIEdST1VQUy4gdGhpcyBkb2VzIG5vdCB3b3JrIGJ1dCBtYWtlcyBhbGwgdGhlIG9yaWdpbmFsIHRlc3RzIHdvcmsuXG4gICAgICAgICAgICAgICAgICAgIC8vYy5lbmRwb2ludHNbMF0uZGV0YWNoRnJvbUNvbm5lY3Rpb24oYyk7XG4gICAgICAgICAgICAgICAgICAgIC8vYy5lbmRwb2ludHNbMV0uZGV0YWNoRnJvbUNvbm5lY3Rpb24oYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgYy5jbGVhbnVwKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggZW5kcG9pbnRzXG4gICAgICAgICAgICBmb3IgKHZhciBqIGluIHJlc3VsdC5lbmRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHJlc3VsdC5lbmRwb2ludHNbal07XG4gICAgICAgICAgICAgICAgaWYgKGUuX2pzUGx1bWIpIHtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS51bnJlZ2lzdGVyRW5kcG9pbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJUkUgc29tZSBlbmRwb2ludCBkZWxldGVkIGV2ZW50P1xuICAgICAgICAgICAgICAgICAgICBlLmNsZWFudXAodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGUuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBpbmZvO1xuICAgICAgICAgICAgX2VhY2goZnVuY3Rpb24oX2VsKSB7XG4gICAgICAgICAgICAgICAgIGluZm8gPSBfaW5mbyhfZWwpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLmVsKSBfaW5pdERyYWdnYWJsZUlmTmVjZXNzYXJ5KGluZm8uZWwsIHRydWUsIG9wdGlvbnMsIGluZm8uaWQsIHRydWUpO1xuICAgICAgICAgICAgfSwgZWwpO1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kcm9wcGFibGUgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGluZm87XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMuYWxsb3dMb29wYmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgX2VhY2goZnVuY3Rpb24oX2VsKSB7XG4gICAgICAgICAgICAgICAgaW5mbyA9IF9pbmZvKF9lbCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uZWwpIF9jdXJyZW50SW5zdGFuY2UuaW5pdERyb3BwYWJsZShpbmZvLmVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sIGVsKTtcbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGhlbHBlcnMgZm9yIHNlbGVjdC9zZWxlY3RFbmRwb2ludHNcbiAgICAgICAgdmFyIF9zZXRPcGVyYXRpb24gPSBmdW5jdGlvbiAobGlzdCwgZnVuYywgYXJncywgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGxpc3QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RbaV1bZnVuY10uYXBwbHkobGlzdFtpXSwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcihsaXN0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0T3BlcmF0aW9uID0gZnVuY3Rpb24gKGxpc3QsIGZ1bmMsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBsaXN0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChbIGxpc3RbaV1bZnVuY10uYXBwbHkobGlzdFtpXSwgYXJncyksIGxpc3RbaV0gXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0dGVyID0gZnVuY3Rpb24gKGxpc3QsIGZ1bmMsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZXRPcGVyYXRpb24obGlzdCwgZnVuYywgYXJndW1lbnRzLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAobGlzdCwgZnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0T3BlcmF0aW9uKGxpc3QsIGZ1bmMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVwYXJlTGlzdCA9IGZ1bmN0aW9uIChpbnB1dCwgZG9Ob3RHZXRJZHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IFwiKlwiKSByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvTm90R2V0SWRzKSByID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gaW5wdXQubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5wdXNoKF9pbmZvKGlucHV0W2ldKS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5wdXNoKF9pbmZvKGlucHV0KS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsdGVyTGlzdCA9IGZ1bmN0aW9uIChsaXN0LCB2YWx1ZSwgbWlzc2luZ0lzRmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdCA9PT0gXCIqXCIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0Lmxlbmd0aCA+IDAgPyBsaXN0LmluZGV4T2YodmFsdWUpICE9IC0xIDogIW1pc3NpbmdJc0ZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgc29tZSBjb25uZWN0aW9ucywgc3BlY2lmeWluZyBzb3VyY2UvdGFyZ2V0L3Njb3BlXG4gICAgICAgIHRoaXMuZ2V0Q29ubmVjdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucywgZmxhdCkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmNvbnN0cnVjdG9yID09IFN0cmluZykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IFwic2NvcGVcIjogb3B0aW9ucyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjb3BlID0gb3B0aW9ucy5zY29wZSB8fCBfY3VycmVudEluc3RhbmNlLmdldERlZmF1bHRTY29wZSgpLFxuICAgICAgICAgICAgICAgIHNjb3BlcyA9IHByZXBhcmVMaXN0KHNjb3BlLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VzID0gcHJlcGFyZUxpc3Qob3B0aW9ucy5zb3VyY2UpLFxuICAgICAgICAgICAgICAgIHRhcmdldHMgPSBwcmVwYXJlTGlzdChvcHRpb25zLnRhcmdldCksXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9ICghZmxhdCAmJiBzY29wZXMubGVuZ3RoID4gMSkgPyB7fSA6IFtdLFxuICAgICAgICAgICAgICAgIF9hZGRPbmUgPSBmdW5jdGlvbiAoc2NvcGUsIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZsYXQgJiYgc2NvcGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcyA9IHJlc3VsdHNbc2NvcGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcyA9IHJlc3VsdHNbc2NvcGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzcy5wdXNoKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSByZXN1bHRzLnB1c2gob2JqKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBjb25uZWN0aW9ucy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBjb25uZWN0aW9uc1tqXSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlSWQgPSBjLnByb3hpZXMgJiYgYy5wcm94aWVzWzBdID8gYy5wcm94aWVzWzBdLm9yaWdpbmFsRXAuZWxlbWVudElkIDogYy5zb3VyY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSBjLnByb3hpZXMgJiYgYy5wcm94aWVzWzFdID8gYy5wcm94aWVzWzFdLm9yaWdpbmFsRXAuZWxlbWVudElkIDogYy50YXJnZXRJZDtcblxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJMaXN0KHNjb3BlcywgYy5zY29wZSkgJiYgZmlsdGVyTGlzdChzb3VyY2VzLCBzb3VyY2VJZCkgJiYgZmlsdGVyTGlzdCh0YXJnZXRzLCB0YXJnZXRJZCkpXG4gICAgICAgICAgICAgICAgICAgIF9hZGRPbmUoYy5zY29wZSwgYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfY3VycnlFYWNoID0gZnVuY3Rpb24gKGxpc3QsIGV4ZWN1dG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpc3QubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZihsaXN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0b3IobGlzdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY3VycnlHZXQgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2lkeF07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9tYWtlQ29tbW9uU2VsZWN0SGFuZGxlciA9IGZ1bmN0aW9uIChsaXN0LCBleGVjdXRvcikge1xuICAgICAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBsaXN0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgZWFjaDogX2N1cnJ5RWFjaChsaXN0LCBleGVjdXRvciksXG4gICAgICAgICAgICAgICAgICAgIGdldDogX2N1cnJ5R2V0KGxpc3QpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXR0ZXJzID0gW1wic2V0SG92ZXJcIiwgXCJyZW1vdmVBbGxPdmVybGF5c1wiLCBcInNldExhYmVsXCIsIFwiYWRkQ2xhc3NcIiwgXCJhZGRPdmVybGF5XCIsIFwicmVtb3ZlT3ZlcmxheVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlbW92ZU92ZXJsYXlzXCIsIFwic2hvd092ZXJsYXlcIiwgXCJoaWRlT3ZlcmxheVwiLCBcInNob3dPdmVybGF5c1wiLCBcImhpZGVPdmVybGF5c1wiLCBcInNldFBhaW50U3R5bGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzZXRIb3ZlclBhaW50U3R5bGVcIiwgXCJzZXRTdXNwZW5kRXZlbnRzXCIsIFwic2V0UGFyYW1ldGVyXCIsIFwic2V0UGFyYW1ldGVyc1wiLCBcInNldFZpc2libGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyZXBhaW50XCIsIFwiYWRkVHlwZVwiLCBcInRvZ2dsZVR5cGVcIiwgXCJyZW1vdmVUeXBlXCIsIFwicmVtb3ZlQ2xhc3NcIiwgXCJzZXRUeXBlXCIsIFwiYmluZFwiLCBcInVuYmluZFwiIF0sXG5cbiAgICAgICAgICAgICAgICBnZXR0ZXJzID0gW1wiZ2V0TGFiZWxcIiwgXCJnZXRPdmVybGF5XCIsIFwiaXNIb3ZlclwiLCBcImdldFBhcmFtZXRlclwiLCBcImdldFBhcmFtZXRlcnNcIiwgXCJnZXRQYWludFN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2V0SG92ZXJQYWludFN0eWxlXCIsIFwiaXNWaXNpYmxlXCIsIFwiaGFzVHlwZVwiLCBcImdldFR5cGVcIiwgXCJpc1N1c3BlbmRFdmVudHNcIiBdLFxuICAgICAgICAgICAgICAgIGksIGlpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IHNldHRlcnMubGVuZ3RoOyBpIDwgaWk7IGkrKylcbiAgICAgICAgICAgICAgICBvdXRbc2V0dGVyc1tpXV0gPSBzZXR0ZXIobGlzdCwgc2V0dGVyc1tpXSwgZXhlY3V0b3IpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGdldHRlcnMubGVuZ3RoOyBpIDwgaWk7IGkrKylcbiAgICAgICAgICAgICAgICBvdXRbZ2V0dGVyc1tpXV0gPSBnZXR0ZXIobGlzdCwgZ2V0dGVyc1tpXSk7XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9tYWtlQ29ubmVjdGlvblNlbGVjdEhhbmRsZXIgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgdmFyIGNvbW1vbiA9IF9tYWtlQ29tbW9uU2VsZWN0SGFuZGxlcihsaXN0LCBfbWFrZUNvbm5lY3Rpb25TZWxlY3RIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiBqc1BsdW1iLmV4dGVuZChjb21tb24sIHtcbiAgICAgICAgICAgICAgICAvLyBzZXR0ZXJzXG4gICAgICAgICAgICAgICAgc2V0RGV0YWNoYWJsZTogc2V0dGVyKGxpc3QsIFwic2V0RGV0YWNoYWJsZVwiLCBfbWFrZUNvbm5lY3Rpb25TZWxlY3RIYW5kbGVyKSxcbiAgICAgICAgICAgICAgICBzZXRSZWF0dGFjaDogc2V0dGVyKGxpc3QsIFwic2V0UmVhdHRhY2hcIiwgX21ha2VDb25uZWN0aW9uU2VsZWN0SGFuZGxlciksXG4gICAgICAgICAgICAgICAgc2V0Q29ubmVjdG9yOiBzZXR0ZXIobGlzdCwgXCJzZXRDb25uZWN0b3JcIiwgX21ha2VDb25uZWN0aW9uU2VsZWN0SGFuZGxlciksXG4gICAgICAgICAgICAgICAgZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpc3QubGVuZ3RoOyBpIDwgaWk7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZGV0YWNoKGxpc3RbaV0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gZ2V0dGVyc1xuICAgICAgICAgICAgICAgIGlzRGV0YWNoYWJsZTogZ2V0dGVyKGxpc3QsIFwiaXNEZXRhY2hhYmxlXCIpLFxuICAgICAgICAgICAgICAgIGlzUmVhdHRhY2g6IGdldHRlcihsaXN0LCBcImlzUmVhdHRhY2hcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfbWFrZUVuZHBvaW50U2VsZWN0SGFuZGxlciA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICB2YXIgY29tbW9uID0gX21ha2VDb21tb25TZWxlY3RIYW5kbGVyKGxpc3QsIF9tYWtlRW5kcG9pbnRTZWxlY3RIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiBqc1BsdW1iLmV4dGVuZChjb21tb24sIHtcbiAgICAgICAgICAgICAgICBzZXRFbmFibGVkOiBzZXR0ZXIobGlzdCwgXCJzZXRFbmFibGVkXCIsIF9tYWtlRW5kcG9pbnRTZWxlY3RIYW5kbGVyKSxcbiAgICAgICAgICAgICAgICBzZXRBbmNob3I6IHNldHRlcihsaXN0LCBcInNldEFuY2hvclwiLCBfbWFrZUVuZHBvaW50U2VsZWN0SGFuZGxlciksXG4gICAgICAgICAgICAgICAgaXNFbmFibGVkOiBnZXR0ZXIobGlzdCwgXCJpc0VuYWJsZWRcIiksXG4gICAgICAgICAgICAgICAgZGV0YWNoQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpc3QubGVuZ3RoOyBpIDwgaWk7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RbaV0uZGV0YWNoQWxsKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInJlbW92ZVwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpc3QubGVuZ3RoOyBpIDwgaWk7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZGVsZXRlT2JqZWN0KHtlbmRwb2ludDogbGlzdFtpXX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgcGFyYW1zLnNjb3BlID0gcGFyYW1zLnNjb3BlIHx8IFwiKlwiO1xuICAgICAgICAgICAgcmV0dXJuIF9tYWtlQ29ubmVjdGlvblNlbGVjdEhhbmRsZXIocGFyYW1zLmNvbm5lY3Rpb25zIHx8IF9jdXJyZW50SW5zdGFuY2UuZ2V0Q29ubmVjdGlvbnMocGFyYW1zLCB0cnVlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZWxlY3RFbmRwb2ludHMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgICAgICBwYXJhbXMuc2NvcGUgPSBwYXJhbXMuc2NvcGUgfHwgXCIqXCI7XG4gICAgICAgICAgICB2YXIgbm9FbGVtZW50RmlsdGVycyA9ICFwYXJhbXMuZWxlbWVudCAmJiAhcGFyYW1zLnNvdXJjZSAmJiAhcGFyYW1zLnRhcmdldCxcbiAgICAgICAgICAgICAgICBlbGVtZW50cyA9IG5vRWxlbWVudEZpbHRlcnMgPyBcIipcIiA6IHByZXBhcmVMaXN0KHBhcmFtcy5lbGVtZW50KSxcbiAgICAgICAgICAgICAgICBzb3VyY2VzID0gbm9FbGVtZW50RmlsdGVycyA/IFwiKlwiIDogcHJlcGFyZUxpc3QocGFyYW1zLnNvdXJjZSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0cyA9IG5vRWxlbWVudEZpbHRlcnMgPyBcIipcIiA6IHByZXBhcmVMaXN0KHBhcmFtcy50YXJnZXQpLFxuICAgICAgICAgICAgICAgIHNjb3BlcyA9IHByZXBhcmVMaXN0KHBhcmFtcy5zY29wZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBlcCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBlbCBpbiBlbmRwb2ludHNCeUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWl0aGVyID0gZmlsdGVyTGlzdChlbGVtZW50cywgZWwsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBmaWx0ZXJMaXN0KHNvdXJjZXMsIGVsLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTWF0Y2hFeGFjdCA9IHNvdXJjZXMgIT0gXCIqXCIsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGZpbHRlckxpc3QodGFyZ2V0cywgZWwsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaEV4YWN0ID0gdGFyZ2V0cyAhPSBcIipcIjtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXkgcmVxdWVzdGVkICdlaXRoZXInIHRoZW4ganVzdCBtYXRjaCBzY29wZS4gb3RoZXJ3aXNlIGlmIHRoZXkgcmVxdWVzdGVkICdzb3VyY2UnIChub3QgYXMgYSB3aWxkY2FyZCkgdGhlbiB3ZSBoYXZlIHRvIG1hdGNoIG9ubHkgZW5kcG9pbnRzIHRoYXQgaGF2ZSBpc1NvdXJjZSBzZXQgdG8gdG8gdHJ1ZSwgYW5kIHRoZSBzYW1lIHRoaW5nIHdpdGggaXNUYXJnZXQuXG4gICAgICAgICAgICAgICAgaWYgKGVpdGhlciB8fCBzb3VyY2UgfHwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcG9pbnRzQnlFbGVtZW50W2VsXS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9lcCA9IGVuZHBvaW50c0J5RWxlbWVudFtlbF1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckxpc3Qoc2NvcGVzLCBfZXAuc2NvcGUsIHRydWUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vTWF0Y2hTb3VyY2UgPSAoc291cmNlTWF0Y2hFeGFjdCAmJiBzb3VyY2VzLmxlbmd0aCA+IDAgJiYgIV9lcC5pc1NvdXJjZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub01hdGNoVGFyZ2V0ID0gKHRhcmdldE1hdGNoRXhhY3QgJiYgdGFyZ2V0cy5sZW5ndGggPiAwICYmICFfZXAuaXNUYXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub01hdGNoU291cmNlIHx8IG5vTWF0Y2hUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBpbm5lcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcC5wdXNoKF9lcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9tYWtlRW5kcG9pbnRTZWxlY3RIYW5kbGVyKGVwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgYWxsIGNvbm5lY3Rpb25zIG1hbmFnZWQgYnkgdGhlIGluc3RhbmNlIG9mIGpzcGx1bWIuXG4gICAgICAgIHRoaXMuZ2V0QWxsQ29ubmVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbnM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RGVmYXVsdFNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfU0NPUEU7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGdldCBhbiBlbmRwb2ludCBieSB1dWlkLlxuICAgICAgICB0aGlzLmdldEVuZHBvaW50ID0gX2dldEVuZHBvaW50O1xuICAgICAgICAvLyBnZXQgZW5kcG9pbnRzIGZvciBzb21lIGVsZW1lbnQuXG4gICAgICAgIHRoaXMuZ2V0RW5kcG9pbnRzID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kcG9pbnRzQnlFbGVtZW50W19pbmZvKGVsKS5pZF07XG4gICAgICAgIH07XG4gICAgICAgIC8vIGdldHMgdGhlIGRlZmF1bHQgZW5kcG9pbnQgdHlwZS4gdXNlZCB3aGVuIHN1YmNsYXNzaW5nLiBzZWUgd2lraS5cbiAgICAgICAgdGhpcy5nZXREZWZhdWx0RW5kcG9pbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzUGx1bWIuRW5kcG9pbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGdldHMgdGhlIGRlZmF1bHQgY29ubmVjdGlvbiB0eXBlLiB1c2VkIHdoZW4gc3ViY2xhc3NpbmcuICBzZWUgd2lraS5cbiAgICAgICAgdGhpcy5nZXREZWZhdWx0Q29ubmVjdGlvblR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ganNQbHVtYi5Db25uZWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKlxuICAgICAgICAgKiBHZXRzIGFuIGVsZW1lbnQncyBpZCwgY3JlYXRpbmcgb25lIGlmIG5lY2Vzc2FyeS4gcmVhbGx5IG9ubHkgZXhwb3NlZFxuICAgICAgICAgKiBmb3IgdGhlIGxpYi1zcGVjaWZpYyBmdW5jdGlvbmFsaXR5IHRvIGFjY2Vzczsgd291bGQgYmUgYmV0dGVyIHRvIHBhc3NcbiAgICAgICAgICogdGhlIGN1cnJlbnQgaW5zdGFuY2UgaW50byB0aGUgbGliLXNwZWNpZmljIGNvZGUgKGV2ZW4gdGhvdWdoIHRoaXMgaXNcbiAgICAgICAgICogYSBzdGF0aWMgY2FsbC4gaSBqdXN0IGRvbid0IHdhbnQgdG8gZXhwb3NlIGl0IHRvIHRoZSBwdWJsaWMgQVBJKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0SWQgPSBfZ2V0SWQ7XG5cbiAgICAgICAgdGhpcy5hcHBlbmRFbGVtZW50ID0gX2FwcGVuZEVsZW1lbnQ7XG5cbiAgICAgICAgdmFyIF9ob3ZlclN1c3BlbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSG92ZXJTdXNwZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2hvdmVyU3VzcGVuZGVkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldEhvdmVyU3VzcGVuZGVkID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIF9ob3ZlclN1c3BlbmRlZCA9IHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0IGFuIGVsZW1lbnQncyBjb25uZWN0aW9ucyB0byBiZSBoaWRkZW5cbiAgICAgICAgdGhpcy5oaWRlID0gZnVuY3Rpb24gKGVsLCBjaGFuZ2VFbmRwb2ludHMpIHtcbiAgICAgICAgICAgIF9zZXRWaXNpYmxlKGVsLCBcIm5vbmVcIiwgY2hhbmdlRW5kcG9pbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGV4cG9zZWQgZm9yIG90aGVyIG9iamVjdHMgdG8gdXNlIHRvIGdldCBhIHVuaXF1ZSBpZC5cbiAgICAgICAgdGhpcy5pZHN0YW1wID0gX2lkc3RhbXA7XG5cbiAgICAgICAgdGhpcy5jb25uZWN0b3JzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckNvbm5lY3RvclR5cGUgPSBmdW5jdGlvbiAoY29ubmVjdG9yLCBuYW1lKSB7XG4gICAgICAgICAgICBjb25uZWN0b3JUeXBlcy5wdXNoKFtjb25uZWN0b3IsIG5hbWVdKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBlbnN1cmUgdGhhdCwgaWYgdGhlIGN1cnJlbnQgY29udGFpbmVyIGV4aXN0cywgaXQgaXMgYSBET00gZWxlbWVudCBhbmQgbm90IGEgc2VsZWN0b3IuXG4gICAgICAgIC8vIGlmIGl0IGRvZXMgbm90IGV4aXN0IGFuZCBgY2FuZGlkYXRlYCBpcyBzdXBwbGllZCwgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhhdCBlbGVtZW50IHdpbGwgYmUgc2V0IGFzIHRoZSBDb250YWluZXIuXG4gICAgICAgIC8vIHRoaXMgaXMgdXNlZCB0byBkbyBhIGJldHRlciBkZWZhdWx0IGJlaGF2aW91ciBmb3IgdGhlIGNhc2UgdGhhdCB0aGUgdXNlciBoYXMgbm90IHNldCBhIGNvbnRhaW5lcjpcbiAgICAgICAgLy8gYWRkRW5kcG9pbnQsIG1ha2VTb3VyY2UsIG1ha2VUYXJnZXQgYW5kIGNvbm5lY3QgYWxsIGNhbGwgdGhpcyBtZXRob2Qgd2l0aCB0aGUgb2Zmc2V0UGFyZW50IG9mIHRoZVxuICAgICAgICAvLyBlbGVtZW50IGluIHF1ZXN0aW9uIChmb3IgY29ubmVjdCBpdCBpcyB0aGUgc291cmNlIGVsZW1lbnQpLiBTbyBpZiBubyBjb250YWluZXIgaXMgc2V0LCBpdCBpcyBpbmZlcnJlZFxuICAgICAgICAvLyB0byBiZSB0aGUgb2Zmc2V0UGFyZW50IG9mIHRoZSBmaXJzdCBlbGVtZW50IHRoZSB1c2VyIHRyaWVzIHRvIGNvbm5lY3QuXG4gICAgICAgIHZhciBfZW5zdXJlQ29udGFpbmVyID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgaWYgKCFfY29udGFpbmVyICYmIGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjYW4gPSBfY3VycmVudEluc3RhbmNlLmdldEVsZW1lbnQoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuLm9mZnNldFBhcmVudCkgX2N1cnJlbnRJbnN0YW5jZS5zZXRDb250YWluZXIoY2FuLm9mZnNldFBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9nZXRDb250YWluZXJGcm9tRGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5Db250YWluZXIpXG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZXRDb250YWluZXIoX2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5Db250YWluZXIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyBtYW5hZ2VkIG9yIG5vdC4gaWYgbm90LCBhZGQgdG8gb3VyIG1hcC4gaWYgZHJhd2luZyBpcyBub3Qgc3VzcGVuZGVkIHRoZW5cbiAgICAgICAgLy8gd2UnbGwgYWxzbyBzdGFzaCBpdHMgZGltZW5zaW9uczsgb3RoZXJ3aXNlIHdlJ2xsIGRvIHRoaXMgaW4gYSBsYXp5IHdheSB0aHJvdWdoIHVwZGF0ZU9mZnNldC5cbiAgICAgICAgdmFyIF9tYW5hZ2UgPSBfY3VycmVudEluc3RhbmNlLm1hbmFnZSA9IGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgX3RyYW5zaWVudCkge1xuICAgICAgICAgICAgaWYgKCFtYW5hZ2VkRWxlbWVudHNbaWRdKSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZEVsZW1lbnRzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50czogW10sXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zOiBbXVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtYW5hZ2VkRWxlbWVudHNbaWRdLmluZm8gPSBfdXBkYXRlT2Zmc2V0KHsgZWxJZDogaWQsIHRpbWVzdGFtcDogX3N1c3BlbmRlZEF0IH0pO1xuICAgICAgICAgICAgICAgIGlmICghX3RyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmZpcmUoXCJtYW5hZ2VFbGVtZW50XCIsIHsgaWQ6aWQsIGluZm86bWFuYWdlZEVsZW1lbnRzW2lkXS5pbmZvLCBlbDplbGVtZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRFbGVtZW50c1tpZF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF91bm1hbmFnZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICBpZiAobWFuYWdlZEVsZW1lbnRzW2lkXSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkRWxlbWVudHNbaWRdO1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZmlyZShcInVubWFuYWdlRWxlbWVudFwiLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVwZGF0ZXMgdGhlIG9mZnNldCBhbmQgc2l6ZSBmb3IgYSBnaXZlbiBlbGVtZW50LCBhbmQgc3RvcmVzIHRoZVxuICAgICAgICAgKiB2YWx1ZXMuIGlmICdvZmZzZXQnIGlzIG5vdCBudWxsIHdlIHVzZSB0aGF0IChpdCB3b3VsZCBoYXZlIGJlZW5cbiAgICAgICAgICogcGFzc2VkIGluIGZyb20gYSBkcmFnIGNhbGwpIGJlY2F1c2UgaXQncyBmYXN0ZXI7IGJ1dCBpZiBpdCBpcyBudWxsLFxuICAgICAgICAgKiBvciBpZiAncmVjYWxjJyBpcyB0cnVlIGluIG9yZGVyIHRvIGZvcmNlIGEgcmVjYWxjdWxhdGlvbiwgd2UgZ2V0IHRoZSBjdXJyZW50IHZhbHVlcy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfdXBkYXRlT2Zmc2V0ID0gdGhpcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG5cbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBwYXJhbXMudGltZXN0YW1wLCByZWNhbGMgPSBwYXJhbXMucmVjYWxjLCBvZmZzZXQgPSBwYXJhbXMub2Zmc2V0LCBlbElkID0gcGFyYW1zLmVsSWQsIHM7XG4gICAgICAgICAgICBpZiAoX3N1c3BlbmREcmF3aW5nICYmICF0aW1lc3RhbXApIHRpbWVzdGFtcCA9IF9zdXNwZW5kZWRBdDtcbiAgICAgICAgICAgIGlmICghcmVjYWxjKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCAmJiB0aW1lc3RhbXAgPT09IG9mZnNldFRpbWVzdGFtcHNbZWxJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtvOiBwYXJhbXMub2Zmc2V0IHx8IG9mZnNldHNbZWxJZF0sIHM6IHNpemVzW2VsSWRdfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjYWxjIHx8ICghb2Zmc2V0ICYmIG9mZnNldHNbZWxJZF0gPT0gbnVsbCkpIHsgLy8gaWYgZm9yY2VkIHJlcGFpbnQgb3Igbm8gb2Zmc2V0IGF2YWlsYWJsZSwgd2UgcmVjYWxjdWxhdGUuXG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgc2l6ZSBhbmQgb2Zmc2V0LCBhbmQgc3RvcmUgdGhlbVxuICAgICAgICAgICAgICAgIHMgPSBtYW5hZ2VkRWxlbWVudHNbZWxJZF0gPyBtYW5hZ2VkRWxlbWVudHNbZWxJZF0uZWwgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZXNbZWxJZF0gPSBfY3VycmVudEluc3RhbmNlLmdldFNpemUocyk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldHNbZWxJZF0gPSBfY3VycmVudEluc3RhbmNlLmdldE9mZnNldChzKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VGltZXN0YW1wc1tlbElkXSA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldHNbZWxJZF0gPSBvZmZzZXQgfHwgb2Zmc2V0c1tlbElkXTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZXNbZWxJZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzID0gbWFuYWdlZEVsZW1lbnRzW2VsSWRdLmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocyAhPSBudWxsKSBzaXplc1tlbElkXSA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0U2l6ZShzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0VGltZXN0YW1wc1tlbElkXSA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldHNbZWxJZF0gJiYgIW9mZnNldHNbZWxJZF0ucmlnaHQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRzW2VsSWRdLnJpZ2h0ID0gb2Zmc2V0c1tlbElkXS5sZWZ0ICsgc2l6ZXNbZWxJZF1bMF07XG4gICAgICAgICAgICAgICAgb2Zmc2V0c1tlbElkXS5ib3R0b20gPSBvZmZzZXRzW2VsSWRdLnRvcCArIHNpemVzW2VsSWRdWzFdO1xuICAgICAgICAgICAgICAgIG9mZnNldHNbZWxJZF0ud2lkdGggPSBzaXplc1tlbElkXVswXTtcbiAgICAgICAgICAgICAgICBvZmZzZXRzW2VsSWRdLmhlaWdodCA9IHNpemVzW2VsSWRdWzFdO1xuICAgICAgICAgICAgICAgIG9mZnNldHNbZWxJZF0uY2VudGVyeCA9IG9mZnNldHNbZWxJZF0ubGVmdCArIChvZmZzZXRzW2VsSWRdLndpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0c1tlbElkXS5jZW50ZXJ5ID0gb2Zmc2V0c1tlbElkXS50b3AgKyAob2Zmc2V0c1tlbElkXS5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtvOiBvZmZzZXRzW2VsSWRdLCBzOiBzaXplc1tlbElkXX07XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhbGxiYWNrIGZyb20gdGhlIGN1cnJlbnQgbGlicmFyeSB0byB0ZWxsIHVzIHRvIHByZXBhcmUgb3Vyc2VsdmVzIChhdHRhY2hcbiAgICAgICAgICogbW91c2UgbGlzdGVuZXJzIGV0YzsgY2FuJ3QgZG8gdGhhdCB1bnRpbCB0aGUgbGlicmFyeSBoYXMgcHJvdmlkZWQgYSBiaW5kIG1ldGhvZClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZXMgPSByb290LmpzUGx1bWIuZ2V0UmVuZGVyTW9kZXMoKTtcblxuICAgICAgICAgICAgdmFyIF9vbmVUeXBlID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBuYW1lLCBmbikge1xuICAgICAgICAgICAgICAgIHJvb3QuanNQbHVtYi5Db25uZWN0b3JzW3JlbmRlcmVyXVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5qc1BsdW1iLkNvbm5lY3RvclJlbmRlcmVyc1tyZW5kZXJlcl0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9qdS5leHRlbmQocm9vdC5qc1BsdW1iLkNvbm5lY3RvcnNbcmVuZGVyZXJdW25hbWVdLCBbIGZuLCByb290LmpzUGx1bWIuQ29ubmVjdG9yUmVuZGVyZXJzW3JlbmRlcmVyXV0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFyb290LmpzUGx1bWIuY29ubmVjdG9yc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uZWN0b3JUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlbmRlcmVyVHlwZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9vbmVUeXBlKHJlbmRlcmVyVHlwZXNbal0sIGNvbm5lY3RvclR5cGVzW2ldWzFdLCBjb25uZWN0b3JUeXBlc1tpXVswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb290LmpzUGx1bWIuY29ubmVjdG9yc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIF9nZXRDb250YWluZXJGcm9tRGVmYXVsdHMoKTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmFuY2hvck1hbmFnZXIgPSBuZXcgcm9vdC5qc1BsdW1iLkFuY2hvck1hbmFnZXIoe2pzUGx1bWJJbnN0YW5jZTogX2N1cnJlbnRJbnN0YW5jZX0pO1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmZpcmUoXCJyZWFkeVwiLCBfY3VycmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMubG9nID0gbG9nO1xuICAgICAgICB0aGlzLmpzUGx1bWJVSUNvbXBvbmVudCA9IGpzUGx1bWJVSUNvbXBvbmVudDtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGFuY2hvciB3aXRoIHRoZSBnaXZlbiBwYXJhbXMuXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnM6IFRoZSBuZXdseSBjcmVhdGVkIEFuY2hvci5cbiAgICAgICAgICogVGhyb3dzOiBhbiBlcnJvciBpZiBhIG5hbWVkIGFuY2hvciB3YXMgbm90IGZvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYWtlQW5jaG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBwLCBfYSA9IGZ1bmN0aW9uICh0LCBwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QuanNQbHVtYi5BbmNob3JzW3RdKSByZXR1cm4gbmV3IHJvb3QuanNQbHVtYi5BbmNob3JzW3RdKHApO1xuICAgICAgICAgICAgICAgIGlmICghX2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5Eb05vdFRocm93RXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IG1zZzogXCJqc1BsdW1iOiB1bmtub3duIGFuY2hvciB0eXBlICdcIiArIHQgKyBcIidcIiB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciBzcGVjaW1lbiA9IGFyZ3VtZW50c1swXSwgZWxlbWVudElkID0gYXJndW1lbnRzWzFdLCBqc1BsdW1iSW5zdGFuY2UgPSBhcmd1bWVudHNbMl0sIG5ld0FuY2hvciA9IG51bGw7XG4gICAgICAgICAgICAvLyBpZiBpdCBhcHBlYXJzIHRvIGJlIGFuIGFuY2hvciBhbHJlYWR5Li4uXG4gICAgICAgICAgICBpZiAoc3BlY2ltZW4uY29tcHV0ZSAmJiBzcGVjaW1lbi5nZXRPcmllbnRhdGlvbikgcmV0dXJuIHNwZWNpbWVuOyAgLy9UT0RPIGhhenkgaGVyZSBhYm91dCB3aGV0aGVyIGl0IHNob3VsZCBiZSBhZGRlZCBvciBpcyBhbHJlYWR5IGFkZGVkIHNvbWVob3cuXG4gICAgICAgICAgICAvLyBpcyBpdCB0aGUgbmFtZSBvZiBhbiBhbmNob3IgdHlwZT9cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzcGVjaW1lbiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbmV3QW5jaG9yID0gX2EoYXJndW1lbnRzWzBdLCB7ZWxlbWVudElkOiBlbGVtZW50SWQsIGpzUGx1bWJJbnN0YW5jZTogX2N1cnJlbnRJbnN0YW5jZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaXMgaXQgYW4gYXJyYXk/IGl0IHdpbGwgYmUgb25lIG9mOlxuICAgICAgICAgICAgLy8gXHRcdGFuIGFycmF5IG9mIFtzcGVjLCBwYXJhbXNdIC0gdGhpcyBkZWZpbmVzIGEgc2luZ2xlIGFuY2hvciwgd2hpY2ggbWF5IGJlIGR5bmFtaWMsIGJ1dCBoYXMgcGFyYW1ldGVycy5cbiAgICAgICAgICAgIC8vXHRcdGFuIGFycmF5IG9mIGFycmF5cyAtIHRoaXMgZGVmaW5lcyBzb21lIGR5bmFtaWMgYW5jaG9yc1xuICAgICAgICAgICAgLy9cdFx0YW4gYXJyYXkgb2YgbnVtYmVycyAtIHRoaXMgZGVmaW5lcyBhIHNpbmdsZSBhbmNob3IuXG4gICAgICAgICAgICBlbHNlIGlmIChfanUuaXNBcnJheShzcGVjaW1lbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2p1LmlzQXJyYXkoc3BlY2ltZW5bMF0pIHx8IF9qdS5pc1N0cmluZyhzcGVjaW1lblswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgW3NwZWMsIHBhcmFtc10gZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaW1lbi5sZW5ndGggPT0gMiAmJiBfanUuaXNPYmplY3Qoc3BlY2ltZW5bMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBmaXJzdCBhcmcgaXMgYSBzdHJpbmcsIGl0cyBhIG5hbWVkIGFuY2hvciB3aXRoIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9qdS5pc1N0cmluZyhzcGVjaW1lblswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcCA9IHJvb3QuanNQbHVtYi5leHRlbmQoe2VsZW1lbnRJZDogZWxlbWVudElkLCBqc1BsdW1iSW5zdGFuY2U6IF9jdXJyZW50SW5zdGFuY2V9LCBzcGVjaW1lblsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QW5jaG9yID0gX2Eoc3BlY2ltZW5bMF0sIHBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBmaXJzdCBhcmcgaXMgYXJyYXksIHNlY29uZCBpcyBwYXJhbXMuIHdlIHRyZWF0IGFzIGEgZHluYW1pYyBhbmNob3IsIHdoaWNoIGlzIGZpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlIGZpcnN0IGFyZyBoYXMgb25seSBvbmUgZW50cnkuIHlvdSBjb3VsZCBhcmd1ZSBhbGwgYW5jaG9ycyBzaG91bGQgYmUgaW1wbGljaXRseSBkeW5hbWljIGluIGZhY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcCA9IHJvb3QuanNQbHVtYi5leHRlbmQoe2VsZW1lbnRJZDogZWxlbWVudElkLCBqc1BsdW1iSW5zdGFuY2U6IF9jdXJyZW50SW5zdGFuY2UsIGFuY2hvcnM6IHNwZWNpbWVuWzBdfSwgc3BlY2ltZW5bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FuY2hvciA9IG5ldyByb290LmpzUGx1bWIuRHluYW1pY0FuY2hvcihwcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QW5jaG9yID0gbmV3IGpzUGx1bWIuRHluYW1pY0FuY2hvcih7YW5jaG9yczogc3BlY2ltZW4sIHNlbGVjdG9yOiBudWxsLCBlbGVtZW50SWQ6IGVsZW1lbnRJZCwganNQbHVtYkluc3RhbmNlOiBfY3VycmVudEluc3RhbmNlfSk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzcGVjaW1lblswXSwgeTogc3BlY2ltZW5bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogKHNwZWNpbWVuLmxlbmd0aCA+PSA0KSA/IFsgc3BlY2ltZW5bMl0sIHNwZWNpbWVuWzNdIF0gOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRzOiAoc3BlY2ltZW4ubGVuZ3RoID49IDYpID8gWyBzcGVjaW1lbls0XSwgc3BlY2ltZW5bNV0gXSA6IFsgMCwgMCBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudElkOiBlbGVtZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBqc1BsdW1iSW5zdGFuY2U6IF9jdXJyZW50SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NDbGFzczogc3BlY2ltZW4ubGVuZ3RoID09IDcgPyBzcGVjaW1lbls2XSA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QW5jaG9yID0gbmV3IHJvb3QuanNQbHVtYi5BbmNob3IoYW5jaG9yUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QW5jaG9yLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByb290LmpzUGx1bWIuQW5jaG9yKGFuY2hvclBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5ld0FuY2hvci5pZCkgbmV3QW5jaG9yLmlkID0gXCJhbmNob3JfXCIgKyBfaWRzdGFtcCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0FuY2hvcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWFrZXMgYSBsaXN0IG9mIGFuY2hvcnMgZnJvbSB0aGUgZ2l2ZW4gbGlzdCBvZiB0eXBlcyBvciBjb29yZHMsIGVnXG4gICAgICAgICAqIFtcIlRvcENlbnRlclwiLCBcIlJpZ2h0TWlkZGxlXCIsIFwiQm90dG9tQ2VudGVyXCIsIFswLCAxLCAtMSwgLTFdIF1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFrZUFuY2hvcnMgPSBmdW5jdGlvbiAodHlwZXMsIGVsZW1lbnRJZCwganNQbHVtYkluc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdHlwZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZXNbaV0gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKHJvb3QuanNQbHVtYi5BbmNob3JzW3R5cGVzW2ldXSh7ZWxlbWVudElkOiBlbGVtZW50SWQsIGpzUGx1bWJJbnN0YW5jZToganNQbHVtYkluc3RhbmNlfSkpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9qdS5pc0FycmF5KHR5cGVzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKF9jdXJyZW50SW5zdGFuY2UubWFrZUFuY2hvcih0eXBlc1tpXSwgZWxlbWVudElkLCBqc1BsdW1iSW5zdGFuY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhIGR5bmFtaWMgYW5jaG9yIGZyb20gdGhlIGdpdmVuIGxpc3Qgb2YgYW5jaG9ycyAod2hpY2ggbWF5IGJlIGluIHNob3J0aGFuZCBub3RhdGlvbiBhcyBzdHJpbmdzIG9yIGRpbWVuc2lvbiBhcnJheXMsIG9yIEFuY2hvclxuICAgICAgICAgKiBvYmplY3RzIHRoZW1zZWx2ZXMpIGFuZCB0aGUgZ2l2ZW4sIG9wdGlvbmFsLCBhbmNob3JTZWxlY3RvciBmdW5jdGlvbiAoanNQbHVtYiB1c2VzIGEgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdCBwcm92aWRlZDsgbW9zdCBwZW9wbGUgd2lsbFxuICAgICAgICAgKiBub3QgbmVlZCB0byBwcm92aWRlIHRoaXMgLSBpIHRoaW5rKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFrZUR5bmFtaWNBbmNob3IgPSBmdW5jdGlvbiAoYW5jaG9ycywgYW5jaG9yU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcm9vdC5qc1BsdW1iLkR5bmFtaWNBbmNob3Ioe2FuY2hvcnM6IGFuY2hvcnMsIHNlbGVjdG9yOiBhbmNob3JTZWxlY3RvciwgZWxlbWVudElkOiBudWxsLCBqc1BsdW1iSW5zdGFuY2U6IF9jdXJyZW50SW5zdGFuY2V9KTtcbiAgICAgICAgfTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1ha2VTb3VyY2UvbWFrZVRhcmdldCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuXG4gICAgICAgIHRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgX3NldEVuZHBvaW50UGFpbnRTdHlsZXNBbmRBbmNob3IgPSBmdW5jdGlvbiAoZXAsIGVwSW5kZXgsIF9pbnN0YW5jZSkge1xuICAgICAgICAgICAvKiBlcC5wYWludFN0eWxlID0gZXAucGFpbnRTdHlsZSB8fFxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5EZWZhdWx0cy5FbmRwb2ludFN0eWxlc1tlcEluZGV4XSB8fFxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5EZWZhdWx0cy5FbmRwb2ludFN0eWxlO1xuXG4gICAgICAgICAgICBlcC5ob3ZlclBhaW50U3R5bGUgPSBlcC5ob3ZlclBhaW50U3R5bGUgfHxcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2UuRGVmYXVsdHMuRW5kcG9pbnRIb3ZlclN0eWxlc1tlcEluZGV4XSB8fFxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5EZWZhdWx0cy5FbmRwb2ludEhvdmVyU3R5bGU7XG5cbiAgICAgICAgICAgIGVwLmFuY2hvciA9IGVwLmFuY2hvciB8fFxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5EZWZhdWx0cy5BbmNob3JzW2VwSW5kZXhdIHx8XG4gICAgICAgICAgICAgICAgX2luc3RhbmNlLkRlZmF1bHRzLkFuY2hvcjtcblxuICAgICAgICAgICAgZXAuZW5kcG9pbnQgPSBlcC5lbmRwb2ludCB8fFxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5EZWZhdWx0cy5FbmRwb2ludHNbZXBJbmRleF0gfHxcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2UuRGVmYXVsdHMuRW5kcG9pbnQ7Ki9cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUT0RPIHB1dCBhbGwgdGhlIHNvdXJjZSBzdHVmZiBpbnNpZGUgb25lIHBhcmVudCwga2V5ZWQgYnkgaWQuXG4gICAgICAgIHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9ucyA9IHt9O1xuXG4gICAgICAgIHZhciBzZWxlY3RvckZpbHRlciA9IGZ1bmN0aW9uIChldnQsIF9lbCwgc2VsZWN0b3IsIF9pbnN0YW5jZSwgbmVnYXRlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGV2dC50YXJnZXQgfHwgZXZ0LnNyY0VsZW1lbnQsIG9rID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VsID0gX2luc3RhbmNlLmdldFNlbGVjdG9yKF9lbCwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsW2pdID09IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmVnYXRlID8gIW9rIDogb2s7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU1AgdGFyZ2V0IHNvdXJjZSByZWZhY3RvclxuICAgICAgICB2YXIgX21ha2VFbGVtZW50RHJvcEhhbmRsZXIgPSBmdW5jdGlvbiAoZWxJbmZvLCBwLCBkcm9wT3B0aW9ucywgaXNTb3VyY2UsIGlzVGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgcHJveHlDb21wb25lbnQgPSBuZXcganNQbHVtYlVJQ29tcG9uZW50KHApO1xuICAgICAgICAgICAgdmFyIF9kcm9wID0gcC5fanNQbHVtYi5FbmRwb2ludERyb3BIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICBqc1BsdW1iOiBfY3VycmVudEluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsSW5mby5kZWYuZW5hYmxlZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzRnVsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q291bnQgPSBfY3VycmVudEluc3RhbmNlLnNlbGVjdCh7dGFyZ2V0OiBlbEluZm8uaWR9KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbEluZm8uZGVmLm1heENvbm5lY3Rpb25zID4gMCAmJiB0YXJnZXRDb3VudCA+PSBlbEluZm8uZGVmLm1heENvbm5lY3Rpb25zO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxJbmZvLmVsLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRJZDogZWxJbmZvLmlkLFxuICAgICAgICAgICAgICAgIGlzU291cmNlOiBpc1NvdXJjZSxcbiAgICAgICAgICAgICAgICBpc1RhcmdldDogaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmFkZENsYXNzKGVsSW5mby5lbCwgY2xhenopO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnJlbW92ZUNsYXNzKGVsSW5mby5lbCwgY2xhenopO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25Ecm9wOiBmdW5jdGlvbiAoanBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBqcGMuZW5kcG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UuYW5jaG9yLmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNEcm9wQWxsb3dlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlDb21wb25lbnQuaXNEcm9wQWxsb3dlZC5hcHBseShwcm94eUNvbXBvbmVudCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzUmVkcm9wOmZ1bmN0aW9uKGpwYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGpwYy5zdXNwZW5kZWRFbGVtZW50ICE9IG51bGwgJiYganBjLnN1c3BlbmRlZEVuZHBvaW50ICE9IG51bGwgJiYganBjLnN1c3BlbmRlZEVuZHBvaW50LmVsZW1lbnQgPT09IGVsSW5mby5lbCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRFbmRwb2ludDogZnVuY3Rpb24gKGpwYykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYSBuZXcgRW5kcG9pbnQgZm9yIHRoZSB0YXJnZXQsIG9yIGdldCBpdCBmcm9tIHRoZSBjYWNoZSBpZiB1bmlxdWVFbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBzZXQuIGlmIGl0cyBhIHJlZHJvcCB0aGUgbmV3IGVuZHBvaW50IHdpbGwgYmUgaW1tZWRpYXRlbHkgY2xlYW5lZCB1cC5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RW5kcG9pbnQgPSBlbEluZm8uZGVmLmVuZHBvaW50O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vIGNhY2hlZCBlbmRwb2ludCwgb3IgdGhlcmUgd2FzIG9uZSBidXQgaXQgaGFzIGJlZW4gY2xlYW5lZCB1cFxuICAgICAgICAgICAgICAgICAgICAvLyAoaWUuIGRldGFjaGVkKSwgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RW5kcG9pbnQgPT0gbnVsbCB8fCBuZXdFbmRwb2ludC5fanNQbHVtYiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXBzID0gX2N1cnJlbnRJbnN0YW5jZS5kZXJpdmVFbmRwb2ludEFuZEFuY2hvclNwZWMoanBjLmdldFR5cGUoKS5qb2luKFwiIFwiKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHAgPSBlcHMuZW5kcG9pbnRzID8gcm9vdC5qc1BsdW1iLmV4dGVuZChwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6ZWxJbmZvLmRlZi5kZWYuZW5kcG9pbnQgfHwgZXBzLmVuZHBvaW50c1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOnA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXBzLmFuY2hvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcCA9IHJvb3QuanNQbHVtYi5leHRlbmQocHAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yOmVsSW5mby5kZWYuZGVmLmFuY2hvciB8fCBlcHMuYW5jaG9yc1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RW5kcG9pbnQgPSBfY3VycmVudEluc3RhbmNlLmFkZEVuZHBvaW50KGVsSW5mby5lbCwgcHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RW5kcG9pbnQuX210TmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnVuaXF1ZUVuZHBvaW50KSBlbEluZm8uZGVmLmVuZHBvaW50ID0gbmV3RW5kcG9pbnQ7ICAvLyBtYXkgb2YgY291cnNlIGp1c3Qgc3RvcmUgd2hhdCBpdCBqdXN0IHB1bGxlZCBvdXQuIHRoYXQncyBvay5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB0ZXN0IG9wdGlvbnMgdG8gbWFrZVRhcmdldCB0byBzZWUgaWYgd2Ugc2hvdWxkIGRvIHRoaXM/XG4gICAgICAgICAgICAgICAgICAgIG5ld0VuZHBvaW50Ll9kb05vdERlbGV0ZU9uRGV0YWNoID0gZmFsc2U7IC8vIHJlc2V0LlxuICAgICAgICAgICAgICAgICAgICBuZXdFbmRwb2ludC5fZGVsZXRlT25EZXRhY2ggPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGNvbm5lY3Rpb24gaXMgZGV0YWNoYWJsZSwgaW5pdCB0aGUgbmV3IGVuZHBvaW50IHRvIGJlIGRyYWdnYWJsZSwgdG8gc3VwcG9ydCB0aGF0IGhhcHBlbmluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpwYy5pc0RldGFjaGFibGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VuZHBvaW50LmluaXREcmFnZ2FibGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgYW5jaG9yIGhhcyBhICdwb3NpdGlvbkZpbmRlcicgc2V0LCB0aGVuIGRlbGVnYXRlIHRvIHRoYXQgZnVuY3Rpb24gdG8gZmluZFxuICAgICAgICAgICAgICAgICAgICAvLyBvdXQgd2hlcmUgdG8gbG9jYXRlIHRoZSBhbmNob3IuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdFbmRwb2ludC5hbmNob3IucG9zaXRpb25GaW5kZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyb3BQb3NpdGlvbiA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0VUlQb3NpdGlvbihhcmd1bWVudHMsIF9jdXJyZW50SW5zdGFuY2UuZ2V0Wm9vbSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbFBvc2l0aW9uID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRPZmZzZXQoZWxJbmZvLmVsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbFNpemUgPSBfY3VycmVudEluc3RhbmNlLmdldFNpemUoZWxJbmZvLmVsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcCA9IGRyb3BQb3NpdGlvbiA9PSBudWxsID8gWzAsMF0gOiBuZXdFbmRwb2ludC5hbmNob3IucG9zaXRpb25GaW5kZXIoZHJvcFBvc2l0aW9uLCBlbFBvc2l0aW9uLCBlbFNpemUsIG5ld0VuZHBvaW50LmFuY2hvci5jb25zdHJ1Y3RvclBhcmFtcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VuZHBvaW50LmFuY2hvci54ID0gYXBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFbmRwb2ludC5hbmNob3IueSA9IGFwWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IGZpZ3VyZSBhbiBvcmllbnRhdGlvbiBmb3IgaXQuLmtpbmQgb2YgaGFyZCB0byBrbm93IHdoYXQgdG8gZG8gYWN0dWFsbHkuIHByb2JhYmx5IHRoZSBiZXN0IHRoaW5nIGkgY2FuIGRvIGlzIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IHNwZWNpZnlpbmcgYW4gb3JpZW50YXRpb24gaW4gdGhlIGFuY2hvcidzIHNwZWMuIGlmIG9uZSBpcyBub3Qgc3VwcGxpZWQgdGhlbiBpIHdpbGwgbWFrZSB0aGUgb3JpZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIHdoYXQgd2lsbCBjYXVzZSB0aGUgbW9zdCBuYXR1cmFsIGxpbmsgdG8gdGhlIHNvdXJjZTogaXQgd2lsbCBiZSBwb2ludGluZyBhdCB0aGUgc291cmNlLCBidXQgaXQgbmVlZHMgdG8gYmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBvbmUgYXhpcyBvbmx5LCBhbmQgc28gaG93IHRvIG1ha2UgdGhhdCBjaG9pY2U/IGkgdGhpbmsgaSB3aWxsIHVzZSB3aGljaGV2ZXIgYXhpcyBpcyB0aGUgb25lIGluIHdoaWNoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdGFyZ2V0IGlzIGZ1cnRoZXN0IGF3YXkgZnJvbSB0aGUgc291cmNlLlxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0VuZHBvaW50O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWF5YmVDbGVhbnVwOiBmdW5jdGlvbiAoZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVwLl9tdE5ldyAmJiBlcC5jb25uZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZGVsZXRlT2JqZWN0KHtlbmRwb2ludDogZXB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXAuX210TmV3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB3cmFwIGRyb3AgZXZlbnRzIGFzIG5lZWRlZCBhbmQgaW5pdGlhbGlzZSBkcm9wcGFibGVcbiAgICAgICAgICAgIHZhciBkcm9wRXZlbnQgPSByb290LmpzUGx1bWIuZHJhZ0V2ZW50cy5kcm9wO1xuICAgICAgICAgICAgZHJvcE9wdGlvbnMuc2NvcGUgPSBkcm9wT3B0aW9ucy5zY29wZSB8fCAocC5zY29wZSB8fCBfY3VycmVudEluc3RhbmNlLkRlZmF1bHRzLlNjb3BlKTtcbiAgICAgICAgICAgIGRyb3BPcHRpb25zW2Ryb3BFdmVudF0gPSBfanUud3JhcChkcm9wT3B0aW9uc1tkcm9wRXZlbnRdLCBfZHJvcCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRhcmdldCwgcmV0dXJuIHRydWUgZnJvbSB0aGUgb3ZlciBldmVudC4gdGhpcyB3aWxsIGNhdXNlIGthdGF2b3JpbyB0byBzdG9wIHNldHRpbmcgZHJvcHMgdG8gaG92ZXJcbiAgICAgICAgICAgIC8vIGlmIG11bHRpcGxlRHJvcCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICAgICAgICBpZiAoaXNUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBkcm9wT3B0aW9uc1tyb290LmpzUGx1bWIuZHJhZ0V2ZW50cy5vdmVyXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhbmlsbGEganNwbHVtYiBvbmx5XG4gICAgICAgICAgICBpZiAocC5hbGxvd0xvb3BiYWNrID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGRyb3BPcHRpb25zLmNhbkRyb3AgPSBmdW5jdGlvbiAoX2RyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlID0gX2RyYWcuZ2V0RHJhZ0VsZW1lbnQoKS5fanNQbHVtYlJlbGF0ZWRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGUgIT0gZWxJbmZvLmVsO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmluaXREcm9wcGFibGUoZWxJbmZvLmVsLCBkcm9wT3B0aW9ucywgXCJpbnRlcm5hbFwiKTtcblxuICAgICAgICAgICAgcmV0dXJuIF9kcm9wO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2VlIEFQSSBkb2NzXG4gICAgICAgIHRoaXMubWFrZVRhcmdldCA9IGZ1bmN0aW9uIChlbCwgcGFyYW1zLCByZWZlcmVuY2VQYXJhbXMpIHtcblxuICAgICAgICAgICAgLy8gcHV0IGpzcGx1bWIgcmVmIGludG8gcGFyYW1zIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIHBhcmFtcyBwYXNzZWQgaW5cbiAgICAgICAgICAgIHZhciBwID0gcm9vdC5qc1BsdW1iLmV4dGVuZCh7X2pzUGx1bWI6IHRoaXN9LCByZWZlcmVuY2VQYXJhbXMpO1xuICAgICAgICAgICAgcm9vdC5qc1BsdW1iLmV4dGVuZChwLCBwYXJhbXMpO1xuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgYXBwcm9wcmlhdGUgcGFpbnQgc3R5bGVzIGFuZCBhbmNob3IgZnJvbSB0aGUgcGFyYW1zIGdpdmVuXG4gICAgICAgICAgICBfc2V0RW5kcG9pbnRQYWludFN0eWxlc0FuZEFuY2hvcihwLCAxLCB0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGRlbGV0ZUVuZHBvaW50c09uRGV0YWNoID0gIShwLmRlbGV0ZUVuZHBvaW50c09uRGV0YWNoID09PSBmYWxzZSksXG4gICAgICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnMgPSBwLm1heENvbm5lY3Rpb25zIHx8IC0xLFxuXG4gICAgICAgICAgICAgICAgX2RvT25lID0gZnVuY3Rpb24gKGVsKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBlbGVtZW50J3MgaWQgYW5kIHN0b3JlIHRoZSBlbmRwb2ludCBkZWZpbml0aW9uIGZvciBpdC4gIGpzUGx1bWIuY29ubmVjdCBjYWxscyB3aWxsIGxvb2sgZm9yIG9uZSBvZiB0aGVzZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHVzZSB0aGUgZW5kcG9pbnQgZGVmaW5pdGlvbiBpZiBmb3VuZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGVjb2RlIHRoZSBpbmZvIGZvciB0aGlzIGVsZW1lbnQgKGlkIGFuZCBlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxJbmZvID0gX2luZm8oZWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxpZCA9IGVsSW5mby5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BPcHRpb25zID0gcm9vdC5qc1BsdW1iLmV4dGVuZCh7fSwgcC5kcm9wT3B0aW9ucyB8fCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJkZWZhdWx0XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zW2VsaWRdID0gdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zW2VsaWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIF9lbnN1cmVDb250YWluZXIoZWxpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgdGhlIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kZWYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWY6IHJvb3QuanNQbHVtYi5leHRlbmQoe30sIHApLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlRW5kcG9pbnQ6IHAudW5pcXVlRW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhDb25uZWN0aW9uczogbWF4Q29ubmVjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGVsSW5mby5kZWYgPSBfZGVmO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnNbZWxpZF1bdHlwZV0gPSBfZGVmO1xuICAgICAgICAgICAgICAgICAgICBfbWFrZUVsZW1lbnREcm9wSGFuZGxlcihlbEluZm8sIHAsIGRyb3BPcHRpb25zLCBwLmlzU291cmNlID09PSB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3Rhc2ggdGhlIGRlZmluaXRpb24gb24gdGhlIGRyb3BcbiAgICAgICAgICAgICAgICAgICAgZWxJbmZvLmVsLl9rYXRhdm9yaW9Ecm9wW2VsSW5mby5lbC5fa2F0YXZvcmlvRHJvcC5sZW5ndGggLSAxXS50YXJnZXREZWYgPSBfZGVmO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBtYWtlIGFuIGFycmF5IGlmIG9ubHkgZ2l2ZW4gb25lIGVsZW1lbnRcbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSBlbC5sZW5ndGggJiYgZWwuY29uc3RydWN0b3IgIT0gU3RyaW5nID8gZWwgOiBbIGVsIF07XG5cbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGVhY2ggb25lIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfZG9PbmUoaW5wdXRzW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2VlIGFwaSBkb2NzXG4gICAgICAgIHRoaXMudW5tYWtlVGFyZ2V0ID0gZnVuY3Rpb24gKGVsLCBkb05vdENsZWFyQXJyYXlzKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IF9pbmZvKGVsKTtcbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZGVzdHJveURyb3BwYWJsZShpbmZvLmVsLCBcImludGVybmFsXCIpO1xuICAgICAgICAgICAgaWYgKCFkb05vdENsZWFyQXJyYXlzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1tpbmZvLmlkXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2VlIGFwaSBkb2NzXG4gICAgICAgIHRoaXMubWFrZVNvdXJjZSA9IGZ1bmN0aW9uIChlbCwgcGFyYW1zLCByZWZlcmVuY2VQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBwID0gcm9vdC5qc1BsdW1iLmV4dGVuZCh7X2pzUGx1bWI6IHRoaXN9LCByZWZlcmVuY2VQYXJhbXMpO1xuICAgICAgICAgICAgcm9vdC5qc1BsdW1iLmV4dGVuZChwLCBwYXJhbXMpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBwLmNvbm5lY3Rpb25UeXBlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgdmFyIGFhZSA9IF9jdXJyZW50SW5zdGFuY2UuZGVyaXZlRW5kcG9pbnRBbmRBbmNob3JTcGVjKHR5cGUpO1xuICAgICAgICAgICAgcC5lbmRwb2ludCA9IHAuZW5kcG9pbnQgfHwgYWFlLmVuZHBvaW50c1swXTtcbiAgICAgICAgICAgIHAuYW5jaG9yID0gcC5hbmNob3IgfHwgYWFlLmFuY2hvcnNbMF07XG4gICAgICAgICAgICBfc2V0RW5kcG9pbnRQYWludFN0eWxlc0FuZEFuY2hvcihwLCAwLCB0aGlzKTtcbiAgICAgICAgICAgIHZhciBtYXhDb25uZWN0aW9ucyA9IHAubWF4Q29ubmVjdGlvbnMgfHwgLTEsXG4gICAgICAgICAgICAgICAgb25NYXhDb25uZWN0aW9ucyA9IHAub25NYXhDb25uZWN0aW9ucyxcbiAgICAgICAgICAgICAgICBfZG9PbmUgPSBmdW5jdGlvbiAoZWxJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgZWxlbWVudCdzIGlkIGFuZCBzdG9yZSB0aGUgZW5kcG9pbnQgZGVmaW5pdGlvbiBmb3IgaXQuICBqc1BsdW1iLmNvbm5lY3QgY2FsbHMgd2lsbCBsb29rIGZvciBvbmUgb2YgdGhlc2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB1c2UgdGhlIGVuZHBvaW50IGRlZmluaXRpb24gaWYgZm91bmQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGlkID0gZWxJbmZvLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2RlbCA9IHRoaXMuZ2V0RWxlbWVudChlbEluZm8uZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9uc1tlbGlkXSA9IHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9uc1tlbGlkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgX2Vuc3VyZUNvbnRhaW5lcihlbGlkKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgX2RlZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZjpyb290LmpzUGx1bWIuZXh0ZW5kKHt9LCBwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUVuZHBvaW50OiBwLnVuaXF1ZUVuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IG1heENvbm5lY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zW2VsaWRdW3R5cGVdID0gX2RlZjtcbiAgICAgICAgICAgICAgICAgICAgZWxJbmZvLmRlZiA9IF9kZWY7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3BFdmVudCA9IHJvb3QuanNQbHVtYi5kcmFnRXZlbnRzLnN0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnRXZlbnQgPSByb290LmpzUGx1bWIuZHJhZ0V2ZW50cy5kcmFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ09wdGlvbnMgPSByb290LmpzUGx1bWIuZXh0ZW5kKHsgfSwgcC5kcmFnT3B0aW9ucyB8fCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0RyYWcgPSBkcmFnT3B0aW9ucy5kcmFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdTdG9wID0gZHJhZ09wdGlvbnMuc3RvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50QWRkZWRCdXROb0RyYWdZZXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgc2NvcGUgaWYgaXRzIG5vdCBzZXQgaW4gZHJhZ09wdGlvbnMgYnV0IHdhcyBwYXNzZWQgaW4gaW4gcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIGRyYWdPcHRpb25zLnNjb3BlID0gZHJhZ09wdGlvbnMuc2NvcGUgfHwgcC5zY29wZTtcblxuICAgICAgICAgICAgICAgICAgICBkcmFnT3B0aW9uc1tkcmFnRXZlbnRdID0gX2p1LndyYXAoZHJhZ09wdGlvbnNbZHJhZ0V2ZW50XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRHJhZykgZXhpc3RpbmdEcmFnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludEFkZGVkQnV0Tm9EcmFnWWV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRyYWdPcHRpb25zW3N0b3BFdmVudF0gPSBfanUud3JhcChkcmFnT3B0aW9uc1tzdG9wRXZlbnRdLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1N0b3ApIGV4aXN0aW5nU3RvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVwLl9qc1BsdW1iICE9IG51bGwpIHsgLy8gaWYgbm90IGNsZWFuZWQgdXAuLi5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBhbmNob3IgdG8gdGhlIGFuY2hvciB0aGF0IHdhcyBpbml0aWFsbHkgcHJvdmlkZWQuIHRoZSBvbmUgd2Ugd2VyZSB1c2luZyB0byBkcmFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNvbm5lY3Rpb24gd2FzIGp1c3QgYSBwbGFjZWhvbGRlciB0aGF0IHdhcyBsb2NhdGVkIGF0IHRoZSBwbGFjZSB0aGUgdXNlciBwcmVzc2VkIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdXNlIGJ1dHRvbiB0byBpbml0aWF0ZSB0aGUgZHJhZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRGVmID0gcC5hbmNob3IgfHwgdGhpcy5EZWZhdWx0cy5BbmNob3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZEFuY2hvciA9IGVwLmFuY2hvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ29ubmVjdGlvbiA9IGVwLmNvbm5lY3Rpb25zWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICAgIG5ld0FuY2hvciA9IHRoaXMubWFrZUFuY2hvcihhbmNob3JEZWYsIGVsaWQsIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZWwgPSBlcC5lbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFuY2hvciBoYXMgYSAncG9zaXRpb25GaW5kZXInIHNldCwgdGhlbiBkZWxlZ2F0ZSB0byB0aGF0IGZ1bmN0aW9uIHRvIGZpbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXQgd2hlcmUgdG8gbG9jYXRlIHRoZSBhbmNob3IuIGlzc3VlIDExNy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3QW5jaG9yLnBvc2l0aW9uRmluZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsUG9zaXRpb24gPSBfY3VycmVudEluc3RhbmNlLmdldE9mZnNldChfZWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxTaXplID0gdGhpcy5nZXRTaXplKF9lbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wUG9zaXRpb24gPSB7IGxlZnQ6IGVsUG9zaXRpb24ubGVmdCArIChvbGRBbmNob3IueCAqIGVsU2l6ZVswXSksIHRvcDogZWxQb3NpdGlvbi50b3AgKyAob2xkQW5jaG9yLnkgKiBlbFNpemVbMV0pIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcCA9IG5ld0FuY2hvci5wb3NpdGlvbkZpbmRlcihkcm9wUG9zaXRpb24sIGVsUG9zaXRpb24sIGVsU2l6ZSwgbmV3QW5jaG9yLmNvbnN0cnVjdG9yUGFyYW1zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBbmNob3IueCA9IGFwWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBbmNob3IueSA9IGFwWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwLnNldEFuY2hvcihuZXdBbmNob3IsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwLnJlcGFpbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnQoZXAuZWxlbWVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkQ29ubmVjdGlvbiAhPSBudWxsKSB0aGlzLnJlcGFpbnQob2xkQ29ubmVjdGlvbi50YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZSBtb3VzZSwgYWRkIGFuIEVuZHBvaW50LCBpZiB3ZSBhcmUgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlRG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIHJpZ2h0IG1vdXNlIGJ1dHRvbiwgYWJvcnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gMyB8fCBlLmJ1dHRvbiA9PT0gMikgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHN0b3JlIGRlZiBvbiBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9uc1tlbGlkXVt0eXBlXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZGlzYWJsZWQsIHJldHVybi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVmLmVuYWJsZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZWxpZCA9IHRoaXMuZ2V0SWQodGhpcy5nZXRFbGVtZW50KGVsSW5mby5lbCkpOyAvLyBlbGlkIG1pZ2h0IGhhdmUgY2hhbmdlZCBzaW5jZSB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIHRvIGNvbmZpZ3VyZSB0aGUgZWxlbWVudC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSBmaWx0ZXIgd2FzIGdpdmVuLCBydW4gaXQsIGFuZCByZXR1cm4gaWYgaXQgc2F5cyBuby5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gX2p1LmlzU3RyaW5nKHAuZmlsdGVyKSA/IHNlbGVjdG9yRmlsdGVyKGUsIGVsSW5mby5lbCwgcC5maWx0ZXIsIHRoaXMsIHAuZmlsdGVyRXhjbHVkZSkgOiBwLmZpbHRlcihlLCBlbEluZm8uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBtYXhDb25uZWN0aW9ucyByZWFjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlQ291bnQgPSB0aGlzLnNlbGVjdCh7c291cmNlOiBlbGlkfSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5tYXhDb25uZWN0aW9ucyA+PSAwICYmIChzb3VyY2VDb3VudCA+PSBkZWYubWF4Q29ubmVjdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uTWF4Q29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25NYXhDb25uZWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbEluZm8uZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhDb25uZWN0aW9uczogbWF4Q29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgcG9zaXRpb24gb24gdGhlIGVsZW1lbnQgYXQgd2hpY2ggdGhlIG1vdXNlIHdhcyBwcmVzc2VkOyB0aGlzIGlzIHdoZXJlIHRoZSBlbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBsb2NhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVseHkgPSByb290LmpzUGx1bWIuZ2V0UG9zaXRpb25PbkVsZW1lbnQoZSwgX2RlbCwgX3pvb20pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG92ZXJyaWRlIHRoZSBhbmNob3IgaW4gaGVyZSwgYW5kIGZvcmNlICdpc1NvdXJjZScsIGJ1dCB3ZSBkb24ndCB3YW50IHRvIG1lc3Mgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhcmFtcyBwYXNzZWQgaW4sIGJlY2F1c2UgYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIHdlJ3JlIGdvaW5nIHRvIHJlc2V0IHRoZSBlbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gaGF2ZSB0aGUgYW5jaG9yIHdlIHdlcmUgZ2l2ZW4uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcEVuZHBvaW50UGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICByb290LmpzUGx1bWIuZXh0ZW5kKHRlbXBFbmRwb2ludFBhcmFtcywgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wRW5kcG9pbnRQYXJhbXMuaXNUZW1wb3JhcnlTb3VyY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEVuZHBvaW50UGFyYW1zLmFuY2hvciA9IFsgZWx4eVswXSwgZWx4eVsxXSAsIDAsIDBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEVuZHBvaW50UGFyYW1zLmRyYWdPcHRpb25zID0gZHJhZ09wdGlvbnM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYuZGVmLnNjb3BlKSB0ZW1wRW5kcG9pbnRQYXJhbXMuc2NvcGUgPSBkZWYuZGVmLnNjb3BlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcCA9IHRoaXMuYWRkRW5kcG9pbnQoZWxpZCwgdGVtcEVuZHBvaW50UGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50QWRkZWRCdXROb0RyYWdZZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXAuX2RvTm90RGVsZXRlT25EZXRhY2ggPSBmYWxzZTsgLy8gcmVzZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcC5fZGVsZXRlT25EZXRhY2ggPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB1bmlxdWUgZW5kcG9pbnQgYW5kIGl0J3MgYWxyZWFkeSBiZWVuIGNyZWF0ZWQsIHB1c2ggaXQgb250byB0aGUgZW5kcG9pbnQgd2UgY3JlYXRlLiBhdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBhIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbiB3ZSdsbCBzd2l0Y2ggdG8gdGhhdCBlbmRwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBpcyB0aGUgc2FtZSBjb2RlIGFzIHRoZSBwcm9ncmFtbWF0aWMgZW5kcG9pbnRzIGNyZWF0ZSBvbiBsaW5lIDEwNTAgaXNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnVuaXF1ZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWYuZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLmVuZHBvaW50ID0gZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwLl9kZWxldGVPbkRldGFjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcC5fZG9Ob3REZWxldGVPbkRldGFjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXAuZmluYWxFbmRwb2ludCA9IGRlZi5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9kZWxUZW1wRW5kcG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtb3VzZXVwIGV2ZW50IGlzIGZpcmVkIG9ubHkgaWYgbm8gZHJhZ2dpbmcgb2NjdXJyZWQsIGJ5IGpxdWVyeSBhbmQgeXVpLCBidXQgZm9yIG1vb3Rvb2xzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgZmlyZWQgZXZlbiBpZiBkcmFnZ2luZyBoYXMgb2NjdXJyZWQsIGluIHdoaWNoIGNhc2Ugd2Ugd291bGQgYmxvdyBhd2F5IGEgcGVyZmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVnaXRpbWF0ZSBlbmRwb2ludCwgd2VyZSBpdCBub3QgZm9yIHRoaXMgY2hlY2suICB0aGUgZmxhZyBpcyBzZXQgYWZ0ZXIgYWRkaW5nIGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kcG9pbnQgYW5kIGNsZWFyZWQgaW4gYSBkcmFnIGxpc3RlbmVyIHdlIHNldCBpbiB0aGUgZHJhZ09wdGlvbnMgYWJvdmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5vZmYoZXAuY2FudmFzLCBcIm1vdXNldXBcIiwgX2RlbFRlbXBFbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5vZmYoZWxJbmZvLmVsLCBcIm1vdXNldXBcIiwgX2RlbFRlbXBFbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50QWRkZWRCdXROb0RyYWdZZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRBZGRlZEJ1dE5vRHJhZ1lldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlbGV0ZUVuZHBvaW50KGVwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLm9uKGVwLmNhbnZhcywgXCJtb3VzZXVwXCIsIF9kZWxUZW1wRW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5vbihlbEluZm8uZWwsIFwibW91c2V1cFwiLCBfZGVsVGVtcEVuZHBvaW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uYWxseSBjaGVjayBmb3IgYXR0cmlidXRlcyB0byBleHRyYWN0IGZyb20gdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5kZWYuZXh0cmFjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGF0dCBpbiBkZWYuZGVmLmV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSAoZS5zcmNFbGVtZW50IHx8IGUudGFyZ2V0KS5nZXRBdHRyaWJ1dGUoYXR0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRbZGVmLmRlZi5leHRyYWN0W2F0dF1dID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZW4gdHJpZ2dlciBpdHMgbW91c2Vkb3duIGV2ZW50LCB3aGljaCB3aWxsIGtpY2sgb2ZmIGEgZHJhZywgd2hpY2ggd2lsbCBzdGFydCBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBuZXcgY29ubmVjdGlvbiBmcm9tIHRoaXMgZW5kcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnRyaWdnZXIoZXAuY2FudmFzLCBcIm1vdXNlZG93blwiLCBlLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmNvbnN1bWUoZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub24oZWxJbmZvLmVsLCBcIm1vdXNlZG93blwiLCBtb3VzZURvd25MaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIF9kZWYudHJpZ2dlciA9IG1vdXNlRG93bkxpc3RlbmVyO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGEgZmlsdGVyIHdhcyBwcm92aWRlZCwgc2V0IGl0IGFzIGEgZHJhZ0ZpbHRlciBvbiB0aGUgZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gcHJldmVudCB0aGUgZWxlbWVudCBkcmFnIGZ1bmN0aW9uIGZyb20ga2lja2luZyBpbiB3aGVuIHdlIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gZHJhZyBhIG5ldyBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLmZpbHRlciAmJiAoX2p1LmlzU3RyaW5nKHAuZmlsdGVyKSB8fCBfanUuaXNGdW5jdGlvbihwLmZpbHRlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnNldERyYWdGaWx0ZXIoZWxJbmZvLmVsLCBwLmZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcE9wdGlvbnMgPSByb290LmpzUGx1bWIuZXh0ZW5kKHt9LCBwLmRyb3BPcHRpb25zIHx8IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICBfbWFrZUVsZW1lbnREcm9wSGFuZGxlcihlbEluZm8sIHAsIGRyb3BPcHRpb25zLCB0cnVlLCBwLmlzVGFyZ2V0ID09PSB0cnVlKTtcblxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGlucHV0cyA9IGVsLmxlbmd0aCAmJiBlbC5jb25zdHJ1Y3RvciAhPSBTdHJpbmcgPyBlbCA6IFsgZWwgXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGlucHV0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2RvT25lKF9pbmZvKGlucHV0c1tpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZWUgYXBpIGRvY3NcbiAgICAgICAgdGhpcy51bm1ha2VTb3VyY2UgPSBmdW5jdGlvbiAoZWwsIGNvbm5lY3Rpb25UeXBlLCBkb05vdENsZWFyQXJyYXlzKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IF9pbmZvKGVsKTtcbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZGVzdHJveURyb3BwYWJsZShpbmZvLmVsLCBcImludGVybmFsXCIpO1xuICAgICAgICAgICAgdmFyIGVsZGVmcyA9IHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9uc1tpbmZvLmlkXTtcbiAgICAgICAgICAgIGlmIChlbGRlZnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkZWYgaW4gZWxkZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uVHlwZSA9PSBudWxsIHx8IGNvbm5lY3Rpb25UeXBlID09PSBkZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZURvd25MaXN0ZW5lciA9IGVsZGVmc1tkZWZdLnRyaWdnZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW91c2VEb3duTGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5vZmYoaW5mby5lbCwgXCJtb3VzZWRvd25cIiwgbW91c2VEb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb05vdENsZWFyQXJyYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9uc1tpbmZvLmlkXVtkZWZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZWUgYXBpIGRvY3NcbiAgICAgICAgdGhpcy51bm1ha2VFdmVyeVNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zKVxuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UudW5tYWtlU291cmNlKGksIG51bGwsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZ2V0U2NvcGUgPSBmdW5jdGlvbiAoZWwsIHR5cGVzLCBjb25uZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgdHlwZXMgPSBfanUuaXNBcnJheSh0eXBlcykgPyB0eXBlcyA6IFsgdHlwZXMgXTtcbiAgICAgICAgICAgIHZhciBpZCA9IF9nZXRJZChlbCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uVHlwZSA9IGNvbm5lY3Rpb25UeXBlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbGRlZnMgPSB0aGlzW3R5cGVzW2ldXVtpZF07XG4gICAgICAgICAgICAgICAgaWYgKGVsZGVmcyAmJiBlbGRlZnNbY29ubmVjdGlvblR5cGVdKSByZXR1cm4gZWxkZWZzW2Nvbm5lY3Rpb25UeXBlXS5kZWYuc2NvcGUgfHwgdGhpcy5EZWZhdWx0cy5TY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHZhciBfc2V0U2NvcGUgPSBmdW5jdGlvbiAoZWwsIHNjb3BlLCB0eXBlcywgY29ubmVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIHR5cGVzID0gX2p1LmlzQXJyYXkodHlwZXMpID8gdHlwZXMgOiBbIHR5cGVzIF07XG4gICAgICAgICAgICB2YXIgaWQgPSBfZ2V0SWQoZWwpO1xuICAgICAgICAgICAgY29ubmVjdGlvblR5cGUgPSBjb25uZWN0aW9uVHlwZSB8fCBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxkZWZzID0gdGhpc1t0eXBlc1tpXV1baWRdO1xuICAgICAgICAgICAgICAgIGlmIChlbGRlZnMgJiYgZWxkZWZzW2Nvbm5lY3Rpb25UeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBlbGRlZnNbY29ubmVjdGlvblR5cGVdLmRlZi5zY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5nZXRTY29wZSA9IGZ1bmN0aW9uIChlbCwgc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U2NvcGUoZWwsIFsgXCJzb3VyY2VFbmRwb2ludERlZmluaXRpb25zXCIsIFwidGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1wiIF0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFNvdXJjZVNjb3BlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldFNjb3BlKGVsLCBcInNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNcIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0VGFyZ2V0U2NvcGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U2NvcGUoZWwsIFwidGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1wiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRTY29wZSA9IGZ1bmN0aW9uIChlbCwgc2NvcGUsIGNvbm5lY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNvdXJjZVNjb3BlKGVsLCBzY29wZSwgY29ubmVjdGlvblR5cGUpO1xuICAgICAgICAgICAgdGhpcy5zZXRUYXJnZXRTY29wZShlbCwgc2NvcGUsIGNvbm5lY3Rpb25UeXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2VTY29wZSA9IGZ1bmN0aW9uIChlbCwgc2NvcGUsIGNvbm5lY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICBfc2V0U2NvcGUoZWwsIHNjb3BlLCBcInNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNcIiwgY29ubmVjdGlvblR5cGUpO1xuICAgICAgICAgICAgLy8gd2UgZ2V0IHRoZSBzb3VyY2Ugc2NvcGUgZHVyaW5nIHRoZSBtb3VzZWRvd24gZXZlbnQsIGJ1dCB3ZSBhbHNvIHdhbnQgdG8gc2V0IHRoaXMuXG4gICAgICAgICAgICB0aGlzLnNldERyYWdTY29wZShlbCwgc2NvcGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFRhcmdldFNjb3BlID0gZnVuY3Rpb24gKGVsLCBzY29wZSwgY29ubmVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIF9zZXRTY29wZShlbCwgc2NvcGUsIFwidGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1wiLCBjb25uZWN0aW9uVHlwZSk7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BTY29wZShlbCwgc2NvcGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNlZSBhcGkgZG9jc1xuICAgICAgICB0aGlzLnVubWFrZUV2ZXJ5VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnMpXG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS51bm1ha2VUYXJnZXQoaSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9ucyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZG9lcyB0aGUgd29yayBvZiBzZXR0aW5nIGEgc291cmNlIGVuYWJsZWQgb3IgZGlzYWJsZWQuXG4gICAgICAgIHZhciBfc2V0RW5hYmxlZCA9IGZ1bmN0aW9uICh0eXBlLCBlbCwgc3RhdGUsIHRvZ2dsZSwgY29ubmVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIHZhciBhID0gdHlwZSA9PSBcInNvdXJjZVwiID8gdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zIDogdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zO1xuICAgICAgICAgICAgY29ubmVjdGlvblR5cGUgPSBjb25uZWN0aW9uVHlwZSB8fCBcImRlZmF1bHRcIjtcblxuXG4gICAgICAgICAgICBpZiAoX2p1LmlzU3RyaW5nKGVsKSAmJiBhW2VsXSAmJiBhW2VsXVtjb25uZWN0aW9uVHlwZV0pIHtcbiAgICAgICAgICAgICAgICBhW2VsXVtjb25uZWN0aW9uVHlwZV0uZW5hYmxlZCA9IHRvZ2dsZSA/ICFhW2VsXVtjb25uZWN0aW9uVHlwZV0uZW5hYmxlZCA6IHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZWwubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IF9pbmZvKGVsW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFbaW5mby5pZF0gJiYgYVtpbmZvLmlkXVtjb25uZWN0aW9uVHlwZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBhW2luZm8uaWRdW2Nvbm5lY3Rpb25UeXBlXS5lbmFibGVkID0gdG9nZ2xlID8gIWFbaW5mby5pZF1bY29ubmVjdGlvblR5cGVdLmVuYWJsZWQgOiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYSBET00gZWxlbWVudFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX2luZm8oZWwpLmlkO1xuICAgICAgICAgICAgICAgIGlmIChhW2lkXSAmJiBhW2lkXVtjb25uZWN0aW9uVHlwZV0pXG4gICAgICAgICAgICAgICAgICAgIGFbaWRdW2Nvbm5lY3Rpb25UeXBlXS5lbmFibGVkID0gdG9nZ2xlID8gIWFbaWRdW2Nvbm5lY3Rpb25UeXBlXS5lbmFibGVkIDogc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHZhciBfZmlyc3QgPSBmdW5jdGlvbiAoZWwsIGZuKSB7XG4gICAgICAgICAgICBpZiAoX2p1LmlzU3RyaW5nKGVsKSB8fCAhZWwubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBbIGVsIF0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWwubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBbIGVsWzBdIF0pO1xuXG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLnRvZ2dsZVNvdXJjZUVuYWJsZWQgPSBmdW5jdGlvbiAoZWwsIGNvbm5lY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICBfc2V0RW5hYmxlZChcInNvdXJjZVwiLCBlbCwgbnVsbCwgdHJ1ZSwgY29ubmVjdGlvblR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTb3VyY2VFbmFibGVkKGVsLCBjb25uZWN0aW9uVHlwZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRTb3VyY2VFbmFibGVkID0gZnVuY3Rpb24gKGVsLCBzdGF0ZSwgY29ubmVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfc2V0RW5hYmxlZChcInNvdXJjZVwiLCBlbCwgc3RhdGUsIG51bGwsIGNvbm5lY3Rpb25UeXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc1NvdXJjZSA9IGZ1bmN0aW9uIChlbCwgY29ubmVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UeXBlID0gY29ubmVjdGlvblR5cGUgfHwgXCJkZWZhdWx0XCI7XG4gICAgICAgICAgICByZXR1cm4gX2ZpcnN0KGVsLCBmdW5jdGlvbiAoX2VsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZGVmcyA9IHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9uc1tfaW5mbyhfZWwpLmlkXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxkZWZzICE9IG51bGwgJiYgZWxkZWZzW2Nvbm5lY3Rpb25UeXBlXSAhPSBudWxsO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc1NvdXJjZUVuYWJsZWQgPSBmdW5jdGlvbiAoZWwsIGNvbm5lY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uVHlwZSA9IGNvbm5lY3Rpb25UeXBlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgcmV0dXJuIF9maXJzdChlbCwgZnVuY3Rpb24gKF9lbCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXAgPSB0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbX2luZm8oX2VsKS5pZF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcCAmJiBzZXBbY29ubmVjdGlvblR5cGVdICYmIHNlcFtjb25uZWN0aW9uVHlwZV0uZW5hYmxlZCA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50b2dnbGVUYXJnZXRFbmFibGVkID0gZnVuY3Rpb24gKGVsLCBjb25uZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgX3NldEVuYWJsZWQoXCJ0YXJnZXRcIiwgZWwsIG51bGwsIHRydWUsIGNvbm5lY3Rpb25UeXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVGFyZ2V0RW5hYmxlZChlbCwgY29ubmVjdGlvblR5cGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaXNUYXJnZXQgPSBmdW5jdGlvbiAoZWwsIGNvbm5lY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uVHlwZSA9IGNvbm5lY3Rpb25UeXBlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgcmV0dXJuIF9maXJzdChlbCwgZnVuY3Rpb24gKF9lbCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGRlZnMgPSB0aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnNbX2luZm8oX2VsKS5pZF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZGVmcyAhPSBudWxsICYmIGVsZGVmc1tjb25uZWN0aW9uVHlwZV0gIT0gbnVsbDtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNUYXJnZXRFbmFibGVkID0gZnVuY3Rpb24gKGVsLCBjb25uZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgY29ubmVjdGlvblR5cGUgPSBjb25uZWN0aW9uVHlwZSB8fCBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIHJldHVybiBfZmlyc3QoZWwsIGZ1bmN0aW9uIChfZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVwID0gdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zW19pbmZvKF9lbCkuaWRdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXAgJiYgdGVwW2Nvbm5lY3Rpb25UeXBlXSAmJiB0ZXBbY29ubmVjdGlvblR5cGVdLmVuYWJsZWQgPT09IHRydWU7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFRhcmdldEVuYWJsZWQgPSBmdW5jdGlvbiAoZWwsIHN0YXRlLCBjb25uZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9zZXRFbmFibGVkKFwidGFyZ2V0XCIsIGVsLCBzdGF0ZSwgbnVsbCwgY29ubmVjdGlvblR5cGUpO1xuICAgICAgICB9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gZW5kIG1ha2VTb3VyY2UvbWFrZVRhcmdldCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFx0XHRcdFx0XG5cbiAgICAgICAgdGhpcy5yZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5iaW5kKFwicmVhZHlcIiwgZm4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZWxFYWNoID0gZnVuY3Rpb24oZWwsIGZuKSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0IGJvdGggbGlzdHMuLi5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwgPT0gJ29iamVjdCcgJiYgZWwubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVsLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZWxbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgLy8gLi4uYW5kIHNpbmdsZSBzdHJpbmdzIG9yIGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgIGZuKGVsKTtcblxuICAgICAgICAgICAgcmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVwYWludCBzb21lIGVsZW1lbnQncyBlbmRwb2ludHMgYW5kIGNvbm5lY3Rpb25zXG4gICAgICAgIHRoaXMucmVwYWludCA9IGZ1bmN0aW9uIChlbCwgdWksIHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgcmV0dXJuIF9lbEVhY2goZWwsIGZ1bmN0aW9uKF9lbCkge1xuICAgICAgICAgICAgICAgIF9kcmF3KF9lbCwgdWksIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJldmFsaWRhdGUgPSBmdW5jdGlvbiAoZWwsIHRpbWVzdGFtcCwgaXNJZEFscmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBfZWxFYWNoKGVsLCBmdW5jdGlvbihfZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxJZCA9IGlzSWRBbHJlYWR5ID8gX2VsIDogX2N1cnJlbnRJbnN0YW5jZS5nZXRJZChfZWwpO1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UudXBkYXRlT2Zmc2V0KHsgZWxJZDogZWxJZCwgcmVjYWxjOiB0cnVlLCB0aW1lc3RhbXA6dGltZXN0YW1wIH0pO1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UucmVwYWludChfZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVwYWludCBldmVyeSBlbmRwb2ludCBhbmQgY29ubmVjdGlvbi5cbiAgICAgICAgdGhpcy5yZXBhaW50RXZlcnl0aGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyB0aW1lc3RhbXAgY2F1c2VzIGNvbnRpbnVvdXMgYW5jaG9ycyB0byBub3QgcmVwYWludCBwcm9wZXJseS5cbiAgICAgICAgICAgIC8vIGZpeCB0aGlzLiBkbyBub3QganVzdCB0YWtlIG91dCB0aGUgdGltZXN0YW1wLiBpdCBydW5zIGEgbG90IGZhc3RlciB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgdGltZXN0YW1wIGluY2x1ZGVkLlxuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IF90aW1lc3RhbXAoKSwgZWxJZDtcblxuICAgICAgICAgICAgZm9yIChlbElkIGluIGVuZHBvaW50c0J5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UudXBkYXRlT2Zmc2V0KHsgZWxJZDogZWxJZCwgcmVjYWxjOiB0cnVlLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChlbElkIGluIGVuZHBvaW50c0J5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF9kcmF3KGVsSWQsIG51bGwsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsRW5kcG9pbnRzID0gZnVuY3Rpb24gKGVsLCByZWN1cnNlLCBhZmZlY3RlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICBhZmZlY3RlZEVsZW1lbnRzID0gYWZmZWN0ZWRFbGVtZW50cyB8fCBbXTtcbiAgICAgICAgICAgIHZhciBfb25lID0gZnVuY3Rpb24gKF9lbCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gX2luZm8oX2VsKSxcbiAgICAgICAgICAgICAgICAgICAgZWJlID0gZW5kcG9pbnRzQnlFbGVtZW50W2luZm8uaWRdLFxuICAgICAgICAgICAgICAgICAgICBpLCBpaTtcblxuICAgICAgICAgICAgICAgIGlmIChlYmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFbGVtZW50cy5wdXNoKGluZm8pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGViZS5sZW5ndGg7IGkgPCBpaTsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5kZWxldGVFbmRwb2ludChlYmVbaV0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVuZHBvaW50c0J5RWxlbWVudFtpbmZvLmlkXTtcblxuICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmVsICYmIGluZm8uZWwubm9kZVR5cGUgIT0gMyAmJiBpbmZvLmVsLm5vZGVUeXBlICE9IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gaW5mby5lbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb25lKGluZm8uZWwuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfb25lKGVsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZG9SZW1vdmUgPSBmdW5jdGlvbihpbmZvLCBhZmZlY3RlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnJlbW92ZUFsbEVuZHBvaW50cyhpbmZvLmlkLCB0cnVlLCBhZmZlY3RlZEVsZW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBfb25lID0gZnVuY3Rpb24oX2luZm8pIHtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmdldERyYWdNYW5hZ2VyKCkuZWxlbWVudFJlbW92ZWQoX2luZm8uaWQpO1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5jbGVhckZvcihfaW5mby5pZCk7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5hbmNob3JNYW5hZ2VyLnJlbW92ZUZsb2F0aW5nQ29ubmVjdGlvbihfaW5mby5pZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2N1cnJlbnRJbnN0YW5jZS5pc1NvdXJjZShfaW5mby5lbCkpIF9jdXJyZW50SW5zdGFuY2UudW5tYWtlU291cmNlKF9pbmZvLmVsKTtcbiAgICAgICAgICAgICAgICBpZiAoX2N1cnJlbnRJbnN0YW5jZS5pc1RhcmdldChfaW5mby5lbCkpIF9jdXJyZW50SW5zdGFuY2UudW5tYWtlVGFyZ2V0KF9pbmZvLmVsKTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlc3Ryb3lEcmFnZ2FibGUoX2luZm8uZWwpO1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZGVzdHJveURyb3BwYWJsZShfaW5mby5lbCk7XG5cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBfY3VycmVudEluc3RhbmNlLmZsb2F0aW5nQ29ubmVjdGlvbnNbX2luZm8uaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkRWxlbWVudHNbX2luZm8uaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvZmZzZXRzW19pbmZvLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAoX2luZm8uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5yZW1vdmVFbGVtZW50KF9pbmZvLmVsKTtcbiAgICAgICAgICAgICAgICAgICAgX2luZm8uZWwuX2pzUGx1bWIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgYWZmZWN0ZWQgY2hpbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGZvciAodmFyIGFlID0gMTsgYWUgPCBhZmZlY3RlZEVsZW1lbnRzLmxlbmd0aDsgYWUrKykge1xuICAgICAgICAgICAgICAgIF9vbmUoYWZmZWN0ZWRFbGVtZW50c1thZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5kIGFsd2F5cyByZW1vdmUgdGhlIHJlcXVlc3RlZCBvbmUgZnJvbSB0aGUgZG9tLlxuICAgICAgICAgICAgX29uZShpbmZvKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBlbGVtZW50LCBpbmNsdWRpbmcgY2xlYW5pbmcgdXAgYWxsIGVuZHBvaW50cyByZWdpc3RlcmVkIGZvciBpdC5cbiAgICAgICAgICogVGhpcyBpcyBleHBvc2VkIGluIHRoZSBwdWJsaWMgQVBJIGJ1dCBhbHNvIHVzZWQgaW50ZXJuYWxseSBieSBqc1BsdW1iIHdoZW4gcmVtb3ZpbmcgdGhlXG4gICAgICAgICAqIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGEgY29ubmVjdGlvbiBkcmFnLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAoZWwsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBfaW5mbyhlbCksIGFmZmVjdGVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChpbmZvLnRleHQpIHtcbiAgICAgICAgICAgICAgICBpbmZvLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5mby5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmZvLmlkKSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kb1JlbW92ZShpbmZvLCBhZmZlY3RlZEVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9LCBkb05vdFJlcGFpbnQgPT09IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZW1wdHkgPSBmdW5jdGlvbiAoZWwsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBfb25lID0gZnVuY3Rpb24oZWwsIGRvbnRSZW1vdmVGb2N1cykge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gX2luZm8oZWwpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGluZm8uZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmZvLmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGluZm8uZWwuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfb25lKGluZm8uZWwuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb250UmVtb3ZlRm9jdXMpIF9kb1JlbW92ZShpbmZvLCBhZmZlY3RlZEVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmJhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF9vbmUoZWwsIHRydWUpO1xuICAgICAgICAgICAgfSwgZG9Ob3RSZXBhaW50ID09PSBmYWxzZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnNpbGVudGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UucmVtb3ZlQWxsR3JvdXBzKCk7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5yZW1vdmVHcm91cE1hbmFnZXIoKTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlbGV0ZUV2ZXJ5RW5kcG9pbnQoKTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnVuYmluZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9SZXNldCkgdGhpcy5kb1Jlc2V0KCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfY2xlYXJPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmNhbnZhcyAmJiBvYmouY2FudmFzLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgb2JqLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jYW52YXMpO1xuICAgICAgICAgICAgb2JqLmNsZWFudXAoKTtcbiAgICAgICAgICAgIG9iai5kZXN0cm95KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2Uuc2VsZWN0KCkuZWFjaChfY2xlYXJPYmplY3QpO1xuICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZWxlY3RFbmRwb2ludHMoKS5lYWNoKF9jbGVhck9iamVjdCk7XG5cbiAgICAgICAgICAgIGVuZHBvaW50c0J5RWxlbWVudCA9IHt9O1xuICAgICAgICAgICAgZW5kcG9pbnRzQnlVVUlEID0ge307XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXREZWZhdWx0U2NvcGUgPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgICAgIERFRkFVTFRfU0NPUEUgPSBzY29wZTtcbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNldHMgd2hldGhlciBvciBub3Qgc29tZSBlbGVtZW50IHNob3VsZCBiZSBjdXJyZW50bHkgZHJhZ2dhYmxlLlxuICAgICAgICB0aGlzLnNldERyYWdnYWJsZSA9IF9zZXREcmFnZ2FibGU7XG5cbiAgICAgICAgdGhpcy5kZXJpdmVFbmRwb2ludEFuZEFuY2hvclNwZWMgPSBmdW5jdGlvbih0eXBlLCBkb250UHJlcGVuZERlZmF1bHQpIHtcbiAgICAgICAgICAgIHZhciBiaXRzID0gKChkb250UHJlcGVuZERlZmF1bHQgPyBcIlwiIDogXCJkZWZhdWx0IFwiKSArIHR5cGUpLnNwbGl0KC9bXFxzXS8pLCBlcHMgPSBudWxsLCBlcCA9IG51bGwsIGEgPSBudWxsLCBhcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX3QgPSBfY3VycmVudEluc3RhbmNlLmdldFR5cGUoYml0c1tpXSwgXCJjb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIGlmIChfdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3QuZW5kcG9pbnRzKSBlcHMgPSBfdC5lbmRwb2ludHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdC5lbmRwb2ludCkgZXAgPSBfdC5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90LmFuY2hvcnMpIGFzID0gX3QuYW5jaG9ycztcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90LmFuY2hvcikgYSA9IF90LmFuY2hvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBlbmRwb2ludHM6IGVwcyA/IGVwcyA6IFsgZXAsIGVwIF0sIGFuY2hvcnM6IGFzID8gYXMgOiBbYSwgYSBdfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXRzIHRoZSBpZCBvZiBzb21lIGVsZW1lbnQsIGNoYW5naW5nIHdoYXRldmVyIHdlIG5lZWQgdG8gdG8ga2VlcCB0cmFjay5cbiAgICAgICAgdGhpcy5zZXRJZCA9IGZ1bmN0aW9uIChlbCwgbmV3SWQsIGRvTm90U2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIGlkO1xuXG4gICAgICAgICAgICBpZiAoX2p1LmlzU3RyaW5nKGVsKSkge1xuICAgICAgICAgICAgICAgIGlkID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMuZ2V0RWxlbWVudChlbCk7XG4gICAgICAgICAgICAgICAgaWQgPSB0aGlzLmdldElkKGVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNDb25ucyA9IHRoaXMuZ2V0Q29ubmVjdGlvbnMoe3NvdXJjZTogaWQsIHNjb3BlOiAnKid9LCB0cnVlKSxcbiAgICAgICAgICAgICAgICB0Q29ubnMgPSB0aGlzLmdldENvbm5lY3Rpb25zKHt0YXJnZXQ6IGlkLCBzY29wZTogJyonfSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIG5ld0lkID0gXCJcIiArIG5ld0lkO1xuXG4gICAgICAgICAgICBpZiAoIWRvTm90U2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgZWwgPSB0aGlzLmdldEVsZW1lbnQoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGVsLCBcImlkXCIsIG5ld0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMuZ2V0RWxlbWVudChuZXdJZCk7XG5cbiAgICAgICAgICAgIGVuZHBvaW50c0J5RWxlbWVudFtuZXdJZF0gPSBlbmRwb2ludHNCeUVsZW1lbnRbaWRdIHx8IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcG9pbnRzQnlFbGVtZW50W25ld0lkXS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnRzQnlFbGVtZW50W25ld0lkXVtpXS5zZXRFbGVtZW50SWQobmV3SWQpO1xuICAgICAgICAgICAgICAgIGVuZHBvaW50c0J5RWxlbWVudFtuZXdJZF1baV0uc2V0UmVmZXJlbmNlRWxlbWVudChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgZW5kcG9pbnRzQnlFbGVtZW50W2lkXTtcblxuICAgICAgICAgICAgdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zW25ld0lkXSA9IHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9uc1tpZF07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zW2lkXTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1tuZXdJZF0gPSB0aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnNbaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1tpZF07XG5cbiAgICAgICAgICAgIHRoaXMuYW5jaG9yTWFuYWdlci5jaGFuZ2VJZChpZCwgbmV3SWQpO1xuICAgICAgICAgICAgdGhpcy5nZXREcmFnTWFuYWdlcigpLmNoYW5nZUlkKGlkLCBuZXdJZCk7XG4gICAgICAgICAgICBtYW5hZ2VkRWxlbWVudHNbbmV3SWRdID0gbWFuYWdlZEVsZW1lbnRzW2lkXTtcbiAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkRWxlbWVudHNbaWRdO1xuXG4gICAgICAgICAgICB2YXIgX2Nvbm5zID0gZnVuY3Rpb24gKGxpc3QsIGVwSWR4LCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGlzdC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RbaV0uZW5kcG9pbnRzW2VwSWR4XS5zZXRFbGVtZW50SWQobmV3SWQpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0W2ldLmVuZHBvaW50c1tlcElkeF0uc2V0UmVmZXJlbmNlRWxlbWVudChlbCk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RbaV1bdHlwZSArIFwiSWRcIl0gPSBuZXdJZDtcbiAgICAgICAgICAgICAgICAgICAgbGlzdFtpXVt0eXBlXSA9IGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29ubnMoc0Nvbm5zLCAwLCBcInNvdXJjZVwiKTtcbiAgICAgICAgICAgIF9jb25ucyh0Q29ubnMsIDEsIFwidGFyZ2V0XCIpO1xuXG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQobmV3SWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0RGVidWdMb2cgPSBmdW5jdGlvbiAoZGVidWdMb2cpIHtcbiAgICAgICAgICAgIGxvZyA9IGRlYnVnTG9nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0U3VzcGVuZERyYXdpbmcgPSBmdW5jdGlvbiAodmFsLCByZXBhaW50QWZ0ZXJ3YXJkcykge1xuICAgICAgICAgICAgdmFyIGN1clZhbCA9IF9zdXNwZW5kRHJhd2luZztcbiAgICAgICAgICAgIF9zdXNwZW5kRHJhd2luZyA9IHZhbDtcbiAgICAgICAgICAgIGlmICh2YWwpIF9zdXNwZW5kZWRBdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpOyBlbHNlIF9zdXNwZW5kZWRBdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwYWludEFmdGVyd2FyZHMpIHRoaXMucmVwYWludEV2ZXJ5dGhpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiBjdXJWYWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBkcmF3aW5nIGlzIGN1cnJlbnRseSBzdXNwZW5kZWQuXG4gICAgICAgIHRoaXMuaXNTdXNwZW5kRHJhd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VzcGVuZERyYXdpbmc7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmV0dXJuIHRpbWVzdGFtcCBmb3Igd2hlbiBkcmF3aW5nIHdhcyBzdXNwZW5kZWQuXG4gICAgICAgIHRoaXMuZ2V0U3VzcGVuZGVkQXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1c3BlbmRlZEF0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYmF0Y2ggPSBmdW5jdGlvbiAoZm4sIGRvTm90UmVwYWludEFmdGVyd2FyZHMpIHtcbiAgICAgICAgICAgIHZhciBfd2FzU3VzcGVuZGVkID0gdGhpcy5pc1N1c3BlbmREcmF3aW5nKCk7XG4gICAgICAgICAgICBpZiAoIV93YXNTdXNwZW5kZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdXNwZW5kRHJhd2luZyh0cnVlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX2p1LmxvZyhcIkZ1bmN0aW9uIHJ1biB3aGlsZSBzdXNwZW5kZWQgZmFpbGVkXCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfd2FzU3VzcGVuZGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3VzcGVuZERyYXdpbmcoZmFsc2UsICFkb05vdFJlcGFpbnRBZnRlcndhcmRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRvV2hpbGVTdXNwZW5kZWQgPSB0aGlzLmJhdGNoO1xuXG4gICAgICAgIHRoaXMuZ2V0Q2FjaGVkRGF0YSA9IF9nZXRDYWNoZWREYXRhO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IF90aW1lc3RhbXA7XG4gICAgICAgIHRoaXMuc2hvdyA9IGZ1bmN0aW9uIChlbCwgY2hhbmdlRW5kcG9pbnRzKSB7XG4gICAgICAgICAgICBfc2V0VmlzaWJsZShlbCwgXCJibG9ja1wiLCBjaGFuZ2VFbmRwb2ludHMpO1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIHRoaXMgbWV0aG9kIHRvIHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgICAgdGhpcy50b2dnbGVWaXNpYmxlID0gX3RvZ2dsZVZpc2libGU7XG4gICAgICAgIHRoaXMudG9nZ2xlRHJhZ2dhYmxlID0gX3RvZ2dsZURyYWdnYWJsZTtcbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lciA9IHRoaXMuYmluZDtcbiAgICB9O1xuXG4gICAgX2p1LmV4dGVuZChyb290LmpzUGx1bWJJbnN0YW5jZSwgX2p1LkV2ZW50R2VuZXJhdG9yLCB7XG4gICAgICAgIHNldEF0dHJpYnV0ZTogZnVuY3Rpb24gKGVsLCBhLCB2KSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShlbCwgYSwgdik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKGVsLCBhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUocm9vdC5qc1BsdW1iLmdldEVsZW1lbnQoZWwpLCBhKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydFRvRnVsbE92ZXJsYXlTcGVjOiBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgICAgICBpZiAoX2p1LmlzU3RyaW5nKHNwZWMpKSB7XG4gICAgICAgICAgICAgICAgc3BlYyA9IFsgc3BlYywgeyB9IF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGVjWzFdLmlkID0gc3BlY1sxXS5pZCB8fCBfanUudXVpZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVyQ29ubmVjdGlvblR5cGU6IGZ1bmN0aW9uIChpZCwgdHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvblR5cGVzW2lkXSA9IHJvb3QuanNQbHVtYi5leHRlbmQoe30sIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHR5cGUub3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUub3ZlcmxheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSBzdHJpbmcsIGNvbnZlcnQgdG8gb2JqZWN0IHJlcHJlc2VudGF0aW9uIHNvIHRoYXQgd2UgY2FuIHN0b3JlIHRoZSB0eXBlaWQgb24gaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYXNzaWduIGFuIGlkLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZm8gPSB0aGlzLmNvbnZlcnRUb0Z1bGxPdmVybGF5U3BlYyh0eXBlLm92ZXJsYXlzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdG9bZm9bMV0uaWRdID0gZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25UeXBlc1tpZF0ub3ZlcmxheXMgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJDb25uZWN0aW9uVHlwZXM6IGZ1bmN0aW9uICh0eXBlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0eXBlcylcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblR5cGUoaSwgdHlwZXNbaV0pO1xuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlckVuZHBvaW50VHlwZTogZnVuY3Rpb24gKGlkLCB0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmRwb2ludFR5cGVzW2lkXSA9IHJvb3QuanNQbHVtYi5leHRlbmQoe30sIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHR5cGUub3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUub3ZlcmxheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSBzdHJpbmcsIGNvbnZlcnQgdG8gb2JqZWN0IHJlcHJlc2VudGF0aW9uIHNvIHRoYXQgd2UgY2FuIHN0b3JlIHRoZSB0eXBlaWQgb24gaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYXNzaWduIGFuIGlkLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZm8gPSB0aGlzLmNvbnZlcnRUb0Z1bGxPdmVybGF5U3BlYyh0eXBlLm92ZXJsYXlzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdG9bZm9bMV0uaWRdID0gZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZHBvaW50VHlwZXNbaWRdLm92ZXJsYXlzID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVyRW5kcG9pbnRUeXBlczogZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHR5cGVzKVxuICAgICAgICAgICAgICAgIC8vdGhpcy5fZW5kcG9pbnRUeXBlc1tpXSA9IGpzUGx1bWIuZXh0ZW5kKHt9LCB0eXBlc1tpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlckVuZHBvaW50VHlwZShpLCB0eXBlc1tpXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uIChpZCwgdHlwZURlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlRGVzY3JpcHRvciA9PT0gXCJjb25uZWN0aW9uXCIgPyB0aGlzLl9jb25uZWN0aW9uVHlwZXNbaWRdIDogdGhpcy5fZW5kcG9pbnRUeXBlc1tpZF07XG4gICAgICAgIH0sXG4gICAgICAgIHNldElkQ2hhbmdlZDogZnVuY3Rpb24gKG9sZElkLCBuZXdJZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRJZChvbGRJZCwgbmV3SWQsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBzZXQgcGFyZW50OiBjaGFuZ2UgdGhlIHBhcmVudCBmb3Igc29tZSBub2RlIGFuZCB1cGRhdGUgYWxsIHRoZSByZWdpc3RyYXRpb25zIHdlIG5lZWQgdG8uXG4gICAgICAgIHNldFBhcmVudDogZnVuY3Rpb24gKGVsLCBuZXdQYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBfZG9tID0gdGhpcy5nZXRFbGVtZW50KGVsKSxcbiAgICAgICAgICAgICAgICBfaWQgPSB0aGlzLmdldElkKF9kb20pLFxuICAgICAgICAgICAgICAgIF9wZG9tID0gdGhpcy5nZXRFbGVtZW50KG5ld1BhcmVudCksXG4gICAgICAgICAgICAgICAgX3BpZCA9IHRoaXMuZ2V0SWQoX3Bkb20pO1xuXG4gICAgICAgICAgICBfZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX2RvbSk7XG4gICAgICAgICAgICBfcGRvbS5hcHBlbmRDaGlsZChfZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0RHJhZ01hbmFnZXIoKS5zZXRQYXJlbnQoX2RvbSwgX2lkLCBfcGRvbSwgX3BpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG8xLCBvMiwgbmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgaWYgKG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBvMVtuYW1lc1tpXV0gPSBvMltuYW1lc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChpIGluIG8yKSBvMVtpXSA9IG8yW2ldO1xuICAgICAgICAgICAgcmV0dXJuIG8xO1xuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZ0Nvbm5lY3Rpb25zOiB7fSxcbiAgICAgICAgZ2V0RmxvYXRpbmdBbmNob3JJbmRleDogZnVuY3Rpb24gKGpwYykge1xuICAgICAgICAgICAgcmV0dXJuIGpwYy5lbmRwb2ludHNbMF0uaXNGbG9hdGluZygpID8gMCA6IGpwYy5lbmRwb2ludHNbMV0uaXNGbG9hdGluZygpID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgfSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBzdGF0aWMgaW5zdGFuY2UgKyBBTUQgcmVnaXN0cmF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdFxuXG4vLyBjcmVhdGUgc3RhdGljIGluc3RhbmNlIGFuZCBhc3NpZ24gdG8gd2luZG93IGlmIHdpbmRvdyBleGlzdHMuXHRcbiAgICB2YXIganNQbHVtYiA9IG5ldyBqc1BsdW1iSW5zdGFuY2UoKTtcbiAgICAvLyByZWdpc3RlciBvbiAncm9vdCcgKGxldHMgdXMgcnVuIG9uIHNlcnZlciBvciBicm93c2VyKVxuICAgIHJvb3QuanNQbHVtYiA9IGpzUGx1bWI7XG4gICAgLy8gYWRkICdnZXRJbnN0YW5jZScgbWV0aG9kIHRvIHN0YXRpYyBpbnN0YW5jZVxuICAgIGpzUGx1bWIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoX2RlZmF1bHRzKSB7XG4gICAgICAgIHZhciBqID0gbmV3IGpzUGx1bWJJbnN0YW5jZShfZGVmYXVsdHMpO1xuICAgICAgICBqLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIGo7XG4gICAgfTtcbiAgICBqc1BsdW1iLmVhY2ggPSBmdW5jdGlvbiAoc3BlYywgZm4pIHtcbiAgICAgICAgaWYgKHNwZWMgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBmbihqc1BsdW1iLmdldEVsZW1lbnQoc3BlYykpO1xuICAgICAgICBlbHNlIGlmIChzcGVjLmxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgZm4oanNQbHVtYi5nZXRFbGVtZW50KHNwZWNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmbihzcGVjKTsgLy8gYXNzdW1lIGl0J3MgYW4gZWxlbWVudC5cbiAgICB9O1xuLy8gbWF5YmUgcmVnaXN0ZXIgc3RhdGljIGluc3RhbmNlIGFzIGFuIEFNRCBtb2R1bGUsIGFuZCBnZXRJbnN0YW5jZSBtZXRob2QgdG9vLlxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZGVmaW5lKFwianNwbHVtYlwiLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzUGx1bWI7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbmUoXCJqc3BsdW1iaW5zdGFuY2VcIiwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBqc1BsdW1iLmdldEluc3RhbmNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDb21tb25KU1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZXhwb3J0cy5qc1BsdW1iID0ganNQbHVtYjtcbiAgICB9XG5cbiAgICAvLyBucG1cbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGpzUGx1bWI7XG4gICAgfVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gZW5kIHN0YXRpYyBpbnN0YW5jZSArIEFNRCByZWdpc3RyYXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx0XHRcblxufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuXG4vKlxuICoganNQbHVtYlxuICpcbiAqIFRpdGxlOmpzUGx1bWIgMi4xLjBcbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byB2aXN1YWxseSBjb25uZWN0IGVsZW1lbnRzIG9uIGFuIEhUTUwgcGFnZSwgdXNpbmcgU1ZHLlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgYmFzZSBmdW5jdGlvbmFsaXR5IGZvciBET00gdHlwZSBhZGFwdGVycy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE2IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqXG4gKiBodHRwOi8vanNwbHVtYnRvb2xraXQuY29tXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9zcG9ycml0dC9qc3BsdW1iXG4gKlxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG47XG4oZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHJvb3QgPSB0aGlzLCBfanUgPSByb290LmpzUGx1bWJVdGlsO1xuXG4gICAgdmFyIHN2Z0F2YWlsYWJsZSA9ICEhd2luZG93LlNWR0FuZ2xlIHx8IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlXCIsIFwiMS4xXCIpLFxuXG4gICAgICAgIF9nZW5Mb2MgPSBmdW5jdGlvbiAoZSwgcHJlZml4KSB7XG4gICAgICAgICAgICBpZiAoZSA9PSBudWxsKSByZXR1cm4gWyAwLCAwIF07XG4gICAgICAgICAgICB2YXIgdHMgPSBfdG91Y2hlcyhlKSwgdCA9IF9nZXRUb3VjaCh0cywgMCk7XG4gICAgICAgICAgICByZXR1cm4gW3RbcHJlZml4ICsgXCJYXCJdLCB0W3ByZWZpeCArIFwiWVwiXV07XG4gICAgICAgIH0sXG4gICAgICAgIF9wYWdlTG9jYXRpb24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCkgcmV0dXJuIFsgMCwgMCBdO1xuICAgICAgICAgICAgcmV0dXJuIF9nZW5Mb2MoZSwgXCJwYWdlXCIpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NyZWVuTG9jYXRpb24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZW5Mb2MoZSwgXCJzY3JlZW5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIF9jbGllbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dlbkxvYyhlLCBcImNsaWVudFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFRvdWNoID0gZnVuY3Rpb24gKHRvdWNoZXMsIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdWNoZXMuaXRlbSA/IHRvdWNoZXMuaXRlbShpZHgpIDogdG91Y2hlc1tpZHhdO1xuICAgICAgICB9LFxuICAgICAgICBfdG91Y2hlcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAwID8gZS50b3VjaGVzIDpcbiAgICAgICAgICAgICAgICAgICAgZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDAgPyBlLmNoYW5nZWRUb3VjaGVzIDpcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAwID8gZS50YXJnZXRUb3VjaGVzIDpcbiAgICAgICAgICAgICAgICBbIGUgXTtcbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICBNYW5hZ2VzIGRyYWdnaW5nIGZvciBzb21lIGluc3RhbmNlIG9mIGpzUGx1bWIuXG5cbiAgICAgVE9ETyBpbnN0ZWFkIG9mIHRoaXMgYmVpbmcgYWNjZXNzZWQgZGlyZWN0bHksIGl0IHNob3VsZCBzdWJzY3JpYmUgdG8gZXZlbnRzIG9uIHRoZSBqc1BsdW1iIGluc3RhbmNlOiBldmVyeSBtZXRob2RcbiAgICAgaW4gaGVyZSBpcyBjYWxsZWQgZGlyZWN0bHkgYnkganNQbHVtYi4gQnV0IHdoYXQgc2hvdWxkIGhhcHBlbiBpcyB0aGF0IHdlIGhhdmUgdW5wdWJsaXNoZWQgZXZlbnRzIHRoYXQgdGhpcyBsaXN0ZW5zXG4gICAgIHRvLiAgVGhlIG9ubHkgdHJpY2sgaXMgZ2V0dGluZyBvbmUgb2YgdGhlc2UgaW5zdGFudGlhdGVkIHdpdGggZXZlcnkganNQbHVtYiBpbnN0YW5jZTogaXQgbmVlZHMgdG8gaGF2ZSBhIGhvb2sgc29tZWhvdy5cbiAgICAgQmFzaWNhbGx5IHRoZSBnZW5lcmFsIGlkZWEgaXMgdG8gcHVsbCBBTEwgdGhlIGRyYWcgY29kZSBvdXQgKHByb3RvdHlwZSBtZXRob2QgcmVnaXN0cmF0aW9ucyBwbHVzIHRoaXMpIGludG8gYVxuICAgICBkZWRpY2F0ZWQgZHJhZyBzY3JpcHQpLCB0aGF0IGRvZXMgbm90IG5lY2Vzc2FyaWx5IG5lZWQgdG8gYmUgaW5jbHVkZWQuXG5cblxuICAgICAqL1xuICAgIHZhciBEcmFnTWFuYWdlciA9IGZ1bmN0aW9uIChfY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAgIHZhciBfZHJhZ2dhYmxlcyA9IHt9LCBfZGxpc3QgPSBbXSwgX2RlbGVtZW50cyA9IHt9LCBfZWxlbWVudHNXaXRoRW5kcG9pbnRzID0ge30sXG4gICAgICAgIC8vIGVsZW1lbnRpZHMgbWFwcGVkIHRvIHRoZSBkcmFnZ2FibGUgdG8gd2hpY2ggdGhleSBiZWxvbmcuXG4gICAgICAgICAgICBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICByZWdpc3RlciBzb21lIGVsZW1lbnQgYXMgZHJhZ2dhYmxlLiAgcmlnaHQgbm93IHRoZSBkcmFnIGluaXQgc3R1ZmYgaXMgZG9uZSBlbHNld2hlcmUsIGFuZCBpdCBpc1xuICAgICAgICAgcG9zc2libGUgdGhhdCB3aWxsIGNvbnRpbnVlIHRvIGJlIHRoZSBjYXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGlkID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRJZChlbCksXG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRPZmZzZXQoZWwpO1xuXG4gICAgICAgICAgICBpZiAoIV9kcmFnZ2FibGVzW2lkXSkge1xuICAgICAgICAgICAgICAgIF9kcmFnZ2FibGVzW2lkXSA9IGVsO1xuICAgICAgICAgICAgICAgIF9kbGlzdC5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICBfZGVsZW1lbnRzW2lkXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb29rIGZvciBjaGlsZCBlbGVtZW50cyB0aGF0IGhhdmUgZW5kcG9pbnRzIGFuZCByZWdpc3RlciB0aGVtIGFnYWluc3QgdGhpcyBkcmFnZ2FibGUuXG4gICAgICAgICAgICB2YXIgX29uZUxldmVsID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSAhPSAzICYmIHAuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSAhPSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNFbCA9IGpzUGx1bWIuZ2V0RWxlbWVudChwLmNoaWxkTm9kZXNbaV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaWQgPSBfY3VycmVudEluc3RhbmNlLmdldElkKHAuY2hpbGROb2Rlc1tpXSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNpZCAmJiBfZWxlbWVudHNXaXRoRW5kcG9pbnRzW2NpZF0gJiYgX2VsZW1lbnRzV2l0aEVuZHBvaW50c1tjaWRdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY09mZiA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0T2Zmc2V0KGNFbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZWxlbWVudHNbaWRdW2NpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogY2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY09mZi5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjT2ZmLnRvcCAtIHBhcmVudE9mZnNldC50b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tjaWRdID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vbmVMZXZlbChwLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX29uZUxldmVsKGVsKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZWZyZXNoIHRoZSBvZmZzZXRzIGZvciBjaGlsZCBlbGVtZW50cyBvZiB0aGlzIGVsZW1lbnQuXG4gICAgICAgIHRoaXMudXBkYXRlT2Zmc2V0cyA9IGZ1bmN0aW9uIChlbElkLCBjaGlsZE9mZnNldE92ZXJyaWRlcykge1xuICAgICAgICAgICAgaWYgKGVsSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkT2Zmc2V0T3ZlcnJpZGVzID0gY2hpbGRPZmZzZXRPdmVycmlkZXMgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIGRvbUVsID0ganNQbHVtYi5nZXRFbGVtZW50KGVsSWQpLFxuICAgICAgICAgICAgICAgICAgICBpZCA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0SWQoZG9tRWwpLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IF9kZWxlbWVudHNbaWRdLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSBfY3VycmVudEluc3RhbmNlLmdldE9mZnNldChkb21FbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbCA9IGpzUGx1bWIuZ2V0RWxlbWVudChpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY09mZiA9IGNoaWxkT2Zmc2V0T3ZlcnJpZGVzW2ldIHx8IF9jdXJyZW50SW5zdGFuY2UuZ2V0T2Zmc2V0KGNlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgdXBkYXRlIGlmIHdlIGhhdmUgYSB2YWx1ZSBhbHJlYWR5IGFuZCB3ZSdkIGp1c3QgYmUgd3JpdGluZyAwLDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsLm9mZnNldFBhcmVudCA9PSBudWxsICYmIF9kZWxlbWVudHNbaWRdW2ldICE9IG51bGwpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlbGVtZW50c1tpZF1baV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNPZmYubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjT2ZmLnRvcCAtIHBhcmVudE9mZnNldC50b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tpXSA9IGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgbm90aWZpY2F0aW9uIHRoYXQgYW4gZW5kcG9pbnQgd2FzIGFkZGVkIHRvIHRoZSBnaXZlbiBlbC4gIHdlIGdvIHVwIGZyb20gdGhhdCBlbCdzIHBhcmVudFxuICAgICAgICAgbm9kZSwgbG9va2luZyBmb3IgYSBwYXJlbnQgdGhhdCBoYXMgYmVlbiByZWdpc3RlcmVkIGFzIGEgZHJhZ2dhYmxlLiBpZiB3ZSBmaW5kIG9uZSwgd2UgYWRkIHRoaXNcbiAgICAgICAgIGVsIHRvIHRoYXQgcGFyZW50J3MgbGlzdCBvZiBlbGVtZW50cyB0byB1cGRhdGUgb24gZHJhZyAoaWYgaXQgaXMgbm90IHRoZXJlIGFscmVhZHkpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuZHBvaW50QWRkZWQgPSBmdW5jdGlvbiAoZWwsIGlkKSB7XG5cbiAgICAgICAgICAgIGlkID0gaWQgfHwgX2N1cnJlbnRJbnN0YW5jZS5nZXRJZChlbCk7XG5cbiAgICAgICAgICAgIHZhciBiID0gZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgICAgICBwID0gZWwucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgX2VsZW1lbnRzV2l0aEVuZHBvaW50c1tpZF0gPSBfZWxlbWVudHNXaXRoRW5kcG9pbnRzW2lkXSA/IF9lbGVtZW50c1dpdGhFbmRwb2ludHNbaWRdICsgMSA6IDE7XG5cbiAgICAgICAgICAgIHdoaWxlIChwICE9IG51bGwgJiYgcCAhPSBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpZCA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0SWQocCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBpZCAmJiBfZHJhZ2dhYmxlc1twaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwTG9jID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRPZmZzZXQocCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kZWxlbWVudHNbcGlkXVtpZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNMb2MgPSBfY3VycmVudEluc3RhbmNlLmdldE9mZnNldChlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVsZW1lbnRzW3BpZF1baWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY0xvYy5sZWZ0IC0gcExvYy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGNMb2MudG9wIC0gcExvYy50b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tpZF0gPSBwaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBwLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5lbmRwb2ludERlbGV0ZWQgPSBmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIGlmIChfZWxlbWVudHNXaXRoRW5kcG9pbnRzW2VuZHBvaW50LmVsZW1lbnRJZF0pIHtcbiAgICAgICAgICAgICAgICBfZWxlbWVudHNXaXRoRW5kcG9pbnRzW2VuZHBvaW50LmVsZW1lbnRJZF0tLTtcbiAgICAgICAgICAgICAgICBpZiAoX2VsZW1lbnRzV2l0aEVuZHBvaW50c1tlbmRwb2ludC5lbGVtZW50SWRdIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBfZGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RlbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBfZGVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9kZWxlbWVudHNbaV1bZW5kcG9pbnQuZWxlbWVudElkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tlbmRwb2ludC5lbGVtZW50SWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY2hhbmdlSWQgPSBmdW5jdGlvbiAob2xkSWQsIG5ld0lkKSB7XG4gICAgICAgICAgICBfZGVsZW1lbnRzW25ld0lkXSA9IF9kZWxlbWVudHNbb2xkSWRdO1xuICAgICAgICAgICAgX2RlbGVtZW50c1tvbGRJZF0gPSB7fTtcbiAgICAgICAgICAgIF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbbmV3SWRdID0gX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tvbGRJZF07XG4gICAgICAgICAgICBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW29sZElkXSA9IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRFbGVtZW50c0ZvckRyYWdnYWJsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9kZWxlbWVudHNbaWRdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZWxlbWVudFJlbW92ZWQgPSBmdW5jdGlvbiAoZWxlbWVudElkKSB7XG4gICAgICAgICAgICB2YXIgZWxJZCA9IF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbZWxlbWVudElkXTtcbiAgICAgICAgICAgIGlmIChlbElkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9kZWxlbWVudHNbZWxJZF1bZWxlbWVudElkXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tlbGVtZW50SWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfZHJhZ2dhYmxlcyA9IHt9O1xuICAgICAgICAgICAgX2RsaXN0ID0gW107XG4gICAgICAgICAgICBfZGVsZW1lbnRzID0ge307XG4gICAgICAgICAgICBfZWxlbWVudHNXaXRoRW5kcG9pbnRzID0ge307XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbm90aWZpY2F0aW9uIGRyYWcgZW5kZWQuIFdlIGNoZWNrIGF1dG9tYXRpY2FsbHkgaWYgbmVlZCB0byB1cGRhdGUgc29tZVxuICAgICAgICAvLyBhbmNlc3RvcidzIG9mZnNldHMuXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZHJhZ0VuZGVkID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwub2Zmc2V0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfY3VycmVudEluc3RhbmNlLmdldElkKGVsKSxcbiAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3IgPSBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2lkXTtcblxuICAgICAgICAgICAgICAgIGlmIChhbmNlc3RvcikgdGhpcy51cGRhdGVPZmZzZXRzKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldFBhcmVudCA9IGZ1bmN0aW9uIChlbCwgZWxJZCwgcCwgcElkLCBjdXJyZW50Q2hpbGRMb2NhdGlvbikge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2VsSWRdO1xuICAgICAgICAgICAgaWYgKCFfZGVsZW1lbnRzW3BJZF0pIHtcbiAgICAgICAgICAgICAgICBfZGVsZW1lbnRzW3BJZF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwTG9jID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRPZmZzZXQocCksXG4gICAgICAgICAgICAgICAgY0xvYyA9IGN1cnJlbnRDaGlsZExvY2F0aW9uIHx8IF9jdXJyZW50SW5zdGFuY2UuZ2V0T2Zmc2V0KGVsKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9kZWxlbWVudHNbY3VycmVudF1bZWxJZF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9kZWxlbWVudHNbcElkXVtlbElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDplbElkLFxuICAgICAgICAgICAgICAgIG9mZnNldCA6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY0xvYy5sZWZ0IC0gcExvYy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IGNMb2MudG9wIC0gcExvYy50b3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tlbElkXSA9IHBJZDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNsZWFyUGFyZW50ID0gZnVuY3Rpb24oZWwsIGVsSWQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tlbElkXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9kZWxlbWVudHNbY3VycmVudF1bZWxJZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbZWxJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXZhbGlkYXRlUGFyZW50ID0gZnVuY3Rpb24oZWwsIGVsSWQsIGNoaWxkT2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbZWxJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjbyA9IHt9O1xuICAgICAgICAgICAgICAgIGNvW2VsSWRdID0gY2hpbGRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVPZmZzZXRzKGN1cnJlbnQsIGNvKTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnJldmFsaWRhdGUoY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXREcmFnQW5jZXN0b3IgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBkZSA9IGpzUGx1bWIuZ2V0RWxlbWVudChlbCksXG4gICAgICAgICAgICAgICAgaWQgPSBfY3VycmVudEluc3RhbmNlLmdldElkKGRlKSxcbiAgICAgICAgICAgICAgICBhaWQgPSBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2lkXTtcblxuICAgICAgICAgICAgaWYgKGFpZClcbiAgICAgICAgICAgICAgICByZXR1cm4ganNQbHVtYi5nZXRFbGVtZW50KGFpZCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICB9O1xuXG4gICAgdmFyIHRyaW0gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyID09IG51bGwgPyBudWxsIDogKHN0ci5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKS5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWwsIGNuKSB7XG4gICAgICAgICAgICBjbiA9IHRyaW0oY24pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUuYmFzZVZhbCAhPSBcInVuZGVmaW5lZFwiKSAgLy8gU1ZHXG4gICAgICAgICAgICAgICAgZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBjbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBjbjtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldENsYXNzTmFtZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT0gXCJ1bmRlZmluZWRcIikgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgX2NsYXNzTWFuaXAgPSBmdW5jdGlvbiAoZWwsIGNsYXNzZXNUb0FkZCwgY2xhc3Nlc1RvUmVtb3ZlKSB7XG4gICAgICAgICAgICBjbGFzc2VzVG9BZGQgPSBjbGFzc2VzVG9BZGQgPT0gbnVsbCA/IFtdIDogX2p1LmlzQXJyYXkoY2xhc3Nlc1RvQWRkKSA/IGNsYXNzZXNUb0FkZCA6IGNsYXNzZXNUb0FkZC5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlID0gY2xhc3Nlc1RvUmVtb3ZlID09IG51bGwgPyBbXSA6IF9qdS5pc0FycmF5KGNsYXNzZXNUb1JlbW92ZSkgPyBjbGFzc2VzVG9SZW1vdmUgOiBjbGFzc2VzVG9SZW1vdmUuc3BsaXQoL1xccysvKTtcblxuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IF9nZXRDbGFzc05hbWUoZWwpLFxuICAgICAgICAgICAgICAgIGN1ckNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoL1xccysvKTtcblxuICAgICAgICAgICAgdmFyIF9vbmVTZXQgPSBmdW5jdGlvbiAoYWRkLCBjbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJDbGFzc2VzLmluZGV4T2YoY2xhc3Nlc1tpXSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2xhc3Nlcy5wdXNoKGNsYXNzZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGN1ckNsYXNzZXMuaW5kZXhPZihjbGFzc2VzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggIT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2xhc3Nlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9vbmVTZXQodHJ1ZSwgY2xhc3Nlc1RvQWRkKTtcbiAgICAgICAgICAgIF9vbmVTZXQoZmFsc2UsIGNsYXNzZXNUb1JlbW92ZSk7XG5cbiAgICAgICAgICAgIF9zZXRDbGFzc05hbWUoZWwsIGN1ckNsYXNzZXMuam9pbihcIiBcIikpO1xuICAgICAgICB9O1xuXG4gICAgcm9vdC5qc1BsdW1iLmV4dGVuZChyb290LmpzUGx1bWJJbnN0YW5jZS5wcm90b3R5cGUsIHtcblxuICAgICAgICBoZWFkbGVzczogZmFsc2UsXG5cbiAgICAgICAgcGFnZUxvY2F0aW9uOiBfcGFnZUxvY2F0aW9uLFxuICAgICAgICBzY3JlZW5Mb2NhdGlvbjogX3NjcmVlbkxvY2F0aW9uLFxuICAgICAgICBjbGllbnRMb2NhdGlvbjogX2NsaWVudExvY2F0aW9uLFxuXG4gICAgICAgIGdldERyYWdNYW5hZ2VyOmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ01hbmFnZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdNYW5hZ2VyID0gbmV3IERyYWdNYW5hZ2VyKHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcmFnTWFuYWdlcjtcbiAgICAgICAgfSxcblxuICAgICAgICByZWNhbGN1bGF0ZU9mZnNldHM6ZnVuY3Rpb24oZWxJZCkge1xuICAgICAgICAgICAgdGhpcy5nZXREcmFnTWFuYWdlcigpLnVwZGF0ZU9mZnNldHMoZWxJZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRWxlbWVudDpmdW5jdGlvbih0YWcsIHN0eWxlLCBjbGF6eiwgYXR0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRWxlbWVudE5TKG51bGwsIHRhZywgc3R5bGUsIGNsYXp6LCBhdHRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVFbGVtZW50TlM6ZnVuY3Rpb24obnMsIHRhZywgc3R5bGUsIGNsYXp6LCBhdHRzKSB7XG4gICAgICAgICAgICB2YXIgZSA9IG5zID09IG51bGwgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZykgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHRhZyk7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHN0eWxlID0gc3R5bGUgfHwge307XG4gICAgICAgICAgICBmb3IgKGkgaW4gc3R5bGUpXG4gICAgICAgICAgICAgICAgZS5zdHlsZVtpXSA9IHN0eWxlW2ldO1xuXG4gICAgICAgICAgICBpZiAoY2xhenopXG4gICAgICAgICAgICAgICAgZS5jbGFzc05hbWUgPSBjbGF6ejtcblxuICAgICAgICAgICAgYXR0cyA9IGF0dHMgfHwge307XG4gICAgICAgICAgICBmb3IgKGkgaW4gYXR0cylcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShpLCBcIlwiICsgYXR0c1tpXSk7XG5cbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKGVsLCBhdHROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICE9IG51bGwgPyBlbC5nZXRBdHRyaWJ1dGUoYXR0TmFtZSkgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEF0dHJpYnV0ZTogZnVuY3Rpb24gKGVsLCBhLCB2KSB7XG4gICAgICAgICAgICBpZiAoZWwuc2V0QXR0cmlidXRlICE9IG51bGwpIGVsLnNldEF0dHJpYnV0ZShhLCB2KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoZWwsIGF0dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gYXR0cylcbiAgICAgICAgICAgICAgICBpZiAoYXR0cy5oYXNPd25Qcm9wZXJ0eShpKSkgZWwuc2V0QXR0cmlidXRlKGksIGF0dHNbaV0pO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRUb1Jvb3Q6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRSZW5kZXJNb2RlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFsgXCJzdmdcIiAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q2xhc3M6X2dldENsYXNzTmFtZSxcbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChlbCwgY2xhenopIHtcbiAgICAgICAgICAgIGpzUGx1bWIuZWFjaChlbCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfY2xhc3NNYW5pcChlLCBjbGF6eik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIChlbCwgY2xhenopIHtcbiAgICAgICAgICAgIGVsID0ganNQbHVtYi5nZXRFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QpIHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhenopO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRDbGFzc05hbWUoZWwpLmluZGV4T2YoY2xhenopICE9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKGVsLCBjbGF6eikge1xuICAgICAgICAgICAganNQbHVtYi5lYWNoKGVsLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF9jbGFzc01hbmlwKGUsIG51bGwsIGNsYXp6KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVDbGFzc2VzOiBmdW5jdGlvbiAoZWwsIHRvQWRkLCB0b1JlbW92ZSkge1xuICAgICAgICAgICAganNQbHVtYi5lYWNoKGVsLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF9jbGFzc01hbmlwKGUsIHRvQWRkLCB0b1JlbW92ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q2xhc3M6IGZ1bmN0aW9uIChlbCwgY2xhenopIHtcbiAgICAgICAgICAgIGpzUGx1bWIuZWFjaChlbCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfc2V0Q2xhc3NOYW1lKGUsIGNsYXp6KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKGVsLCBwKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gcC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgZWwuc3R5bGUudG9wID0gcC50b3AgKyBcInB4XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBfb25lID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGVsLnN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2ID8gdi5zdWJzdHJpbmcoMCwgdi5sZW5ndGggLSAyKSA6IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBfb25lKFwibGVmdFwiKSxcbiAgICAgICAgICAgICAgICB0b3A6IF9vbmUoXCJ0b3BcIilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldFN0eWxlOmZ1bmN0aW9uKGVsLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuY3VycmVudFN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRTZWxlY3RvcjogZnVuY3Rpb24gKGN0eCwgc3BlYykge1xuICAgICAgICAgICAgdmFyIHNlbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VsID0gY3R4Lm5vZGVUeXBlICE9IG51bGwgPyBjdHggOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VsID0gY3R4LnF1ZXJ5U2VsZWN0b3JBbGwoc3BlYyk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE9mZnNldDpmdW5jdGlvbihlbCwgcmVsYXRpdmVUb1Jvb3QsIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgZWwgPSBqc1BsdW1iLmdldEVsZW1lbnQoZWwpO1xuICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBlbC5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IGVsLm9mZnNldFRvcFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3AgPSAocmVsYXRpdmVUb1Jvb3QgIHx8IChjb250YWluZXIgIT0gbnVsbCAmJiAoZWwgIT0gY29udGFpbmVyICYmIGVsLm9mZnNldFBhcmVudCAhPSBjb250YWluZXIpKSkgPyAgZWwub2Zmc2V0UGFyZW50IDogbnVsbCxcbiAgICAgICAgICAgICAgICBfbWF5YmVBZGp1c3RTY3JvbGwgPSBmdW5jdGlvbihvZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldFBhcmVudCAhPSBudWxsICYmIG9mZnNldFBhcmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiAob2Zmc2V0UGFyZW50LnNjcm9sbFRvcCA+IDAgfHwgb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmxlZnQgLT0gb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQudG9wIC09IG9mZnNldFBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIHdoaWxlIChvcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0LmxlZnQgKz0gb3Aub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICBvdXQudG9wICs9IG9wLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICBfbWF5YmVBZGp1c3RTY3JvbGwob3ApO1xuICAgICAgICAgICAgICAgIG9wID0gcmVsYXRpdmVUb1Jvb3QgPyBvcC5vZmZzZXRQYXJlbnQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3Aub2Zmc2V0UGFyZW50ID09IGNvbnRhaW5lciA/IG51bGwgOiBvcC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGNvbnRhaW5lciBpcyBzY3JvbGxlZCBhbmQgdGhlIGVsZW1lbnQgKG9yIGl0cyBvZmZzZXQgcGFyZW50KSBpcyBub3QgYWJzb2x1dGUgb3IgZml4ZWQsIGFkanVzdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgIGlmIChjb250YWluZXIgIT0gbnVsbCAmJiAhcmVsYXRpdmVUb1Jvb3QgJiYgKGNvbnRhaW5lci5zY3JvbGxUb3AgPiAwIHx8IGNvbnRhaW5lci5zY3JvbGxMZWZ0ID4gMCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHAgPSBlbC5vZmZzZXRQYXJlbnQgIT0gbnVsbCA/IHRoaXMuZ2V0U3R5bGUoZWwub2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIpIDogXCJzdGF0aWNcIixcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0U3R5bGUoZWwsIFwicG9zaXRpb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKHAgIT09IFwiYWJzb2x1dGVcIiAmJiBwICE9PSBcImZpeGVkXCIgJiYgcHAgIT09IFwiYWJzb2x1dGVcIiAmJiBwcCAhPSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmxlZnQgLT0gY29udGFpbmVyLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIG91dC50b3AgLT0gY29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvL1xuICAgICAgICAvLyByZXR1cm4geCt5IHByb3BvcnRpb24gb2YgdGhlIGdpdmVuIGVsZW1lbnQncyBzaXplIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGxvY2F0aW9uIG9mIHRoZSBnaXZlbiBldmVudC5cbiAgICAgICAgLy9cbiAgICAgICAgZ2V0UG9zaXRpb25PbkVsZW1lbnQ6IGZ1bmN0aW9uIChldnQsIGVsLCB6b29tKSB7XG4gICAgICAgICAgICB2YXIgYm94ID0gdHlwZW9mIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gXCJ1bmRlZmluZWRcIiA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogeyBsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSxcbiAgICAgICAgICAgICAgICBib2R5ID0gZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgICAgICBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgY2xpZW50VG9wID0gZG9jRWxlbS5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMCxcbiAgICAgICAgICAgICAgICBjbGllbnRMZWZ0ID0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwLFxuICAgICAgICAgICAgICAgIHBzdCA9IDAsXG4gICAgICAgICAgICAgICAgcHNsID0gMCxcbiAgICAgICAgICAgICAgICB0b3AgPSBib3gudG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wICsgKHBzdCAqIHpvb20pLFxuICAgICAgICAgICAgICAgIGxlZnQgPSBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0ICsgKHBzbCAqIHpvb20pLFxuICAgICAgICAgICAgICAgIGNsID0ganNQbHVtYi5wYWdlTG9jYXRpb24oZXZ0KSxcbiAgICAgICAgICAgICAgICB3ID0gYm94LndpZHRoIHx8IChlbC5vZmZzZXRXaWR0aCAqIHpvb20pLFxuICAgICAgICAgICAgICAgIGggPSBib3guaGVpZ2h0IHx8IChlbC5vZmZzZXRIZWlnaHQgKiB6b29tKSxcbiAgICAgICAgICAgICAgICB4ID0gKGNsWzBdIC0gbGVmdCkgLyB3LFxuICAgICAgICAgICAgICAgIHkgPSAoY2xbMV0gLSB0b3ApIC8gaDtcblxuICAgICAgICAgICAgcmV0dXJuIFsgeCwgeSBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBzb21lIGVsZW1lbnQgYXMgcmVhZCBmcm9tIHRoZSBsZWZ0L3RvcCBwcm9wZXJ0aWVzIGluIGl0cyBzdHlsZS5cbiAgICAgICAgICogQG1ldGhvZCBnZXRBYnNvbHV0ZVBvc2l0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgVGhlIGVsZW1lbnQgdG8gcmV0cmlldmUgdGhlIGFic29sdXRlIGNvb3JkaW5hdGVzIGZyb20uICoqTm90ZSoqIHRoaXMgaXMgYSBET00gZWxlbWVudCwgbm90IGEgc2VsZWN0b3IgZnJvbSB0aGUgdW5kZXJseWluZyBsaWJyYXJ5LlxuICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gW2xlZnQsIHRvcF0gcGl4ZWwgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgX29uZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNzID0gZWwuc3R5bGVbc107XG4gICAgICAgICAgICAgICAgaWYgKHNzKSByZXR1cm4gcGFyc2VGbG9hdChzcy5zdWJzdHJpbmcoMCwgc3MubGVuZ3RoIC0gMikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBbIF9vbmUoXCJsZWZ0XCIpLCBfb25lKFwidG9wXCIpIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHNvbWUgZWxlbWVudCBieSBzZXR0aW5nIHRoZSBsZWZ0L3RvcCBwcm9wZXJ0aWVzIGluIGl0cyBzdHlsZS5cbiAgICAgICAgICogQG1ldGhvZCBzZXRBYnNvbHV0ZVBvc2l0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBvbi4gKipOb3RlKiogdGhpcyBpcyBhIERPTSBlbGVtZW50LCBub3QgYSBzZWxlY3RvciBmcm9tIHRoZSB1bmRlcmx5aW5nIGxpYnJhcnkuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHh5IHggYW5kIHkgY29vcmRpbmF0ZXNcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJbXX0gW2FuaW1hdGVGcm9tXSBPcHRpb25hbCBwcmV2aW91cyB4eSB0byBhbmltYXRlIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYW5pbWF0ZU9wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBzZXRBYnNvbHV0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoZWwsIHh5LCBhbmltYXRlRnJvbSwgYW5pbWF0ZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChhbmltYXRlRnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShlbCwge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIis9XCIgKyAoeHlbMF0gLSBhbmltYXRlRnJvbVswXSksXG4gICAgICAgICAgICAgICAgICAgIHRvcDogXCIrPVwiICsgKHh5WzFdIC0gYW5pbWF0ZUZyb21bMV0pXG4gICAgICAgICAgICAgICAgfSwgYW5pbWF0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUubGVmdCA9IHh5WzBdICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLnRvcCA9IHh5WzFdICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0cyB0aGUgc2l6ZSBmb3IgdGhlIGVsZW1lbnQsIGluIGFuIGFycmF5IDogWyB3aWR0aCwgaGVpZ2h0IF0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTaXplOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBbIGVsLm9mZnNldFdpZHRoLCBlbC5vZmZzZXRIZWlnaHQgXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLm9mZnNldFdpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgfSk7XG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qXG4gKiBqc1BsdW1iXG4gKlxuICogVGl0bGU6anNQbHVtYiAyLjEuMFxuICpcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHZpc3VhbGx5IGNvbm5lY3QgZWxlbWVudHMgb24gYW4gSFRNTCBwYWdlLCB1c2luZyBTVkcuXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGNvZGUgZm9yIGNvbXBvbmVudHMgdGhhdCBzdXBwb3J0IG92ZXJsYXlzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTYganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxuICpcbiAqIGh0dHA6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHA6Ly9naXRodWIuY29tL3Nwb3JyaXR0L2pzcGx1bWJcbiAqXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcm9vdCA9IHRoaXMsIF9qcCA9IHJvb3QuanNQbHVtYiwgX2p1ID0gcm9vdC5qc1BsdW1iVXRpbDtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBCRUdJTiBPdmVybGF5Q2FwYWJsZWpzUGx1bWJVSUNvbXBvbmVudCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIF9pbnRlcm5hbExhYmVsT3ZlcmxheUlkID0gXCJfX2xhYmVsXCIsXG4gICAgLy8gdGhpcyBpcyBhIHNob3J0Y3V0IGhlbHBlciBtZXRob2QgdG8gbGV0IHBlb3BsZSBhZGQgYSBsYWJlbCBhc1xuICAgIC8vIG92ZXJsYXkuXG4gICAgICAgIF9tYWtlTGFiZWxPdmVybGF5ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgcGFyYW1zKSB7XG5cbiAgICAgICAgICAgIHZhciBfcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBjc3NDbGFzczogcGFyYW1zLmNzc0NsYXNzLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbFN0eWxlOiBjb21wb25lbnQubGFiZWxTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IF9pbnRlcm5hbExhYmVsT3ZlcmxheUlkLFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWI6IGNvbXBvbmVudC5fanNQbHVtYi5pbnN0YW5jZSAgLy8gVE9ETyBub3QgbmVjZXNzYXJ5LCBzaW5jZSB0aGUgaW5zdGFuY2UgY2FuIGJlIGFjY2Vzc2VkIHRocm91Z2ggdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1lcmdlZFBhcmFtcyA9IF9qcC5leHRlbmQoX3BhcmFtcywgcGFyYW1zKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfanAuT3ZlcmxheXNbY29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlLmdldFJlbmRlck1vZGUoKV0uTGFiZWwobWVyZ2VkUGFyYW1zKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3Byb2Nlc3NPdmVybGF5ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgbykge1xuICAgICAgICAgICAgdmFyIF9uZXdPdmVybGF5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChfanUuaXNBcnJheShvKSkge1x0Ly8gdGhpcyBpcyBmb3IgdGhlIHNob3J0aGFuZCBbXCJBcnJvd1wiLCB7IHdpZHRoOjUwIH1dIHN5bnRheFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYWxzbyBhIHRocmVlIGFyZyB2ZXJzaW9uOlxuICAgICAgICAgICAgICAgIC8vIFtcIkFycm93XCIsIHsgd2lkdGg6NTAgfSwge2xvY2F0aW9uOjAuN31dXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggbWVyZ2VzIHRoZSAzcmQgYXJnIGludG8gdGhlIDJuZC5cbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG9bMF0sXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIG9iamVjdCBzbyBhcyBub3QgdG8gbWVzcyB1cCBhbnlvbmUgZWxzZSdzIHJlZmVyZW5jZS4uLlxuICAgICAgICAgICAgICAgICAgICBwID0gX2pwLmV4dGVuZCh7Y29tcG9uZW50OiBjb21wb25lbnQsIF9qc1BsdW1iOiBjb21wb25lbnQuX2pzUGx1bWIuaW5zdGFuY2V9LCBvWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAoby5sZW5ndGggPT0gMykgX2pwLmV4dGVuZChwLCBvWzJdKTtcbiAgICAgICAgICAgICAgICBfbmV3T3ZlcmxheSA9IG5ldyBfanAuT3ZlcmxheXNbY29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlLmdldFJlbmRlck1vZGUoKV1bdHlwZV0ocCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG8uY29uc3RydWN0b3IgPT0gU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgX25ld092ZXJsYXkgPSBuZXcgX2pwLk92ZXJsYXlzW2NvbXBvbmVudC5fanNQbHVtYi5pbnN0YW5jZS5nZXRSZW5kZXJNb2RlKCldW29dKHtjb21wb25lbnQ6IGNvbXBvbmVudCwgX2pzUGx1bWI6IGNvbXBvbmVudC5fanNQbHVtYi5pbnN0YW5jZX0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfbmV3T3ZlcmxheSA9IG87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9uZXdPdmVybGF5LmlkID0gX25ld092ZXJsYXkuaWQgfHwgX2p1LnV1aWQoKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5jYWNoZVR5cGVJdGVtKFwib3ZlcmxheVwiLCBfbmV3T3ZlcmxheSwgX25ld092ZXJsYXkuaWQpO1xuICAgICAgICAgICAgLy9jb21wb25lbnQuX2pzUGx1bWIub3ZlcmxheXMucHVzaChfbmV3T3ZlcmxheSk7XG4gICAgICAgICAgICBjb21wb25lbnQuX2pzUGx1bWIub3ZlcmxheXNbX25ld092ZXJsYXkuaWRdID0gX25ld092ZXJsYXk7XG5cbiAgICAgICAgICAgIHJldHVybiBfbmV3T3ZlcmxheTtcbiAgICAgICAgfTtcblxuICAgIF9qcC5PdmVybGF5Q2FwYWJsZUpzUGx1bWJVSUNvbXBvbmVudCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcblxuICAgICAgICByb290LmpzUGx1bWJVSUNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzID0ge307XG4gICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheVBvc2l0aW9ucyA9IHt9O1xuXG4gICAgICAgIGlmIChwYXJhbXMubGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVmYXVsdFR5cGUoKS5vdmVybGF5c1tfaW50ZXJuYWxMYWJlbE92ZXJsYXlJZF0gPSBbXCJMYWJlbFwiLCB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IHBhcmFtcy5sYWJlbCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogcGFyYW1zLmxhYmVsTG9jYXRpb24gfHwgdGhpcy5kZWZhdWx0TGFiZWxMb2NhdGlvbiB8fCAwLjUsXG4gICAgICAgICAgICAgICAgbGFiZWxTdHlsZTogcGFyYW1zLmxhYmVsU3R5bGUgfHwgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5EZWZhdWx0cy5MYWJlbFN0eWxlLFxuICAgICAgICAgICAgICAgIGlkOl9pbnRlcm5hbExhYmVsT3ZlcmxheUlkXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0TGlzdGVuZXJDb21wb25lbnQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV0uc2V0TGlzdGVuZXJDb21wb25lbnQoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIF9qcC5PdmVybGF5Q2FwYWJsZUpzUGx1bWJVSUNvbXBvbmVudC5hcHBseVR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50LCB0KSB7XG4gICAgICAgIGlmICh0Lm92ZXJsYXlzKSB7XG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIG9uZXMgaW4gdGhlIHR5cGUuIGlmIGFscmVhZHkgcHJlc2VudCBvbiB0aGUgY29tcG9uZW50LFxuICAgICAgICAgICAgLy8gZG9udCByZW1vdmUgb3IgcmUtYWRkLlxuICAgICAgICAgICAgdmFyIGtlZXAgPSB7fSwgaTtcblxuICAgICAgICAgICAgZm9yIChpIGluIHQub3ZlcmxheXMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZyA9IGNvbXBvbmVudC5fanNQbHVtYi5vdmVybGF5c1t0Lm92ZXJsYXlzW2ldWzFdLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF5YmUgdXBkYXRlIGZyb20gZGF0YSwgaWYgdGhlcmUgd2VyZSBwYXJhbWV0ZXJpc2VkIHZhbHVlcyBmb3IgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnVwZGF0ZUZyb20odC5vdmVybGF5c1tpXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGtlZXBbdC5vdmVybGF5c1tpXVsxXS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBjb21wb25lbnQuZ2V0Q2FjaGVkVHlwZUl0ZW0oXCJvdmVybGF5XCIsIHQub3ZlcmxheXNbaV1bMV0uaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnJlYXR0YWNoKGNvbXBvbmVudC5fanNQbHVtYi5pbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXliZSB1cGRhdGUgZnJvbSBkYXRhLCBpZiB0aGVyZSB3ZXJlIHBhcmFtZXRlcmlzZWQgdmFsdWVzIGZvciBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMudXBkYXRlRnJvbSh0Lm92ZXJsYXlzW2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5fanNQbHVtYi5vdmVybGF5c1tjLmlkXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gY29tcG9uZW50LmFkZE92ZXJsYXkodC5vdmVybGF5c1tpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAga2VlcFtjLmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgbG9vcCB0aHJvdWdoIHRoZSBmdWxsIG92ZXJsYXlzIGFuZCByZW1vdmUgdGhvc2UgdGhhdCB3ZSBkb250IHdhbnQgdG8ga2VlcFxuICAgICAgICAgICAgZm9yIChpIGluIGNvbXBvbmVudC5fanNQbHVtYi5vdmVybGF5cykge1xuICAgICAgICAgICAgICAgIGlmIChrZWVwW2NvbXBvbmVudC5fanNQbHVtYi5vdmVybGF5c1tpXS5pZF0gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnJlbW92ZU92ZXJsYXkoY29tcG9uZW50Ll9qc1BsdW1iLm92ZXJsYXlzW2ldLmlkLCB0cnVlKTsgLy8gcmVtb3ZlIG92ZXJsYXkgYnV0IGRvbnQgY2xlYW4gaXQgdXAuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgd291bGQgcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBldGM7IG92ZXJsYXlzIGFyZSBuZXZlciBkaXNjYXJkZWQgYnkgdGhlIHR5cGVzIHN0dWZmLCB0aGV5IGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGRldGFjaGVkL3JlYXR0YWNoZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX2p1LmV4dGVuZChfanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQsIHJvb3QuanNQbHVtYlVJQ29tcG9uZW50LCB7XG5cbiAgICAgICAgc2V0SG92ZXI6IGZ1bmN0aW9uIChob3ZlciwgaWdub3JlQXR0YWNoZWRFbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIgJiYgIXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaXNDb25uZWN0aW9uQmVpbmdEcmFnZ2VkKCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXVtob3ZlciA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0odGhpcy5fanNQbHVtYi5pbnN0YW5jZS5ob3ZlckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChvdmVybGF5LCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIHZhciBvID0gX3Byb2Nlc3NPdmVybGF5KHRoaXMsIG92ZXJsYXkpO1xuICAgICAgICAgICAgaWYgKCFkb05vdFJlcGFpbnQpIHRoaXMucmVwYWludCgpO1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH0sXG4gICAgICAgIGdldE92ZXJsYXk6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaWRdO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPdmVybGF5czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIub3ZlcmxheXM7XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGVPdmVybGF5OiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy5nZXRPdmVybGF5KGlkKTtcbiAgICAgICAgICAgIGlmIChvKSBvLmhpZGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGlkZU92ZXJsYXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMpXG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXS5oaWRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dPdmVybGF5OiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy5nZXRPdmVybGF5KGlkKTtcbiAgICAgICAgICAgIGlmIChvKSBvLnNob3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd092ZXJsYXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMpXG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXS5zaG93KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUFsbE92ZXJsYXlzOiBmdW5jdGlvbiAoZG9Ob3RSZXBhaW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXS5jbGVhbnVwKSB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldLmNsZWFudXAoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5vdmVybGF5cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5vdmVybGF5UG9zaXRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghZG9Ob3RSZXBhaW50KVxuICAgICAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVPdmVybGF5OiBmdW5jdGlvbiAob3ZlcmxheUlkLCBkb250Q2xlYW51cCkge1xuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW292ZXJsYXlJZF07XG4gICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICAgIGlmICghZG9udENsZWFudXAgJiYgby5jbGVhbnVwKSBvLmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fanNQbHVtYi5vdmVybGF5c1tvdmVybGF5SWRdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iLm92ZXJsYXlQb3NpdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9qc1BsdW1iLm92ZXJsYXlQb3NpdGlvbnNbb3ZlcmxheUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlT3ZlcmxheXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU92ZXJsYXkoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW92ZVBhcmVudDogZnVuY3Rpb24gKG5ld1BhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmdDYW52YXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJnQ2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iZ0NhbnZhcyk7XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmFwcGVuZENoaWxkKHRoaXMuYmdDYW52YXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV0uaXNBcHBlbmRlZEF0VG9wTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV0uZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvID0gdGhpcy5nZXRPdmVybGF5KF9pbnRlcm5hbExhYmVsT3ZlcmxheUlkKTtcbiAgICAgICAgICAgIHJldHVybiBsbyAhPSBudWxsID8gbG8uZ2V0TGFiZWwoKSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldExhYmVsT3ZlcmxheTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3ZlcmxheShfaW50ZXJuYWxMYWJlbE92ZXJsYXlJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldExhYmVsOiBmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgdmFyIGxvID0gdGhpcy5nZXRPdmVybGF5KF9pbnRlcm5hbExhYmVsT3ZlcmxheUlkKTtcbiAgICAgICAgICAgIGlmICghbG8pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gbC5jb25zdHJ1Y3RvciA9PSBTdHJpbmcgfHwgbC5jb25zdHJ1Y3RvciA9PSBGdW5jdGlvbiA/IHsgbGFiZWw6IGwgfSA6IGw7XG4gICAgICAgICAgICAgICAgbG8gPSBfbWFrZUxhYmVsT3ZlcmxheSh0aGlzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbX2ludGVybmFsTGFiZWxPdmVybGF5SWRdID0gbG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobC5jb25zdHJ1Y3RvciA9PSBTdHJpbmcgfHwgbC5jb25zdHJ1Y3RvciA9PSBGdW5jdGlvbikgbG8uc2V0TGFiZWwobCk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsLmxhYmVsKSBsby5zZXRMYWJlbChsLmxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwubG9jYXRpb24pIGxvLnNldExvY2F0aW9uKGwubG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmlzU3VzcGVuZERyYXdpbmcoKSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldLmNsZWFudXAoZm9yY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV0uZGVzdHJveShmb3JjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5vdmVybGF5UG9zaXRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXNbdiA/IFwic2hvd092ZXJsYXlzXCIgOiBcImhpZGVPdmVybGF5c1wiXSgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRBYnNvbHV0ZU92ZXJsYXlQb3NpdGlvbjogZnVuY3Rpb24gKG92ZXJsYXksIHh5KSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLm92ZXJsYXlQb3NpdGlvbnNbb3ZlcmxheS5pZF0gPSB4eTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QWJzb2x1dGVPdmVybGF5UG9zaXRpb246IGZ1bmN0aW9uIChvdmVybGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi5vdmVybGF5UG9zaXRpb25zID8gdGhpcy5fanNQbHVtYi5vdmVybGF5UG9zaXRpb25zW292ZXJsYXkuaWRdIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgX2NsYXp6TWFuaXA6ZnVuY3Rpb24oYWN0aW9uLCBjbGF6eiwgZG9udFVwZGF0ZU92ZXJsYXlzKSB7XG4gICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVPdmVybGF5cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldW2FjdGlvbiArIFwiQ2xhc3NcIl0oY2xhenopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkQ2xhc3M6ZnVuY3Rpb24oY2xhenosIGRvbnRVcGRhdGVPdmVybGF5cykge1xuICAgICAgICAgICAgdGhpcy5fY2xhenpNYW5pcChcImFkZFwiLCBjbGF6eiwgZG9udFVwZGF0ZU92ZXJsYXlzKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczpmdW5jdGlvbihjbGF6eiwgZG9udFVwZGF0ZU92ZXJsYXlzKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGF6ek1hbmlwKFwicmVtb3ZlXCIsIGNsYXp6LCBkb250VXBkYXRlT3ZlcmxheXMpXG4gICAgICAgIH1cbiAgICB9KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVORCBPdmVybGF5Q2FwYWJsZWpzUGx1bWJVSUNvbXBvbmVudCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qXG4gKiBqc1BsdW1iXG4gKiBcbiAqIFRpdGxlOmpzUGx1bWIgMi4xLjBcbiAqIFxuICogUHJvdmlkZXMgYSB3YXkgdG8gdmlzdWFsbHkgY29ubmVjdCBlbGVtZW50cyBvbiBhbiBIVE1MIHBhZ2UsIHVzaW5nIFNWRy5cbiAqIFxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBjb2RlIGZvciBFbmRwb2ludHMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNiBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXG4gKiBcbiAqIGh0dHA6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHA6Ly9naXRodWIuY29tL3Nwb3JyaXR0L2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJvb3QgPSB0aGlzLCBfanAgPSByb290LmpzUGx1bWIsIF9qdSA9IHJvb3QuanNQbHVtYlV0aWw7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGRyYWcgaGFuZGxlciBmb3IgYSBjb25uZWN0aW9uXG4gICAgdmFyIF9tYWtlQ29ubmVjdGlvbkRyYWdIYW5kbGVyID0gZnVuY3Rpb24gKGVuZHBvaW50LCBwbGFjZWhvbGRlciwgX2pzUGx1bWIpIHtcbiAgICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRyYWc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlci5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdWkgPSBfanNQbHVtYi5nZXRVSVBvc2l0aW9uKGFyZ3VtZW50cywgX2pzUGx1bWIuZ2V0Wm9vbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF91aSAhPSBudWxsKSBqc1BsdW1iLnNldFBvc2l0aW9uKHBsYWNlaG9sZGVyLmVsZW1lbnQsIF91aSk7XG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnJlcGFpbnQocGxhY2Vob2xkZXIuZWxlbWVudCwgX3VpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHJlcGFpbnQgdGhlIHNvdXJjZSBlbmRwb2ludCwgYmVjYXVzZSBvbmx5IGNvbnRpbnVvdXMvZHluYW1pYyBhbmNob3JzIGNhdXNlIHRoZSBlbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSByZXBhaW50ZWQsIHNvIHN0YXRpYyBhbmNob3JzIG5lZWQgdG8gYmUgdG9sZCAob3IgdGhlIGVuZHBvaW50IGdldHMgZHJhZ2dlZCBhcm91bmQpXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50LnBhaW50KHthbmNob3JQb2ludDplbmRwb2ludC5hbmNob3IuZ2V0Q3VycmVudExvY2F0aW9uKHtlbGVtZW50OmVuZHBvaW50LmVsZW1lbnR9KX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wRHJhZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBjcmVhdGVzIGEgcGxhY2Vob2xkZXIgZGl2IGZvciBkcmFnZ2luZyBwdXJwb3NlcywgYWRkcyBpdCwgYW5kIHByZS1jb21wdXRlcyBpdHMgb2Zmc2V0LlxuICAgIHZhciBfbWFrZURyYWdnYWJsZVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBsYWNlaG9sZGVyLCBfanNQbHVtYiwgaXBjbywgaXBzKSB7XG4gICAgICAgIHZhciBuID0ganNQbHVtYi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcG9zaXRpb24gOiBcImFic29sdXRlXCIgfSk7XG4gICAgICAgIF9qc1BsdW1iLmFwcGVuZEVsZW1lbnQobik7XG4gICAgICAgIHZhciBpZCA9IF9qc1BsdW1iLmdldElkKG4pO1xuICAgICAgICBqc1BsdW1iLnNldFBvc2l0aW9uKG4sIGlwY28pO1xuICAgICAgICBuLnN0eWxlLndpZHRoID0gaXBzWzBdICsgXCJweFwiO1xuICAgICAgICBuLnN0eWxlLmhlaWdodCA9IGlwc1sxXSArIFwicHhcIjtcbiAgICAgICAgX2pzUGx1bWIubWFuYWdlKGlkLCBuLCB0cnVlKTsgLy8gVFJBTlNJRU5UIE1BTkFHRVxuICAgICAgICAvLyBjcmVhdGUgYW5kIGFzc2lnbiBhbiBpZCwgYW5kIGluaXRpYWxpemUgdGhlIG9mZnNldC5cbiAgICAgICAgcGxhY2Vob2xkZXIuaWQgPSBpZDtcbiAgICAgICAgcGxhY2Vob2xkZXIuZWxlbWVudCA9IG47XG4gICAgfTtcblxuICAgIC8vIGNyZWF0ZSBhIGZsb2F0aW5nIGVuZHBvaW50IChmb3IgZHJhZyBjb25uZWN0aW9ucylcbiAgICB2YXIgX21ha2VGbG9hdGluZ0VuZHBvaW50ID0gZnVuY3Rpb24gKHBhaW50U3R5bGUsIHJlZmVyZW5jZUFuY2hvciwgZW5kcG9pbnQsIHJlZmVyZW5jZUNhbnZhcywgc291cmNlRWxlbWVudCwgX2pzUGx1bWIsIF9uZXdFbmRwb2ludCwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGZsb2F0aW5nQW5jaG9yID0gbmV3IF9qcC5GbG9hdGluZ0FuY2hvcih7IHJlZmVyZW5jZTogcmVmZXJlbmNlQW5jaG9yLCByZWZlcmVuY2VDYW52YXM6IHJlZmVyZW5jZUNhbnZhcywganNQbHVtYkluc3RhbmNlOiBfanNQbHVtYiB9KTtcbiAgICAgICAgLy9zZXR0aW5nIHRoZSBzY29wZSBoZXJlIHNob3VsZCBub3QgYmUgdGhlIHdheSB0byBmaXggdGhhdCBtb290b29scyBpc3N1ZS4gIGl0IHNob3VsZCBiZSBmaXhlZCBieSBub3RcbiAgICAgICAgLy8gYWRkaW5nIHRoZSBmbG9hdGluZyBlbmRwb2ludCBhcyBhIGRyb3BwYWJsZS4gIHRoYXQgbWFrZXMgbW9yZSBzZW5zZSBhbnl3YXkhXG4gICAgICAgIC8vIFRSQU5TSUVOVCBNQU5BR0VcbiAgICAgICAgcmV0dXJuIF9uZXdFbmRwb2ludCh7XG4gICAgICAgICAgICBwYWludFN0eWxlOiBwYWludFN0eWxlLFxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50LFxuICAgICAgICAgICAgYW5jaG9yOiBmbG9hdGluZ0FuY2hvcixcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlRWxlbWVudCxcbiAgICAgICAgICAgIHNjb3BlOiBzY29wZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gWyBcImNvbm5lY3RvclN0eWxlXCIsIFwiY29ubmVjdG9ySG92ZXJTdHlsZVwiLCBcImNvbm5lY3Rvck92ZXJsYXlzXCIsXG4gICAgICAgIFwiY29ubmVjdG9yXCIsIFwiY29ubmVjdGlvblR5cGVcIiwgXCJjb25uZWN0b3JDbGFzc1wiLCBcImNvbm5lY3RvckhvdmVyQ2xhc3NcIiBdO1xuXG4gICAgLy8gYSBoZWxwZXIgZnVuY3Rpb24gdGhhdCB0cmllcyB0byBmaW5kIGEgY29ubmVjdGlvbiB0byB0aGUgZ2l2ZW4gZWxlbWVudCwgYW5kIHJldHVybnMgaXQgaWYgc28uIGlmIGVsZW1lbnRXaXRoUHJlY2VkZW5jZSBpcyBudWxsLFxuICAgIC8vIG9yIG5vIGNvbm5lY3Rpb24gdG8gaXQgaXMgZm91bmQsIHdlIHJldHVybiB0aGUgZmlyc3QgY29ubmVjdGlvbiBpbiBvdXIgbGlzdC5cbiAgICB2YXIgZmluZENvbm5lY3Rpb25Ub1VzZUZvckR5bmFtaWNBbmNob3IgPSBmdW5jdGlvbiAoZXAsIGVsZW1lbnRXaXRoUHJlY2VkZW5jZSkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgaWYgKGVsZW1lbnRXaXRoUHJlY2VkZW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVwLmNvbm5lY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVwLmNvbm5lY3Rpb25zW2ldLnNvdXJjZUlkID09IGVsZW1lbnRXaXRoUHJlY2VkZW5jZSB8fCBlcC5jb25uZWN0aW9uc1tpXS50YXJnZXRJZCA9PSBlbGVtZW50V2l0aFByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVwLmNvbm5lY3Rpb25zW2lkeF07XG4gICAgfTtcblxuICAgIF9qcC5FbmRwb2ludCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9qc1BsdW1iID0gcGFyYW1zLl9qc1BsdW1iLFxuICAgICAgICAgICAgX25ld0Nvbm5lY3Rpb24gPSBwYXJhbXMubmV3Q29ubmVjdGlvbixcbiAgICAgICAgICAgIF9uZXdFbmRwb2ludCA9IHBhcmFtcy5uZXdFbmRwb2ludDtcblxuICAgICAgICB0aGlzLmlkUHJlZml4ID0gXCJfanNwbHVtYl9lX1wiO1xuICAgICAgICB0aGlzLmRlZmF1bHRMYWJlbExvY2F0aW9uID0gWyAwLjUsIDAuNSBdO1xuICAgICAgICB0aGlzLmRlZmF1bHRPdmVybGF5S2V5cyA9IFtcIk92ZXJsYXlzXCIsIFwiRW5kcG9pbnRPdmVybGF5c1wiXTtcbiAgICAgICAgX2pwLk92ZXJsYXlDYXBhYmxlSnNQbHVtYlVJQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbi8vIFRZUEVcblxuICAgICAgICB0aGlzLmFwcGVuZFRvRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgY29ubmVjdGlvblR5cGU6cGFyYW1zLmNvbm5lY3Rpb25UeXBlLFxuICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IHBhcmFtcy5tYXhDb25uZWN0aW9ucyA9PSBudWxsID8gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5EZWZhdWx0cy5NYXhDb25uZWN0aW9ucyA6IHBhcmFtcy5tYXhDb25uZWN0aW9ucywgLy8gbWF4aW11bSBudW1iZXIgb2YgY29ubmVjdGlvbnMgdGhpcyBlbmRwb2ludCBjYW4gYmUgdGhlIHNvdXJjZSBvZi4sXG4gICAgICAgICAgICBwYWludFN0eWxlOiBwYXJhbXMuZW5kcG9pbnRTdHlsZSB8fCBwYXJhbXMucGFpbnRTdHlsZSB8fCBwYXJhbXMuc3R5bGUgfHwgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5EZWZhdWx0cy5FbmRwb2ludFN0eWxlIHx8IF9qcC5EZWZhdWx0cy5FbmRwb2ludFN0eWxlLFxuICAgICAgICAgICAgaG92ZXJQYWludFN0eWxlOiBwYXJhbXMuZW5kcG9pbnRIb3ZlclN0eWxlIHx8IHBhcmFtcy5ob3ZlclBhaW50U3R5bGUgfHwgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5EZWZhdWx0cy5FbmRwb2ludEhvdmVyU3R5bGUgfHwgX2pwLkRlZmF1bHRzLkVuZHBvaW50SG92ZXJTdHlsZSxcbiAgICAgICAgICAgIGNvbm5lY3RvclN0eWxlOiBwYXJhbXMuY29ubmVjdG9yU3R5bGUsXG4gICAgICAgICAgICBjb25uZWN0b3JIb3ZlclN0eWxlOiBwYXJhbXMuY29ubmVjdG9ySG92ZXJTdHlsZSxcbiAgICAgICAgICAgIGNvbm5lY3RvckNsYXNzOiBwYXJhbXMuY29ubmVjdG9yQ2xhc3MsXG4gICAgICAgICAgICBjb25uZWN0b3JIb3ZlckNsYXNzOiBwYXJhbXMuY29ubmVjdG9ySG92ZXJDbGFzcyxcbiAgICAgICAgICAgIGNvbm5lY3Rvck92ZXJsYXlzOiBwYXJhbXMuY29ubmVjdG9yT3ZlcmxheXMsXG4gICAgICAgICAgICBjb25uZWN0b3I6IHBhcmFtcy5jb25uZWN0b3IsXG4gICAgICAgICAgICBjb25uZWN0b3JUb29sdGlwOiBwYXJhbXMuY29ubmVjdG9yVG9vbHRpcFxuICAgICAgICB9KTtcblxuLy8gRU5EIFRZUEVcblxuICAgICAgICB0aGlzLl9qc1BsdW1iLmVuYWJsZWQgPSAhKHBhcmFtcy5lbmFibGVkID09PSBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IF9qcC5nZXRFbGVtZW50KHBhcmFtcy5zb3VyY2UpO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLnV1aWQgPSBwYXJhbXMudXVpZDtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50ID0gbnVsbDtcbiAgICAgICAgdmFyIGluUGxhY2VDb3B5ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIudXVpZCkgcGFyYW1zLmVuZHBvaW50c0J5VVVJRFt0aGlzLl9qc1BsdW1iLnV1aWRdID0gdGhpcztcbiAgICAgICAgdGhpcy5lbGVtZW50SWQgPSBwYXJhbXMuZWxlbWVudElkO1xuICAgICAgICB0aGlzLmRyYWdQcm94eSA9IHBhcmFtcy5kcmFnUHJveHk7XG5cbiAgICAgICAgdGhpcy5fanNQbHVtYi5jb25uZWN0aW9uQ29zdCA9IHBhcmFtcy5jb25uZWN0aW9uQ29zdDtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5jb25uZWN0aW9uc0RpcmVjdGVkID0gcGFyYW1zLmNvbm5lY3Rpb25zRGlyZWN0ZWQ7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIuY3VycmVudEFuY2hvckNsYXNzID0gXCJcIjtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5ldmVudHMgPSB7fTtcblxuICAgICAgICB2YXIgX3VwZGF0ZUFuY2hvckNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gc3Rhc2ggb2xkLCBnZXQgbmV3XG4gICAgICAgICAgICB2YXIgb2xkQW5jaG9yQ2xhc3MgPSBfanNQbHVtYi5lbmRwb2ludEFuY2hvckNsYXNzUHJlZml4ICsgXCItXCIgKyB0aGlzLl9qc1BsdW1iLmN1cnJlbnRBbmNob3JDbGFzcztcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuY3VycmVudEFuY2hvckNsYXNzID0gdGhpcy5hbmNob3IuZ2V0Q3NzQ2xhc3MoKTtcbiAgICAgICAgICAgIHZhciBhbmNob3JDbGFzcyA9IF9qc1BsdW1iLmVuZHBvaW50QW5jaG9yQ2xhc3NQcmVmaXggKyAodGhpcy5fanNQbHVtYi5jdXJyZW50QW5jaG9yQ2xhc3MgPyBcIi1cIiArIHRoaXMuX2pzUGx1bWIuY3VycmVudEFuY2hvckNsYXNzIDogXCJcIik7XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3Mob2xkQW5jaG9yQ2xhc3MpO1xuICAgICAgICAgICAgdGhpcy5hZGRDbGFzcyhhbmNob3JDbGFzcyk7XG4gICAgICAgICAgICAvLyBhZGQgYW5kIHJlbW92ZSBhdCB0aGUgc2FtZSB0aW1lIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHJlZmxvd3MuXG4gICAgICAgICAgICBqc1BsdW1iLnVwZGF0ZUNsYXNzZXModGhpcy5lbGVtZW50LCBhbmNob3JDbGFzcywgb2xkQW5jaG9yQ2xhc3MpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5wcmVwYXJlQW5jaG9yID0gZnVuY3Rpb24oYW5jaG9yUGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UubWFrZUFuY2hvcihhbmNob3JQYXJhbXMsIHRoaXMuZWxlbWVudElkLCBfanNQbHVtYik7XG4gICAgICAgICAgICBhLmJpbmQoXCJhbmNob3JDaGFuZ2VkXCIsIGZ1bmN0aW9uIChjdXJyZW50QW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKFwiYW5jaG9yQ2hhbmdlZFwiLCB7ZW5kcG9pbnQ6IHRoaXMsIGFuY2hvcjogY3VycmVudEFuY2hvcn0pO1xuICAgICAgICAgICAgICAgIF91cGRhdGVBbmNob3JDbGFzcygpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0UHJlcGFyZWRBbmNob3IgPSBmdW5jdGlvbihhbmNob3IsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5jb250aW51b3VzQW5jaG9yRmFjdG9yeS5jbGVhcih0aGlzLmVsZW1lbnRJZCk7XG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgICAgIF91cGRhdGVBbmNob3JDbGFzcygpO1xuXG4gICAgICAgICAgICBpZiAoIWRvTm90UmVwYWludClcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLnJlcGFpbnQodGhpcy5lbGVtZW50SWQpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldEFuY2hvciA9IGZ1bmN0aW9uIChhbmNob3JQYXJhbXMsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnByZXBhcmVBbmNob3IoYW5jaG9yUGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJlcGFyZWRBbmNob3IoYSwgZG9Ob3RSZXBhaW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpbnRlcm5hbEhvdmVyID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zW2ldLnNldEhvdmVyKHN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIb3ZlcihzdGF0ZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmJpbmQoXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW50ZXJuYWxIb3Zlcih0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmluZChcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGludGVybmFsSG92ZXIoZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBTkNIT1IgTUFOQUdFUlxuICAgICAgICBpZiAoIXBhcmFtcy5fdHJhbnNpZW50KSAvLyBpbiBwbGFjZSBjb3BpZXMsIGZvciBleGFtcGxlLCBhcmUgdHJhbnNpZW50LiAgdGhleSB3aWxsIG5ldmVyIG5lZWQgdG8gYmUgcmV0cmlldmVkIGR1cmluZyBhIHBhaW50IGN5Y2xlLCBiZWNhdXNlIHRoZXkgZG9udCBtb3ZlLCBhbmQgdGhlbiB0aGV5IGFyZSBkZWxldGVkLlxuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5hbmNob3JNYW5hZ2VyLmFkZCh0aGlzLCB0aGlzLmVsZW1lbnRJZCk7XG5cbiAgICAgICAgdGhpcy5wcmVwYXJlRW5kcG9pbnQgPSBmdW5jdGlvbihlcCwgdHlwZUlkKSB7XG4gICAgICAgICAgICB2YXIgX2UgPSBmdW5jdGlvbiAodCwgcCkge1xuICAgICAgICAgICAgICAgIHZhciBybSA9IF9qc1BsdW1iLmdldFJlbmRlck1vZGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoX2pwLkVuZHBvaW50c1tybV1bdF0pIHJldHVybiBuZXcgX2pwLkVuZHBvaW50c1tybV1bdF0ocCk7XG4gICAgICAgICAgICAgICAgaWYgKCFfanNQbHVtYi5EZWZhdWx0cy5Eb05vdFRocm93RXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IG1zZzogXCJqc1BsdW1iOiB1bmtub3duIGVuZHBvaW50IHR5cGUgJ1wiICsgdCArIFwiJ1wiIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZW5kcG9pbnRBcmdzID0ge1xuICAgICAgICAgICAgICAgIF9qc1BsdW1iOiB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiBwYXJhbXMuY3NzQ2xhc3MsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiBwYXJhbXMuY29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHBhcmFtcy50b29sdGlwLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RvclRvb2x0aXA6IHBhcmFtcy5jb25uZWN0b3JUb29sdGlwLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiB0aGlzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZW5kcG9pbnQ7XG5cbiAgICAgICAgICAgIGlmIChfanUuaXNTdHJpbmcoZXApKVxuICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gX2UoZXAsIGVuZHBvaW50QXJncyk7XG4gICAgICAgICAgICBlbHNlIGlmIChfanUuaXNBcnJheShlcCkpIHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludEFyZ3MgPSBfanUubWVyZ2UoZXBbMV0sIGVuZHBvaW50QXJncyk7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnQgPSBfZShlcFswXSwgZW5kcG9pbnRBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gZXAuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXNzaWduIGEgY2xvbmUgZnVuY3Rpb24gdXNpbmcgYSBjb3B5IG9mIGVuZHBvaW50QXJncy4gdGhpcyBpcyB1c2VkIHdoZW4gYSBkcmFnIHN0YXJ0czogdGhlIGVuZHBvaW50IHRoYXQgd2FzIGRyYWdnZWQgaXMgY2xvbmVkLFxuICAgICAgICAgICAgLy8gYW5kIHRoZSBjbG9uZSBpcyBsZWZ0IGluIGl0cyBwbGFjZSB3aGlsZSB0aGUgb3JpZ2luYWwgb25lIGdvZXMgb2ZmIG9uIGEgbWFnaWNhbCBqb3VybmV5LlxuICAgICAgICAgICAgLy8gdGhlIGNvcHkgaXMgdG8gZ2V0IGFyb3VuZCBhIGNsb3N1cmUgcHJvYmxlbSwgaW4gd2hpY2ggZW5kcG9pbnRBcmdzIGVuZHMgdXAgZ2V0dGluZyBzaGFyZWQgYnlcbiAgICAgICAgICAgIC8vIHRoZSB3aG9sZSB3b3JsZC5cbiAgICAgICAgICAgIC8vdmFyIGFyZ3NGb3JDbG9uZSA9IGpzUGx1bWIuZXh0ZW5kKHt9LCBlbmRwb2ludEFyZ3MpO1xuICAgICAgICAgICAgZW5kcG9pbnQuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzLCBhbmQgdGhlIGNvZGUgYWJvdmUsIGNhbiBiZSByZWZhY3RvcmVkIHRvIGJlIG1vcmUgZHJ5LlxuICAgICAgICAgICAgICAgIGlmIChfanUuaXNTdHJpbmcoZXApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2UoZXAsIGVuZHBvaW50QXJncyk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2p1LmlzQXJyYXkoZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50QXJncyA9IF9qdS5tZXJnZShlcFsxXSwgZW5kcG9pbnRBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lKGVwWzBdLCBlbmRwb2ludEFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgZW5kcG9pbnQudHlwZUlkID0gdHlwZUlkO1xuICAgICAgICAgICAgcmV0dXJuIGVuZHBvaW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0RW5kcG9pbnQgPSBmdW5jdGlvbihlcCwgZG9Ob3RSZXBhaW50KSB7XG4gICAgICAgICAgICB2YXIgX2VwID0gdGhpcy5wcmVwYXJlRW5kcG9pbnQoZXApO1xuICAgICAgICAgICAgdGhpcy5zZXRQcmVwYXJlZEVuZHBvaW50KF9lcCwgdHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRQcmVwYXJlZEVuZHBvaW50ID0gZnVuY3Rpb24gKGVwLCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZHBvaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50LmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW5kcG9pbnQgPSBlcDtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHRoaXMuZW5kcG9pbnQudHlwZTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5lbmRwb2ludC5jYW52YXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgX2pwLmV4dGVuZCh0aGlzLCBwYXJhbXMsIHR5cGVQYXJhbWV0ZXJzKTtcblxuICAgICAgICB0aGlzLmlzU291cmNlID0gcGFyYW1zLmlzU291cmNlIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVGVtcG9yYXJ5U291cmNlID0gcGFyYW1zLmlzVGVtcG9yYXJ5U291cmNlIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVGFyZ2V0ID0gcGFyYW1zLmlzVGFyZ2V0IHx8IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMgPSBwYXJhbXMuY29ubmVjdGlvbnMgfHwgW107XG4gICAgICAgIHRoaXMuY29ubmVjdG9yUG9pbnRlckV2ZW50cyA9IHBhcmFtc1tcImNvbm5lY3Rvci1wb2ludGVyLWV2ZW50c1wiXTtcblxuICAgICAgICB0aGlzLnNjb3BlID0gcGFyYW1zLnNjb3BlIHx8IF9qc1BsdW1iLmdldERlZmF1bHRTY29wZSgpO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVhdHRhY2hDb25uZWN0aW9ucyA9IHBhcmFtcy5yZWF0dGFjaCB8fCBfanNQbHVtYi5EZWZhdWx0cy5SZWF0dGFjaENvbm5lY3Rpb25zO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zRGV0YWNoYWJsZSA9IF9qc1BsdW1iLkRlZmF1bHRzLkNvbm5lY3Rpb25zRGV0YWNoYWJsZTtcbiAgICAgICAgaWYgKHBhcmFtcy5jb25uZWN0aW9uc0RldGFjaGFibGUgPT09IGZhbHNlIHx8IHBhcmFtcy5kZXRhY2hhYmxlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnNEZXRhY2hhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhZ0FsbG93ZWRXaGVuRnVsbCA9IHBhcmFtcy5kcmFnQWxsb3dlZFdoZW5GdWxsICE9PSBmYWxzZTtcblxuICAgICAgICBpZiAocGFyYW1zLm9uTWF4Q29ubmVjdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmJpbmQoXCJtYXhDb25uZWN0aW9uc1wiLCBwYXJhbXMub25NYXhDb25uZWN0aW9ucyk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gYWRkIGEgY29ubmVjdGlvbi4gbm90IHBhcnQgb2YgcHVibGljIEFQSS5cbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5hZGRDb25uZWN0aW9uID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnMucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXNbKHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoID4gMCA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArIFwiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnRDb25uZWN0ZWRDbGFzcyk7XG4gICAgICAgICAgICB0aGlzWyh0aGlzLmlzRnVsbCgpID8gXCJhZGRcIiA6IFwicmVtb3ZlXCIpICsgXCJDbGFzc1wiXShfanNQbHVtYi5lbmRwb2ludEZ1bGxDbGFzcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kZXRhY2hGcm9tQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBpZHgsIGRvTm90Q2xlYW51cCkge1xuICAgICAgICAgICAgaWR4ID0gaWR4ID09IG51bGwgPyB0aGlzLmNvbm5lY3Rpb25zLmluZGV4T2YoY29ubmVjdGlvbikgOiBpZHg7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXNbKHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoID4gMCA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArIFwiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnRDb25uZWN0ZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgdGhpc1sodGhpcy5pc0Z1bGwoKSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArIFwiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnRGdWxsQ2xhc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKHRoaXMuX2ZvcmNlRGVsZXRlT25EZXRhY2ggfHwgKCFkb05vdENsZWFudXAgJiYgdGhpcy5fZGVsZXRlT25EZXRhY2gpKSAmJiB0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF9qc1BsdW1iLmRlbGV0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAvL2RlbGV0ZUF0dGFjaGVkT2JqZWN0czogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlQXR0YWNoZWRPYmplY3RzOiBkb05vdENsZWFudXAgIT09IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvL3RoaXMuZGV0YWNoID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIGlnbm9yZVRhcmdldCwgZm9yY2VEZXRhY2gsIGZpcmVFdmVudCwgb3JpZ2luYWxFdmVudCwgZW5kcG9pbnRCZWluZ0RlbGV0ZWQsIGNvbm5lY3Rpb25JbmRleCkge1xuXG4gICAgICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25JbmRleCA9IHBhcmFtcy5jb25uZWN0aW9uSW5kZXgsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IHBhcmFtcy5jb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIGlnbm9yZVRhcmdldCA9IHBhcmFtcy5pZ25vcmVUYXJnZXQsXG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50ID0gcGFyYW1zLmZpcmVFdmVudCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50ID0gcGFyYW1zLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnRCZWluZ0RlbGV0ZWQgPSBwYXJhbXMuZW5kcG9pbnRCZWluZ0RlbGV0ZWQsXG4gICAgICAgICAgICAgICAgZm9yY2VEZXRhY2ggPSBwYXJhbXMuZm9yY2VEZXRhY2g7XG5cbiAgICAgICAgICAgIHZhciBpZHggPSBjb25uZWN0aW9uSW5kZXggPT0gbnVsbCA/IHRoaXMuY29ubmVjdGlvbnMuaW5kZXhPZihjb25uZWN0aW9uKSA6IGNvbm5lY3Rpb25JbmRleCxcbiAgICAgICAgICAgICAgICBhY3R1YWxseURldGFjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmaXJlRXZlbnQgPSAoZmlyZUV2ZW50ICE9PSBmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlRGV0YWNoIHx8IGNvbm5lY3Rpb24uX2ZvcmNlRGV0YWNoIHx8IChjb25uZWN0aW9uLmlzRGV0YWNoYWJsZSgpICYmIGNvbm5lY3Rpb24uaXNEZXRhY2hBbGxvd2VkKGNvbm5lY3Rpb24pICYmIHRoaXMuaXNEZXRhY2hBbGxvd2VkKGNvbm5lY3Rpb24pICYmIF9qc1BsdW1iLmNoZWNrQ29uZGl0aW9uKFwiYmVmb3JlRGV0YWNoXCIsIGNvbm5lY3Rpb24sIGVuZHBvaW50QmVpbmdEZWxldGVkKSApKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZGVsZXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQ6ICghaWdub3JlVGFyZ2V0ICYmIGZpcmVFdmVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlQXR0YWNoZWRPYmplY3RzOnBhcmFtcy5kZWxldGVBdHRhY2hlZE9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZGVsZXRlQXR0YWNoZWRPYmplY3RzOm51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbGx5RGV0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY3R1YWxseURldGFjaGVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGV0YWNoQWxsID0gZnVuY3Rpb24gKGZpcmVFdmVudCwgZm9yY2VEZXRhY2gpIHtcbiAgICAgICAgICAgIHZhciB1bmFmZmVjdGVkQ29ubnMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgY291bGQgcGFzcyB0aGUgaW5kZXggaW4gdG8gdGhlIGRldGFjaCBtZXRob2QgdG8gc2F2ZSBzb21lIHRpbWUgKGluZGV4IHdpbGwgYWx3YXlzIGJlIHplcm8gaW4gdGhpcyB3aGlsZSBsb29wKVxuICAgICAgICAgICAgICAgIHZhciBhY3R1YWxseURldGFjaGVkID0gdGhpcy5kZXRhY2goe1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOnRoaXMuY29ubmVjdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZVRhcmdldDpmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VEZXRhY2g6Zm9yY2VEZXRhY2ggPT09IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudDpmaXJlRXZlbnQgIT09IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50Om51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50QmVpbmdEZWxldGVkOnRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JbmRleDowXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3R1YWxseURldGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuYWZmZWN0ZWRDb25ucy5wdXNoKHRoaXMuY29ubmVjdGlvbnNbMF0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnNwbGljZSgwLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zID0gdW5hZmZlY3RlZENvbm5zO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGV0YWNoRnJvbSA9IGZ1bmN0aW9uICh0YXJnZXRFbmRwb2ludCwgZmlyZUV2ZW50LCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgYyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbnNbaV0uZW5kcG9pbnRzWzFdID09IHRhcmdldEVuZHBvaW50IHx8IHRoaXMuY29ubmVjdGlvbnNbaV0uZW5kcG9pbnRzWzBdID09IHRhcmdldEVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGMucHVzaCh0aGlzLmNvbm5lY3Rpb25zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246Y1tqXSxcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlVGFyZ2V0OmZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmb3JjZURldGFjaDp0cnVlLFxuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQ6ZmlyZUV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50Om9yaWdpbmFsRXZlbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50SWQgPSB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldElkKGVsKSxcbiAgICAgICAgICAgICAgICBjdXJJZCA9IHRoaXMuZWxlbWVudElkO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBlbmRwb2ludCBmcm9tIHRoZSBsaXN0IGZvciB0aGUgY3VycmVudCBlbmRwb2ludCdzIGVsZW1lbnRcbiAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24ocGFyYW1zLmVuZHBvaW50c0J5RWxlbWVudFt0aGlzLmVsZW1lbnRJZF0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuaWQgPT0gdGhpcy5pZDtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBqc1BsdW1iLmdldEVsZW1lbnQoZWwpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50SWQgPSBfanNQbHVtYi5nZXRJZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgX2pzUGx1bWIuYW5jaG9yTWFuYWdlci5yZWhvbWVFbmRwb2ludCh0aGlzLCBjdXJJZCwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIF9qc1BsdW1iLmRyYWdNYW5hZ2VyLmVuZHBvaW50QWRkZWQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIF9qdS5hZGRUb0xpc3QocGFyYW1zLmVuZHBvaW50c0J5RWxlbWVudCwgcGFyZW50SWQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByaXZhdGUgYnV0IG11c3QgYmUgZXhwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFrZUluUGxhY2VDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvYyA9IHRoaXMuYW5jaG9yLmdldEN1cnJlbnRMb2NhdGlvbih7ZWxlbWVudDogdGhpc30pLFxuICAgICAgICAgICAgICAgIG8gPSB0aGlzLmFuY2hvci5nZXRPcmllbnRhdGlvbih0aGlzKSxcbiAgICAgICAgICAgICAgICBhY2MgPSB0aGlzLmFuY2hvci5nZXRDc3NDbGFzcygpLFxuICAgICAgICAgICAgICAgIGluUGxhY2VBbmNob3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgbG9jWzBdLCBsb2NbMV0gXTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q3VycmVudExvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBsb2NbMF0sIGxvY1sxXSBdO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRPcmllbnRhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldENzc0NsYXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIF9uZXdFbmRwb2ludCh7XG4gICAgICAgICAgICAgICAgZHJvcE9wdGlvbnM6IHBhcmFtcy5kcm9wT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhbmNob3I6IGluUGxhY2VBbmNob3IsXG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgcGFpbnRTdHlsZTogdGhpcy5nZXRQYWludFN0eWxlKCksXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IHBhcmFtcy5oaWRlT25EcmFnID8gXCJCbGFua1wiIDogdGhpcy5lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBfdHJhbnNpZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIHNjb3BlOiB0aGlzLnNjb3BlLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZTp0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJucyBhIGNvbm5lY3Rpb24gZnJvbSB0aGUgcG9vbDsgdXNlZCB3aGVuIGRyYWdnaW5nIHN0YXJ0cy4gIGp1c3QgZ2V0cyB0aGUgaGVhZCBvZiB0aGUgYXJyYXkgaWYgaXQgY2FuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0b3JTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSB0aGlzLmNvbm5lY3Rpb25zWzBdO1xuICAgICAgICAgICAgLy8gU1AgdGFyZ2V0IHNvdXJjZSByZWZhY3RvclxuICAgICAgICAgICAgaWYgKC8qdGhpcy5pc1RhcmdldCAmJiAqL2NhbmRpZGF0ZSkgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jb25uZWN0aW9ucy5sZW5ndGggPCB0aGlzLl9qc1BsdW1iLm1heENvbm5lY3Rpb25zKSB8fCB0aGlzLl9qc1BsdW1iLm1heENvbm5lY3Rpb25zID09IC0xID8gbnVsbCA6IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldFN0eWxlID0gdGhpcy5zZXRQYWludFN0eWxlO1xuXG4gICAgICAgIHRoaXMucGFpbnQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gcGFyYW1zLnRpbWVzdGFtcCwgcmVjYWxjID0gIShwYXJhbXMucmVjYWxjID09PSBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoIXRpbWVzdGFtcCB8fCB0aGlzLnRpbWVzdGFtcCAhPT0gdGltZXN0YW1wKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IF9qc1BsdW1iLnVwZGF0ZU9mZnNldCh7IGVsSWQ6IHRoaXMuZWxlbWVudElkLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KTtcblxuICAgICAgICAgICAgICAgIHZhciB4eSA9IHBhcmFtcy5vZmZzZXQgPyBwYXJhbXMub2Zmc2V0Lm8gOiBpbmZvLm87XG4gICAgICAgICAgICAgICAgaWYgKHh5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwID0gcGFyYW1zLmFuY2hvclBvaW50LCBjb25uZWN0b3JQYWludFN0eWxlID0gcGFyYW1zLmNvbm5lY3RvclBhaW50U3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2ggPSBwYXJhbXMuZGltZW5zaW9ucyB8fCBpbmZvLnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yUGFyYW1zID0geyB4eTogWyB4eS5sZWZ0LCB4eS50b3AgXSwgd2g6IHdoLCBlbGVtZW50OiB0aGlzLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2FsYyAmJiB0aGlzLmFuY2hvci5pc0R5bmFtaWMgJiYgdGhpcy5jb25uZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBmaW5kQ29ubmVjdGlvblRvVXNlRm9yRHluYW1pY0FuY2hvcih0aGlzLCBwYXJhbXMuZWxlbWVudFdpdGhQcmVjZWRlbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb0lkeCA9IGMuZW5kcG9pbnRzWzBdID09IHRoaXMgPyAxIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb0lkID0gb0lkeCA9PT0gMCA/IGMuc291cmNlSWQgOiBjLnRhcmdldElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvSW5mbyA9IF9qc1BsdW1iLmdldENhY2hlZERhdGEob0lkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb09mZnNldCA9IG9JbmZvLm8sIG9XSCA9IG9JbmZvLnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yUGFyYW1zLnR4eSA9IFsgb09mZnNldC5sZWZ0LCBvT2Zmc2V0LnRvcCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvclBhcmFtcy50d2ggPSBvV0g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yUGFyYW1zLnRFbGVtZW50ID0gYy5lbmRwb2ludHNbb0lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcCA9IHRoaXMuYW5jaG9yLmNvbXB1dGUoYW5jaG9yUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnQuY29tcHV0ZShhcCwgdGhpcy5hbmNob3IuZ2V0T3JpZW50YXRpb24odGhpcyksIHRoaXMuX2pzUGx1bWIucGFpbnRTdHlsZUluVXNlLCBjb25uZWN0b3JQYWludFN0eWxlIHx8IHRoaXMucGFpbnRTdHlsZUluVXNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludC5wYWludCh0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGVJblVzZSwgdGhpcy5hbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBwYWludCBvdmVybGF5c1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iLm92ZXJsYXlzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheVBsYWNlbWVudHNbaV0gPSBvLmRyYXcodGhpcy5lbmRwb2ludCwgdGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnBhaW50KHRoaXMuX2pzUGx1bWIub3ZlcmxheVBsYWNlbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldFR5cGVEZXNjcmlwdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5kcG9pbnRcIjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi52aXNpYmxlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVwYWludCA9IHRoaXMucGFpbnQ7XG5cbiAgICAgICAgdmFyIGRyYWdnaW5nSW5pdGlhbGlzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0RHJhZ2dhYmxlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAvLyBpcyB0aGlzIGEgY29ubmVjdGlvbiBzb3VyY2U/IHdlIG1ha2UgaXQgZHJhZ2dhYmxlIGFuZCBoYXZlIHRoZVxuICAgICAgICAgICAgLy8gZHJhZyBsaXN0ZW5lciBtYWludGFpbiBhIGNvbm5lY3Rpb24gd2l0aCBhIGZsb2F0aW5nIGVuZHBvaW50LlxuICAgICAgICAgICAgaWYgKCFkcmFnZ2luZ0luaXRpYWxpc2VkICYmIF9qcC5pc0RyYWdTdXBwb3J0ZWQodGhpcy5lbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlckluZm8gPSB7IGlkOiBudWxsLCBlbGVtZW50OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIGpwYyA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSnBjID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSnBjUGFyYW1zID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgX2RyYWdIYW5kbGVyID0gX21ha2VDb25uZWN0aW9uRHJhZ0hhbmRsZXIodGhpcywgcGxhY2Vob2xkZXJJbmZvLCBfanNQbHVtYiksXG4gICAgICAgICAgICAgICAgICAgIGRyYWdPcHRpb25zID0gcGFyYW1zLmRyYWdPcHRpb25zIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0T3B0cyA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBzdGFydEV2ZW50ID0gX2pwLmRyYWdFdmVudHMuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BFdmVudCA9IF9qcC5kcmFnRXZlbnRzLnN0b3AsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdFdmVudCA9IF9qcC5kcmFnRXZlbnRzLmRyYWcsXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVN0YXJ0RXZlbnQgPSBfanAuZHJhZ0V2ZW50cy5iZWZvcmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDtcblxuICAgICAgICAgICAgICAgIC8vIHJlc3BvbmQgdG8gYmVmb3JlU3RhcnQgZnJvbSBrYXRhdm9yaW87IHRoaXMgd2lsbCBoYXZlLCBvcHRpb25hbGx5LCBhIHBheWxvYWQgb2YgYXR0cmlidXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2VyZSBwbGFjZWQgdGhlcmUgYnkgdGhlIG1ha2VTb3VyY2UgbW91c2Vkb3duIGxpc3RlbmVyLlxuICAgICAgICAgICAgICAgIHZhciBiZWZvcmVTdGFydCA9IGZ1bmN0aW9uKGJlZm9yZVN0YXJ0UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBiZWZvcmVTdGFydFBhcmFtcy5lLnBheWxvYWQgfHwge307XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGZ1bmN0aW9uIChzdGFydFBhcmFtcykge1xuXG4vLyAtLS0tLS0tLS0tLS0tICAgZmlyc3QsIGdldCBhIGNvbm5lY3Rpb24gdG8gZHJhZy4gdGhpcyBtYXkgYmUgbnVsbCwgaW4gd2hpY2ggY2FzZSB3ZSBhcmUgZHJhZ2dpbmcgYSBuZXcgb25lLlxuXG4gICAgICAgICAgICAgICAgICAgIGpwYyA9IHRoaXMuY29ubmVjdG9yU2VsZWN0b3IoKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gbm93IGEgYnVuY2ggb2YgdGVzdHMgYWJvdXQgd2hldGhlciBvciBub3QgdG8gcHJvY2VlZCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jb250aW51ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBlbmFibGVkLCByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCgpKSBfY29udGludWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gY29ubmVjdGlvbiBhbmQgd2UncmUgbm90IGEgc291cmNlIC0gb3IgdGVtcG9yYXJpbHkgYSBzb3VyY2UsIGFzIGlzIHRoZSBjYXNlIHdpdGggbWFrZVNvdXJjZSAtIHJldHVybi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpwYyA9PSBudWxsICYmICF0aGlzLmlzU291cmNlICYmICF0aGlzLmlzVGVtcG9yYXJ5U291cmNlKSBfY29udGludWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIHdlJ3JlIGZ1bGwgYW5kIG5vdCBhbGxvd2VkIHRvIGRyYWcsIGFsc28gcmV0dXJuIGZhbHNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NvdXJjZSAmJiB0aGlzLmlzRnVsbCgpICYmICEoanBjICE9IG51bGwgJiYgdGhpcy5kcmFnQWxsb3dlZFdoZW5GdWxsKSkgX2NvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjb25uZWN0aW9uIHdhcyBzZXR1cCBhcyBub3QgZGV0YWNoYWJsZSBvciBvbmUgb2YgaXRzIGVuZHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAvLyB3YXMgc2V0dXAgYXMgY29ubmVjdGlvbnNEZXRhY2hhYmxlID0gZmFsc2UsIG9yIERlZmF1bHRzLkNvbm5lY3Rpb25zRGV0YWNoYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBzZXQgdG8gZmFsc2UuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpwYyAhPSBudWxsICYmICFqcGMuaXNEZXRhY2hhYmxlKHRoaXMpKSBfY29udGludWUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlRHJhZyA9IF9qc1BsdW1iLmNoZWNrQ29uZGl0aW9uKGpwYyA9PSBudWxsID8gXCJiZWZvcmVEcmFnXCIgOiBcImJlZm9yZVN0YXJ0RGV0YWNoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OnRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6dGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSWQ6dGhpcy5lbGVtZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOmpwY1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZURyYWcgPT09IGZhbHNlKSBfY29udGludWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSB3ZSBtaWdodCBoYXZlIGJlZW4gZ2l2ZW4gc29tZSBkYXRhLiB3ZSdsbCBwYXNzIGl0IGluIHRvIGEgbmV3IGNvbm5lY3Rpb24gYXMgJ2RhdGEnLlxuICAgICAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIGFsc28gbWVyZ2UgaW4gdGhlIG9wdGlvbmFsIHBheWxvYWQgd2Ugd2VyZSBnaXZlbiBvbiBtb3VzZWRvd24uXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBiZWZvcmVEcmFnID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc1BsdW1iLmV4dGVuZChiZWZvcmVEcmFnLCBwYXlsb2FkIHx8IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBubyBiZWZvcmVEcmFnIGRhdGEsIG1heWJlIHVzZSB0aGUgcGF5bG9hZCBvbiBpdHMgb3duLlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRHJhZyA9IHBheWxvYWQgfHwge307XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jb250aW51ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZm9yIG1vb3Rvb2xzIGFuZCB5dWkuIHJldHVybmluZyBmYWxzZSBmcm9tIHRoaXMgY2F1c2VzIGpxdWVyeSB0byBzdG9wIGRyYWcuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZXZlbnRzIGFyZSB3cmFwcGVkIGluIGJvdGggbW9vdG9vbHMgYW5kIHl1aSBhbnl3YXksIGJ1dCBpIGRvbid0IHRoaW5rIHJldHVybmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsc2UgZnJvbSB0aGUgc3RhcnQgY2FsbGJhY2sgd291bGQgc3RvcCBhIGRyYWcuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2pzUGx1bWIuc3RvcERyYWcpIF9qc1BsdW1iLnN0b3BEcmFnKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kcmFnSGFuZGxlci5zdG9wRHJhZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9rIHRvIHByb2NlZWQuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgaG92ZXIgZm9yIGFsbCBjb25uZWN0aW9ucyBmb3IgdGhpcyBlbmRwb2ludCBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uc1tpXS5zZXRIb3ZlcihmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDbGFzcyhcImVuZHBvaW50RHJhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuc2V0Q29ubmVjdGlvbkJlaW5nRHJhZ2dlZCh0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBub3QgZnVsbCBidXQgdGhlcmUgd2FzIGEgY29ubmVjdGlvbiwgbWFrZSBpdCBudWxsLiB3ZSdsbCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgICAgICAgICAgICAgICBpZiAoanBjICYmICF0aGlzLmlzRnVsbCgpICYmIHRoaXMuaXNTb3VyY2UpIGpwYyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIudXBkYXRlT2Zmc2V0KHsgZWxJZDogdGhpcy5lbGVtZW50SWQgfSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0gICAgbWFrZSB0aGUgZWxlbWVudCB3ZSB3aWxsIGRyYWcgYXJvdW5kLCBhbmQgcG9zaXRpb24gaXQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXBjbyA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZ2V0T2Zmc2V0KHRoaXMuY2FudmFzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc0VsZW1lbnQgPSB0aGlzLmNhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwcyA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZ2V0U2l6ZSh0aGlzLmNhbnZhcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgX21ha2VEcmFnZ2FibGVQbGFjZWhvbGRlcihwbGFjZWhvbGRlckluZm8sIF9qc1BsdW1iLCBpcGNvLCBpcHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBpZCBvZiB0aGUgZHJhZ2dpbmcgZGl2IGFuZCB0aGUgc291cmNlIGVsZW1lbnQuIHRoZSBkcm9wIGZ1bmN0aW9uIHdpbGwgcGljayB0aGVzZSB1cC4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnNldEF0dHJpYnV0ZXModGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZHJhZ0lkXCI6IHBsYWNlaG9sZGVySW5mby5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZWxJZFwiOiB0aGlzLmVsZW1lbnRJZFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLSBjcmVhdGUgYW4gZW5kcG9pbnQgdGhhdCB3aWxsIGJlIG91ciBmbG9hdGluZyBlbmRwb2ludCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kcG9pbnRUb0Zsb2F0ID0gdGhpcy5kcmFnUHJveHkgfHwgdGhpcy5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ1Byb3h5ID09IG51bGwgJiYgdGhpcy5jb25uZWN0aW9uVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWFlID0gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5kZXJpdmVFbmRwb2ludEFuZEFuY2hvclNwZWModGhpcy5jb25uZWN0aW9uVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWFlLmVuZHBvaW50c1sxXSkgZW5kcG9pbnRUb0Zsb2F0ID0gYWFlLmVuZHBvaW50c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyQW5jaG9yID0gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5tYWtlQW5jaG9yKFwiQ2VudGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXJBbmNob3IuaXNGbG9hdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludCA9IF9tYWtlRmxvYXRpbmdFbmRwb2ludCh0aGlzLmdldFBhaW50U3R5bGUoKSwgY2VudGVyQW5jaG9yLCBlbmRwb2ludFRvRmxvYXQsIHRoaXMuY2FudmFzLCBwbGFjZWhvbGRlckluZm8uZWxlbWVudCwgX2pzUGx1bWIsIF9uZXdFbmRwb2ludCwgdGhpcy5zY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc2F2ZWRBbmNob3IgPSB0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQuYW5jaG9yO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpwYyA9PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SG92ZXIoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGNvbm5lY3Rpb24uIG9uZSBlbmQgaXMgdGhpcyBlbmRwb2ludCwgdGhlIG90aGVyIGlzIGEgZmxvYXRpbmcgZW5kcG9pbnQuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYyA9IF9uZXdDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VFbmRwb2ludDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbmRwb2ludDogdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5lbGVtZW50LCAgLy8gZm9yIG1ha2VTb3VyY2Ugd2l0aCBwYXJlbnQgb3B0aW9uLiAgZW5zdXJlIHNvdXJjZSBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHBsYWNlaG9sZGVySW5mby5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvcnM6IFsgdGhpcy5hbmNob3IsIHRoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludC5hbmNob3IgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWludFN0eWxlOiBwYXJhbXMuY29ubmVjdG9yU3R5bGUsIC8vIHRoaXMgY2FuIGJlIG51bGwuIENvbm5lY3Rpb24gd2lsbCB1c2UgdGhlIGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJQYWludFN0eWxlOiBwYXJhbXMuY29ubmVjdG9ySG92ZXJTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3I6IHBhcmFtcy5jb25uZWN0b3IsIC8vIHRoaXMgY2FuIGFsc28gYmUgbnVsbC4gQ29ubmVjdGlvbiB3aWxsIHVzZSB0aGUgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5czogcGFyYW1zLmNvbm5lY3Rvck92ZXJsYXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuY29ubmVjdGlvblR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHRoaXMuY29ubmVjdG9yQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJDbGFzczogdGhpcy5jb25uZWN0b3JIb3ZlckNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOnBhcmFtcy5zY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOmJlZm9yZURyYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLmFkZENsYXNzKF9qc1BsdW1iLmRyYWdnaW5nQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50LmFkZENsYXNzKF9qc1BsdW1iLmRyYWdnaW5nQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50LmFuY2hvciA9IF9zYXZlZEFuY2hvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgYW4gZXZlbnQgdGhhdCBpbmZvcm1zIHRoYXQgYSBjb25uZWN0aW9uIGlzIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmZpcmUoXCJjb25uZWN0aW9uRHJhZ1wiLCBqcGMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciB0aGUgbmV3IGNvbm5lY3Rpb24gb24gdGhlIGRyYWcgbWFuYWdlci4gVGhpcyBjb25uZWN0aW9uLCBhdCB0aGlzIHBvaW50LCBpcyAncGVuZGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaGFzIGFzIGl0cyB0YXJnZXQgYSB0ZW1wb3JhcnkgZWxlbWVudCAodGhlICdwbGFjZWhvbGRlcicpLiBJZiB0aGUgY29ubmVjdGlvbiBzdWJzZXF1ZW50bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY29tZXMgZXN0YWJsaXNoZWQsIHRoZSBhbmNob3IgbWFuYWdlciBpcyBpbmZvcm1lZCB0aGF0IHRoZSB0YXJnZXQgb2YgdGhlIGNvbm5lY3Rpb24gaGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VkLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5hbmNob3JNYW5hZ2VyLm5ld0Nvbm5lY3Rpb24oanBjKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdKcGMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLnNldEhvdmVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBhbmNob3IgaWR4XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9ySWR4ID0ganBjLmVuZHBvaW50c1swXS5pZCA9PSB0aGlzLmlkID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRldGFjaEZyb21Db25uZWN0aW9uKGpwYywgbnVsbCwgdHJ1ZSk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRldGFjaCBmcm9tIHRoZSBjb25uZWN0aW9uIHdoaWxlIGRyYWdnaW5nIGlzIG9jY3VycmluZy4gYnV0IGRvbnQgY2xlYW51cCBhdXRvbWF0aWNhbGx5LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgb3JpZ2luYWwgc2NvcGUgKGlzc3VlIDU3KVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdTY29wZSA9IF9qc1BsdW1iLmdldERyYWdTY29wZShjYW52YXNFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnNldEF0dHJpYnV0ZSh0aGlzLmNhbnZhcywgXCJvcmlnaW5hbFNjb3BlXCIsIGRyYWdTY29wZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgYW4gZXZlbnQgdGhhdCBpbmZvcm1zIHRoYXQgYSBjb25uZWN0aW9uIGlzIGJlaW5nIGRyYWdnZWQuIHdlIGRvIHRoaXMgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNpbmcgdGhlIG9yaWdpbmFsIHRhcmdldCB3aXRoIHRoZSBmbG9hdGluZyBlbGVtZW50IGluZm8uXG4gICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5maXJlKFwiY29ubmVjdGlvbkRyYWdcIiwganBjKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IHdlIHJlcGxhY2Ugb3Vyc2VsdmVzIHdpdGggdGhlIHRlbXBvcmFyeSBkaXYgd2UgY3JlYXRlZCBhYm92ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmNob3JJZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0pwY1BhcmFtcyA9IFsganBjLnNvdXJjZSwganBjLnNvdXJjZUlkLCBjYW52YXNFbGVtZW50LCBkcmFnU2NvcGUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQoanBjLmVuZHBvaW50c1thbmNob3JJZHhdLmVsZW1lbnRJZCwgcGxhY2Vob2xkZXJJbmZvLmlkLCBqcGMsIHBsYWNlaG9sZGVySW5mby5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0pwY1BhcmFtcyA9IFsganBjLnRhcmdldCwganBjLnRhcmdldElkLCBjYW52YXNFbGVtZW50LCBkcmFnU2NvcGUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMudGFyZ2V0ID0gcGxhY2Vob2xkZXJJbmZvLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLnRhcmdldElkID0gcGxhY2Vob2xkZXJJbmZvLmlkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuYW5jaG9yTWFuYWdlci51cGRhdGVPdGhlckVuZHBvaW50KGpwYy5zb3VyY2VJZCwganBjLmVuZHBvaW50c1thbmNob3JJZHhdLmVsZW1lbnRJZCwganBjLnRhcmdldElkLCBqcGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgb3JpZ2luYWwgZW5kcG9pbnQgYW5kIGFzc2lnbiB0aGUgbmV3IGZsb2F0aW5nIGVuZHBvaW50IGZvciB0aGUgZHJhZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zdXNwZW5kZWRFbmRwb2ludCA9IGpwYy5lbmRwb2ludHNbYW5jaG9ySWR4XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUFJPVklERSBUSEUgU1VTUEVOREVEIEVMRU1FTlQsIEJFIElUIEEgU09VUkNFIE9SIFRBUkdFVCAoSVNTVUUgMzkpXG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuc3VzcGVuZGVkRWxlbWVudCA9IGpwYy5lbmRwb2ludHNbYW5jaG9ySWR4XS5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuc3VzcGVuZGVkRWxlbWVudElkID0ganBjLmVuZHBvaW50c1thbmNob3JJZHhdLmVsZW1lbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zdXNwZW5kZWRFbGVtZW50VHlwZSA9IGFuY2hvcklkeCA9PT0gMCA/IFwic291cmNlXCIgOiBcInRhcmdldFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuc3VzcGVuZGVkRW5kcG9pbnQuc2V0SG92ZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50LnJlZmVyZW5jZUVuZHBvaW50ID0ganBjLnN1c3BlbmRlZEVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLmVuZHBvaW50c1thbmNob3JJZHhdID0gdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuYWRkQ2xhc3MoX2pzUGx1bWIuZHJhZ2dpbmdDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQuYWRkQ2xhc3MoX2pzUGx1bWIuZHJhZ2dpbmdDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBpdCBhbmQgcmVnaXN0ZXIgY29ubmVjdGlvbiBvbiBpdC5cbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZmxvYXRpbmdDb25uZWN0aW9uc1twbGFjZWhvbGRlckluZm8uaWRdID0ganBjO1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHJlZ2lzdGVyIGZvciB0aGUgdGFyZ2V0IGVuZHBvaW50OyB3ZSB3aWxsIG5vdCBiZSBkcmFnZ2luZyB0aGUgc291cmNlIGF0IGFueSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSB0aGlzIGNvbm5lY3Rpb24gaXMgZWl0aGVyIGRpc2NhcmRlZCBvciBtYWRlIGludG8gYSBwZXJtYW5lbnQgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgX2p1LmFkZFRvTGlzdChwYXJhbXMuZW5kcG9pbnRzQnlFbGVtZW50LCBwbGFjZWhvbGRlckluZm8uaWQsIHRoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRlbGwganNwbHVtYiBhYm91dCBpdFxuICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5jdXJyZW50bHlEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnNldENvbm5lY3Rpb25CZWluZ0RyYWdnZWQoZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqcGMgJiYganBjLmVuZHBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGFjdHVhbCBkcm9wIGV2ZW50IChkZWNvZGUgZnJvbSBsaWJyYXJ5IGFyZ3MgdG8gc3RvcCBmdW5jdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX2pzUGx1bWIuZ2V0RHJvcEV2ZW50KGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmxvY2sgdGhlIG90aGVyIGVuZHBvaW50IChpZiBpdCBpcyBkeW5hbWljLCBpdCB3b3VsZCBoYXZlIGJlZW4gbG9ja2VkIGF0IGRyYWcgc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gX2pzUGx1bWIuZ2V0RmxvYXRpbmdBbmNob3JJbmRleChqcGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLmVuZHBvaW50c1tpZHggPT09IDAgPyAxIDogMF0uYW5jaG9yLmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRG9udCB3YW50IHRvIGtub3cgYWJvdXQgY3NzIGNsYXNzZXMgaW5zaWRlIGpzcGx1bWIsIGlkZWFsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMucmVtb3ZlQ2xhc3MoX2pzUGx1bWIuZHJhZ2dpbmdDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgdGhlIGZsb2F0aW5nIGVuZHBvaW50IHRoZW4gdGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGRyb3BwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIGFub3RoZXIgZW5kcG9pbnQuICBJZiBpdCBpcyBhIG5ldyBjb25uZWN0aW9uIHdlIHRocm93IGl0IGF3YXkuIElmIGl0IGlzIGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBjb25uZWN0aW9uIHdlIGNoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgcmVhdHRhY2ggaXQsIHRocm93aW5nIGl0IGF3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iICYmIChqcGMuZGVsZXRlQ29ubmVjdGlvbk5vdyB8fCBqcGMuZW5kcG9pbnRzW2lkeF0gPT0gdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDZhLiBpZiB0aGUgY29ubmVjdGlvbiB3YXMgYW4gZXhpc3Rpbmcgb25lLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nSnBjICYmIGpwYy5zdXNwZW5kZWRFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXggZm9yIGlzc3VlMzUsIHRoYW5rcyBTeWx2YWluIEdpemFyZDogd2hlbiBmaXJpbmcgdGhlIGRldGFjaCBldmVudCBtYWtlIHN1cmUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZsb2F0aW5nIGVuZHBvaW50IGhhcyBiZWVuIHJlcGxhY2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuZmxvYXRpbmdFbGVtZW50ID0ganBjLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5mbG9hdGluZ0lkID0ganBjLnNvdXJjZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nRW5kcG9pbnQgPSBqcGMuZW5kcG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLnNvdXJjZSA9IGV4aXN0aW5nSnBjUGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLnNvdXJjZUlkID0gZXhpc3RpbmdKcGNQYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGEgY29weSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudDsgdGhlIGFuY2hvciBtYW5hZ2VyIHdpbGwgd2FudCB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5mbG9hdGluZ0VsZW1lbnQgPSBqcGMudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nSWQgPSBqcGMudGFyZ2V0SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuZmxvYXRpbmdFbmRwb2ludCA9IGpwYy5lbmRwb2ludHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuZmxvYXRpbmdJbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMudGFyZ2V0ID0gZXhpc3RpbmdKcGNQYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMudGFyZ2V0SWQgPSBleGlzdGluZ0pwY1BhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZSA9IHRoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludDsgLy8gc3RvcmUgZm9yIGxhdGVyIHJlbW92YWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHNjb3BlIChpc3N1ZSA1NylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuc2V0RHJhZ1Njb3BlKGV4aXN0aW5nSnBjUGFyYW1zWzJdLCBleGlzdGluZ0pwY1BhcmFtc1szXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5lbmRwb2ludHNbaWR4XSA9IGpwYy5zdXNwZW5kZWRFbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUYgdGhlIGNvbm5lY3Rpb24gc2hvdWxkIGJlIHJlYXR0YWNoZWQsIG9yIHRoZSBvdGhlciBlbmRwb2ludCByZWZ1c2VzIGRldGFjaCwgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgY29ubmVjdGlvbiB0byBpdHMgb3JpZ2luYWwgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpwYy5pc1JlYXR0YWNoKCkgfHwganBjLl9mb3JjZVJlYXR0YWNoIHx8IGpwYy5fZm9yY2VEZXRhY2ggfHwgIWpwYy5lbmRwb2ludHNbaWR4ID09PSAwID8gMSA6IDBdLmRldGFjaCh7Y29ubmVjdGlvbjpqcGMsIGlnbm9yZVRhcmdldDpmYWxzZSwgZm9yY2VEZXRhY2g6ZmFsc2UsIGZpcmVFdmVudDp0cnVlLCBvcmlnaW5hbEV2ZW50Om9yaWdpbmFsRXZlbnQsIGVuZHBvaW50QmVpbmdEZWxldGVkOnRydWV9KSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuc2V0SG92ZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLl9mb3JjZURldGFjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuX2ZvcmNlUmVhdHRhY2ggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50LmRldGFjaEZyb21Db25uZWN0aW9uKGpwYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuc3VzcGVuZGVkRW5kcG9pbnQuYWRkQ29ubmVjdGlvbihqcGMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgY29kZSBpcyBkdXBsaWNhdGVkIGluIGxvdHMgb2YgcGxhY2VzLi4uYW5kIHRoZXJlIGlzIG5vdGhpbmcgZXh0ZXJuYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBjb2RlOyBpdCBhbGwgcmVmZXJzIHRvIHRoZSBjb25uZWN0aW9uIGl0c2VsZi4gd2UgY291bGQgYWRkIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBjaGVja1Nhbml0eShjb25uZWN0aW9uKWAgbWV0aG9kIHRvIGFuY2hvck1hbmFnZXIgdGhhdCBkaWQgdGhpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFuY2hvck1hbmFnZXIudXBkYXRlT3RoZXJFbmRwb2ludChqcGMuc291cmNlSWQsIGpwYy5mbG9hdGluZ0lkLCBqcGMudGFyZ2V0SWQsIGpwYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQoanBjLmZsb2F0aW5nSWQsIGpwYy5zb3VyY2VJZCwganBjLCBqcGMuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIucmVwYWludChleGlzdGluZ0pwY1BhcmFtc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5kZWxldGVPYmplY3Qoe2VuZHBvaW50OiBmZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlVGFyZ2V0cyBzZXRzIHRoaXMgZmxhZywgdG8gdGVsbCB1cyB3ZSBoYXZlIGJlZW4gcmVwbGFjZWQgYW5kIHNob3VsZCBkZWxldGUgdGhpcyBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxldGVBZnRlckRyYWdTdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZGVsZXRlT2JqZWN0KHtlbmRwb2ludDogdGhpc30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFpbnQoe3JlY2FsYzogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsdGhvdWdoIHRoZSBjb25uZWN0aW9uIGlzIG5vIGxvbmdlciB2YWxpZCwgdGhlcmUgYXJlIHVzZSBjYXNlcyB3aGVyZSB0aGlzIGlzIHVzZWZ1bC5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmZpcmUoXCJjb25uZWN0aW9uRHJhZ1N0b3BcIiwganBjLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgdGhpcyBldmVudCB0byBnaXZlIHBlb3BsZSBtb3JlIGZpbmUtZ3JhaW5lZCBjb250cm9sIChjb25uZWN0aW9uRHJhZ1N0b3AgZmlyZXMgYSBsb3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanBjLnBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5maXJlKFwiY29ubmVjdGlvbkFib3J0ZWRcIiwganBjLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRlbGwganNwbHVtYiB0aGF0IGRyYWdnaW5nIGlzIGZpbmlzaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuY3VycmVudGx5RHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zdXNwZW5kZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zdXNwZW5kZWRFbmRwb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gZW5kcG9pbnRzLCBqcGMgYWxyZWFkeSBjbGVhbmVkIHVwLiBidXQgc3RpbGwgd2Ugd2FudCB0byBlbnN1cmUgd2UncmUgcmVzZXQgcHJvcGVybHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGZsb2F0aW5nIGVuZHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vIChhbmQgaXRzIGFzc29jaWF0ZWQgZmxvYXRpbmcgZW5kcG9pbnQgYW5kIHZpc3VhbCBhcnRlZmFjdHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlckluZm8gJiYgcGxhY2Vob2xkZXJJbmZvLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnJlbW92ZShwbGFjZWhvbGRlckluZm8uZWxlbWVudCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGlucGxhY2UgY29weVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5QbGFjZUNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmRlbGV0ZU9iamVjdCh7ZW5kcG9pbnQ6IGluUGxhY2VDb3B5fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBvdXIgY2FudmFzIHZpc2libGUgKFRPRE86IGhhbmQgb2ZmIHRvIGxpYnJhcnk7IHdlIHNob3VsZCBub3Qga25vdyBhYm91dCBET00pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmxvY2sgb3VyIGFuY2hvclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmNob3IubG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBmbG9hdGluZyBhbmNob3IuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBkcmFnT3B0aW9ucyA9IF9qcC5leHRlbmQoZGVmYXVsdE9wdHMsIGRyYWdPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBkcmFnT3B0aW9ucy5zY29wZSA9IHRoaXMuc2NvcGUgfHwgZHJhZ09wdGlvbnMuc2NvcGU7XG4gICAgICAgICAgICAgICAgZHJhZ09wdGlvbnNbYmVmb3JlU3RhcnRFdmVudF0gPSBfanUud3JhcChkcmFnT3B0aW9uc1tiZWZvcmVTdGFydEV2ZW50XSwgYmVmb3JlU3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkcmFnT3B0aW9uc1tzdGFydEV2ZW50XSA9IF9qdS53cmFwKGRyYWdPcHRpb25zW3N0YXJ0RXZlbnRdLCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIGV4dHJhY3RlZCBkcmFnIGhhbmRsZXIgZnVuY3Rpb24gc28gY2FuIGJlIHVzZWQgYnkgbWFrZVNvdXJjZVxuICAgICAgICAgICAgICAgIGRyYWdPcHRpb25zW2RyYWdFdmVudF0gPSBfanUud3JhcChkcmFnT3B0aW9uc1tkcmFnRXZlbnRdLCBfZHJhZ0hhbmRsZXIuZHJhZyk7XG4gICAgICAgICAgICAgICAgZHJhZ09wdGlvbnNbc3RvcEV2ZW50XSA9IF9qdS53cmFwKGRyYWdPcHRpb25zW3N0b3BFdmVudF0sIHN0b3ApO1xuICAgICAgICAgICAgICAgIGRyYWdPcHRpb25zLm11bHRpcGxlRHJvcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgZHJhZ09wdGlvbnMuY2FuRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTb3VyY2UgfHwgdGhpcy5pc1RlbXBvcmFyeVNvdXJjZSB8fCAvKih0aGlzLmlzVGFyZ2V0ICYmICovdGhpcy5jb25uZWN0aW9ucy5sZW5ndGggPiAwLyopKi87XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgX2pzUGx1bWIuaW5pdERyYWdnYWJsZSh0aGlzLmNhbnZhcywgZHJhZ09wdGlvbnMsIFwiaW50ZXJuYWxcIik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5fanNQbHVtYlJlbGF0ZWRFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdJbml0aWFsaXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVwID0gcGFyYW1zLmVuZHBvaW50IHx8IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuRGVmYXVsdHMuRW5kcG9pbnQgfHwgX2pwLkRlZmF1bHRzLkVuZHBvaW50O1xuICAgICAgICB0aGlzLnNldEVuZHBvaW50KGVwLCB0cnVlKTtcbiAgICAgICAgdmFyIGFuY2hvclBhcmFtc1RvVXNlID0gcGFyYW1zLmFuY2hvciA/IHBhcmFtcy5hbmNob3IgOiBwYXJhbXMuYW5jaG9ycyA/IHBhcmFtcy5hbmNob3JzIDogKF9qc1BsdW1iLkRlZmF1bHRzLkFuY2hvciB8fCBcIlRvcFwiKTtcbiAgICAgICAgdGhpcy5zZXRBbmNob3IoYW5jaG9yUGFyYW1zVG9Vc2UsIHRydWUpO1xuXG4gICAgICAgIC8vIGZpbmFsbHksIHNldCB0eXBlIGlmIGl0IHdhcyBwcm92aWRlZFxuICAgICAgICB2YXIgdHlwZSA9IFsgXCJkZWZhdWx0XCIsIChwYXJhbXMudHlwZSB8fCBcIlwiKV0uam9pbihcIiBcIik7XG4gICAgICAgIHRoaXMuYWRkVHlwZSh0eXBlLCBwYXJhbXMuZGF0YSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5lbmRwb2ludC5jYW52YXM7XG4gICAgICAgIHRoaXMuY2FudmFzLl9qc1BsdW1iID0gdGhpcztcblxuICAgICAgICB0aGlzLmluaXREcmFnZ2FibGUoKTtcblxuICAgICAgICAvLyBwdWxsZWQgdGhpcyBvdXQgaW50byBhIGZ1bmN0aW9uIHNvIHdlIGNhbiByZXVzZSBpdCBmb3IgdGhlIGluUGxhY2VDb3B5IGNhbnZhczsgeW91IGNhbiBub3cgZHJvcCBkZXRhY2hlZCBjb25uZWN0aW9uc1xuICAgICAgICAvLyBiYWNrIG9udG8gdGhlIGVuZHBvaW50IHlvdSBkZXRhY2hlZCBpdCBmcm9tLlxuICAgICAgICB2YXIgX2luaXREcm9wVGFyZ2V0ID0gZnVuY3Rpb24gKGNhbnZhcywgaXNUcmFuc2llbnQsIGVuZHBvaW50LCByZWZlcmVuY2VFbmRwb2ludCkge1xuXG4gICAgICAgICAgICBpZiAoX2pwLmlzRHJvcFN1cHBvcnRlZCh0aGlzLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyb3BPcHRpb25zID0gcGFyYW1zLmRyb3BPcHRpb25zIHx8IF9qc1BsdW1iLkRlZmF1bHRzLkRyb3BPcHRpb25zIHx8IF9qcC5EZWZhdWx0cy5Ecm9wT3B0aW9ucztcbiAgICAgICAgICAgICAgICBkcm9wT3B0aW9ucyA9IF9qcC5leHRlbmQoe30sIGRyb3BPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBkcm9wT3B0aW9ucy5zY29wZSA9IGRyb3BPcHRpb25zLnNjb3BlIHx8IHRoaXMuc2NvcGU7XG4gICAgICAgICAgICAgICAgdmFyIGRyb3BFdmVudCA9IF9qcC5kcmFnRXZlbnRzLmRyb3AsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJFdmVudCA9IF9qcC5kcmFnRXZlbnRzLm92ZXIsXG4gICAgICAgICAgICAgICAgICAgIG91dEV2ZW50ID0gX2pwLmRyYWdFdmVudHMub3V0LFxuICAgICAgICAgICAgICAgICAgICBfZXAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBkcm9wID0gX2pzUGx1bWIuRW5kcG9pbnREcm9wSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRFbmRwb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAganNQbHVtYjogX2pzUGx1bWIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuZHBvaW50ICE9IG51bGwgPyBlbmRwb2ludC5pc0VuYWJsZWQoKSA6IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGdWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuZHBvaW50LmlzRnVsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJZDogdGhpcy5lbGVtZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NvdXJjZTogdGhpcy5pc1NvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVGFyZ2V0OiB0aGlzLmlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lcC5hZGRDbGFzcyhjbGF6eik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lcC5yZW1vdmVDbGFzcyhjbGF6eik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEcm9wQWxsb3dlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZXAuaXNEcm9wQWxsb3dlZC5hcHBseShfZXAsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOnJlZmVyZW5jZUVuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWRyb3A6ZnVuY3Rpb24oanBjLCBkaFBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqcGMuc3VzcGVuZGVkRW5kcG9pbnQgJiYgZGhQYXJhbXMucmVmZXJlbmNlICYmIChqcGMuc3VzcGVuZGVkRW5kcG9pbnQuaWQgPT09IGRoUGFyYW1zLnJlZmVyZW5jZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZHJvcE9wdGlvbnNbZHJvcEV2ZW50XSA9IF9qdS53cmFwKGRyb3BPcHRpb25zW2Ryb3BFdmVudF0sIGRyb3AsIHRydWUpO1xuICAgICAgICAgICAgICAgIGRyb3BPcHRpb25zW292ZXJFdmVudF0gPSBfanUud3JhcChkcm9wT3B0aW9uc1tvdmVyRXZlbnRdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcmFnZ2FibGUgPSBfanAuZ2V0RHJhZ09iamVjdChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBfanNQbHVtYi5nZXRBdHRyaWJ1dGUoX2pwLmdldEVsZW1lbnQoZHJhZ2dhYmxlKSwgXCJkcmFnSWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfanBjID0gX2pzUGx1bWIuZmxvYXRpbmdDb25uZWN0aW9uc1tpZF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9qcGMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IF9qc1BsdW1iLmdldEZsb2F0aW5nQW5jaG9ySW5kZXgoX2pwYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIHNob3VsZCBmaXJlIHRoZSAnb3ZlcicgZXZlbnQgaWYgd2UgYXJlIGEgdGFyZ2V0IGFuZCB0aGlzIGlzIGEgbmV3IGNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciB3ZSBhcmUgdGhlIHNhbWUgYXMgdGhlIGZsb2F0aW5nIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jb250ID0gKHRoaXMuaXNUYXJnZXQgJiYgaWR4ICE9PSAwKSB8fCAoX2pwYy5zdXNwZW5kZWRFbmRwb2ludCAmJiB0aGlzLnJlZmVyZW5jZUVuZHBvaW50ICYmIHRoaXMucmVmZXJlbmNlRW5kcG9pbnQuaWQgPT0gX2pwYy5zdXNwZW5kZWRFbmRwb2ludC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmIgPSBfanNQbHVtYi5jaGVja0NvbmRpdGlvbihcImNoZWNrRHJvcEFsbG93ZWRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VFbmRwb2ludDogX2pwYy5lbmRwb2ludHNbaWR4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RW5kcG9pbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IF9qcGNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyhiYiA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArIFwiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnREcm9wQWxsb3dlZENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyhiYiA/IFwicmVtb3ZlXCIgOiBcImFkZFwiKSArIFwiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnREcm9wRm9yYmlkZGVuQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9qcGMuZW5kcG9pbnRzW2lkeF0uYW5jaG9yLm92ZXIodGhpcy5hbmNob3IsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIGRyb3BPcHRpb25zW291dEV2ZW50XSA9IF9qdS53cmFwKGRyb3BPcHRpb25zW291dEV2ZW50XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZ2dhYmxlID0gX2pwLmdldERyYWdPYmplY3QoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gZHJhZ2dhYmxlID09IG51bGwgPyBudWxsIDogX2pzUGx1bWIuZ2V0QXR0cmlidXRlKF9qcC5nZXRFbGVtZW50KGRyYWdnYWJsZSksIFwiZHJhZ0lkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2pwYyA9IGlkID8gX2pzUGx1bWIuZmxvYXRpbmdDb25uZWN0aW9uc1tpZF0gOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfanBjICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBfanNQbHVtYi5nZXRGbG9hdGluZ0FuY2hvckluZGV4KF9qcGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jb250ID0gKHRoaXMuaXNUYXJnZXQgJiYgaWR4ICE9PSAwKSB8fCAoX2pwYy5zdXNwZW5kZWRFbmRwb2ludCAmJiB0aGlzLnJlZmVyZW5jZUVuZHBvaW50ICYmIHRoaXMucmVmZXJlbmNlRW5kcG9pbnQuaWQgPT0gX2pwYy5zdXNwZW5kZWRFbmRwb2ludC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKF9qc1BsdW1iLmVuZHBvaW50RHJvcEFsbG93ZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcyhfanNQbHVtYi5lbmRwb2ludERyb3BGb3JiaWRkZW5DbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2pwYy5lbmRwb2ludHNbaWR4XS5hbmNob3Iub3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgX2pzUGx1bWIuaW5pdERyb3BwYWJsZShjYW52YXMsIGRyb3BPcHRpb25zLCBcImludGVybmFsXCIsIGlzVHJhbnNpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpc2UgdGhlIGVuZHBvaW50J3MgY2FudmFzIGFzIGEgZHJvcCB0YXJnZXQuIFRoZSBkcm9wIGhhbmRsZXIgd2lsbCB0YWtlIGNhcmUgb2YgdGhlIGxvZ2ljIG9mIHdoZXRoZXJcbiAgICAgICAgLy8gc29tZXRoaW5nIGNhbiBhY3R1YWxseSBiZSBkcm9wcGVkLlxuICAgICAgICBpZiAoIXRoaXMuYW5jaG9yLmlzRmxvYXRpbmcpXG4gICAgICAgICAgICBfaW5pdERyb3BUYXJnZXQodGhpcy5jYW52YXMsICEocGFyYW1zLl90cmFuc2llbnQgfHwgdGhpcy5hbmNob3IuaXNGbG9hdGluZyksIHRoaXMsIHBhcmFtcy5yZWZlcmVuY2UpO1xuXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9qdS5leHRlbmQoX2pwLkVuZHBvaW50LCBfanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQsIHtcblxuICAgICAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbiAodiwgZG9Ob3RDaGFuZ2VDb25uZWN0aW9ucywgZG9Ob3ROb3RpZnlPdGhlckVuZHBvaW50KSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLnZpc2libGUgPSB2O1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzKSB0aGlzLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gdiA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgICAgICAgdGhpc1t2ID8gXCJzaG93T3ZlcmxheXNcIiA6IFwiaGlkZU92ZXJsYXlzXCJdKCk7XG4gICAgICAgICAgICBpZiAoIWRvTm90Q2hhbmdlQ29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uc1tpXS5zZXRWaXNpYmxlKHYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvTm90Tm90aWZ5T3RoZXJFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9JZHggPSB0aGlzID09PSB0aGlzLmNvbm5lY3Rpb25zW2ldLmVuZHBvaW50c1swXSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBjaGFuZ2UgdGhlIG90aGVyIGVuZHBvaW50IGlmIHRoaXMgaXMgaXRzIG9ubHkgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25zW2ldLmVuZHBvaW50c1tvSWR4XS5jb25uZWN0aW9ucy5sZW5ndGggPT0gMSkgdGhpcy5jb25uZWN0aW9uc1tpXS5lbmRwb2ludHNbb0lkeF0uc2V0VmlzaWJsZSh2LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QXR0YWNoZWRFbGVtZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbnM7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGx5VHlwZTogZnVuY3Rpb24gKHQsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdGhpcy5zZXRQYWludFN0eWxlKHQuZW5kcG9pbnRTdHlsZSB8fCB0LnBhaW50U3R5bGUsIGRvTm90UmVwYWludCk7XG4gICAgICAgICAgICB0aGlzLnNldEhvdmVyUGFpbnRTdHlsZSh0LmVuZHBvaW50SG92ZXJTdHlsZSB8fCB0LmhvdmVyUGFpbnRTdHlsZSwgZG9Ob3RSZXBhaW50KTtcbiAgICAgICAgICAgIGlmICh0Lm1heENvbm5lY3Rpb25zICE9IG51bGwpIHRoaXMuX2pzUGx1bWIubWF4Q29ubmVjdGlvbnMgPSB0Lm1heENvbm5lY3Rpb25zO1xuICAgICAgICAgICAgaWYgKHQuc2NvcGUpIHRoaXMuc2NvcGUgPSB0LnNjb3BlO1xuICAgICAgICAgICAgX2pwLmV4dGVuZCh0aGlzLCB0LCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgICAgICBpZiAodC5jc3NDbGFzcyAhPSBudWxsICYmIHRoaXMuY2FudmFzKSB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmFkZENsYXNzKHRoaXMuY2FudmFzLCB0LmNzc0NsYXNzKTtcbiAgICAgICAgICAgIF9qcC5PdmVybGF5Q2FwYWJsZUpzUGx1bWJVSUNvbXBvbmVudC5hcHBseVR5cGUodGhpcywgdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIuZW5hYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuZW5hYmxlZCA9IGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhbmNob3JDbGFzcyA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZW5kcG9pbnRBbmNob3JDbGFzc1ByZWZpeCArICh0aGlzLl9qc1BsdW1iLmN1cnJlbnRBbmNob3JDbGFzcyA/IFwiLVwiICsgdGhpcy5fanNQbHVtYi5jdXJyZW50QW5jaG9yQ2xhc3MgOiBcIlwiKTtcbiAgICAgICAgICAgIGpzUGx1bWIucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCBhbmNob3JDbGFzcyk7XG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVuZHBvaW50LmNsZWFudXAodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmVuZHBvaW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuZW5kcG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgLy8gZHJhZy9kcm9wXG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmRlc3Ryb3lEcmFnZ2FibGUodGhpcy5jYW52YXMsIFwiaW50ZXJuYWxcIik7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmRlc3Ryb3lEcm9wcGFibGUodGhpcy5jYW52YXMsIFwiaW50ZXJuYWxcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEhvdmVyOiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5kcG9pbnQgJiYgdGhpcy5fanNQbHVtYiAmJiAhdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5pc0Nvbm5lY3Rpb25CZWluZ0RyYWdnZWQoKSlcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50LnNldEhvdmVyKGgpO1xuICAgICAgICB9LFxuICAgICAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLm1heENvbm5lY3Rpb25zID09PSAwID8gdHJ1ZSA6ICEodGhpcy5pc0Zsb2F0aW5nKCkgfHwgdGhpcy5fanNQbHVtYi5tYXhDb25uZWN0aW9ucyA8IDAgfHwgdGhpcy5jb25uZWN0aW9ucy5sZW5ndGggPCB0aGlzLl9qc1BsdW1iLm1heENvbm5lY3Rpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByaXZhdGUgYnV0IG5lZWRzIHRvIGJlIGV4cG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpc0Zsb2F0aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IgIT0gbnVsbCAmJiB0aGlzLmFuY2hvci5pc0Zsb2F0aW5nO1xuICAgICAgICB9LFxuICAgICAgICBpc0Nvbm5lY3RlZFRvOiBmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25zW2ldLmVuZHBvaW50c1sxXSA9PSBlbmRwb2ludCB8fCB0aGlzLmNvbm5lY3Rpb25zW2ldLmVuZHBvaW50c1swXSA9PSBlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENvbm5lY3Rpb25Db3N0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi5jb25uZWN0aW9uQ29zdDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q29ubmVjdGlvbkNvc3Q6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmNvbm5lY3Rpb25Db3N0ID0gYztcbiAgICAgICAgfSxcbiAgICAgICAgYXJlQ29ubmVjdGlvbnNEaXJlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIuY29ubmVjdGlvbnNEaXJlY3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q29ubmVjdGlvbnNEaXJlY3RlZDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuY29ubmVjdGlvbnNEaXJlY3RlZCA9IGI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEVsZW1lbnRJZDogZnVuY3Rpb24gKF9lbElkKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRJZCA9IF9lbElkO1xuICAgICAgICAgICAgdGhpcy5hbmNob3IuZWxlbWVudElkID0gX2VsSWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFJlZmVyZW5jZUVsZW1lbnQ6IGZ1bmN0aW9uIChfZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IF9qcC5nZXRFbGVtZW50KF9lbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldERyYWdBbGxvd2VkV2hlbkZ1bGw6IGZ1bmN0aW9uIChhbGxvd2VkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdBbGxvd2VkV2hlbkZ1bGwgPSBhbGxvd2VkO1xuICAgICAgICB9LFxuICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yLmVxdWFscyhlbmRwb2ludC5hbmNob3IpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRVdWlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi51dWlkO1xuICAgICAgICB9LFxuICAgICAgICBjb21wdXRlQW5jaG9yOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IuY29tcHV0ZShwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByb290LmpzUGx1bWJJbnN0YW5jZS5wcm90b3R5cGUuRW5kcG9pbnREcm9wSGFuZGxlciA9IGZ1bmN0aW9uIChkaFBhcmFtcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgdmFyIF9qc1BsdW1iID0gZGhQYXJhbXMuanNQbHVtYjtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjbGFzc2VzIHRoYXQgYXJlIGFkZGVkIGR5bmFtaWNhbGx5LiBkcm9wIGlzIG5laXRoZXIgZm9yYmlkZGVuIG5vciBhbGxvd2VkIG5vdyB0aGF0XG4gICAgICAgICAgICAvLyB0aGUgZHJvcCBpcyBmaW5pc2hpbmcuXG4gICAgICAgICAgICBkaFBhcmFtcy5yZW1vdmVDbGFzcyhfanNQbHVtYi5lbmRwb2ludERyb3BBbGxvd2VkQ2xhc3MpO1xuICAgICAgICAgICAgZGhQYXJhbXMucmVtb3ZlQ2xhc3MoX2pzUGx1bWIuZW5kcG9pbnREcm9wRm9yYmlkZGVuQ2xhc3MpO1xuXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IF9qc1BsdW1iLmdldERyb3BFdmVudChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZSA9IF9qc1BsdW1iLmdldERyYWdPYmplY3QoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBpZCA9IF9qc1BsdW1iLmdldEF0dHJpYnV0ZShkcmFnZ2FibGUsIFwiZHJhZ0lkXCIpLFxuICAgICAgICAgICAgICAgIGVsSWQgPSBfanNQbHVtYi5nZXRBdHRyaWJ1dGUoZHJhZ2dhYmxlLCBcImVsSWRcIiksXG4gICAgICAgICAgICAgICAgc2NvcGUgPSBfanNQbHVtYi5nZXRBdHRyaWJ1dGUoZHJhZ2dhYmxlLCBcIm9yaWdpbmFsU2NvcGVcIiksXG4gICAgICAgICAgICAgICAganBjID0gX2pzUGx1bWIuZmxvYXRpbmdDb25uZWN0aW9uc1tpZF07XG5cbiAgICAgICAgICAgIC8vIGlmIG5vIGFjdGl2ZSBjb25uZWN0aW9uLCBiYWlsLlxuICAgICAgICAgICAgaWYgKGpwYyA9PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBpZiB0aGlzIGlzIGFuIGV4aXN0aW5nIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdDb25uZWN0aW9uID0ganBjLnN1c3BlbmRlZEVuZHBvaW50ICE9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGlmIHN1c3BlbmRlZCBlbmRwb2ludCBleGlzdHMgYnV0IGhhcyBiZWVuIGNsZWFuZWQgdXAsIGJhaWwuIFRoaXMgbWVhbnMgaXQncyBhbiBleGlzdGluZyBjb25uZWN0aW9uXG4gICAgICAgICAgICAvLyB0aGF0IGhhcyBiZWVuIGRldGFjaGVkIGFuZCB3aWxsIHNob3J0bHkgYmUgZGlzY2FyZGVkLlxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nQ29ubmVjdGlvbiAmJiBqcGMuc3VzcGVuZGVkRW5kcG9pbnQuX2pzUGx1bWIgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGRyb3AgZW5kcG9pbnQuIGZvciBhIG5vcm1hbCBjb25uZWN0aW9uIHRoaXMgaXMganVzdCB0aGUgb25lIHRoYXQgd291bGQgcmVwbGFjZSB0aGUgY3VycmVudGx5XG4gICAgICAgICAgICAvLyBmbG9hdGluZyBlbmRwb2ludC4gZm9yIGEgbWFrZVRhcmdldCB0aGlzIGlzIGEgbmV3IGVuZHBvaW50IHRoYXQgaXMgY3JlYXRlZCBvbiBkcm9wLiBCdXQgd2UgbGVhdmUgdGhhdCB0b1xuICAgICAgICAgICAgLy8gdGhlIGhhbmRsZXIgdG8gZmlndXJlIG91dC5cbiAgICAgICAgICAgIHZhciBfZXAgPSBkaFBhcmFtcy5nZXRFbmRwb2ludChqcGMpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZ2l2ZW4gYW4gZW5kcG9pbnQgdG8gdXNlLCBiYWlsLlxuICAgICAgICAgICAgaWYgKF9lcCA9PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBkcm9wIGJhY2sgd2hlcmUgdGhlIGNvbm5lY3Rpb24gY2FtZSBmcm9tLCBtYXJrIGl0IGZvcmNlIHJlYXR0YWNoIGFuZFxuICAgICAgICAgICAgLy8gcmV0dXJuOyB0aGUgc3RvcCBoYW5kbGVyIHdpbGwgcmVhdHRhY2guIHdpdGhvdXQgZmlyaW5nIGFuIGV2ZW50LlxuICAgICAgICAgICAgaWYgKGRoUGFyYW1zLmlzUmVkcm9wKGpwYywgZGhQYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAganBjLl9mb3JjZVJlYXR0YWNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBqcGMuc2V0SG92ZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChkaFBhcmFtcy5tYXliZUNsZWFudXApIGRoUGFyYW1zLm1heWJlQ2xlYW51cChfZXApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZW5zdXJlIHdlIGRvbnQgYm90aGVyIHRyeWluZyB0byBkcm9wIHNvdXJjZXMgb24gbm9uLXNvdXJjZSBlcHMsIGFuZCBzYW1lIGZvciB0YXJnZXQuXG4gICAgICAgICAgICB2YXIgaWR4ID0gX2pzUGx1bWIuZ2V0RmxvYXRpbmdBbmNob3JJbmRleChqcGMpO1xuICAgICAgICAgICAgaWYgKChpZHggPT09IDAgJiYgIWRoUGFyYW1zLmlzU291cmNlKXx8IChpZHggPT09IDEgJiYgIWRoUGFyYW1zLmlzVGFyZ2V0KSl7XG4gICAgICAgICAgICAgICAgaWYgKGRoUGFyYW1zLm1heWJlQ2xlYW51cCkgZGhQYXJhbXMubWF5YmVDbGVhbnVwKF9lcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGhQYXJhbXMub25Ecm9wKSBkaFBhcmFtcy5vbkRyb3AoanBjKTtcblxuICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgc2NvcGUgaWYgbmVjZXNzYXJ5IChpc3N1ZSA1NylcbiAgICAgICAgICAgIGlmIChzY29wZSkgX2pzUGx1bWIuc2V0RHJhZ1Njb3BlKGRyYWdnYWJsZSwgc2NvcGUpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IG9mIHRoZSBkcm9wIGlzIGZ1bGwsIGZpcmUgYW4gZXZlbnQgKHdlIGFib3J0IGJlbG93KVxuICAgICAgICAgICAgLy8gbWFrZVRhcmdldDoga2VlcC5cbiAgICAgICAgICAgIHZhciBpc0Z1bGwgPSBkaFBhcmFtcy5pc0Z1bGwoZSk7XG4gICAgICAgICAgICBpZiAoaXNGdWxsKSB7XG4gICAgICAgICAgICAgICAgX2VwLmZpcmUoXCJtYXhDb25uZWN0aW9uc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBqcGMsXG4gICAgICAgICAgICAgICAgICAgIG1heENvbm5lY3Rpb25zOiBfZXAuX2pzUGx1bWIubWF4Q29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICB9LCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpZiBlbmRwb2ludCBlbmFibGVkLCBub3QgZnVsbCwgYW5kIG1hdGNoZXMgdGhlIGluZGV4IG9mIHRoZSBmbG9hdGluZyBlbmRwb2ludC4uLlxuICAgICAgICAgICAgaWYgKCFpc0Z1bGwgJiYgIGRoUGFyYW1zLmVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBfZG9Db250aW51ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgdGVzdGluZyBmb3IgYmVmb3JlRHJvcCwgcmVzZXQgdGhlIGNvbm5lY3Rpb24ncyBzb3VyY2UvdGFyZ2V0IHRvIGJlIHRoZSBhY3R1YWwgRE9NIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgLy8gaW52b2x2ZWQgKHRoYXQgaXMsIHN0YXNoIGFueSB0ZW1wb3Jhcnkgc3R1ZmYgdXNlZCBmb3IgZHJhZ2dpbmcuIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgaXQgYXJvdW5kIGluXG4gICAgICAgICAgICAgICAgLy8gb3JkZXIgdGhhdCB0aGUgYW5jaG9yIG1hbmFnZXIgY2FuIGNsZWFuIHRoaW5ncyB1cCBwcm9wZXJseSkuXG4gICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBqcGMuZmxvYXRpbmdFbGVtZW50ID0ganBjLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nSWQgPSBqcGMuc291cmNlSWQ7XG4gICAgICAgICAgICAgICAgICAgIGpwYy5mbG9hdGluZ0VuZHBvaW50ID0ganBjLmVuZHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBqcGMuc291cmNlID0gZGhQYXJhbXMuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAganBjLnNvdXJjZUlkID0gZGhQYXJhbXMuZWxlbWVudElkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGpwYy5mbG9hdGluZ0VsZW1lbnQgPSBqcGMudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBqcGMuZmxvYXRpbmdJZCA9IGpwYy50YXJnZXRJZDtcbiAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nRW5kcG9pbnQgPSBqcGMuZW5kcG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICBqcGMuZmxvYXRpbmdJbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGpwYy50YXJnZXQgPSBkaFBhcmFtcy5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBqcGMudGFyZ2V0SWQgPSBkaFBhcmFtcy5lbGVtZW50SWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBleGlzdGluZyBjb25uZWN0aW9uIGFuZCBkZXRhY2ggaXMgbm90IGFsbG93ZWQgd2Ugd29uJ3QgY29udGludWUuIFRoZSBjb25uZWN0aW9uJ3NcbiAgICAgICAgICAgICAgICAvLyBlbmRwb2ludHMgaGF2ZSBiZWVuIHJlaW5zdGF0ZWQ7IGV2ZXJ5dGhpbmcgaXMgYmFjayB0byBob3cgaXQgd2FzLlxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0Nvbm5lY3Rpb24gJiYganBjLnN1c3BlbmRlZEVuZHBvaW50LmlkICE9IF9lcC5pZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghanBjLmlzRGV0YWNoQWxsb3dlZChqcGMpIHx8ICFqcGMuZW5kcG9pbnRzW2lkeF0uaXNEZXRhY2hBbGxvd2VkKGpwYykgfHwgIWpwYy5zdXNwZW5kZWRFbmRwb2ludC5pc0RldGFjaEFsbG93ZWQoanBjKSB8fCAhX2pzUGx1bWIuY2hlY2tDb25kaXRpb24oXCJiZWZvcmVEZXRhY2hcIiwganBjKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kb0NvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAtLS0tLS0tLS0tLS0gd3JhcCB0aGUgZXhlY3V0aW9uIHBhdGggaW4gYSBmdW5jdGlvbiBzbyB3ZSBjYW4gc3VwcG9ydCBhc3luY2hyb25vdXMgYmVmb3JlRHJvcFxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRpbnVlRnVuY3Rpb24gPSBmdW5jdGlvbiAob3B0aW9uYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGlzIGpwYyBmcm9tIHRoZSBjdXJyZW50IGVuZHBvaW50LCB3aGljaCBpcyBhIGZsb2F0aW5nIGVuZHBvaW50IHRoYXQgd2Ugd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyBzdWJzZXF1ZW50bHkgZGlzY2FyZC5cbiAgICAgICAgICAgICAgICAgICAganBjLmVuZHBvaW50c1tpZHhdLmRldGFjaEZyb21Db25uZWN0aW9uKGpwYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHN1c3BlbmRlZCBlbmRwb2ludCwgZGV0YWNoIGl0IGZyb20gdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChqcGMuc3VzcGVuZGVkRW5kcG9pbnQpIGpwYy5zdXNwZW5kZWRFbmRwb2ludC5kZXRhY2hGcm9tQ29ubmVjdGlvbihqcGMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGpwYy5lbmRwb2ludHNbaWR4XSA9IF9lcDtcbiAgICAgICAgICAgICAgICAgICAgX2VwLmFkZENvbm5lY3Rpb24oanBjKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb3B5IG91ciBwYXJhbWV0ZXJzIGluIHRvIHRoZSBjb25uZWN0aW9uOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gX2VwLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYVBhcmFtIGluIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zZXRQYXJhbWV0ZXIoYVBhcmFtLCBwYXJhbXNbYVBhcmFtXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBhbiBleGlzdGluZyBjb25uZWN0aW9uIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuaW5pdERyYWdnYWJsZSh0aGlzLmVsZW1lbnQsIGRyYWdPcHRpb25zLCBcImludGVybmFsXCIsIF9qc1BsdW1iKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWRFbGVtZW50SWQgPSBqcGMuc3VzcGVuZGVkRW5kcG9pbnQuZWxlbWVudElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZmlyZU1vdmVFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFNvdXJjZUlkOiBpZHggPT09IDAgPyBzdXNwZW5kZWRFbGVtZW50SWQgOiBqcGMuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U291cmNlSWQ6IGlkeCA9PT0gMCA/IF9lcC5lbGVtZW50SWQgOiBqcGMuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxUYXJnZXRJZDogaWR4ID09IDEgPyBzdXNwZW5kZWRFbGVtZW50SWQgOiBqcGMudGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGFyZ2V0SWQ6IGlkeCA9PSAxID8gX2VwLmVsZW1lbnRJZCA6IGpwYy50YXJnZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFNvdXJjZUVuZHBvaW50OiBpZHggPT09IDAgPyBqcGMuc3VzcGVuZGVkRW5kcG9pbnQgOiBqcGMuZW5kcG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NvdXJjZUVuZHBvaW50OiBpZHggPT09IDAgPyBfZXAgOiBqcGMuZW5kcG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsVGFyZ2V0RW5kcG9pbnQ6IGlkeCA9PSAxID8ganBjLnN1c3BlbmRlZEVuZHBvaW50IDoganBjLmVuZHBvaW50c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUYXJnZXRFbmRwb2ludDogaWR4ID09IDEgPyBfZXAgOiBqcGMuZW5kcG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IGpwY1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFuY2hvck1hbmFnZXIudXBkYXRlT3RoZXJFbmRwb2ludChqcGMuc291cmNlSWQsIGpwYy5mbG9hdGluZ0lkLCBqcGMudGFyZ2V0SWQsIGpwYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQoanBjLmZsb2F0aW5nSWQsIGpwYy5zb3VyY2VJZCwganBjLCBqcGMuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gbWFrZVNvdXJjZSBoYXMgdW5pcXVlRW5kcG9pbnQ6dHJ1ZSwgd2Ugd2FudCB0byBjcmVhdGUgY29ubmVjdGlvbnMgd2l0aCBuZXcgZW5kcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgYXJlIHN1YnNlcXVlbnRseSBkZWxldGVkLiBTbyBtYWtlU291cmNlIHNldHMgYGZpbmFsRW5kcG9pbnRgLCB3aGljaCBpcyB0aGUgRW5kcG9pbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggdGhlIGNvbm5lY3Rpb24gc2hvdWxkIGJlIGF0dGFjaGVkLiBUaGUgYGRldGFjaEZyb21Db25uZWN0aW9uYCBjYWxsIGJlbG93IHJlc3VsdHMgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBlbmRwb2ludCBiZWluZyBjbGVhbmVkIHVwLlxuICAgICAgICAgICAgICAgICAgICBpZiAoanBjLmVuZHBvaW50c1swXS5maW5hbEVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RvRGVsZXRlID0ganBjLmVuZHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90b0RlbGV0ZS5kZXRhY2hGcm9tQ29ubmVjdGlvbihqcGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLmVuZHBvaW50c1swXSA9IGpwYy5lbmRwb2ludHNbMF0uZmluYWxFbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5lbmRwb2ludHNbMF0uYWRkQ29ubmVjdGlvbihqcGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgb3B0aW9uYWxEYXRhIHdhcyBnaXZlbiwgbWVyZ2UgaXQgb250byB0aGUgY29ubmVjdGlvbidzIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfanUuaXNPYmplY3Qob3B0aW9uYWxEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLm1lcmdlRGF0YShvcHRpb25hbERhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmFsaXNlIHdpbGwgaW5mb3JtIHRoZSBhbmNob3IgbWFuYWdlciBhbmQgYWxzbyBhZGQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvbnNCeVNjb3BlIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZmluYWxpc2VDb25uZWN0aW9uKGpwYywgbnVsbCwgb3JpZ2luYWxFdmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBqcGMuc2V0SG92ZXIoZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRvbnRDb250aW51ZUZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UganVzdCBwdXQgaXQgYmFjayBvbiB0aGUgZW5kcG9pbnQgaXQgd2FzIG9uIGJlZm9yZSB0aGUgZHJhZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpwYy5zdXNwZW5kZWRFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLmVuZHBvaW50c1tpZHhdID0ganBjLnN1c3BlbmRlZEVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLnNldEhvdmVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5fZm9yY2VEZXRhY2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zb3VyY2UgPSBqcGMuc3VzcGVuZGVkRW5kcG9pbnQuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuc291cmNlSWQgPSBqcGMuc3VzcGVuZGVkRW5kcG9pbnQuZWxlbWVudElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMudGFyZ2V0ID0ganBjLnN1c3BlbmRlZEVuZHBvaW50LmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLnRhcmdldElkID0ganBjLnN1c3BlbmRlZEVuZHBvaW50LmVsZW1lbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zdXNwZW5kZWRFbmRwb2ludC5hZGRDb25uZWN0aW9uKGpwYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY2hlY2tTYW5pdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFuY2hvck1hbmFnZXIudXBkYXRlT3RoZXJFbmRwb2ludChqcGMuc291cmNlSWQsIGpwYy5mbG9hdGluZ0lkLCBqcGMudGFyZ2V0SWQsIGpwYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQoanBjLmZsb2F0aW5nSWQsIGpwYy5zb3VyY2VJZCwganBjLCBqcGMuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIucmVwYWludChqcGMuc291cmNlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLl9mb3JjZURldGFjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICAvLyBub3cgY2hlY2sgYmVmb3JlRHJvcC4gIHRoaXMgd2lsbCBiZSBhdmFpbGFibGUgb25seSBvbiBFbmRwb2ludHMgdGhhdCBhcmUgc2V0dXAgdG9cbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgYmVmb3JlRHJvcCBjb25kaXRpb24gKGFsdGhvdWdoLCBzZWNyZXRseSwgdW5kZXIgdGhlIGhvb2QgYWxsIEVuZHBvaW50cyBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aGUgQ29ubmVjdGlvbiBoYXZlIHRoZW0sIGJlY2F1c2UgdGhleSBhcmUgb24ganNQbHVtYlVJQ29tcG9uZW50LiAgc2hoaCEpLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gaXQgb25seSBtYWtlcyBzZW5zZSB0byBoYXZlIGl0IG9uIGEgdGFyZ2V0IGVuZHBvaW50LlxuICAgICAgICAgICAgICAgIF9kb0NvbnRpbnVlID0gX2RvQ29udGludWUgJiYgZGhQYXJhbXMuaXNEcm9wQWxsb3dlZChqcGMuc291cmNlSWQsIGpwYy50YXJnZXRJZCwganBjLnNjb3BlLCBqcGMsIF9lcCk7Ly8gJiYganBjLnBlbmRpbmc7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2RvQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVGdW5jdGlvbihfZG9Db250aW51ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9udENvbnRpbnVlRnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkaFBhcmFtcy5tYXliZUNsZWFudXApIGRoUGFyYW1zLm1heWJlQ2xlYW51cChfZXApO1xuXG4gICAgICAgICAgICBfanNQbHVtYi5jdXJyZW50bHlEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qXG4gKiBqc1BsdW1iXG4gKiBcbiAqIFRpdGxlOmpzUGx1bWIgMi4xLjBcbiAqIFxuICogUHJvdmlkZXMgYSB3YXkgdG8gdmlzdWFsbHkgY29ubmVjdCBlbGVtZW50cyBvbiBhbiBIVE1MIHBhZ2UsIHVzaW5nIFNWRy5cbiAqIFxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBjb2RlIGZvciBDb25uZWN0aW9ucy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE1IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqIFxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHA6Ly9naXRodWIuY29tL3Nwb3JyaXR0L2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG47XG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJvb3QgPSB0aGlzLFxuICAgICAgICBfanAgPSByb290LmpzUGx1bWIsXG4gICAgICAgIF9qdSA9IHJvb3QuanNQbHVtYlV0aWw7XG5cbiAgICB2YXIgbWFrZUNvbm5lY3RvciA9IGZ1bmN0aW9uIChfanNQbHVtYiwgcmVuZGVyTW9kZSwgY29ubmVjdG9yTmFtZSwgY29ubmVjdG9yQXJncywgZm9yQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoIV9qc1BsdW1iLkRlZmF1bHRzLkRvTm90VGhyb3dFcnJvcnMgJiYganNQbHVtYi5Db25uZWN0b3JzW3JlbmRlck1vZGVdW2Nvbm5lY3Rvck5hbWVdID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgeyBtc2c6IFwianNQbHVtYjogdW5rbm93biBjb25uZWN0b3IgdHlwZSAnXCIgKyBjb25uZWN0b3JOYW1lICsgXCInXCIgfTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfanAuQ29ubmVjdG9yc1tyZW5kZXJNb2RlXVtjb25uZWN0b3JOYW1lXShjb25uZWN0b3JBcmdzLCBmb3JDb21wb25lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBfbWFrZUFuY2hvciA9IGZ1bmN0aW9uIChhbmNob3JQYXJhbXMsIGVsZW1lbnRJZCwgX2pzUGx1bWIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYW5jaG9yUGFyYW1zKSA/IF9qc1BsdW1iLm1ha2VBbmNob3IoYW5jaG9yUGFyYW1zLCBlbGVtZW50SWQsIF9qc1BsdW1iKSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIF91cGRhdGVDb25uZWN0ZWRDbGFzcyA9IGZ1bmN0aW9uIChjb25uLCBlbGVtZW50LCBfanNQbHVtYiwgcmVtb3ZlKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5fanNQbHVtYkNvbm5lY3Rpb25zID0gZWxlbWVudC5fanNQbHVtYkNvbm5lY3Rpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmUpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50Ll9qc1BsdW1iQ29ubmVjdGlvbnNbY29ubi5pZF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Ll9qc1BsdW1iQ29ubmVjdGlvbnNbY29ubi5pZF0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9qdS5pc0VtcHR5KGVsZW1lbnQuX2pzUGx1bWJDb25uZWN0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgX2pzUGx1bWIuY29ubmVjdGVkQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFkZENsYXNzKGVsZW1lbnQsIF9qc1BsdW1iLmNvbm5lY3RlZENsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIF9qcC5Db25uZWN0aW9uID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgX25ld0VuZHBvaW50ID0gcGFyYW1zLm5ld0VuZHBvaW50O1xuXG4gICAgICAgIHRoaXMuaWQgPSBwYXJhbXMuaWQ7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5pZFByZWZpeCA9IFwiX2pzcGx1bWJfY19cIjtcbiAgICAgICAgdGhpcy5kZWZhdWx0TGFiZWxMb2NhdGlvbiA9IDAuNTtcbiAgICAgICAgdGhpcy5kZWZhdWx0T3ZlcmxheUtleXMgPSBbXCJPdmVybGF5c1wiLCBcIkNvbm5lY3Rpb25PdmVybGF5c1wiXTtcbiAgICAgICAgLy8gaWYgYSBuZXcgY29ubmVjdGlvbiBpcyB0aGUgcmVzdWx0IG9mIG1vdmluZyBzb21lIGV4aXN0aW5nIGNvbm5lY3Rpb24sIHBhcmFtcy5wcmV2aW91c0Nvbm5lY3Rpb25cbiAgICAgICAgLy8gd2lsbCBoYXZlIHRoYXQgQ29ubmVjdGlvbiBpbiBpdC4gbGlzdGVuZXJzIGZvciB0aGUganNQbHVtYkNvbm5lY3Rpb24gZXZlbnQgY2FuIGxvb2sgZm9yIHRoYXRcbiAgICAgICAgLy8gbWVtYmVyIGFuZCB0YWtlIGFjdGlvbiBpZiB0aGV5IG5lZWQgdG8uXG4gICAgICAgIHRoaXMucHJldmlvdXNDb25uZWN0aW9uID0gcGFyYW1zLnByZXZpb3VzQ29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBfanAuZ2V0RWxlbWVudChwYXJhbXMuc291cmNlKTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBfanAuZ2V0RWxlbWVudChwYXJhbXMudGFyZ2V0KTtcbiAgICAgICAgLy8gc291cmNlRW5kcG9pbnQgYW5kIHRhcmdldEVuZHBvaW50IG92ZXJyaWRlIHNvdXJjZS90YXJnZXQsIGlmIHRoZXkgYXJlIHByZXNlbnQuIGJ1dCBcbiAgICAgICAgLy8gc291cmNlIGlzIG5vdCBvdmVycmlkZGVuIGlmIHRoZSBFbmRwb2ludCBoYXMgZGVjbGFyZWQgaXQgaXMgbm90IHRoZSBmaW5hbCB0YXJnZXQgb2YgYSBjb25uZWN0aW9uO1xuICAgICAgICAvLyBpbnN0ZWFkIHdlIHVzZSB0aGUgc291cmNlIHRoYXQgdGhlIEVuZHBvaW50IGRlY2xhcmVzIHdpbGwgYmUgdGhlIGZpbmFsIHNvdXJjZSBlbGVtZW50LlxuICAgICAgICBpZiAocGFyYW1zLnNvdXJjZUVuZHBvaW50KSB0aGlzLnNvdXJjZSA9IHBhcmFtcy5zb3VyY2VFbmRwb2ludC5nZXRFbGVtZW50KCk7XG4gICAgICAgIGlmIChwYXJhbXMudGFyZ2V0RW5kcG9pbnQpIHRoaXMudGFyZ2V0ID0gcGFyYW1zLnRhcmdldEVuZHBvaW50LmdldEVsZW1lbnQoKTtcblxuICAgICAgICBfanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICB0aGlzLnNvdXJjZUlkID0gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5nZXRJZCh0aGlzLnNvdXJjZSk7XG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldElkKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHBhcmFtcy5zY29wZTsgLy8gc2NvcGUgbWF5IGhhdmUgYmVlbiBwYXNzZWQgaW4gdG8gdGhlIGNvbm5lY3QgY2FsbC4gaWYgaXQgd2Fzbid0LCB3ZSB3aWxsIHB1bGwgaXQgZnJvbSB0aGUgc291cmNlIGVuZHBvaW50LCBhZnRlciBoYXZpbmcgaW5pdGlhbGlzZWQgdGhlIGVuZHBvaW50cy4gICAgICAgICAgICBcbiAgICAgICAgdGhpcy5lbmRwb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbmRwb2ludFN0eWxlcyA9IFtdO1xuXG4gICAgICAgIHZhciBfanNQbHVtYiA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2U7XG5cbiAgICAgICAgX2pzUGx1bWIubWFuYWdlKHRoaXMuc291cmNlSWQsIHRoaXMuc291cmNlKTtcbiAgICAgICAgX2pzUGx1bWIubWFuYWdlKHRoaXMudGFyZ2V0SWQsIHRoaXMudGFyZ2V0KTtcblxuICAgICAgICB0aGlzLl9qc1BsdW1iLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmVkaXRhYmxlID0gcGFyYW1zLmVkaXRhYmxlID09PSB0cnVlO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLnBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNzc0NsYXNzOiBwYXJhbXMuY3NzQ2xhc3MsXG4gICAgICAgICAgICBjb250YWluZXI6IHBhcmFtcy5jb250YWluZXIsXG4gICAgICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IHBhcmFtc1tcInBvaW50ZXItZXZlbnRzXCJdLFxuICAgICAgICAgICAgZWRpdG9yUGFyYW1zOiBwYXJhbXMuZWRpdG9yUGFyYW1zLFxuICAgICAgICAgICAgb3ZlcmxheXM6IHBhcmFtcy5vdmVybGF5c1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmxhc3RQYWludGVkQXQgPSBudWxsO1xuXG4gICAgICAgIC8vIGxpc3RlbiB0byBtb3VzZW92ZXIgYW5kIG1vdXNlb3V0IGV2ZW50cyBwYXNzZWQgZnJvbSB0aGUgY29udGFpbmVyIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmJpbmQoXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIb3Zlcih0cnVlKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5iaW5kKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIb3ZlcihmYWxzZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5lZGl0YWJsZVJlcXVlc3RlZCA9IHBhcmFtcy5lZGl0YWJsZSAhPT0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0RWRpdGFibGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IgPyB0aGlzLmNvbm5lY3Rvci5zZXRFZGl0YWJsZShlKSA6IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzRWRpdGFibGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29ubmVjdG9yID8gdGhpcy5jb25uZWN0b3IuaXNFZGl0YWJsZSgpIDogZmFsc2U7IH07XG4gICAgICAgIHRoaXMuaXNFZGl0aW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbm5lY3RvciA/IHRoaXMuY29ubmVjdG9yLmlzRWRpdGluZygpIDogZmFsc2U7IH07XG5cbi8vIElOSVRJQUxJU0FUSU9OIENPREVcblxuICAgICAgICB0aGlzLm1ha2VFbmRwb2ludCA9IGZ1bmN0aW9uIChpc1NvdXJjZSwgZWwsIGVsSWQsIGVwKSB7XG4gICAgICAgICAgICBlbElkID0gZWxJZCB8fCB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldElkKGVsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXBhcmVFbmRwb2ludChfanNQbHVtYiwgX25ld0VuZHBvaW50LCB0aGlzLCBlcCwgaXNTb3VyY2UgPyAwIDogMSwgcGFyYW1zLCBlbCwgZWxJZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgdHlwZSBnaXZlbiwgZ2V0IHRoZSBlbmRwb2ludCBkZWZpbml0aW9ucyBtYXBwaW5nIHRvIHRoYXQgdHlwZSBmcm9tIHRoZSBqc3BsdW1iIGluc3RhbmNlLCBhbmQgdXNlIHRob3NlLlxuICAgICAgICAvLyB3ZSBhcHBseSB0eXBlcyBhdCB0aGUgZW5kIG9mIHRoaXMgY29uc3RydWN0b3IgYnV0IGVuZHBvaW50cyBhcmUgb25seSBob25vdXJlZCBpbiBhIHR5cGUgZGVmaW5pdGlvbiBhdFxuICAgICAgICAvLyBjcmVhdGUgdGltZS5cbiAgICAgICAgaWYgKHBhcmFtcy50eXBlKSB7XG4gICAgICAgICAgICBwYXJhbXMuZW5kcG9pbnRzID0gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5kZXJpdmVFbmRwb2ludEFuZEFuY2hvclNwZWMocGFyYW1zLnR5cGUpLmVuZHBvaW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlUyA9IHRoaXMubWFrZUVuZHBvaW50KHRydWUsIHRoaXMuc291cmNlLCB0aGlzLnNvdXJjZUlkLCBwYXJhbXMuc291cmNlRW5kcG9pbnQpLFxuICAgICAgICAgICAgZVQgPSB0aGlzLm1ha2VFbmRwb2ludChmYWxzZSwgdGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHBhcmFtcy50YXJnZXRFbmRwb2ludCk7XG5cbiAgICAgICAgaWYgKGVTKSBfanUuYWRkVG9MaXN0KHBhcmFtcy5lbmRwb2ludHNCeUVsZW1lbnQsIHRoaXMuc291cmNlSWQsIGVTKTtcbiAgICAgICAgaWYgKGVUKSBfanUuYWRkVG9MaXN0KHBhcmFtcy5lbmRwb2ludHNCeUVsZW1lbnQsIHRoaXMudGFyZ2V0SWQsIGVUKTtcbiAgICAgICAgLy8gaWYgc2NvcGUgbm90IHNldCwgc2V0IGl0IHRvIGJlIHRoZSBzY29wZSBmb3IgdGhlIHNvdXJjZSBlbmRwb2ludC5cbiAgICAgICAgaWYgKCF0aGlzLnNjb3BlKSB0aGlzLnNjb3BlID0gdGhpcy5lbmRwb2ludHNbMF0uc2NvcGU7XG5cbiAgICAgICAgLy8gaWYgZXhwbGljaXRseSB0b2xkIHRvIChvciBub3QgdG8pIGRlbGV0ZSBlbmRwb2ludHMgb24gZGV0YWNoLCBvdmVycmlkZSBlbmRwb2ludCdzIHByZWZlcmVuY2VzXG4gICAgICAgIGlmIChwYXJhbXMuZGVsZXRlRW5kcG9pbnRzT25EZXRhY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbmRwb2ludHNbMF0uX2RlbGV0ZU9uRGV0YWNoID0gcGFyYW1zLmRlbGV0ZUVuZHBvaW50c09uRGV0YWNoO1xuICAgICAgICAgICAgdGhpcy5lbmRwb2ludHNbMV0uX2RlbGV0ZU9uRGV0YWNoID0gcGFyYW1zLmRlbGV0ZUVuZHBvaW50c09uRGV0YWNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCB1bmxlc3MgdGhlIGVuZHBvaW50cyBzYXkgb3RoZXJ3aXNlLCBtYXJrIHRoZW0gZm9yIGRlbGV0aW9uLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmVuZHBvaW50c1swXS5fZG9Ob3REZWxldGVPbkRldGFjaCkgdGhpcy5lbmRwb2ludHNbMF0uX2RlbGV0ZU9uRGV0YWNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5lbmRwb2ludHNbMV0uX2RvTm90RGVsZXRlT25EZXRhY2gpIHRoaXMuZW5kcG9pbnRzWzFdLl9kZWxldGVPbkRldGFjaCA9IHRydWU7XG4gICAgICAgIH1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gREVGQVVMVCBUWVBFIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIERFVEFDSEFCTEVcbiAgICAgICAgdmFyIF9kZXRhY2hhYmxlID0gX2pzUGx1bWIuRGVmYXVsdHMuQ29ubmVjdGlvbnNEZXRhY2hhYmxlO1xuICAgICAgICBpZiAocGFyYW1zLmRldGFjaGFibGUgPT09IGZhbHNlKSBfZGV0YWNoYWJsZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5lbmRwb2ludHNbMF0uY29ubmVjdGlvbnNEZXRhY2hhYmxlID09PSBmYWxzZSkgX2RldGFjaGFibGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZW5kcG9pbnRzWzFdLmNvbm5lY3Rpb25zRGV0YWNoYWJsZSA9PT0gZmFsc2UpIF9kZXRhY2hhYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIFJFQVRUQUNIXG4gICAgICAgIHZhciBfcmVhdHRhY2ggPSBwYXJhbXMucmVhdHRhY2ggfHwgdGhpcy5lbmRwb2ludHNbMF0ucmVhdHRhY2hDb25uZWN0aW9ucyB8fCB0aGlzLmVuZHBvaW50c1sxXS5yZWF0dGFjaENvbm5lY3Rpb25zIHx8IF9qc1BsdW1iLkRlZmF1bHRzLlJlYXR0YWNoQ29ubmVjdGlvbnM7XG5cbiAgICAgICAgdGhpcy5hcHBlbmRUb0RlZmF1bHRUeXBlKHtcbiAgICAgICAgICAgIGRldGFjaGFibGU6IF9kZXRhY2hhYmxlLFxuICAgICAgICAgICAgcmVhdHRhY2g6IF9yZWF0dGFjaCxcbiAgICAgICAgICAgIHBhaW50U3R5bGU6dGhpcy5lbmRwb2ludHNbMF0uY29ubmVjdG9yU3R5bGUgfHwgdGhpcy5lbmRwb2ludHNbMV0uY29ubmVjdG9yU3R5bGUgfHwgcGFyYW1zLnBhaW50U3R5bGUgfHwgX2pzUGx1bWIuRGVmYXVsdHMuUGFpbnRTdHlsZSB8fCBqc1BsdW1iLkRlZmF1bHRzLlBhaW50U3R5bGUsXG4gICAgICAgICAgICBob3ZlclBhaW50U3R5bGU6dGhpcy5lbmRwb2ludHNbMF0uY29ubmVjdG9ySG92ZXJTdHlsZSB8fCB0aGlzLmVuZHBvaW50c1sxXS5jb25uZWN0b3JIb3ZlclN0eWxlIHx8IHBhcmFtcy5ob3ZlclBhaW50U3R5bGUgfHwgX2pzUGx1bWIuRGVmYXVsdHMuSG92ZXJQYWludFN0eWxlIHx8IGpzUGx1bWIuRGVmYXVsdHMuSG92ZXJQYWludFN0eWxlXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgdmFyIF9zdXNwZW5kZWRBdCA9IF9qc1BsdW1iLmdldFN1c3BlbmRlZEF0KCk7XG4gICAgICAgIGlmICghX2pzUGx1bWIuaXNTdXNwZW5kRHJhd2luZygpKSB7XG4gICAgICAgICAgICAvLyBwYWludCB0aGUgZW5kcG9pbnRzXG4gICAgICAgICAgICB2YXIgbXlJbmZvID0gX2pzUGx1bWIuZ2V0Q2FjaGVkRGF0YSh0aGlzLnNvdXJjZUlkKSxcbiAgICAgICAgICAgICAgICBteU9mZnNldCA9IG15SW5mby5vLCBteVdIID0gbXlJbmZvLnMsXG4gICAgICAgICAgICAgICAgb3RoZXJJbmZvID0gX2pzUGx1bWIuZ2V0Q2FjaGVkRGF0YSh0aGlzLnRhcmdldElkKSxcbiAgICAgICAgICAgICAgICBvdGhlck9mZnNldCA9IG90aGVySW5mby5vLFxuICAgICAgICAgICAgICAgIG90aGVyV0ggPSBvdGhlckluZm8ucyxcbiAgICAgICAgICAgICAgICBpbml0aWFsVGltZXN0YW1wID0gX3N1c3BlbmRlZEF0IHx8IF9qc1BsdW1iLnRpbWVzdGFtcCgpLFxuICAgICAgICAgICAgICAgIGFuY2hvckxvYyA9IHRoaXMuZW5kcG9pbnRzWzBdLmFuY2hvci5jb21wdXRlKHtcbiAgICAgICAgICAgICAgICAgICAgeHk6IFsgbXlPZmZzZXQubGVmdCwgbXlPZmZzZXQudG9wIF0sIHdoOiBteVdILCBlbGVtZW50OiB0aGlzLmVuZHBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudElkOiB0aGlzLmVuZHBvaW50c1swXS5lbGVtZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHR4eTogWyBvdGhlck9mZnNldC5sZWZ0LCBvdGhlck9mZnNldC50b3AgXSwgdHdoOiBvdGhlcldILCB0RWxlbWVudDogdGhpcy5lbmRwb2ludHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogaW5pdGlhbFRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVuZHBvaW50c1swXS5wYWludCh7IGFuY2hvckxvYzogYW5jaG9yTG9jLCB0aW1lc3RhbXA6IGluaXRpYWxUaW1lc3RhbXAgfSk7XG5cbiAgICAgICAgICAgIGFuY2hvckxvYyA9IHRoaXMuZW5kcG9pbnRzWzFdLmFuY2hvci5jb21wdXRlKHtcbiAgICAgICAgICAgICAgICB4eTogWyBvdGhlck9mZnNldC5sZWZ0LCBvdGhlck9mZnNldC50b3AgXSwgd2g6IG90aGVyV0gsIGVsZW1lbnQ6IHRoaXMuZW5kcG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRJZDogdGhpcy5lbmRwb2ludHNbMV0uZWxlbWVudElkLFxuICAgICAgICAgICAgICAgIHR4eTogWyBteU9mZnNldC5sZWZ0LCBteU9mZnNldC50b3AgXSwgdHdoOiBteVdILCB0RWxlbWVudDogdGhpcy5lbmRwb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBpbml0aWFsVGltZXN0YW1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRzWzFdLnBhaW50KHsgYW5jaG9yTG9jOiBhbmNob3JMb2MsIHRpbWVzdGFtcDogaW5pdGlhbFRpbWVzdGFtcCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0VHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJjb25uZWN0aW9uXCI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0QXR0YWNoZWRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZHBvaW50cztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmlzRGV0YWNoYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLmRldGFjaGFibGUgPT09IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0RGV0YWNoYWJsZSA9IGZ1bmN0aW9uIChkZXRhY2hhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmRldGFjaGFibGUgPSBkZXRhY2hhYmxlID09PSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzUmVhdHRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi5yZWF0dGFjaCA9PT0gdHJ1ZSB8fCB0aGlzLmVuZHBvaW50c1swXS5yZWF0dGFjaENvbm5lY3Rpb25zID09PSB0cnVlIHx8IHRoaXMuZW5kcG9pbnRzWzFdLnJlYXR0YWNoQ29ubmVjdGlvbnMgPT09IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0UmVhdHRhY2ggPSBmdW5jdGlvbiAocmVhdHRhY2gpIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIucmVhdHRhY2ggPSByZWF0dGFjaCA9PT0gdHJ1ZTtcbiAgICAgICAgfTtcblxuLy8gRU5EIElOSVRJQUxJU0FUSU9OIENPREVcblxuXG4vLyBDT1NUICsgRElSRUNUSU9OQUxJVFlcbiAgICAgICAgLy8gaWYgY29zdCBub3Qgc3VwcGxpZWQsIHRyeSB0byBpbmhlcml0IGZyb20gc291cmNlIGVuZHBvaW50XG4gICAgICAgIHRoaXMuX2pzUGx1bWIuY29zdCA9IHBhcmFtcy5jb3N0IHx8IHRoaXMuZW5kcG9pbnRzWzBdLmdldENvbm5lY3Rpb25Db3N0KCk7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIuZGlyZWN0ZWQgPSBwYXJhbXMuZGlyZWN0ZWQ7XG4gICAgICAgIC8vIGluaGVyaXQgZGlyZWN0ZWQgZmxhZyBpZiBzZXQgbm8gc291cmNlIGVuZHBvaW50XG4gICAgICAgIGlmIChwYXJhbXMuZGlyZWN0ZWQgPT0gbnVsbCkgdGhpcy5fanNQbHVtYi5kaXJlY3RlZCA9IHRoaXMuZW5kcG9pbnRzWzBdLmFyZUNvbm5lY3Rpb25zRGlyZWN0ZWQoKTtcbi8vIEVORCBDT1NUICsgRElSRUNUSU9OQUxJVFlcblxuLy8gUEFSQU1FVEVSU1xuICAgICAgICAvLyBtZXJnZSBhbGwgdGhlIHBhcmFtZXRlcnMgb2JqZWN0cyBpbnRvIHRoZSBjb25uZWN0aW9uLiAgcGFyYW1ldGVycyBzZXRcbiAgICAgICAgLy8gb24gdGhlIGNvbm5lY3Rpb24gdGFrZSBwcmVjZWRlbmNlOyB0aGVuIHNvdXJjZSBlbmRwb2ludCBwYXJhbXMsIHRoZW5cbiAgICAgICAgLy8gZmluYWxseSB0YXJnZXQgZW5kcG9pbnQgcGFyYW1zLlxuICAgICAgICB2YXIgX3AgPSBqc1BsdW1iLmV4dGVuZCh7fSwgdGhpcy5lbmRwb2ludHNbMV0uZ2V0UGFyYW1ldGVycygpKTtcbiAgICAgICAgX2pwLmV4dGVuZChfcCwgdGhpcy5lbmRwb2ludHNbMF0uZ2V0UGFyYW1ldGVycygpKTtcbiAgICAgICAgX2pwLmV4dGVuZChfcCwgdGhpcy5nZXRQYXJhbWV0ZXJzKCkpO1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnMoX3ApO1xuLy8gRU5EIFBBUkFNRVRFUlNcblxuLy8gUEFJTlRJTkdcblxuICAgICAgICB0aGlzLnNldENvbm5lY3Rvcih0aGlzLmVuZHBvaW50c1swXS5jb25uZWN0b3IgfHwgdGhpcy5lbmRwb2ludHNbMV0uY29ubmVjdG9yIHx8IHBhcmFtcy5jb25uZWN0b3IgfHwgX2pzUGx1bWIuRGVmYXVsdHMuQ29ubmVjdG9yIHx8IF9qcC5EZWZhdWx0cy5Db25uZWN0b3IsIHRydWUpO1xuICAgICAgICBpZiAocGFyYW1zLmdlb21ldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5zZXRHZW9tZXRyeShwYXJhbXMuZ2VvbWV0cnkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gcGFyYW1zLmRhdGEgPT0gbnVsbCB8fCAhX2p1LmlzT2JqZWN0KHBhcmFtcy5kYXRhKSA/IHt9IDogcGFyYW1zLmRhdGE7XG4gICAgICAgIHRoaXMuZ2V0RGF0YSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZGF0YTsgfTtcbiAgICAgICAgdGhpcy5zZXREYXRhID0gZnVuY3Rpb24oZCkgeyBkYXRhID0gZCB8fCB7fTsgfTtcbiAgICAgICAgdGhpcy5tZXJnZURhdGEgPSBmdW5jdGlvbihkKSB7IGRhdGEgPSBqc1BsdW1iLmV4dGVuZChkYXRhLCBkKTsgfTtcblxuICAgICAgICAvLyB0aGUgdmVyeSBsYXN0IHRoaW5nIHdlIGRvIGlzIGFwcGx5IHR5cGVzLCBpZiB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgX3R5cGVzID0gWyBcImRlZmF1bHRcIiwgdGhpcy5lbmRwb2ludHNbMF0uY29ubmVjdGlvblR5cGUsIHRoaXMuZW5kcG9pbnRzWzFdLmNvbm5lY3Rpb25UeXBlLCAgcGFyYW1zLnR5cGUgXS5qb2luKFwiIFwiKTtcbiAgICAgICAgaWYgKC9bXlxcc10vLnRlc3QoX3R5cGVzKSlcbiAgICAgICAgICAgIHRoaXMuYWRkVHlwZShfdHlwZXMsIHBhcmFtcy5kYXRhLCB0cnVlKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUNvbm5lY3RlZENsYXNzKCk7XG5cbi8vIEVORCBQQUlOVElORyAgICBcbiAgICB9O1xuXG4gICAgX2p1LmV4dGVuZChfanAuQ29ubmVjdGlvbiwgX2pwLk92ZXJsYXlDYXBhYmxlSnNQbHVtYlVJQ29tcG9uZW50LCB7XG4gICAgICAgIGFwcGx5VHlwZTogZnVuY3Rpb24gKHQsIGRvTm90UmVwYWludCwgdHlwZU1hcCkge1xuXG4gICAgICAgICAgICAvLyBub25lIG9mIHRoZXNlIHRoaW5ncyByZXN1bHQgaW4gdGhlIGNyZWF0aW9uIG9mIG9iamVjdHMgc28gY2FuIGJlIGlnbm9yZWQuXG4gICAgICAgICAgICBpZiAodC5kZXRhY2hhYmxlICE9IG51bGwpIHRoaXMuc2V0RGV0YWNoYWJsZSh0LmRldGFjaGFibGUpO1xuICAgICAgICAgICAgaWYgKHQucmVhdHRhY2ggIT0gbnVsbCkgdGhpcy5zZXRSZWF0dGFjaCh0LnJlYXR0YWNoKTtcbiAgICAgICAgICAgIGlmICh0LnNjb3BlKSB0aGlzLnNjb3BlID0gdC5zY29wZTtcblxuICAgICAgICAgICAgaWYgKHQuY3NzQ2xhc3MgIT0gbnVsbCAmJiB0aGlzLmNhbnZhcykgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5hZGRDbGFzcyh0aGlzLmNhbnZhcywgdC5jc3NDbGFzcyk7XG5cbiAgICAgICAgICAgIHZhciBfYW5jaG9ycyA9IG51bGw7XG4gICAgICAgICAgICAvLyB0aGlzIGFsc28gcmVzdWx0cyBpbiB0aGUgY3JlYXRpb24gb2Ygb2JqZWN0cy5cbiAgICAgICAgICAgIGlmICh0LmFuY2hvcikge1xuICAgICAgICAgICAgICAgIC8vIG5vdGUgdGhhdCBldmVuIGlmIHRoZSBwYXJhbSB3YXMgYW5jaG9yLCB3ZSBzdG9yZSBgYW5jaG9yc2AuXG4gICAgICAgICAgICAgICAgX2FuY2hvcnMgPSB0aGlzLmdldENhY2hlZFR5cGVJdGVtKFwiYW5jaG9yc1wiLCB0eXBlTWFwLmFuY2hvcik7XG4gICAgICAgICAgICAgICAgaWYgKF9hbmNob3JzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2FuY2hvcnMgPSBbIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UubWFrZUFuY2hvcih0LmFuY2hvciksIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UubWFrZUFuY2hvcih0LmFuY2hvcikgXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZVR5cGVJdGVtKFwiYW5jaG9yc1wiLCBfYW5jaG9ycywgdHlwZU1hcC5hbmNob3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHQuYW5jaG9ycykge1xuICAgICAgICAgICAgICAgIF9hbmNob3JzID0gdGhpcy5nZXRDYWNoZWRUeXBlSXRlbShcImFuY2hvcnNcIiwgdHlwZU1hcC5hbmNob3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoX2FuY2hvcnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfYW5jaG9ycyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UubWFrZUFuY2hvcih0LmFuY2hvcnNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5tYWtlQW5jaG9yKHQuYW5jaG9yc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZVR5cGVJdGVtKFwiYW5jaG9yc1wiLCBfYW5jaG9ycywgdHlwZU1hcC5hbmNob3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2FuY2hvcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRzWzBdLmFuY2hvciA9IF9hbmNob3JzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRzWzFdLmFuY2hvciA9IF9hbmNob3JzWzFdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuZHBvaW50c1sxXS5hbmNob3IuaXNEeW5hbWljKSB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLnJlcGFpbnQodGhpcy5lbmRwb2ludHNbMV0uZWxlbWVudElkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2pwLk92ZXJsYXlDYXBhYmxlSnNQbHVtYlVJQ29tcG9uZW50LmFwcGx5VHlwZSh0aGlzLCB0KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChjLCBpbmZvcm1FbmRwb2ludHMpIHtcbiAgICAgICAgICAgIGlmIChpbmZvcm1FbmRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50c1swXS5hZGRDbGFzcyhjKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50c1sxXS5hZGRDbGFzcyhjKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdXNwZW5kZWRFbmRwb2ludCkgdGhpcy5zdXNwZW5kZWRFbmRwb2ludC5hZGRDbGFzcyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmFkZENsYXNzKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKGMsIGluZm9ybUVuZHBvaW50cykge1xuICAgICAgICAgICAgaWYgKGluZm9ybUVuZHBvaW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRzWzBdLnJlbW92ZUNsYXNzKGMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRzWzFdLnJlbW92ZUNsYXNzKGMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1c3BlbmRlZEVuZHBvaW50KSB0aGlzLnN1c3BlbmRlZEVuZHBvaW50LnJlbW92ZUNsYXNzKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IucmVtb3ZlQ2xhc3MoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzVmlzaWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIudmlzaWJsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIudmlzaWJsZSA9IHY7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3IpXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3Iuc2V0VmlzaWJsZSh2KTtcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbm5lY3RlZENsYXNzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5lbmRwb2ludHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5jbGVhbnVwKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUNvbm5lY3RlZENsYXNzOmZ1bmN0aW9uKHJlbW92ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIpIHtcbiAgICAgICAgICAgICAgICBfdXBkYXRlQ29ubmVjdGVkQ2xhc3ModGhpcywgdGhpcy5zb3VyY2UsIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UsIHJlbW92ZSk7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUNvbm5lY3RlZENsYXNzKHRoaXMsIHRoaXMudGFyZ2V0LCB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLCByZW1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRIb3ZlcjogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3IgJiYgdGhpcy5fanNQbHVtYiAmJiAhdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5pc0Nvbm5lY3Rpb25CZWluZ0RyYWdnZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnNldEhvdmVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByb290LmpzUGx1bWJbc3RhdGUgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKHRoaXMuc291cmNlLCB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmhvdmVyU291cmNlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHJvb3QuanNQbHVtYltzdGF0ZSA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0odGhpcy50YXJnZXQsIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaG92ZXJUYXJnZXRDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFV1aWRzOmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFsgdGhpcy5lbmRwb2ludHNbMF0uZ2V0VXVpZCgpLCB0aGlzLmVuZHBvaW50c1sxXS5nZXRVdWlkKCkgXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29zdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIgPyB0aGlzLl9qc1BsdW1iLmNvc3QgOiAtSW5maW5pdHk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENvc3Q6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmNvc3QgPSBjO1xuICAgICAgICB9LFxuICAgICAgICBpc0RpcmVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi5kaXJlY3RlZCA9PT0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29ubmVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEdlb21ldHJ5IDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbm5lY3RvciA/IHRoaXMuY29ubmVjdG9yLmdldEdlb21ldHJ5KCkgOiBudWxsOyB9LFxuICAgICAgICBzZXRHZW9tZXRyeSA6IGZ1bmN0aW9uKGcpIHsgaWYgKHRoaXMuY29ubmVjdG9yKSB0aGlzLmNvbm5lY3Rvci5zZXRHZW9tZXRyeShnKTsgfSxcbiAgICAgICAgcHJlcGFyZUNvbm5lY3RvcjpmdW5jdGlvbihjb25uZWN0b3JTcGVjLCB0eXBlSWQpIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3JBcmdzID0ge1xuICAgICAgICAgICAgICAgICAgICBfanNQbHVtYjogdGhpcy5fanNQbHVtYi5pbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3M6ICh0aGlzLl9qc1BsdW1iLnBhcmFtcy5jc3NDbGFzcyB8fCBcIlwiKSArICh0aGlzLmlzRWRpdGFibGUoKSA/IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZWRpdGFibGVDb25uZWN0b3JDbGFzcyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHRoaXMuX2pzUGx1bWIucGFyYW1zLmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiB0aGlzLl9qc1BsdW1iLnBhcmFtc1tcInBvaW50ZXItZXZlbnRzXCJdLFxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZTp0aGlzLmVkaXRhYmxlUmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZW5kZXJNb2RlID0gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5nZXRSZW5kZXJNb2RlKCksXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yO1xuXG4gICAgICAgICAgICBpZiAoX2p1LmlzU3RyaW5nKGNvbm5lY3RvclNwZWMpKVxuICAgICAgICAgICAgICAgIGNvbm5lY3RvciA9IG1ha2VDb25uZWN0b3IodGhpcy5fanNQbHVtYi5pbnN0YW5jZSwgcmVuZGVyTW9kZSwgY29ubmVjdG9yU3BlYywgY29ubmVjdG9yQXJncywgdGhpcyk7IC8vIGxldHMgeW91IHVzZSBhIHN0cmluZyBhcyBzaG9ydGhhbmQuXG4gICAgICAgICAgICBlbHNlIGlmIChfanUuaXNBcnJheShjb25uZWN0b3JTcGVjKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0b3JTcGVjLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IgPSBtYWtlQ29ubmVjdG9yKHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UsIHJlbmRlck1vZGUsIGNvbm5lY3RvclNwZWNbMF0sIGNvbm5lY3RvckFyZ3MsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yID0gbWFrZUNvbm5lY3Rvcih0aGlzLl9qc1BsdW1iLmluc3RhbmNlLCByZW5kZXJNb2RlLCBjb25uZWN0b3JTcGVjWzBdLCBfanUubWVyZ2UoY29ubmVjdG9yU3BlY1sxXSwgY29ubmVjdG9yQXJncyksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVJZCAhPSBudWxsKSBjb25uZWN0b3IudHlwZUlkID0gdHlwZUlkO1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0UHJlcGFyZWRDb25uZWN0b3I6IGZ1bmN0aW9uKGNvbm5lY3RvciwgZG9Ob3RSZXBhaW50LCBkb05vdENoYW5nZUxpc3RlbmVyQ29tcG9uZW50LCB0eXBlSWQpIHtcblxuICAgICAgICAgICAgdmFyIHByZXZpb3VzLCBwcmV2aW91c0NsYXNzZXMgPSBcIlwiO1xuICAgICAgICAgICAgLy8gdGhlIGNvbm5lY3RvciB3aWxsIG5vdCBiZSBjbGVhbmVkIHVwIGlmIGl0IHdhcyBzZXQgYXMgcGFydCBvZiBhIHR5cGUsIGJlY2F1c2UgYHR5cGVJZGAgd2lsbCBiZSBzZXQgb24gaXRcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBoYXZlbnQgcGFzc2VkIGluIGB0cnVlYCBmb3IgXCJmb3JjZVwiIGhlcmUuXG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gdGhpcy5jb25uZWN0b3I7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNDbGFzc2VzID0gcHJldmlvdXMuZ2V0Q2xhc3MoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICAgICAgICAgIGlmICh0eXBlSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlVHlwZUl0ZW0oXCJjb25uZWN0b3JcIiwgY29ubmVjdG9yLCB0eXBlSWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMuY29ubmVjdG9yLmNhbnZhcztcbiAgICAgICAgICAgIHRoaXMuYmdDYW52YXMgPSB0aGlzLmNvbm5lY3Rvci5iZ0NhbnZhcztcblxuICAgICAgICAgICAgLy8gcHV0IGNsYXNzZXMgZnJvbSBwcmlvciBjb25uZWN0b3Igb250byB0aGUgY2FudmFzXG4gICAgICAgICAgICB0aGlzLmFkZENsYXNzKHByZXZpb3VzQ2xhc3Nlcyk7XG5cbiAgICAgICAgICAgIC8vIG5ldzogaW5zdGVhZCBvZiBiaW5kaW5nIGxpc3RlbmVycyBwZXIgY29ubmVjdG9yLCB3ZSBub3cganVzdCBoYXZlIG9uZSBkZWxlZ2F0ZSBvbiB0aGUgY29udGFpbmVyLlxuICAgICAgICAgICAgLy8gc28gZm9yIHRoYXQgaGFuZGxlciB3ZSBzZXQgdGhlIGNvbm5lY3Rpb24gYXMgdGhlICdfanNQbHVtYicgbWVtYmVyIG9mIHRoZSBjYW52YXMgZWxlbWVudCwgYW5kXG4gICAgICAgICAgICAvLyBiZ0NhbnZhcywgaWYgaXQgZXhpc3RzLCB3aGljaCBpdCBkb2VzIHJpZ2h0IG5vdyBpbiB0aGUgVk1MIHJlbmRlcmVyLCBzbyBpdCB3b24ndCBmcm9tIHYgMi4wLjAgb253YXJkcy5cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcykgdGhpcy5jYW52YXMuX2pzUGx1bWIgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmdDYW52YXMpIHRoaXMuYmdDYW52YXMuX2pzUGx1bWIgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBvID0gdGhpcy5nZXRPdmVybGF5cygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob1tpXS50cmFuc2Zlcikgb1tpXS50cmFuc2Zlcih0aGlzLmNvbm5lY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWRvTm90Q2hhbmdlTGlzdGVuZXJDb21wb25lbnQpIHRoaXMuc2V0TGlzdGVuZXJDb21wb25lbnQodGhpcy5jb25uZWN0b3IpO1xuICAgICAgICAgICAgaWYgKCFkb05vdFJlcGFpbnQpIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRDb25uZWN0b3I6IGZ1bmN0aW9uIChjb25uZWN0b3JTcGVjLCBkb05vdFJlcGFpbnQsIGRvTm90Q2hhbmdlTGlzdGVuZXJDb21wb25lbnQsIHR5cGVJZCkge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXMucHJlcGFyZUNvbm5lY3Rvcihjb25uZWN0b3JTcGVjLCB0eXBlSWQpO1xuICAgICAgICAgICAgdGhpcy5zZXRQcmVwYXJlZENvbm5lY3Rvcihjb25uZWN0b3IsIGRvTm90UmVwYWludCwgZG9Ob3RDaGFuZ2VMaXN0ZW5lckNvbXBvbmVudCwgdHlwZUlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFpbnQ6IGZ1bmN0aW9uIChwYXJhbXMpIHtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmlzU3VzcGVuZERyYXdpbmcoKSAmJiB0aGlzLl9qc1BsdW1iLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IHBhcmFtcy50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG1vdmluZyBvYmplY3QgaXMgbm90IHRoZSBzb3VyY2Ugd2UgbXVzdCB0cmFuc3Bvc2UgdGhlIHR3byByZWZlcmVuY2VzLlxuICAgICAgICAgICAgICAgICAgICBzd2FwID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRJZCA9IHN3YXAgPyB0aGlzLnNvdXJjZUlkIDogdGhpcy50YXJnZXRJZCwgc0lkID0gc3dhcCA/IHRoaXMudGFyZ2V0SWQgOiB0aGlzLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgICAgICB0SWR4ID0gc3dhcCA/IDAgOiAxLCBzSWR4ID0gc3dhcCA/IDEgOiAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA9PSBudWxsIHx8IHRpbWVzdGFtcCAhPSB0aGlzLl9qc1BsdW1iLmxhc3RQYWludGVkQXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUluZm8gPSB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLnVwZGF0ZU9mZnNldCh7ZWxJZDpzSWR9KS5vLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SW5mbyA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UudXBkYXRlT2Zmc2V0KHtlbElkOnRJZH0pLm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBzRSA9IHRoaXMuZW5kcG9pbnRzW3NJZHhdLCB0RSA9IHRoaXMuZW5kcG9pbnRzW3RJZHhdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzQW5jaG9yUCA9IHNFLmFuY2hvci5nZXRDdXJyZW50TG9jYXRpb24oe3h5OiBbc291cmNlSW5mby5sZWZ0LCBzb3VyY2VJbmZvLnRvcF0sIHdoOiBbc291cmNlSW5mby53aWR0aCwgc291cmNlSW5mby5oZWlnaHRdLCBlbGVtZW50OiBzRSwgdGltZXN0YW1wOiB0aW1lc3RhbXB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRBbmNob3JQID0gdEUuYW5jaG9yLmdldEN1cnJlbnRMb2NhdGlvbih7eHk6IFt0YXJnZXRJbmZvLmxlZnQsIHRhcmdldEluZm8udG9wXSwgd2g6IFt0YXJnZXRJbmZvLndpZHRoLCB0YXJnZXRJbmZvLmhlaWdodF0sIGVsZW1lbnQ6IHRFLCB0aW1lc3RhbXA6IHRpbWVzdGFtcH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlc2V0Qm91bmRzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IuY29tcHV0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VQb3M6IHNBbmNob3JQLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UG9zOiB0QW5jaG9yUCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUVuZHBvaW50OiB0aGlzLmVuZHBvaW50c1tzSWR4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVuZHBvaW50OiB0aGlzLmVuZHBvaW50c1t0SWR4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogdGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UubGluZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSW5mbzogc291cmNlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEluZm86IHRhcmdldEluZm9cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXlFeHRlbnRzID0geyBtaW5YOiBJbmZpbml0eSwgbWluWTogSW5maW5pdHksIG1heFg6IC1JbmZpbml0eSwgbWF4WTogLUluZmluaXR5IH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBvdmVybGF5cy4gd2UgZG8gdGhpcyBmaXJzdCBzbyB3ZSBjYW4gZ2V0IHRoZWlyIHBsYWNlbWVudHMsIGFuZCBhZGp1c3QgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5lciBpZiBuZWVkcyBiZSAoaWYgYW4gb3ZlcmxheSB3b3VsZCBiZSBjbGlwcGVkKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iLm92ZXJsYXlzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheVBsYWNlbWVudHNbaV0gPSBvLmRyYXcodGhpcy5jb25uZWN0b3IsIHRoaXMuX2pzUGx1bWIucGFpbnRTdHlsZUluVXNlLCB0aGlzLmdldEFic29sdXRlT3ZlcmxheVBvc2l0aW9uKG8pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheUV4dGVudHMubWluWCA9IE1hdGgubWluKG92ZXJsYXlFeHRlbnRzLm1pblgsIHRoaXMuX2pzUGx1bWIub3ZlcmxheVBsYWNlbWVudHNbaV0ubWluWCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXlFeHRlbnRzLm1heFggPSBNYXRoLm1heChvdmVybGF5RXh0ZW50cy5tYXhYLCB0aGlzLl9qc1BsdW1iLm92ZXJsYXlQbGFjZW1lbnRzW2ldLm1heFgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5RXh0ZW50cy5taW5ZID0gTWF0aC5taW4ob3ZlcmxheUV4dGVudHMubWluWSwgdGhpcy5fanNQbHVtYi5vdmVybGF5UGxhY2VtZW50c1tpXS5taW5ZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheUV4dGVudHMubWF4WSA9IE1hdGgubWF4KG92ZXJsYXlFeHRlbnRzLm1heFksIHRoaXMuX2pzUGx1bWIub3ZlcmxheVBsYWNlbWVudHNbaV0ubWF4WSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcnNlRmxvYXQodGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UubGluZVdpZHRoIHx8IDEpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVXaWR0aCA9IHBhcnNlRmxvYXQodGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UubGluZVdpZHRoIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWluOiBNYXRoLm1pbih0aGlzLmNvbm5lY3Rvci5ib3VuZHMubWluWCAtIChsaW5lV2lkdGggKyBvdXRsaW5lV2lkdGgpLCBvdmVybGF5RXh0ZW50cy5taW5YKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5bWluOiBNYXRoLm1pbih0aGlzLmNvbm5lY3Rvci5ib3VuZHMubWluWSAtIChsaW5lV2lkdGggKyBvdXRsaW5lV2lkdGgpLCBvdmVybGF5RXh0ZW50cy5taW5ZKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWF4OiBNYXRoLm1heCh0aGlzLmNvbm5lY3Rvci5ib3VuZHMubWF4WCArIChsaW5lV2lkdGggKyBvdXRsaW5lV2lkdGgpLCBvdmVybGF5RXh0ZW50cy5tYXhYKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5bWF4OiBNYXRoLm1heCh0aGlzLmNvbm5lY3Rvci5ib3VuZHMubWF4WSArIChsaW5lV2lkdGggKyBvdXRsaW5lV2lkdGgpLCBvdmVybGF5RXh0ZW50cy5tYXhZKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFpbnQgdGhlIGNvbm5lY3Rvci5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IucGFpbnQodGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UsIG51bGwsIGV4dGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiB0aGUgb3ZlcmxheXNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYi5vdmVybGF5cy5oYXNPd25Qcm9wZXJ0eShqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5fanNQbHVtYi5vdmVybGF5c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnBhaW50KHRoaXMuX2pzUGx1bWIub3ZlcmxheVBsYWNlbWVudHNbal0sIGV4dGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmxhc3RQYWludGVkQXQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcGFpbnQ6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMucGFpbnQoeyBlbElkOiB0aGlzLnNvdXJjZUlkLCByZWNhbGM6ICEocGFyYW1zLnJlY2FsYyA9PT0gZmFsc2UpLCB0aW1lc3RhbXA6IHBhcmFtcy50aW1lc3RhbXB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZUVuZHBvaW50OiBmdW5jdGlvbiAoX2pzUGx1bWIsIF9uZXdFbmRwb2ludCwgY29ubiwgZXhpc3RpbmcsIGluZGV4LCBwYXJhbXMsIGVsZW1lbnQsIGVsZW1lbnRJZCkge1xuICAgICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25uLmVuZHBvaW50c1tpbmRleF0gPSBleGlzdGluZztcbiAgICAgICAgICAgICAgICBleGlzdGluZy5hZGRDb25uZWN0aW9uKGNvbm4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtcy5lbmRwb2ludHMpIHBhcmFtcy5lbmRwb2ludHMgPSBbIG51bGwsIG51bGwgXTtcbiAgICAgICAgICAgICAgICB2YXIgZXAgPSBwYXJhbXMuZW5kcG9pbnRzW2luZGV4XSB8fCBwYXJhbXMuZW5kcG9pbnQgfHwgX2pzUGx1bWIuRGVmYXVsdHMuRW5kcG9pbnRzW2luZGV4XSB8fCBqc1BsdW1iLkRlZmF1bHRzLkVuZHBvaW50c1tpbmRleF0gfHwgX2pzUGx1bWIuRGVmYXVsdHMuRW5kcG9pbnQgfHwganNQbHVtYi5EZWZhdWx0cy5FbmRwb2ludDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtcy5lbmRwb2ludFN0eWxlcykgcGFyYW1zLmVuZHBvaW50U3R5bGVzID0gWyBudWxsLCBudWxsIF07XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuZW5kcG9pbnRIb3ZlclN0eWxlcykgcGFyYW1zLmVuZHBvaW50SG92ZXJTdHlsZXMgPSBbIG51bGwsIG51bGwgXTtcbiAgICAgICAgICAgICAgICB2YXIgZXMgPSBwYXJhbXMuZW5kcG9pbnRTdHlsZXNbaW5kZXhdIHx8IHBhcmFtcy5lbmRwb2ludFN0eWxlIHx8IF9qc1BsdW1iLkRlZmF1bHRzLkVuZHBvaW50U3R5bGVzW2luZGV4XSB8fCBqc1BsdW1iLkRlZmF1bHRzLkVuZHBvaW50U3R5bGVzW2luZGV4XSB8fCBfanNQbHVtYi5EZWZhdWx0cy5FbmRwb2ludFN0eWxlIHx8IGpzUGx1bWIuRGVmYXVsdHMuRW5kcG9pbnRTdHlsZTtcbiAgICAgICAgICAgICAgICAvLyBFbmRwb2ludHMgZGVyaXZlIHRoZWlyIGZpbGxTdHlsZSBmcm9tIHRoZSBjb25uZWN0b3IncyBzdHJva2VTdHlsZSwgaWYgbm8gZmlsbFN0eWxlIHdhcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGVzLmZpbGxTdHlsZSA9PSBudWxsICYmIHBhcmFtcy5wYWludFN0eWxlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGVzLmZpbGxTdHlsZSA9IHBhcmFtcy5wYWludFN0eWxlLnN0cm9rZVN0eWxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVzLm91dGxpbmVDb2xvciA9PSBudWxsICYmIHBhcmFtcy5wYWludFN0eWxlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGVzLm91dGxpbmVDb2xvciA9IHBhcmFtcy5wYWludFN0eWxlLm91dGxpbmVDb2xvcjtcbiAgICAgICAgICAgICAgICBpZiAoZXMub3V0bGluZVdpZHRoID09IG51bGwgJiYgcGFyYW1zLnBhaW50U3R5bGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZXMub3V0bGluZVdpZHRoID0gcGFyYW1zLnBhaW50U3R5bGUub3V0bGluZVdpZHRoO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVocyA9IHBhcmFtcy5lbmRwb2ludEhvdmVyU3R5bGVzW2luZGV4XSB8fCBwYXJhbXMuZW5kcG9pbnRIb3ZlclN0eWxlIHx8IF9qc1BsdW1iLkRlZmF1bHRzLkVuZHBvaW50SG92ZXJTdHlsZXNbaW5kZXhdIHx8IGpzUGx1bWIuRGVmYXVsdHMuRW5kcG9pbnRIb3ZlclN0eWxlc1tpbmRleF0gfHwgX2pzUGx1bWIuRGVmYXVsdHMuRW5kcG9pbnRIb3ZlclN0eWxlIHx8IGpzUGx1bWIuRGVmYXVsdHMuRW5kcG9pbnRIb3ZlclN0eWxlO1xuICAgICAgICAgICAgICAgIC8vIGVuZHBvaW50IGhvdmVyIGZpbGwgc3R5bGUgaXMgZGVyaXZlZCBmcm9tIGNvbm5lY3RvcidzIGhvdmVyIHN0cm9rZSBzdHlsZVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaG92ZXJQYWludFN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVocyA9PSBudWxsKSBlaHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVocy5maWxsU3R5bGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWhzLmZpbGxTdHlsZSA9IHBhcmFtcy5ob3ZlclBhaW50U3R5bGUuc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBwYXJhbXMuYW5jaG9ycyA/IHBhcmFtcy5hbmNob3JzW2luZGV4XSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYW5jaG9yID8gcGFyYW1zLmFuY2hvciA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX21ha2VBbmNob3IoX2pzUGx1bWIuRGVmYXVsdHMuQW5jaG9yc1tpbmRleF0sIGVsZW1lbnRJZCwgX2pzUGx1bWIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX21ha2VBbmNob3IoX2pwLkRlZmF1bHRzLkFuY2hvcnNbaW5kZXhdLCBlbGVtZW50SWQsIF9qc1BsdW1iKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9tYWtlQW5jaG9yKF9qc1BsdW1iLkRlZmF1bHRzLkFuY2hvciwgZWxlbWVudElkLCBfanNQbHVtYikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbWFrZUFuY2hvcihfanAuRGVmYXVsdHMuQW5jaG9yLCBlbGVtZW50SWQsIF9qc1BsdW1iKSxcbiAgICAgICAgICAgICAgICAgICAgdSA9IHBhcmFtcy51dWlkcyA/IHBhcmFtcy51dWlkc1tpbmRleF0gOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgZSA9IF9uZXdFbmRwb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIHBhaW50U3R5bGU6IGVzLCBob3ZlclBhaW50U3R5bGU6IGVocywgZW5kcG9pbnQ6IGVwLCBjb25uZWN0aW9uczogWyBjb25uIF0sXG4gICAgICAgICAgICAgICAgICAgIHV1aWQ6IHUsIGFuY2hvcjogYSwgc291cmNlOiBlbGVtZW50LCBzY29wZTogcGFyYW1zLnNjb3BlLFxuICAgICAgICAgICAgICAgICAgICByZWF0dGFjaDogcGFyYW1zLnJlYXR0YWNoIHx8IF9qc1BsdW1iLkRlZmF1bHRzLlJlYXR0YWNoQ29ubmVjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGRldGFjaGFibGU6IHBhcmFtcy5kZXRhY2hhYmxlIHx8IF9qc1BsdW1iLkRlZmF1bHRzLkNvbm5lY3Rpb25zRGV0YWNoYWJsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbm4uZW5kcG9pbnRzW2luZGV4XSA9IGU7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmRyYXdFbmRwb2ludHMgPT09IGZhbHNlKSBlLnNldFZpc2libGUoZmFsc2UsIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuXG4gICAgfSk7IC8vIEVORCBDb25uZWN0aW9uIGNsYXNzICAgICAgICAgICAgXG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qXG4gKiBqc1BsdW1iXG4gKiBcbiAqIFRpdGxlOmpzUGx1bWIgMi4xLjBcbiAqIFxuICogUHJvdmlkZXMgYSB3YXkgdG8gdmlzdWFsbHkgY29ubmVjdCBlbGVtZW50cyBvbiBhbiBIVE1MIHBhZ2UsIHVzaW5nIFNWRy5cbiAqIFxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBjb2RlIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGFuY2hvcnMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNiBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXG4gKiBcbiAqIGh0dHA6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHA6Ly9naXRodWIuY29tL3Nwb3JyaXR0L2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG47XG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgcm9vdCA9IHRoaXMsXG4gICAgICAgIF9qdSA9IHJvb3QuanNQbHVtYlV0aWwsXG4gICAgICAgIF9qcCA9IHJvb3QuanNQbHVtYjtcblxuICAgIC8vXG4gICAgLy8gbWFuYWdlcyBhbmNob3JzIGZvciBhbGwgZWxlbWVudHMuXG4gICAgLy9cbiAgICBfanAuQW5jaG9yTWFuYWdlciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hbUVuZHBvaW50cyA9IHt9LFxuICAgICAgICAgICAgY29udGludW91c0FuY2hvckxvY2F0aW9ucyA9IHt9LFxuICAgICAgICAgICAgdXNlckRlZmluZWRDb250aW51b3VzQW5jaG9yTG9jYXRpb25zID0ge30sXG4gICAgICAgICAgICBjb250aW51b3VzQW5jaG9yT3JpZW50YXRpb25zID0ge30sXG4gICAgICAgICAgICBPcmllbnRhdGlvbiA9IHsgSE9SSVpPTlRBTDogXCJob3Jpem9udGFsXCIsIFZFUlRJQ0FMOiBcInZlcnRpY2FsXCIsIERJQUdPTkFMOiBcImRpYWdvbmFsXCIsIElERU5USVRZOiBcImlkZW50aXR5XCIgfSxcbiAgICAgICAgICAgIGF4ZXMgPSBbXCJsZWZ0XCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIl0sXG4gICAgICAgICAgICBjb25uZWN0aW9uc0J5RWxlbWVudElkID0ge30sXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGFuY2hvckxpc3RzID0ge30sXG4gICAgICAgICAgICBqc1BsdW1iSW5zdGFuY2UgPSBwYXJhbXMuanNQbHVtYkluc3RhbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmdDb25uZWN0aW9ucyA9IHt9LFxuICAgICAgICAgICAgY2FsY3VsYXRlT3JpZW50YXRpb24gPSBmdW5jdGlvbiAoc291cmNlSWQsIHRhcmdldElkLCBzZCwgdGQsIHNvdXJjZUFuY2hvciwgdGFyZ2V0QW5jaG9yKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlSWQgPT09IHRhcmdldElkKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogT3JpZW50YXRpb24uSURFTlRJVFksXG4gICAgICAgICAgICAgICAgICAgIGE6IFtcInRvcFwiLCBcInRvcFwiXVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBNYXRoLmF0YW4yKCh0ZC5jZW50ZXJ5IC0gc2QuY2VudGVyeSksICh0ZC5jZW50ZXJ4IC0gc2QuY2VudGVyeCkpLFxuICAgICAgICAgICAgICAgICAgICB0aGV0YTIgPSBNYXRoLmF0YW4yKChzZC5jZW50ZXJ5IC0gdGQuY2VudGVyeSksIChzZC5jZW50ZXJ4IC0gdGQuY2VudGVyeCkpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgLy8gaW1wcm92ZWQgZmFjZSBjYWxjdWxhdGlvbi4gZ2V0IG1pZHBvaW50cyBvZiBlYWNoIGZhY2UgZm9yIHNvdXJjZSBhbmQgdGFyZ2V0LCB0aGVuIHB1dCBpbiBhbiBhcnJheSB3aXRoIGFsbCBjb21iaW5hdGlvbnMgb2ZcbiAgICAgICAgICAgICAgICAvLyBzb3VyY2UvdGFyZ2V0IGZhY2VzLiBzb3J0IHRoaXMgYXJyYXkgYnkgZGlzdGFuY2UgYmV0d2VlbiBtaWRwb2ludHMuIHRoZSBlbnRyeSBhdCBpbmRleCAwIGlzIG91ciBwcmVmZXJyZWQgb3B0aW9uLiB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBvbmUgYnkgb25lIHVudGlsIHdlIGZpbmQgYW4gZW50cnkgaW4gd2hpY2ggZWFjaCByZXF1ZXN0ZWQgZmFjZSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXSwgbWlkcG9pbnRzID0geyB9O1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAodHlwZXMsIGRpbSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaWRwb2ludHNbdHlwZXNbaV1dID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiBbIGRpbVtpXS5sZWZ0LCBkaW1baV0uY2VudGVyeSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmlnaHRcIjogWyBkaW1baV0ucmlnaHQsIGRpbVtpXS5jZW50ZXJ5IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0b3BcIjogWyBkaW1baV0uY2VudGVyeCwgZGltW2ldLnRvcCBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYm90dG9tXCI6IFsgZGltW2ldLmNlbnRlcnggLCBkaW1baV0uYm90dG9tXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKFsgXCJzb3VyY2VcIiwgXCJ0YXJnZXRcIiBdLCBbIHNkLCB0ZCBdKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHNmID0gMDsgc2YgPCBheGVzLmxlbmd0aDsgc2YrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ZiA9IDA7IHRmIDwgYXhlcy5sZW5ndGg7IHRmKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBheGVzW3NmXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGF4ZXNbdGZdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Q6IEJpbHRvbmcubGluZUxlbmd0aChtaWRwb2ludHMuc291cmNlW2F4ZXNbc2ZdXSwgbWlkcG9pbnRzLnRhcmdldFtheGVzW3RmXV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5kaXN0IDwgYi5kaXN0ID8gLTEgOiBhLmRpc3QgPiBiLmRpc3QgPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIG5vdyBnbyB0aHJvdWdoIHRoaXMgbGlzdCBhbmQgdHJ5IHRvIGdldCBhbiBlbnRyeSB0aGF0IHNhdGlzZmllcyBib3RoICh0aGVyZSB3aWxsIGJlIG9uZSwgdW5sZXNzIG9uZSBvZiB0aGUgYW5jaG9yc1xuICAgICAgICAgICAgICAgIC8vIGRlY2xhcmVzIG5vIGF2YWlsYWJsZSBmYWNlcylcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlRWRnZSA9IGNhbmRpZGF0ZXNbMF0uc291cmNlLCB0YXJnZXRFZGdlID0gY2FuZGlkYXRlc1swXS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VBbmNob3IuaXNDb250aW51b3VzIHx8IHNvdXJjZUFuY2hvci5pc0VkZ2VTdXBwb3J0ZWQoY2FuZGlkYXRlc1tpXS5zb3VyY2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlRWRnZSA9IGNhbmRpZGF0ZXNbaV0uc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VFZGdlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldEFuY2hvci5pc0NvbnRpbnVvdXMgfHwgdGFyZ2V0QW5jaG9yLmlzRWRnZVN1cHBvcnRlZChjYW5kaWRhdGVzW2ldLnRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFZGdlID0gY2FuZGlkYXRlc1tpXS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWRnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlRWRnZSAhPSBudWxsICYmIHRhcmdldEVkZ2UgIT0gbnVsbCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYTogWyBzb3VyY2VFZGdlLCB0YXJnZXRFZGdlIF0sXG4gICAgICAgICAgICAgICAgICAgIHRoZXRhOiB0aGV0YSxcbiAgICAgICAgICAgICAgICAgICAgdGhldGEyOiB0aGV0YTJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgLy8gdXNlZCBieSBwbGFjZUFuY2hvcnMgZnVuY3Rpb25cbiAgICAgICAgICAgIHBsYWNlQW5jaG9yc09uTGluZSA9IGZ1bmN0aW9uIChkZXNjLCBlbGVtZW50RGltZW5zaW9ucywgZWxlbWVudFBvc2l0aW9uLCBjb25uZWN0aW9ucywgaG9yaXpvbnRhbCwgb3RoZXJNdWx0aXBsaWVyLCByZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbXSwgc3RlcCA9IGVsZW1lbnREaW1lbnNpb25zW2hvcml6b250YWwgPyAwIDogMV0gLyAoY29ubmVjdGlvbnMubGVuZ3RoICsgMSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5lY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSAoaSArIDEpICogc3RlcCwgb3RoZXIgPSBvdGhlck11bHRpcGxpZXIgKiBlbGVtZW50RGltZW5zaW9uc1tob3Jpem9udGFsID8gMSA6IDBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV2ZXJzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGVsZW1lbnREaW1lbnNpb25zW2hvcml6b250YWwgPyAwIDogMV0gLSB2YWw7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gKGhvcml6b250YWwgPyB2YWwgOiBvdGhlciksIHggPSBlbGVtZW50UG9zaXRpb25bMF0gKyBkeCwgeHAgPSBkeCAvIGVsZW1lbnREaW1lbnNpb25zWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSAoaG9yaXpvbnRhbCA/IG90aGVyIDogdmFsKSwgeSA9IGVsZW1lbnRQb3NpdGlvblsxXSArIGR5LCB5cCA9IGR5IC8gZWxlbWVudERpbWVuc2lvbnNbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFsgeCwgeSwgeHAsIHlwLCBjb25uZWN0aW9uc1tpXVsxXSwgY29ubmVjdGlvbnNbaV1bMl0gXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAvLyB1c2VkIGJ5IGVkZ2VTb3J0RnVuY3Rpb25zXG4gICAgICAgICAgICBjdXJyeVNvcnQgPSBmdW5jdGlvbiAocmV2ZXJzZUFuZ2xlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXZlcnNlQW5nbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gYVswXVswXSA8IGJbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gYVswXVswXSA+IGJbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgPT09IGZhbHNlID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAvLyB1c2VkIGJ5IGVkZ2VTb3J0RnVuY3Rpb25zXG4gICAgICAgICAgICBsZWZ0U29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgZ2V0IGFkanVzdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgIHZhciBwMSA9IGFbMF1bMF0gPCAwID8gLU1hdGguUEkgLSBhWzBdWzBdIDogTWF0aC5QSSAtIGFbMF1bMF0sXG4gICAgICAgICAgICAgICAgICAgIHAyID0gYlswXVswXSA8IDAgPyAtTWF0aC5QSSAtIGJbMF1bMF0gOiBNYXRoLlBJIC0gYlswXVswXTtcbiAgICAgICAgICAgICAgICBpZiAocDEgPiBwMikgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gYVswXVsxXSA+IGJbMF1bMV0gPyAxIDogLTE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAvLyB1c2VkIGJ5IHBsYWNlQW5jaG9yc1xuICAgICAgICAgICAgZWRnZVNvcnRGdW5jdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgXCJ0b3BcIjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbMF0gPiBiWzBdID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJyaWdodFwiOiBjdXJyeVNvcnQodHJ1ZSksXG4gICAgICAgICAgICAgICAgXCJib3R0b21cIjogY3VycnlTb3J0KHRydWUpLFxuICAgICAgICAgICAgICAgIFwibGVmdFwiOiBsZWZ0U29ydFxuICAgICAgICAgICAgfSxcbiAgICAgICAgLy8gdXNlZCBieSBwbGFjZUFuY2hvcnNcbiAgICAgICAgICAgIF9zb3J0SGVscGVyID0gZnVuY3Rpb24gKF9hcnJheSwgX2ZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9hcnJheS5zb3J0KF9mbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAvLyB1c2VkIGJ5IEFuY2hvck1hbmFnZXIucmVkcmF3XG4gICAgICAgICAgICBwbGFjZUFuY2hvcnMgPSBmdW5jdGlvbiAoZWxlbWVudElkLCBfYW5jaG9yTGlzdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2QgPSBqc1BsdW1iSW5zdGFuY2UuZ2V0Q2FjaGVkRGF0YShlbGVtZW50SWQpLCBzUyA9IGNkLnMsIHNPID0gY2QubyxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VTb21lQW5jaG9ycyA9IGZ1bmN0aW9uIChkZXNjLCBlbGVtZW50RGltZW5zaW9ucywgZWxlbWVudFBvc2l0aW9uLCB1bnNvcnRlZENvbm5lY3Rpb25zLCBpc0hvcml6b250YWwsIG90aGVyTXVsdGlwbGllciwgb3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bnNvcnRlZENvbm5lY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2MgPSBfc29ydEhlbHBlcih1bnNvcnRlZENvbm5lY3Rpb25zLCBlZGdlU29ydEZ1bmN0aW9uc1tkZXNjXSksIC8vIHB1dHMgdGhlbSBpbiBvcmRlciBiYXNlZCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQncyBwb3Mgb24gc2NyZWVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2UgPSBkZXNjID09PSBcInJpZ2h0XCIgfHwgZGVzYyA9PT0gXCJ0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9ycyA9IHBsYWNlQW5jaG9yc09uTGluZShkZXNjLCBlbGVtZW50RGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRQb3NpdGlvbiwgc2MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0hvcml6b250YWwsIG90aGVyTXVsdGlwbGllciwgcmV2ZXJzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWtlcyBhIGNvbXB1dGVkIGFuY2hvciBwb3NpdGlvbiBhbmQgYWRqdXN0cyBpdCBmb3IgcGFyZW50IG9mZnNldCBhbmQgc2Nyb2xsLCB0aGVuIHN0b3JlcyBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3NldEFuY2hvckxvY2F0aW9uID0gZnVuY3Rpb24gKGVuZHBvaW50LCBhbmNob3JQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludW91c0FuY2hvckxvY2F0aW9uc1tlbmRwb2ludC5pZF0gPSBbIGFuY2hvclBvc1swXSwgYW5jaG9yUG9zWzFdLCBhbmNob3JQb3NbMl0sIGFuY2hvclBvc1szXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51b3VzQW5jaG9yT3JpZW50YXRpb25zW2VuZHBvaW50LmlkXSA9IG9yaWVudGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2hvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBhbmNob3JzW2ldWzRdLCB3ZUFyZVNvdXJjZSA9IGMuZW5kcG9pbnRzWzBdLmVsZW1lbnRJZCA9PT0gZWxlbWVudElkLCB3ZUFyZVRhcmdldCA9IGMuZW5kcG9pbnRzWzFdLmVsZW1lbnRJZCA9PT0gZWxlbWVudElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2VBcmVTb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2V0QW5jaG9yTG9jYXRpb24oYy5lbmRwb2ludHNbMF0sIGFuY2hvcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2VBcmVUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2V0QW5jaG9yTG9jYXRpb24oYy5lbmRwb2ludHNbMV0sIGFuY2hvcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHBsYWNlU29tZUFuY2hvcnMoXCJib3R0b21cIiwgc1MsIFtzTy5sZWZ0LCBzTy50b3BdLCBfYW5jaG9yTGlzdHMuYm90dG9tLCB0cnVlLCAxLCBbMCwgMV0pO1xuICAgICAgICAgICAgICAgIHBsYWNlU29tZUFuY2hvcnMoXCJ0b3BcIiwgc1MsIFtzTy5sZWZ0LCBzTy50b3BdLCBfYW5jaG9yTGlzdHMudG9wLCB0cnVlLCAwLCBbMCwgLTFdKTtcbiAgICAgICAgICAgICAgICBwbGFjZVNvbWVBbmNob3JzKFwibGVmdFwiLCBzUywgW3NPLmxlZnQsIHNPLnRvcF0sIF9hbmNob3JMaXN0cy5sZWZ0LCBmYWxzZSwgMCwgWy0xLCAwXSk7XG4gICAgICAgICAgICAgICAgcGxhY2VTb21lQW5jaG9ycyhcInJpZ2h0XCIsIHNTLCBbc08ubGVmdCwgc08udG9wXSwgX2FuY2hvckxpc3RzLnJpZ2h0LCBmYWxzZSwgMSwgWzEsIDBdKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9hbUVuZHBvaW50cyA9IHt9O1xuICAgICAgICAgICAgY29ubmVjdGlvbnNCeUVsZW1lbnRJZCA9IHt9O1xuICAgICAgICAgICAgYW5jaG9yTGlzdHMgPSB7fTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRGbG9hdGluZ0Nvbm5lY3Rpb24gPSBmdW5jdGlvbiAoa2V5LCBjb25uKSB7XG4gICAgICAgICAgICBmbG9hdGluZ0Nvbm5lY3Rpb25zW2tleV0gPSBjb25uO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbW92ZUZsb2F0aW5nQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmbG9hdGluZ0Nvbm5lY3Rpb25zW2tleV07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmV3Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjb25uKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlSWQgPSBjb25uLnNvdXJjZUlkLCB0YXJnZXRJZCA9IGNvbm4udGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgZXAgPSBjb25uLmVuZHBvaW50cyxcbiAgICAgICAgICAgICAgICBkb1JlZ2lzdGVyVGFyZ2V0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICByZWdpc3RlckNvbm5lY3Rpb24gPSBmdW5jdGlvbiAob3RoZXJJbmRleCwgb3RoZXJFbmRwb2ludCwgb3RoZXJBbmNob3IsIGVsSWQsIGMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzb3VyY2VJZCA9PSB0YXJnZXRJZCkgJiYgb3RoZXJBbmNob3IuaXNDb250aW51b3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHRhcmdldCBlbmRwb2ludCdzIGNhbnZhcy4gIHdlIGRvbnQgbmVlZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm4uX2pzUGx1bWIuaW5zdGFuY2UucmVtb3ZlRWxlbWVudChlcFsxXS5jYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9SZWdpc3RlclRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9qdS5hZGRUb0xpc3QoY29ubmVjdGlvbnNCeUVsZW1lbnRJZCwgZWxJZCwgW2MsIG90aGVyRW5kcG9pbnQsIG90aGVyQW5jaG9yLmNvbnN0cnVjdG9yID09IF9qcC5EeW5hbWljQW5jaG9yXSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVnaXN0ZXJDb25uZWN0aW9uKDAsIGVwWzBdLCBlcFswXS5hbmNob3IsIHRhcmdldElkLCBjb25uKTtcbiAgICAgICAgICAgIGlmIChkb1JlZ2lzdGVyVGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyQ29ubmVjdGlvbigxLCBlcFsxXSwgZXBbMV0uYW5jaG9yLCBzb3VyY2VJZCwgY29ubik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZW1vdmVFbmRwb2ludEZyb21BbmNob3JMaXN0cyA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChsaXN0LCBlSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdCkgeyAgLy8gdHJhbnNpZW50IGFuY2hvcnMgZG9udCBnZXQgZW50cmllcyBpbiB0aGlzIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlWzRdID09IGVJZDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgX2p1LnJlbW92ZVdpdGhGdW5jdGlvbihsaXN0LnRvcCwgZik7XG4gICAgICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24obGlzdC5sZWZ0LCBmKTtcbiAgICAgICAgICAgICAgICAgICAgX2p1LnJlbW92ZVdpdGhGdW5jdGlvbihsaXN0LmJvdHRvbSwgZik7XG4gICAgICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24obGlzdC5yaWdodCwgZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoYW5jaG9yTGlzdHNbZW5kcG9pbnQuZWxlbWVudElkXSwgZW5kcG9pbnQuaWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25EZXRhY2hlZCA9IGZ1bmN0aW9uIChjb25uSW5mbywgZG9Ob3RSZWRyYXcpIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gY29ubkluZm8uY29ubmVjdGlvbiB8fCBjb25uSW5mbyxcbiAgICAgICAgICAgICAgICBzb3VyY2VJZCA9IGNvbm5JbmZvLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIHRhcmdldElkID0gY29ubkluZm8udGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgZXAgPSBjb25uZWN0aW9uLmVuZHBvaW50cyxcbiAgICAgICAgICAgICAgICByZW1vdmVDb25uZWN0aW9uID0gZnVuY3Rpb24gKG90aGVySW5kZXgsIG90aGVyRW5kcG9pbnQsIG90aGVyQW5jaG9yLCBlbElkLCBjKSB7XG4gICAgICAgICAgICAgICAgICAgX2p1LnJlbW92ZVdpdGhGdW5jdGlvbihjb25uZWN0aW9uc0J5RWxlbWVudElkW2VsSWRdLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY1swXS5pZCA9PSBjLmlkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZW1vdmVDb25uZWN0aW9uKDEsIGVwWzFdLCBlcFsxXS5hbmNob3IsIHNvdXJjZUlkLCBjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIHJlbW92ZUNvbm5lY3Rpb24oMCwgZXBbMF0sIGVwWzBdLmFuY2hvciwgdGFyZ2V0SWQsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uZmxvYXRpbmdJZCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbi5mbG9hdGluZ0luZGV4LCBjb25uZWN0aW9uLmZsb2F0aW5nRW5kcG9pbnQsIGNvbm5lY3Rpb24uZmxvYXRpbmdFbmRwb2ludC5hbmNob3IsIGNvbm5lY3Rpb24uZmxvYXRpbmdJZCwgY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRW5kcG9pbnRGcm9tQW5jaG9yTGlzdHMoY29ubmVjdGlvbi5mbG9hdGluZ0VuZHBvaW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gYW5jaG9yTGlzdHMgICAgICAgICAgICBcbiAgICAgICAgICAgIHJlbW92ZUVuZHBvaW50RnJvbUFuY2hvckxpc3RzKGNvbm5lY3Rpb24uZW5kcG9pbnRzWzBdKTtcbiAgICAgICAgICAgIHJlbW92ZUVuZHBvaW50RnJvbUFuY2hvckxpc3RzKGNvbm5lY3Rpb24uZW5kcG9pbnRzWzFdKTtcblxuICAgICAgICAgICAgaWYgKCFkb05vdFJlZHJhdykge1xuICAgICAgICAgICAgICAgIHNlbGYucmVkcmF3KGNvbm5lY3Rpb24uc291cmNlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnRhcmdldElkICE9PSBjb25uZWN0aW9uLnNvdXJjZUlkKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlZHJhdyhjb25uZWN0aW9uLnRhcmdldElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGQgPSBmdW5jdGlvbiAoZW5kcG9pbnQsIGVsZW1lbnRJZCkge1xuICAgICAgICAgICAgX2p1LmFkZFRvTGlzdChfYW1FbmRwb2ludHMsIGVsZW1lbnRJZCwgZW5kcG9pbnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYW5nZUlkID0gZnVuY3Rpb24gKG9sZElkLCBuZXdJZCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtuZXdJZF0gPSBjb25uZWN0aW9uc0J5RWxlbWVudElkW29sZElkXTtcbiAgICAgICAgICAgIF9hbUVuZHBvaW50c1tuZXdJZF0gPSBfYW1FbmRwb2ludHNbb2xkSWRdO1xuICAgICAgICAgICAgZGVsZXRlIGNvbm5lY3Rpb25zQnlFbGVtZW50SWRbb2xkSWRdO1xuICAgICAgICAgICAgZGVsZXRlIF9hbUVuZHBvaW50c1tvbGRJZF07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29ubmVjdGlvbnNGb3IgPSBmdW5jdGlvbiAoZWxlbWVudElkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtlbGVtZW50SWRdIHx8IFtdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEVuZHBvaW50c0ZvciA9IGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfYW1FbmRwb2ludHNbZWxlbWVudElkXSB8fCBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVFbmRwb2ludCA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgX2p1LnJlbW92ZVdpdGhGdW5jdGlvbihfYW1FbmRwb2ludHNbZW5kcG9pbnQuZWxlbWVudElkXSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5pZCA9PSBlbmRwb2ludC5pZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVtb3ZlRW5kcG9pbnRGcm9tQW5jaG9yTGlzdHMoZW5kcG9pbnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsZWFyRm9yID0gZnVuY3Rpb24gKGVsZW1lbnRJZCkge1xuICAgICAgICAgICAgZGVsZXRlIF9hbUVuZHBvaW50c1tlbGVtZW50SWRdO1xuICAgICAgICAgICAgX2FtRW5kcG9pbnRzW2VsZW1lbnRJZF0gPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdXBkYXRlcyB0aGUgZ2l2ZW4gYW5jaG9yIGxpc3QgYnkgZWl0aGVyIHVwZGF0aW5nIGFuIGV4aXN0aW5nIGFuY2hvcidzIGluZm8sIG9yIGFkZGluZyBpdC4gdGhpcyBmdW5jdGlvblxuICAgICAgICAvLyBhbHNvIHJlbW92ZXMgdGhlIGFuY2hvciBmcm9tIGl0cyBwcmV2aW91cyBsaXN0LCBpZiB0aGUgZWRnZSBpdCBpcyBvbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgLy8gYWxsIGNvbm5lY3Rpb25zIGZvdW5kIGFsb25nIHRoZSB3YXkgKHRob3NlIHRoYXQgYXJlIGNvbm5lY3RlZCB0byBvbmUgb2YgdGhlIGZhY2VzIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgLy8gb3BlcmF0ZXMgb24pIGFyZSBhZGRlZCB0byB0aGUgY29ubnNUb1BhaW50IGxpc3QsIGFzIGFyZSB0aGVpciBlbmRwb2ludHMuIGluIHRoaXMgd2F5IHdlIGtub3cgdG8gcmVwYWludFxuICAgICAgICAvLyB0aGVtIHd0aG91dCBoYXZpbmcgdG8gY2FsY3VsYXRlIGFueXRoaW5nIGVsc2UgYWJvdXQgdGhlbS5cbiAgICAgICAgdmFyIF91cGRhdGVBbmNob3JMaXN0ID0gZnVuY3Rpb24gKGxpc3RzLCB0aGV0YSwgb3JkZXIsIGNvbm4sIGFCb29sZWFuLCBvdGhlckVsSWQsIGlkeCwgcmV2ZXJzZSwgZWRnZUlkLCBlbElkLCBjb25uc1RvUGFpbnQsIGVuZHBvaW50c1RvUGFpbnQpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRyeSB0byBmaW5kIHRoZSBleGFjdCBtYXRjaCwgYnV0IGtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IGluZGV4IG9mIGEgbWF0Y2hpbmcgZWxlbWVudCBpZCBhbG9uZyB0aGUgd2F5LnNcbiAgICAgICAgICAgIHZhciBleGFjdElkeCA9IC0xLFxuICAgICAgICAgICAgICAgIGZpcnN0TWF0Y2hpbmdFbElkeCA9IC0xLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gY29ubi5lbmRwb2ludHNbaWR4XSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludElkID0gZW5kcG9pbnQuaWQsXG4gICAgICAgICAgICAgICAgb0lkeCA9IFsxLCAwXVtpZHhdLFxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgWyB0aGV0YSwgb3JkZXIgXSxcbiAgICAgICAgICAgICAgICAgICAgY29ubixcbiAgICAgICAgICAgICAgICAgICAgYUJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgIG90aGVyRWxJZCxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRJZFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgbGlzdFRvQWRkVG8gPSBsaXN0c1tlZGdlSWRdLFxuICAgICAgICAgICAgICAgIGxpc3RUb1JlbW92ZUZyb20gPSBlbmRwb2ludC5fY29udGludW91c0FuY2hvckVkZ2UgPyBsaXN0c1tlbmRwb2ludC5fY29udGludW91c0FuY2hvckVkZ2VdIDogbnVsbCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZTtcblxuICAgICAgICAgICAgaWYgKGxpc3RUb1JlbW92ZUZyb20pIHtcbiAgICAgICAgICAgICAgICB2YXIgcklkeCA9IF9qdS5maW5kV2l0aEZ1bmN0aW9uKGxpc3RUb1JlbW92ZUZyb20sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlWzRdID09IGVuZHBvaW50SWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJJZHggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdFRvUmVtb3ZlRnJvbS5zcGxpY2UocklkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBhbGwgY29ubmVjdGlvbnMgZnJvbSB0aGlzIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RUb1JlbW92ZUZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IGxpc3RUb1JlbW92ZUZyb21baV1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfanUuYWRkV2l0aEZ1bmN0aW9uKGNvbm5zVG9QYWludCwgY2FuZGlkYXRlLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLmlkID09IGNhbmRpZGF0ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmFkZFdpdGhGdW5jdGlvbihlbmRwb2ludHNUb1BhaW50LCBsaXN0VG9SZW1vdmVGcm9tW2ldWzFdLmVuZHBvaW50c1tpZHhdLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmlkID09IGNhbmRpZGF0ZS5lbmRwb2ludHNbaWR4XS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmFkZFdpdGhGdW5jdGlvbihlbmRwb2ludHNUb1BhaW50LCBsaXN0VG9SZW1vdmVGcm9tW2ldWzFdLmVuZHBvaW50c1tvSWR4XSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5pZCA9PSBjYW5kaWRhdGUuZW5kcG9pbnRzW29JZHhdLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0VG9BZGRUby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IGxpc3RUb0FkZFRvW2ldWzFdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaWR4ID09IDEgJiYgbGlzdFRvQWRkVG9baV1bM10gPT09IG90aGVyRWxJZCAmJiBmaXJzdE1hdGNoaW5nRWxJZHggPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TWF0Y2hpbmdFbElkeCA9IGk7XG4gICAgICAgICAgICAgICAgX2p1LmFkZFdpdGhGdW5jdGlvbihjb25uc1RvUGFpbnQsIGNhbmRpZGF0ZSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuaWQgPT0gY2FuZGlkYXRlLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9qdS5hZGRXaXRoRnVuY3Rpb24oZW5kcG9pbnRzVG9QYWludCwgbGlzdFRvQWRkVG9baV1bMV0uZW5kcG9pbnRzW2lkeF0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmlkID09IGNhbmRpZGF0ZS5lbmRwb2ludHNbaWR4XS5pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfanUuYWRkV2l0aEZ1bmN0aW9uKGVuZHBvaW50c1RvUGFpbnQsIGxpc3RUb0FkZFRvW2ldWzFdLmVuZHBvaW50c1tvSWR4XSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuaWQgPT0gY2FuZGlkYXRlLmVuZHBvaW50c1tvSWR4XS5pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleGFjdElkeCAhPSAtMSkge1xuICAgICAgICAgICAgICAgIGxpc3RUb0FkZFRvW2V4YWN0SWR4XSA9IHZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbnNlcnRJZHggPSByZXZlcnNlID8gZmlyc3RNYXRjaGluZ0VsSWR4ICE9IC0xID8gZmlyc3RNYXRjaGluZ0VsSWR4IDogMCA6IGxpc3RUb0FkZFRvLmxlbmd0aDsgLy8gb2YgY291cnNlIHdlIHdpbGwgZ2V0IHRoaXMgZnJvbSBoYXZpbmcgbG9va2VkIHRocm91Z2ggdGhlIGFycmF5IHNob3J0bHkuXG4gICAgICAgICAgICAgICAgbGlzdFRvQWRkVG8uc3BsaWNlKGluc2VydElkeCwgMCwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3RvcmUgdGhpcyBmb3IgbmV4dCB0aW1lLlxuICAgICAgICAgICAgZW5kcG9pbnQuX2NvbnRpbnVvdXNBbmNob3JFZGdlID0gZWRnZUlkO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGZpbmQgdGhlIGVudHJ5IGluIGFuIGVuZHBvaW50J3MgbGlzdCBmb3IgdGhpcyBjb25uZWN0aW9uIGFuZCB1cGRhdGUgaXRzIHRhcmdldCBlbmRwb2ludFxuICAgICAgICAvLyB3aXRoIHRoZSBjdXJyZW50IHRhcmdldCBpbiB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgYW5kIHNvdXJjZUNoYW5nZWQgbmVlZCB0byBiZSBmb2xkZXIgaW50byBvbmUuXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMudXBkYXRlT3RoZXJFbmRwb2ludCA9IGZ1bmN0aW9uIChzb3VyY2VFbElkLCBvbGRUYXJnZXRJZCwgbmV3VGFyZ2V0SWQsIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBzSW5kZXggPSBfanUuZmluZFdpdGhGdW5jdGlvbihjb25uZWN0aW9uc0J5RWxlbWVudElkW3NvdXJjZUVsSWRdLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVswXS5pZCA9PT0gY29ubmVjdGlvbi5pZDtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0SW5kZXggPSBfanUuZmluZFdpdGhGdW5jdGlvbihjb25uZWN0aW9uc0J5RWxlbWVudElkW29sZFRhcmdldElkXSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlbMF0uaWQgPT09IGNvbm5lY3Rpb24uaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBvciBhZGQgZGF0YSBmb3Igc291cmNlXG4gICAgICAgICAgICBpZiAoc0luZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtzb3VyY2VFbElkXVtzSW5kZXhdWzBdID0gY29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uc0J5RWxlbWVudElkW3NvdXJjZUVsSWRdW3NJbmRleF1bMV0gPSBjb25uZWN0aW9uLmVuZHBvaW50c1sxXTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uc0J5RWxlbWVudElkW3NvdXJjZUVsSWRdW3NJbmRleF1bMl0gPSBjb25uZWN0aW9uLmVuZHBvaW50c1sxXS5hbmNob3IuY29uc3RydWN0b3IgPT0gX2pwLkR5bmFtaWNBbmNob3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBlbnRyeSBmb3IgcHJldmlvdXMgdGFyZ2V0IChpZiB0aGVyZSlcbiAgICAgICAgICAgIGlmICh0SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zQnlFbGVtZW50SWRbb2xkVGFyZ2V0SWRdLnNwbGljZSh0SW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIC8vIGFkZCBlbnRyeSBmb3IgbmV3IHRhcmdldFxuICAgICAgICAgICAgICAgIF9qdS5hZGRUb0xpc3QoY29ubmVjdGlvbnNCeUVsZW1lbnRJZCwgbmV3VGFyZ2V0SWQsIFtjb25uZWN0aW9uLCBjb25uZWN0aW9uLmVuZHBvaW50c1swXSwgY29ubmVjdGlvbi5lbmRwb2ludHNbMF0uYW5jaG9yLmNvbnN0cnVjdG9yID09IF9qcC5EeW5hbWljQW5jaG9yXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24udXBkYXRlQ29ubmVjdGVkQ2xhc3MoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBub3RpZmljYXRpb24gdGhhdCB0aGUgY29ubmVjdGlvbiBnaXZlbiBoYXMgY2hhbmdlZCBzb3VyY2UgZnJvbSB0aGUgb3JpZ2luYWxJZCB0byB0aGUgbmV3SWQuXG4gICAgICAgIC8vIFRoaXMgaW52b2x2ZXM6XG4gICAgICAgIC8vIDEuIHJlbW92aW5nIHRoZSBjb25uZWN0aW9uIGZyb20gdGhlIGxpc3Qgb2YgY29ubmVjdGlvbnMgc3RvcmVkIGZvciB0aGUgb3JpZ2luYWxJZFxuICAgICAgICAvLyAyLiB1cGRhdGluZyB0aGUgc291cmNlIGluZm9ybWF0aW9uIGZvciB0aGUgdGFyZ2V0IG9mIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIDMuIHJlLXJlZ2lzdGVyaW5nIHRoZSBjb25uZWN0aW9uIGluIGNvbm5lY3Rpb25zQnlFbGVtZW50SWQgd2l0aCB0aGUgbmV3SWRcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5zb3VyY2VDaGFuZ2VkID0gZnVuY3Rpb24gKG9yaWdpbmFsSWQsIG5ld0lkLCBjb25uZWN0aW9uLCBuZXdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxJZCAhPT0gbmV3SWQpIHtcblxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc291cmNlSWQgPSBuZXdJZDtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnNvdXJjZSA9IG5ld0VsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGVudHJ5IHRoYXQgcG9pbnRzIGZyb20gdGhlIG9sZCBzb3VyY2UgdG8gdGhlIHRhcmdldFxuICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24oY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtvcmlnaW5hbElkXSwgZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZm9bMF0uaWQgPT09IGNvbm5lY3Rpb24uaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBlbnRyeSBmb3IgdGFyZ2V0IGFuZCB1cGRhdGUgaXRcbiAgICAgICAgICAgICAgICB2YXIgdElkeCA9IF9qdS5maW5kV2l0aEZ1bmN0aW9uKGNvbm5lY3Rpb25zQnlFbGVtZW50SWRbY29ubmVjdGlvbi50YXJnZXRJZF0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpWzBdLmlkID09PSBjb25uZWN0aW9uLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0SWR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtjb25uZWN0aW9uLnRhcmdldElkXVt0SWR4XVswXSA9IGNvbm5lY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zQnlFbGVtZW50SWRbY29ubmVjdGlvbi50YXJnZXRJZF1bdElkeF1bMV0gPSBjb25uZWN0aW9uLmVuZHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtjb25uZWN0aW9uLnRhcmdldElkXVt0SWR4XVsyXSA9IGNvbm5lY3Rpb24uZW5kcG9pbnRzWzBdLmFuY2hvci5jb25zdHJ1Y3RvciA9PSBfanAuRHluYW1pY0FuY2hvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWRkIGVudHJ5IGZvciBuZXcgc291cmNlXG4gICAgICAgICAgICAgICAgX2p1LmFkZFRvTGlzdChjb25uZWN0aW9uc0J5RWxlbWVudElkLCBuZXdJZCwgW2Nvbm5lY3Rpb24sIGNvbm5lY3Rpb24uZW5kcG9pbnRzWzFdLCBjb25uZWN0aW9uLmVuZHBvaW50c1sxXS5hbmNob3IuY29uc3RydWN0b3IgPT0gX2pwLkR5bmFtaWNBbmNob3JdKTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gU1Agbm90IGZpbmFsIG9uIHRoaXMgeWV0LiB3aGVuIGEgdXNlciBkcmFncyBhbiBleGlzdGluZyBjb25uZWN0aW9uIGFuZCBpdCB0dXJucyBpbnRvIGEgc2VsZlxuICAgICAgICAgICAgICAgIC8vIGxvb3AsIHRoZW4gdGhpcyBjb2RlIGhpZGVzIHRoZSB0YXJnZXQgZW5kcG9pbnQgKGJ5IHJlbW92aW5nIGl0IGZyb20gdGhlIERPTSkgQnV0IEkgdGhpbmsgdGhpcyBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBvY2N1ciBvbmx5IGlmIHRoZSBhbmNob3IgaXMgQ29udGludW91c1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLmVuZHBvaW50c1sxXS5hbmNob3IuaXNDb250aW51b3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnNvdXJjZSA9PT0gY29ubmVjdGlvbi50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uX2pzUGx1bWIuaW5zdGFuY2UucmVtb3ZlRWxlbWVudChjb25uZWN0aW9uLmVuZHBvaW50c1sxXS5jYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uZW5kcG9pbnRzWzFdLmNhbnZhcy5wYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLl9qc1BsdW1iLmluc3RhbmNlLmFwcGVuZEVsZW1lbnQoY29ubmVjdGlvbi5lbmRwb2ludHNbMV0uY2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24udXBkYXRlQ29ubmVjdGVkQ2xhc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBtb3ZlcyB0aGUgZ2l2ZW4gZW5kcG9pbnQgZnJvbSBgY3VycmVudElkYCB0byBgZWxlbWVudGAuXG4gICAgICAgIC8vIFRoaXMgaW52b2x2ZXM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIGNoYW5naW5nIHRoZSBrZXkgaW4gX2FtRW5kcG9pbnRzIHVuZGVyIHdoaWNoIHRoZSBlbmRwb2ludCBpcyBzdG9yZWRcbiAgICAgICAgLy8gMi4gY2hhbmdpbmcgdGhlIHNvdXJjZSBvciB0YXJnZXQgdmFsdWVzIGluIGFsbCBvZiB0aGUgZW5kcG9pbnQncyBjb25uZWN0aW9uc1xuICAgICAgICAvLyAzLiBjaGFuZ2luZyB0aGUgYXJyYXkgaW4gY29ubmVjdGlvbnNCeUVsZW1lbnRJZCBpbiB3aGljaCB0aGUgZW5kcG9pbnQncyBjb25uZWN0aW9uc1xuICAgICAgICAvLyAgICBhcmUgc3RvcmVkIChkb25lIGJ5IGVpdGhlciBzb3VyY2VDaGFuZ2VkIG9yIHVwZGF0ZU90aGVyRW5kcG9pbnQpXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMucmVob21lRW5kcG9pbnQgPSBmdW5jdGlvbiAoZXAsIGN1cnJlbnRJZCwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGVwcyA9IF9hbUVuZHBvaW50c1tjdXJyZW50SWRdIHx8IFtdLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRJZCA9IGpzUGx1bWJJbnN0YW5jZS5nZXRJZChlbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnRJZCAhPT0gY3VycmVudElkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGVwcy5pbmRleE9mKGVwKTtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9lcCA9IGVwcy5zcGxpY2UoaWR4LCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGQoX2VwLCBlbGVtZW50SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcC5jb25uZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlcC5jb25uZWN0aW9uc1tpXS5zb3VyY2VJZCA9PSBjdXJyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9lcC5jb25uZWN0aW9uc1tpXS5zb3VyY2VJZCA9IGVwLmVsZW1lbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgLy9lcC5jb25uZWN0aW9uc1tpXS5zb3VyY2UgPSBlcC5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNvdXJjZUNoYW5nZWQoY3VycmVudElkLCBlcC5lbGVtZW50SWQsIGVwLmNvbm5lY3Rpb25zW2ldLCBlcC5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXAuY29ubmVjdGlvbnNbaV0udGFyZ2V0SWQgPT0gY3VycmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVwLmNvbm5lY3Rpb25zW2ldLnRhcmdldElkID0gZXAuZWxlbWVudElkO1xuICAgICAgICAgICAgICAgICAgICBlcC5jb25uZWN0aW9uc1tpXS50YXJnZXQgPSBlcC5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZU90aGVyRW5kcG9pbnQoZXAuY29ubmVjdGlvbnNbaV0uc291cmNlSWQsIGN1cnJlbnRJZCwgZXAuZWxlbWVudElkLCBlcC5jb25uZWN0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVkcmF3ID0gZnVuY3Rpb24gKGVsZW1lbnRJZCwgdWksIHRpbWVzdGFtcCwgb2Zmc2V0VG9VSSwgY2xlYXJFZGl0cywgZG9Ob3RSZWNhbGNFbmRwb2ludCkge1xuXG4gICAgICAgICAgICBpZiAoIWpzUGx1bWJJbnN0YW5jZS5pc1N1c3BlbmREcmF3aW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIHRoZSBlbmRwb2ludHMgZm9yIHRoaXMgZWxlbWVudFxuICAgICAgICAgICAgICAgIHZhciBlcCA9IF9hbUVuZHBvaW50c1tlbGVtZW50SWRdIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludENvbm5lY3Rpb25zID0gY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtlbGVtZW50SWRdIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uc1RvUGFpbnQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRzVG9QYWludCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBhbmNob3JzVG9VcGRhdGUgPSBbXTtcblxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRpbWVzdGFtcCB8fCBqc1BsdW1iSW5zdGFuY2UudGltZXN0YW1wKCk7XG4gICAgICAgICAgICAgICAgLy8gb2Zmc2V0VG9VSSBhcmUgdmFsdWVzIHRoYXQgd291bGQgaGF2ZSBiZWVuIGNhbGN1bGF0ZWQgaW4gdGhlIGRyYWdNYW5hZ2VyIHdoZW4gcmVnaXN0ZXJpbmdcbiAgICAgICAgICAgICAgICAvLyBhbiBlbmRwb2ludCBmb3IgYW4gZWxlbWVudCB0aGF0IGhhZCBhIHBhcmVudCAoc29tZXdoZXJlIGluIHRoZSBoaWVyYXJjaHkpIHRoYXQgaGFkIGJlZW5cbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlcmVkIGFzIGRyYWdnYWJsZS5cbiAgICAgICAgICAgICAgICBvZmZzZXRUb1VJID0gb2Zmc2V0VG9VSSB8fCB7bGVmdDogMCwgdG9wOiAwfTtcbiAgICAgICAgICAgICAgICBpZiAodWkpIHtcbiAgICAgICAgICAgICAgICAgICAgdWkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB1aS5sZWZ0ICsgb2Zmc2V0VG9VSS5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB1aS50b3AgKyBvZmZzZXRUb1VJLnRvcFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHZhbGlkIGZvciBvbmUgcGFpbnQgY3ljbGUuXG4gICAgICAgICAgICAgICAgdmFyIG15T2Zmc2V0ID0ganNQbHVtYkluc3RhbmNlLnVwZGF0ZU9mZnNldCh7IGVsSWQ6IGVsZW1lbnRJZCwgb2Zmc2V0OiB1aSwgcmVjYWxjOiBmYWxzZSwgdGltZXN0YW1wOiB0aW1lc3RhbXAgfSksXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uQ2FjaGUgPSB7fTtcblxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbGx5LCBmaXJzdCB3ZSBzaG91bGQgY29tcHV0ZSB0aGUgb3JpZW50YXRpb24gb2YgdGhpcyBlbGVtZW50IHRvIGFsbCBvdGhlciBlbGVtZW50cyB0byB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZWxlbWVudCBpcyBjb25uZWN0ZWQgd2l0aCBhIGNvbnRpbnVvdXMgYW5jaG9yICh3aGV0aGVyIGJvdGggZW5kcyBvZiB0aGUgY29ubmVjdGlvbiBoYXZlXG4gICAgICAgICAgICAgICAgLy8gYSBjb250aW51b3VzIGFuY2hvciBvciBqdXN0IG9uZSlcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kcG9pbnRDb25uZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29ubiA9IGVuZHBvaW50Q29ubmVjdGlvbnNbaV1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZCA9IGNvbm4uc291cmNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZCA9IGNvbm4udGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb250aW51b3VzID0gY29ubi5lbmRwb2ludHNbMF0uYW5jaG9yLmlzQ29udGludW91cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENvbnRpbnVvdXMgPSBjb25uLmVuZHBvaW50c1sxXS5hbmNob3IuaXNDb250aW51b3VzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VDb250aW51b3VzIHx8IHRhcmdldENvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvS2V5ID0gc291cmNlSWQgKyBcIl9cIiArIHRhcmdldElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBvcmllbnRhdGlvbkNhY2hlW29LZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9JZHggPSBjb25uLnNvdXJjZUlkID09IGVsZW1lbnRJZCA/IDEgOiAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlQ29udGludW91cyAmJiAhYW5jaG9yTGlzdHNbc291cmNlSWRdKSBhbmNob3JMaXN0c1tzb3VyY2VJZF0gPSB7IHRvcDogW10sIHJpZ2h0OiBbXSwgYm90dG9tOiBbXSwgbGVmdDogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRDb250aW51b3VzICYmICFhbmNob3JMaXN0c1t0YXJnZXRJZF0pIGFuY2hvckxpc3RzW3RhcmdldElkXSA9IHsgdG9wOiBbXSwgcmlnaHQ6IFtdLCBib3R0b206IFtdLCBsZWZ0OiBbXSB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudElkICE9IHRhcmdldElkKSBqc1BsdW1iSW5zdGFuY2UudXBkYXRlT2Zmc2V0KHsgZWxJZDogdGFyZ2V0SWQsIHRpbWVzdGFtcDogdGltZXN0YW1wIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRJZCAhPSBzb3VyY2VJZCkganNQbHVtYkluc3RhbmNlLnVwZGF0ZU9mZnNldCh7IGVsSWQ6IHNvdXJjZUlkLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRkID0ganNQbHVtYkluc3RhbmNlLmdldENhY2hlZERhdGEodGFyZ2V0SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNkID0ganNQbHVtYkluc3RhbmNlLmdldENhY2hlZERhdGEoc291cmNlSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SWQgPT0gc291cmNlSWQgJiYgKHNvdXJjZUNvbnRpbnVvdXMgfHwgdGFyZ2V0Q29udGludW91cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIG1heSB3YW50IHRvIGltcHJvdmUgdGhpcyBieSBzb21laG93IGRldGVybWluaW5nIHRoZSBmYWNlIHdlJ2QgbGlrZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHB1dCB0aGUgY29ubmVjdG9yIG9uLiAgaWRlYWxseSwgd2hlbiBkcmF3aW5nLCB0aGUgZmFjZSBzaG91bGQgYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IGRldGVybWluaW5nIHdoaWNoIGZhY2UgaXMgY2xvc2VzdCB0byB0aGUgcG9pbnQgYXQgd2hpY2ggdGhlIG1vdXNlIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcyByZWxlYXNlZC4gIGZvciBub3csIHdlJ3JlIHB1dHRpbmcgaXQgb24gdGhlIHRvcCBmYWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVBbmNob3JMaXN0KCBhbmNob3JMaXN0c1tzb3VyY2VJZF0sIC1NYXRoLlBJIC8gMiwgMCwgY29ubiwgZmFsc2UsIHRhcmdldElkLCAwLCBmYWxzZSwgXCJ0b3BcIiwgc291cmNlSWQsIGNvbm5lY3Rpb25zVG9QYWludCwgZW5kcG9pbnRzVG9QYWludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZUFuY2hvckxpc3QoIGFuY2hvckxpc3RzW3RhcmdldElkXSwgLU1hdGguUEkgLyAyLCAwLCBjb25uLCBmYWxzZSwgc291cmNlSWQsIDEsIGZhbHNlLCBcInRvcFwiLCB0YXJnZXRJZCwgY29ubmVjdGlvbnNUb1BhaW50LCBlbmRwb2ludHNUb1BhaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gY2FsY3VsYXRlT3JpZW50YXRpb24oc291cmNlSWQsIHRhcmdldElkLCBzZC5vLCB0ZC5vLCBjb25uLmVuZHBvaW50c1swXS5hbmNob3IsIGNvbm4uZW5kcG9pbnRzWzFdLmFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uQ2FjaGVbb0tleV0gPSBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdvdWxkIGJlIGEgcGVyZm9ybWFuY2UgZW5oYW5jZW1lbnQsIGJ1dCB0aGUgY29tcHV0ZWQgYW5nbGVzIG5lZWQgdG8gYmUgY2xhbXBlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSAoLVBJLzIgLT4gUEkvMikgcmFuZ2UgaW4gb3JkZXIgZm9yIHRoZSBzb3J0aW5nIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBvcmllbnRhdGlvbkNhY2hlW29LZXkyXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOm8ub3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOltvLmFbMV0sIG8uYVswXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGV0YTpvLnRoZXRhICsgTWF0aC5QSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZXRhMjpvLnRoZXRhMiArIE1hdGguUElcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07Ki9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZUNvbnRpbnVvdXMpIF91cGRhdGVBbmNob3JMaXN0KGFuY2hvckxpc3RzW3NvdXJjZUlkXSwgby50aGV0YSwgMCwgY29ubiwgZmFsc2UsIHRhcmdldElkLCAwLCBmYWxzZSwgby5hWzBdLCBzb3VyY2VJZCwgY29ubmVjdGlvbnNUb1BhaW50LCBlbmRwb2ludHNUb1BhaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Q29udGludW91cykgX3VwZGF0ZUFuY2hvckxpc3QoYW5jaG9yTGlzdHNbdGFyZ2V0SWRdLCBvLnRoZXRhMiwgLTEsIGNvbm4sIHRydWUsIHNvdXJjZUlkLCAxLCB0cnVlLCBvLmFbMV0sIHRhcmdldElkLCBjb25uZWN0aW9uc1RvUGFpbnQsIGVuZHBvaW50c1RvUGFpbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlQ29udGludW91cykgX2p1LmFkZFdpdGhGdW5jdGlvbihhbmNob3JzVG9VcGRhdGUsIHNvdXJjZUlkLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBzb3VyY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldENvbnRpbnVvdXMpIF9qdS5hZGRXaXRoRnVuY3Rpb24oYW5jaG9yc1RvVXBkYXRlLCB0YXJnZXRJZCwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gdGFyZ2V0SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qdS5hZGRXaXRoRnVuY3Rpb24oY29ubmVjdGlvbnNUb1BhaW50LCBjb25uLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLmlkID09IGNvbm4uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc291cmNlQ29udGludW91cyAmJiBvSWR4ID09PSAwKSB8fCAodGFyZ2V0Q29udGludW91cyAmJiBvSWR4ID09PSAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanUuYWRkV2l0aEZ1bmN0aW9uKGVuZHBvaW50c1RvUGFpbnQsIGNvbm4uZW5kcG9pbnRzW29JZHhdLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5pZCA9PSBjb25uLmVuZHBvaW50c1tvSWR4XS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBsYWNlIEVuZHBvaW50cyB3aG9zZSBhbmNob3JzIGFyZSBjb250aW51b3VzIGJ1dCBoYXZlIG5vIENvbm5lY3Rpb25zXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcFtpXS5jb25uZWN0aW9ucy5sZW5ndGggPT09IDAgJiYgZXBbaV0uYW5jaG9yLmlzQ29udGludW91cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmNob3JMaXN0c1tlbGVtZW50SWRdKSBhbmNob3JMaXN0c1tlbGVtZW50SWRdID0geyB0b3A6IFtdLCByaWdodDogW10sIGJvdHRvbTogW10sIGxlZnQ6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlQW5jaG9yTGlzdChhbmNob3JMaXN0c1tlbGVtZW50SWRdLCAtTWF0aC5QSSAvIDIsIDAsIHtlbmRwb2ludHM6IFtlcFtpXSwgZXBbaV1dLCBwYWludDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgfX0sIGZhbHNlLCBlbGVtZW50SWQsIDAsIGZhbHNlLCBlcFtpXS5hbmNob3IuZ2V0RGVmYXVsdEZhY2UoKSwgZWxlbWVudElkLCBjb25uZWN0aW9uc1RvUGFpbnQsIGVuZHBvaW50c1RvUGFpbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmFkZFdpdGhGdW5jdGlvbihhbmNob3JzVG9VcGRhdGUsIGVsZW1lbnRJZCwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gZWxlbWVudElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIC8vIG5vdyBwbGFjZSBhbGwgdGhlIGNvbnRpbnVvdXMgYW5jaG9ycyB3ZSBuZWVkIHRvO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbmNob3JzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VBbmNob3JzKGFuY2hvcnNUb1VwZGF0ZVtpXSwgYW5jaG9yTGlzdHNbYW5jaG9yc1RvVXBkYXRlW2ldXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm93IHRoYXQgY29udGludW91cyBhbmNob3JzIGhhdmUgYmVlbiBwbGFjZWQsIHBhaW50IGFsbCB0aGUgZW5kcG9pbnRzIGZvciB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHBlcmZvcm1hbmNlOiBhZGQgdGhlIGVuZHBvaW50IGlkcyB0byBhIHRlbXAgYXJyYXksIGFuZCB0aGVuIHdoZW4gaXRlcmF0aW5nIGluIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgLy8gbG9vcCwgY2hlY2sgdGhhdCB3ZSBkaWRuJ3QganVzdCBwYWludCB0aGF0IGVuZHBvaW50LiB3ZSBjYW4gcHJvYmFibHkgc2hhdmUgb2ZmIGEgZmV3IG1vcmUgbWlsbGlzZWNvbmRzIHRoaXMgd2F5LlxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlcFtpXS5wYWludCh7IHRpbWVzdGFtcDogdGltZXN0YW1wLCBvZmZzZXQ6IG15T2Zmc2V0LCBkaW1lbnNpb25zOiBteU9mZnNldC5zLCByZWNhbGM6IGRvTm90UmVjYWxjRW5kcG9pbnQgIT09IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gLi4uIGFuZCBhbnkgb3RoZXIgZW5kcG9pbnRzIHdlIGNhbWUgYWNyb3NzIGFzIGEgcmVzdWx0IG9mIHRoZSBjb250aW51b3VzIGFuY2hvcnMuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZHBvaW50c1RvUGFpbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNkID0ganNQbHVtYkluc3RhbmNlLmdldENhY2hlZERhdGEoZW5kcG9pbnRzVG9QYWludFtpXS5lbGVtZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludHNUb1BhaW50W2ldLnBhaW50KHsgdGltZXN0YW1wOiB0aW1lc3RhbXAsIG9mZnNldDogY2QsIGRpbWVuc2lvbnM6IGNkLnMgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcGFpbnQgYWxsIHRoZSBzdGFuZGFyZCBhbmQgXCJkeW5hbWljIGNvbm5lY3Rpb25zXCIsIHdoaWNoIGFyZSBjb25uZWN0aW9ucyB3aG9zZSBvdGhlciBhbmNob3IgaXNcbiAgICAgICAgICAgICAgICAvLyBzdGF0aWMgYW5kIHRoZXJlZm9yZSBkb2VzIG5lZWQgdG8gYmUgcmVjb21wdXRlZDsgd2UgbWFrZSBzdXJlIHRoYXQgaGFwcGVucyBvbmx5IG9uZSB0aW1lLlxuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyB3ZSBjb3VsZCBoYXZlIGNvbXBpbGVkIGEgbGlzdCBvZiB0aGVzZSBpbiB0aGUgZmlyc3QgcGFzcyB0aHJvdWdoIGNvbm5lY3Rpb25zOyBtaWdodCBzYXZlIHNvbWUgdGltZS5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5kcG9pbnRDb25uZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJFbmRwb2ludCA9IGVuZHBvaW50Q29ubmVjdGlvbnNbaV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckVuZHBvaW50LmFuY2hvci5jb25zdHJ1Y3RvciA9PSBfanAuRHluYW1pY0FuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJFbmRwb2ludC5wYWludCh7IGVsZW1lbnRXaXRoUHJlY2VkZW5jZTogZWxlbWVudElkLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qdS5hZGRXaXRoRnVuY3Rpb24oY29ubmVjdGlvbnNUb1BhaW50LCBlbmRwb2ludENvbm5lY3Rpb25zW2ldWzBdLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLmlkID09IGVuZHBvaW50Q29ubmVjdGlvbnNbaV1bMF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCB0aGUgY29ubmVjdGlvbnMgZm9yIHRoZSBvdGhlciBlbmRwb2ludCBub3cgbmVlZCB0byBiZSByZXBhaW50ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3RoZXJFbmRwb2ludC5jb25uZWN0aW9ucy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckVuZHBvaW50LmNvbm5lY3Rpb25zW2tdICE9PSBlbmRwb2ludENvbm5lY3Rpb25zW2ldWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanUuYWRkV2l0aEZ1bmN0aW9uKGNvbm5lY3Rpb25zVG9QYWludCwgb3RoZXJFbmRwb2ludC5jb25uZWN0aW9uc1trXSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLmlkID09IG90aGVyRW5kcG9pbnQuY29ubmVjdGlvbnNba10uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG90aGVyRW5kcG9pbnQuYW5jaG9yLmNvbnN0cnVjdG9yID09IF9qcC5BbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qdS5hZGRXaXRoRnVuY3Rpb24oY29ubmVjdGlvbnNUb1BhaW50LCBlbmRwb2ludENvbm5lY3Rpb25zW2ldWzBdLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLmlkID09IGVuZHBvaW50Q29ubmVjdGlvbnNbaV1bMF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBhaW50IGN1cnJlbnQgZmxvYXRpbmcgY29ubmVjdGlvbiBmb3IgdGhpcyBlbGVtZW50LCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICAgICAgICAgICAgdmFyIGZjID0gZmxvYXRpbmdDb25uZWN0aW9uc1tlbGVtZW50SWRdO1xuICAgICAgICAgICAgICAgIGlmIChmYylcbiAgICAgICAgICAgICAgICAgICAgZmMucGFpbnQoe3RpbWVzdGFtcDogdGltZXN0YW1wLCByZWNhbGM6IGZhbHNlLCBlbElkOiBlbGVtZW50SWR9KTtcblxuICAgICAgICAgICAgICAgIC8vIHBhaW50IGFsbCB0aGUgY29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29ubmVjdGlvbnNUb1BhaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zVG9QYWludFtpXS5wYWludCh7ZWxJZDogZWxlbWVudElkLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCwgcmVjYWxjOiBmYWxzZSwgY2xlYXJFZGl0czogY2xlYXJFZGl0c30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgQ29udGludW91c0FuY2hvciA9IGZ1bmN0aW9uIChhbmNob3JQYXJhbXMpIHtcbiAgICAgICAgICAgIF9qdS5FdmVudEdlbmVyYXRvci5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiQ29udGludW91c1wiO1xuICAgICAgICAgICAgdGhpcy5pc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pc0NvbnRpbnVvdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGZhY2VzID0gYW5jaG9yUGFyYW1zLmZhY2VzIHx8IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXSxcbiAgICAgICAgICAgICAgICBjbG9ja3dpc2UgPSAhKGFuY2hvclBhcmFtcy5jbG9ja3dpc2UgPT09IGZhbHNlKSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVGYWNlcyA9IHsgfSxcbiAgICAgICAgICAgICAgICBvcHBvc2l0ZXMgPSB7IFwidG9wXCI6IFwiYm90dG9tXCIsIFwicmlnaHRcIjogXCJsZWZ0XCIsIFwibGVmdFwiOiBcInJpZ2h0XCIsIFwiYm90dG9tXCI6IFwidG9wXCIgfSxcbiAgICAgICAgICAgICAgICBjbG9ja3dpc2VPcHRpb25zID0geyBcInRvcFwiOiBcInJpZ2h0XCIsIFwicmlnaHRcIjogXCJib3R0b21cIiwgXCJsZWZ0XCI6IFwidG9wXCIsIFwiYm90dG9tXCI6IFwibGVmdFwiIH0sXG4gICAgICAgICAgICAgICAgYW50aUNsb2Nrd2lzZU9wdGlvbnMgPSB7IFwidG9wXCI6IFwibGVmdFwiLCBcInJpZ2h0XCI6IFwidG9wXCIsIFwibGVmdFwiOiBcImJvdHRvbVwiLCBcImJvdHRvbVwiOiBcInJpZ2h0XCIgfSxcbiAgICAgICAgICAgICAgICBzZWNvbmRCZXN0ID0gY2xvY2t3aXNlID8gY2xvY2t3aXNlT3B0aW9ucyA6IGFudGlDbG9ja3dpc2VPcHRpb25zLFxuICAgICAgICAgICAgICAgIGxhc3RDaG9pY2UgPSBjbG9ja3dpc2UgPyBhbnRpQ2xvY2t3aXNlT3B0aW9ucyA6IGNsb2Nrd2lzZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3MgPSBhbmNob3JQYXJhbXMuY3NzQ2xhc3MgfHwgXCJcIjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUZhY2VzW2ZhY2VzW2ldXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0RGVmYXVsdEZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY2VzLmxlbmd0aCA9PT0gMCA/IFwidG9wXCIgOiBmYWNlc1swXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBnaXZlbiBlZGdlIGlzIHN1cHBvcnRlZCwgcmV0dXJucyBpdC4gb3RoZXJ3aXNlIGxvb2tzIGZvciBhIHN1YnN0aXR1dGUgdGhhdCBfaXNfXG4gICAgICAgICAgICAvLyBzdXBwb3J0ZWQuIGlmIG5vbmUgc3VwcG9ydGVkIHdlIGFsc28gcmV0dXJuIHRoZSByZXF1ZXN0IGVkZ2UuXG4gICAgICAgICAgICB0aGlzLnZlcmlmeUVkZ2UgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGVGYWNlc1tlZGdlXSkgcmV0dXJuIGVkZ2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXZhaWxhYmxlRmFjZXNbb3Bwb3NpdGVzW2VkZ2VdXSkgcmV0dXJuIG9wcG9zaXRlc1tlZGdlXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdmFpbGFibGVGYWNlc1tzZWNvbmRCZXN0W2VkZ2VdXSkgcmV0dXJuIHNlY29uZEJlc3RbZWRnZV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXZhaWxhYmxlRmFjZXNbbGFzdENob2ljZVtlZGdlXV0pIHJldHVybiBsYXN0Q2hvaWNlW2VkZ2VdO1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlOyAvLyB3ZSBoYXZlIHRvIGdpdmUgdGhlbSBzb21ldGhpbmcuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmlzRWRnZVN1cHBvcnRlZCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZUZhY2VzW2VkZ2VdID09PSB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5jb21wdXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VyRGVmaW5lZENvbnRpbnVvdXNBbmNob3JMb2NhdGlvbnNbcGFyYW1zLmVsZW1lbnQuaWRdIHx8IGNvbnRpbnVvdXNBbmNob3JMb2NhdGlvbnNbcGFyYW1zLmVsZW1lbnQuaWRdIHx8IFswLCAwXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlckRlZmluZWRDb250aW51b3VzQW5jaG9yTG9jYXRpb25zW3BhcmFtcy5lbGVtZW50LmlkXSB8fCBjb250aW51b3VzQW5jaG9yTG9jYXRpb25zW3BhcmFtcy5lbGVtZW50LmlkXSB8fCBbMCwgMF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250aW51b3VzQW5jaG9yT3JpZW50YXRpb25zW2VuZHBvaW50LmlkXSB8fCBbMCwgMF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jbGVhclVzZXJEZWZpbmVkTG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHVzZXJEZWZpbmVkQ29udGludW91c0FuY2hvckxvY2F0aW9uc1thbmNob3JQYXJhbXMuZWxlbWVudElkXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNldFVzZXJEZWZpbmVkTG9jYXRpb24gPSBmdW5jdGlvbiAobG9jKSB7XG4gICAgICAgICAgICAgICAgdXNlckRlZmluZWRDb250aW51b3VzQW5jaG9yTG9jYXRpb25zW2FuY2hvclBhcmFtcy5lbGVtZW50SWRdID0gbG9jO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3NzQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNzc0NsYXNzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBjb250aW51b3VzIGFuY2hvcnNcbiAgICAgICAganNQbHVtYkluc3RhbmNlLmNvbnRpbnVvdXNBbmNob3JGYWN0b3J5ID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250aW51b3VzQW5jaG9yKHBhcmFtcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdXNlckRlZmluZWRDb250aW51b3VzQW5jaG9yTG9jYXRpb25zW2VsZW1lbnRJZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbnRpbnVvdXNBbmNob3JMb2NhdGlvbnNbZWxlbWVudElkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9ycyBtb2RlbCBhIHBvc2l0aW9uIG9uIHNvbWUgZWxlbWVudCBhdCB3aGljaCBhbiBFbmRwb2ludCBtYXkgYmUgbG9jYXRlZC4gIFRoZXkgYmVnYW4gYXMgYSBmaXJzdCBjbGFzcyBjaXRpemVuIG9mIGpzUGx1bWIsIGllLiBhIHVzZXJcbiAgICAgKiB3YXMgcmVxdWlyZWQgdG8gY3JlYXRlIHRoZXNlIHRoZW1zZWx2ZXMsIGJ1dCBvdmVyIHRpbWUgdGhpcyBoYXMgYmVlbiByZXBsYWNlZCBieSB0aGUgY29uY2VwdCBvZiByZWZlcnJpbmcgdG8gdGhlbSBlaXRoZXIgYnkgbmFtZSAoZWcuIFwiVG9wTWlkZGxlXCIpLFxuICAgICAqIG9yIGJ5IGFuIGFycmF5IGRlc2NyaWJpbmcgdGhlaXIgY29vcmRpbmF0ZXMgKGVnLiBbIDAsIDAuNSwgMCwgLTEgXSwgd2hpY2ggaXMgdGhlIHNhbWUgYXMgXCJUb3BNaWRkbGVcIikuICBqc1BsdW1iIG5vdyBoYW5kbGVzIGFsbCBvZiB0aGVcbiAgICAgKiBjcmVhdGlvbiBvZiBBbmNob3JzIHdpdGhvdXQgdXNlciBpbnRlcnZlbnRpb24uXG4gICAgICovXG4gICAgX2pwLkFuY2hvciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy54ID0gcGFyYW1zLnggfHwgMDtcbiAgICAgICAgdGhpcy55ID0gcGFyYW1zLnkgfHwgMDtcbiAgICAgICAgdGhpcy5lbGVtZW50SWQgPSBwYXJhbXMuZWxlbWVudElkO1xuICAgICAgICB0aGlzLmNzc0NsYXNzID0gcGFyYW1zLmNzc0NsYXNzIHx8IFwiXCI7XG4gICAgICAgIHRoaXMudXNlckRlZmluZWRMb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSBwYXJhbXMub3JpZW50YXRpb24gfHwgWyAwLCAwIF07XG4gICAgICAgIHRoaXMubGFzdFJldHVyblZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gcGFyYW1zLm9mZnNldHMgfHwgWyAwLCAwIF07XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gbnVsbDtcblxuICAgICAgICBfanUuRXZlbnRHZW5lcmF0b3IuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jb21wdXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuXG4gICAgICAgICAgICB2YXIgeHkgPSBwYXJhbXMueHksIHdoID0gcGFyYW1zLndoLCB0aW1lc3RhbXAgPSBwYXJhbXMudGltZXN0YW1wO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmNsZWFyVXNlckRlZmluZWRMb2NhdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJEZWZpbmVkTG9jYXRpb24gPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGltZXN0YW1wICYmIHRpbWVzdGFtcCA9PT0gc2VsZi50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFJldHVyblZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy51c2VyRGVmaW5lZExvY2F0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZXR1cm5WYWx1ZSA9IHRoaXMudXNlckRlZmluZWRMb2NhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJldHVyblZhbHVlID0gWyB4eVswXSArICh0aGlzLnggKiB3aFswXSkgKyB0aGlzLm9mZnNldHNbMF0sIHh5WzFdICsgKHRoaXMueSAqIHdoWzFdKSArIHRoaXMub2Zmc2V0c1sxXSBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXR1cm5WYWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5sYXN0UmV0dXJuVmFsdWUgPT0gbnVsbCB8fCAocGFyYW1zLnRpbWVzdGFtcCAhPSBudWxsICYmIHRoaXMudGltZXN0YW1wICE9IHBhcmFtcy50aW1lc3RhbXApKSA/IHRoaXMuY29tcHV0ZShwYXJhbXMpIDogdGhpcy5sYXN0UmV0dXJuVmFsdWU7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfanUuZXh0ZW5kKF9qcC5BbmNob3IsIF9qdS5FdmVudEdlbmVyYXRvciwge1xuICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICAgICAgICAgIGlmICghYW5jaG9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYW8gPSBhbmNob3IuZ2V0T3JpZW50YXRpb24oKSxcbiAgICAgICAgICAgICAgICBvID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCA9PSBhbmNob3IueCAmJiB0aGlzLnkgPT0gYW5jaG9yLnkgJiYgdGhpcy5vZmZzZXRzWzBdID09IGFuY2hvci5vZmZzZXRzWzBdICYmIHRoaXMub2Zmc2V0c1sxXSA9PSBhbmNob3Iub2Zmc2V0c1sxXSAmJiBvWzBdID09IGFvWzBdICYmIG9bMV0gPT0gYW9bMV07XG4gICAgICAgIH0sXG4gICAgICAgIGdldFVzZXJEZWZpbmVkTG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJEZWZpbmVkTG9jYXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldFVzZXJEZWZpbmVkTG9jYXRpb246IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJEZWZpbmVkTG9jYXRpb24gPSBsO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhclVzZXJEZWZpbmVkTG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckRlZmluZWRMb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE9yaWVudGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q3NzQ2xhc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNzc0NsYXNzO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBBbmNob3IgdGhhdCBmbG9hdHMuIGl0cyBvcmllbnRhdGlvbiBpcyBjb21wdXRlZCBkeW5hbWljYWxseSBmcm9tXG4gICAgICogaXRzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBhbmNob3IgaXQgaXMgZmxvYXRpbmcgcmVsYXRpdmUgdG8uICBJdCBpcyB1c2VkIHdoZW4gY3JlYXRpbmdcbiAgICAgKiBhIGNvbm5lY3Rpb24gdGhyb3VnaCBkcmFnIGFuZCBkcm9wLlxuICAgICAqXG4gICAgICogVE9ETyBGbG9hdGluZ0FuY2hvciBjb3VsZCB0b3RhbGx5IGJlIHJlZmFjdG9yZWQgdG8gZXh0ZW5kIEFuY2hvciBqdXN0IHNsaWdodGx5LlxuICAgICAqL1xuICAgIF9qcC5GbG9hdGluZ0FuY2hvciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcblxuICAgICAgICBfanAuQW5jaG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgYW5jaG9yIHRoYXQgdGhpcyBmbG9hdGluZyBhbmNob3IgaXMgcmVmZXJlbmNlZCB0byBmb3JcbiAgICAgICAgLy8gcHVycG9zZXMgb2YgY2FsY3VsYXRpbmcgdGhlIG9yaWVudGF0aW9uLlxuICAgICAgICB2YXIgcmVmID0gcGFyYW1zLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIC8vIHRoZSBjYW52YXMgdGhpcyByZWZlcnMgdG8uXG4gICAgICAgICAgICByZWZDYW52YXMgPSBwYXJhbXMucmVmZXJlbmNlQ2FudmFzLFxuICAgICAgICAgICAgc2l6ZSA9IF9qcC5nZXRTaXplKHJlZkNhbnZhcyksXG4gICAgICAgICAgICAvLyB0aGVzZSBhcmUgdXNlZCB0byBzdG9yZSB0aGUgY3VycmVudCByZWxhdGl2ZSBwb3NpdGlvbiBvZiBvdXJcbiAgICAgICAgICAgIC8vIGFuY2hvciB3cnQgdGhlIHJlZmVyZW5jZSBhbmNob3IuIHRoZXkgb25seSBpbmRpY2F0ZVxuICAgICAgICAgICAgLy8gZGlyZWN0aW9uLCBzbyBoYXZlIGEgdmFsdWUgb2YgMSBvciAtMSAob3IsIHZlcnkgcmFyZWx5LCAwKS4gdGhlc2VcbiAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgd3JpdHRlbiBieSB0aGUgY29tcHV0ZSBtZXRob2QsIGFuZCByZWFkXG4gICAgICAgICAgICAvLyBieSB0aGUgZ2V0T3JpZW50YXRpb24gbWV0aG9kLlxuICAgICAgICAgICAgeERpciA9IDAsIHlEaXIgPSAwLFxuICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IG1lbWJlciB1c2VkIHRvIHN0b3JlIGFuIG9yaWVudGF0aW9uIHdoZW4gdGhlIGZsb2F0aW5nXG4gICAgICAgICAgICAvLyBhbmNob3IgaXMgaG92ZXJpbmcgb3ZlciBhbm90aGVyIGFuY2hvci5cbiAgICAgICAgICAgIG9yaWVudGF0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIF9sYXN0UmVzdWx0ID0gbnVsbDtcblxuICAgICAgICAvLyBjbGVhciBmcm9tIHBhcmVudC4gd2Ugd2FudCBmbG9hdGluZyBhbmNob3Igb3JpZW50YXRpb24gdG8gYWx3YXlzIGJlIGNvbXB1dGVkLlxuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gbnVsbDtcblxuICAgICAgICAvLyBzZXQgdGhlc2UgdG8gMCBlYWNoOyB0aGV5IGFyZSB1c2VkIGJ5IGNlcnRhaW4gdHlwZXMgb2YgY29ubmVjdG9ycyBpbiB0aGUgbG9vcGJhY2sgY2FzZSxcbiAgICAgICAgLy8gd2hlbiB0aGUgY29ubmVjdG9yIGlzIHRyeWluZyB0byBjbGVhciB0aGUgZWxlbWVudCBpdCBpcyBvbi4gYnV0IGZvciBmbG9hdGluZyBhbmNob3IgaXQncyBub3RcbiAgICAgICAgLy8gdmVyeSBpbXBvcnRhbnQuXG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG5cbiAgICAgICAgdGhpcy5pc0Zsb2F0aW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmNvbXB1dGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgeHkgPSBwYXJhbXMueHksXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWyB4eVswXSArIChzaXplWzBdIC8gMiksIHh5WzFdICsgKHNpemVbMV0gLyAyKSBdOyAvLyByZXR1cm4gb3JpZ2luIG9mIHRoZSBlbGVtZW50LiB3ZSBtYXkgd2lzaCB0byBpbXByb3ZlIHRoaXMgc28gdGhhdCBhbnkgb2JqZWN0IGNhbiBiZSB0aGUgZHJhZyBwcm94eS5cbiAgICAgICAgICAgIF9sYXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKF9lbmRwb2ludCkge1xuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uKSByZXR1cm4gb3JpZW50YXRpb247XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHJlZi5nZXRPcmllbnRhdGlvbihfZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGhlcmUgd2UgdGFrZSBpbnRvIGFjY291bnQgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBvdGhlclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvcjogaWYgaXQgZGVjbGFyZXMgemVybyBmb3Igc29tZSBkaXJlY3Rpb24sIHdlIGRlY2xhcmUgemVybyB0b28uIHRoaXMgbWlnaHQgbm90IGJlIHRoZSBtb3N0IGF3ZXNvbWUuIHBlcmhhcHMgd2UgY2FuIGNvbWVcbiAgICAgICAgICAgICAgICAvLyB1cCB3aXRoIGEgYmV0dGVyIHdheS4gaXQncyBqdXN0IHNvIHRoYXQgdGhlIGxpbmUgd2UgZHJhdyBsb29rcyBsaWtlIGl0IG1ha2VzIHNlbnNlLiBtYXliZSB0aGlzIHdvbnQgbWFrZSBzZW5zZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gWyBNYXRoLmFicyhvWzBdKSAqIHhEaXIgKiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKG9bMV0pICogeURpciAqIC0xIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5vdGlmaWNhdGlvbiB0aGUgZW5kcG9pbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYW5jaG9yIGlzIGhvdmVyaW5nXG4gICAgICAgICAqIG92ZXIgYW5vdGhlciBhbmNob3I7IHdlIHdhbnQgdG8gYXNzdW1lIHRoYXQgYW5jaG9yJ3Mgb3JpZW50YXRpb25cbiAgICAgICAgICogZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgaG92ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm92ZXIgPSBmdW5jdGlvbiAoYW5jaG9yLCBlbmRwb2ludCkge1xuICAgICAgICAgICAgb3JpZW50YXRpb24gPSBhbmNob3IuZ2V0T3JpZW50YXRpb24oZW5kcG9pbnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBub3RpZmljYXRpb24gdGhlIGVuZHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFuY2hvciBpcyBub1xuICAgICAgICAgKiBsb25nZXIgaG92ZXJpbmcgb3ZlciBhbm90aGVyIGFuY2hvcjsgd2Ugc2hvdWxkIHJlc3VtZSBjYWxjdWxhdGluZ1xuICAgICAgICAgKiBvcmllbnRhdGlvbiBhcyB3ZSBub3JtYWxseSBkby5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3JpZW50YXRpb24gPSBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIF9sYXN0UmVzdWx0ID09IG51bGwgPyB0aGlzLmNvbXB1dGUocGFyYW1zKSA6IF9sYXN0UmVzdWx0O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuRmxvYXRpbmdBbmNob3IsIF9qcC5BbmNob3IpO1xuXG4gICAgdmFyIF9jb252ZXJ0QW5jaG9yID0gZnVuY3Rpb24gKGFuY2hvciwganNQbHVtYkluc3RhbmNlLCBlbGVtZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIGFuY2hvci5jb25zdHJ1Y3RvciA9PSBfanAuQW5jaG9yID8gYW5jaG9yIDoganNQbHVtYkluc3RhbmNlLm1ha2VBbmNob3IoYW5jaG9yLCBlbGVtZW50SWQsIGpzUGx1bWJJbnN0YW5jZSk7XG4gICAgfTtcblxuICAgIC8qIFxuICAgICAqIEEgRHluYW1pY0FuY2hvciBpcyBhbiBBbmNob3IgdGhhdCBjb250YWlucyBhIGxpc3Qgb2Ygb3RoZXIgQW5jaG9ycywgd2hpY2ggaXQgY3ljbGVzXG4gICAgICogdGhyb3VnaCBhdCBjb21wdXRlIHRpbWUgdG8gZmluZCB0aGUgb25lIHRoYXQgaXMgbG9jYXRlZCBjbG9zZXN0IHRvXG4gICAgICogdGhlIGNlbnRlciBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQsIGFuZCByZXR1cm5zIHRoYXQgQW5jaG9yJ3MgY29tcHV0ZVxuICAgICAqIG1ldGhvZCByZXN1bHQuIHRoaXMgY2F1c2VzIGVuZHBvaW50cyB0byBmb2xsb3cgZWFjaCBvdGhlciB3aXRoXG4gICAgICogcmVzcGVjdCB0byB0aGUgb3JpZW50YXRpb24gb2YgdGhlaXIgdGFyZ2V0IGVsZW1lbnRzLCB3aGljaCBpcyBhIHVzZWZ1bFxuICAgICAqIGZlYXR1cmUgZm9yIHNvbWUgYXBwbGljYXRpb25zLlxuICAgICAqIFxuICAgICAqL1xuICAgIF9qcC5EeW5hbWljQW5jaG9yID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBfanAuQW5jaG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdGhpcy5pc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICB0aGlzLmFuY2hvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5lbGVtZW50SWQgPSBwYXJhbXMuZWxlbWVudElkO1xuICAgICAgICB0aGlzLmpzUGx1bWJJbnN0YW5jZSA9IHBhcmFtcy5qc1BsdW1iSW5zdGFuY2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMuYW5jaG9ycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yc1tpXSA9IF9jb252ZXJ0QW5jaG9yKHBhcmFtcy5hbmNob3JzW2ldLCB0aGlzLmpzUGx1bWJJbnN0YW5jZSwgdGhpcy5lbGVtZW50SWQpO1xuXG4gICAgICAgIHRoaXMuZ2V0QW5jaG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuY2hvcnM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHZhciBfY3VyQW5jaG9yID0gdGhpcy5hbmNob3JzLmxlbmd0aCA+IDAgPyB0aGlzLmFuY2hvcnNbMF0gOiBudWxsLFxuICAgICAgICAgICAgX2xhc3RBbmNob3IgPSBfY3VyQW5jaG9yLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG5cbiAgICAgICAgLy8gaGVscGVyIG1ldGhvZCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNlbnRlcnMgb2YgdGhlIHR3byBlbGVtZW50cy5cbiAgICAgICAgICAgIF9kaXN0YW5jZSA9IGZ1bmN0aW9uIChhbmNob3IsIGN4LCBjeSwgeHksIHdoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4ID0geHlbMF0gKyAoYW5jaG9yLnggKiB3aFswXSksIGF5ID0geHlbMV0gKyAoYW5jaG9yLnkgKiB3aFsxXSksXG4gICAgICAgICAgICAgICAgICAgIGFjeCA9IHh5WzBdICsgKHdoWzBdIC8gMiksIGFjeSA9IHh5WzFdICsgKHdoWzFdIC8gMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChNYXRoLnNxcnQoTWF0aC5wb3coY3ggLSBheCwgMikgKyBNYXRoLnBvdyhjeSAtIGF5LCAyKSkgK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnNxcnQoTWF0aC5wb3coYWN4IC0gYXgsIDIpICsgTWF0aC5wb3coYWN5IC0gYXksIDIpKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAvLyBkZWZhdWx0IG1ldGhvZCB1c2VzIGRpc3RhbmNlIGJldHdlZW4gZWxlbWVudCBjZW50ZXJzLiAgeW91IGNhbiBwcm92aWRlIHlvdXIgb3duIG1ldGhvZCBpbiB0aGUgZHluYW1pYyBhbmNob3JcbiAgICAgICAgLy8gY29uc3RydWN0b3IgKGFuZCBhbHNvIHRvIGpzUGx1bWIubWFrZUR5bmFtaWNBbmNob3IpLiB0aGUgYXJndW1lbnRzIHRvIGl0IGFyZSBmb3VyIGFycmF5czpcbiAgICAgICAgLy8geHkgLSB4eSBsb2Mgb2YgdGhlIGFuY2hvcidzIGVsZW1lbnRcbiAgICAgICAgLy8gd2ggLSBhbmNob3IncyBlbGVtZW50J3MgZGltZW5zaW9uc1xuICAgICAgICAvLyB0eHkgLSB4eSBsb2Mgb2YgdGhlIGVsZW1lbnQgb2YgdGhlIG90aGVyIGFuY2hvciBpbiB0aGUgY29ubmVjdGlvblxuICAgICAgICAvLyB0d2ggLSBkaW1lbnNpb25zIG9mIHRoZSBlbGVtZW50IG9mIHRoZSBvdGhlciBhbmNob3IgaW4gdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIC8vIGFuY2hvcnMgLSB0aGUgbGlzdCBvZiBzZWxlY3RhYmxlIGFuY2hvcnNcbiAgICAgICAgICAgIF9hbmNob3JTZWxlY3RvciA9IHBhcmFtcy5zZWxlY3RvciB8fCBmdW5jdGlvbiAoeHksIHdoLCB0eHksIHR3aCwgYW5jaG9ycykge1xuICAgICAgICAgICAgICAgIHZhciBjeCA9IHR4eVswXSArICh0d2hbMF0gLyAyKSwgY3kgPSB0eHlbMV0gKyAodHdoWzFdIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIG1pbklkeCA9IC0xLCBtaW5EaXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNob3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gX2Rpc3RhbmNlKGFuY2hvcnNbaV0sIGN4LCBjeSwgeHksIHdoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5JZHggPSBpICsgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhbmNob3JzW21pbklkeF07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY29tcHV0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciB4eSA9IHBhcmFtcy54eSwgd2ggPSBwYXJhbXMud2gsIHR4eSA9IHBhcmFtcy50eHksIHR3aCA9IHBhcmFtcy50d2g7XG5cbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gcGFyYW1zLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgdmFyIHVkbCA9IHNlbGYuZ2V0VXNlckRlZmluZWRMb2NhdGlvbigpO1xuICAgICAgICAgICAgaWYgKHVkbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVkbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYW5jaG9yIGlzIGxvY2tlZCBvciBhbiBvcHBvc2l0ZSBlbGVtZW50IHdhcyBub3QgZ2l2ZW4sIHdlXG4gICAgICAgICAgICAvLyBtYWludGFpbiBvdXIgc3RhdGUuIGFuY2hvciB3aWxsIGJlIGxvY2tlZFxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgdGhlIHNvdXJjZSBvZiBhIGRyYWcgYW5kIGRyb3AuXG4gICAgICAgICAgICBpZiAodGhpcy5sb2NrZWQgfHwgdHh5ID09IG51bGwgfHwgdHdoID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jdXJBbmNob3IuY29tcHV0ZShwYXJhbXMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcmFtcy50aW1lc3RhbXAgPSBudWxsOyAvLyBvdGhlcndpc2UgY2xlYXIgdGhpcywgaSB0aGluay4gd2Ugd2FudCB0aGUgYW5jaG9yIHRvIGNvbXB1dGUuXG5cbiAgICAgICAgICAgIF9jdXJBbmNob3IgPSBfYW5jaG9yU2VsZWN0b3IoeHksIHdoLCB0eHksIHR3aCwgdGhpcy5hbmNob3JzKTtcbiAgICAgICAgICAgIHRoaXMueCA9IF9jdXJBbmNob3IueDtcbiAgICAgICAgICAgIHRoaXMueSA9IF9jdXJBbmNob3IueTtcblxuICAgICAgICAgICAgaWYgKF9jdXJBbmNob3IgIT0gX2xhc3RBbmNob3IpXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKFwiYW5jaG9yQ2hhbmdlZFwiLCBfY3VyQW5jaG9yKTtcblxuICAgICAgICAgICAgX2xhc3RBbmNob3IgPSBfY3VyQW5jaG9yO1xuXG4gICAgICAgICAgICByZXR1cm4gX2N1ckFuY2hvci5jb21wdXRlKHBhcmFtcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVc2VyRGVmaW5lZExvY2F0aW9uKCkgfHwgKF9jdXJBbmNob3IgIT0gbnVsbCA/IF9jdXJBbmNob3IuZ2V0Q3VycmVudExvY2F0aW9uKHBhcmFtcykgOiBudWxsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKF9lbmRwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJBbmNob3IgIT0gbnVsbCA/IF9jdXJBbmNob3IuZ2V0T3JpZW50YXRpb24oX2VuZHBvaW50KSA6IFsgMCwgMCBdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm92ZXIgPSBmdW5jdGlvbiAoYW5jaG9yLCBlbmRwb2ludCkge1xuICAgICAgICAgICAgaWYgKF9jdXJBbmNob3IgIT0gbnVsbCkgX2N1ckFuY2hvci5vdmVyKGFuY2hvciwgZW5kcG9pbnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfY3VyQW5jaG9yICE9IG51bGwpIF9jdXJBbmNob3Iub3V0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRDc3NDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2N1ckFuY2hvciAmJiBfY3VyQW5jaG9yLmdldENzc0NsYXNzKCkpIHx8IFwiXCI7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfanUuZXh0ZW5kKF9qcC5EeW5hbWljQW5jaG9yLCBfanAuQW5jaG9yKTtcblxuLy8gLS0tLS0tLS0gYmFzaWMgYW5jaG9ycyAtLS0tLS0tLS0tLS0tLS0tLS0gICAgXG4gICAgdmFyIF9jdXJyeUFuY2hvciA9IGZ1bmN0aW9uICh4LCB5LCBveCwgb3ksIHR5cGUsIGZuSW5pdCkge1xuICAgICAgICBfanAuQW5jaG9yc1t0eXBlXSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBhID0gcGFyYW1zLmpzUGx1bWJJbnN0YW5jZS5tYWtlQW5jaG9yKFsgeCwgeSwgb3gsIG95LCAwLCAwIF0sIHBhcmFtcy5lbGVtZW50SWQsIHBhcmFtcy5qc1BsdW1iSW5zdGFuY2UpO1xuICAgICAgICAgICAgYS50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIGlmIChmbkluaXQpIGZuSW5pdChhLCBwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIF9jdXJyeUFuY2hvcigwLjUsIDAsIDAsIC0xLCBcIlRvcENlbnRlclwiKTtcbiAgICBfY3VycnlBbmNob3IoMC41LCAxLCAwLCAxLCBcIkJvdHRvbUNlbnRlclwiKTtcbiAgICBfY3VycnlBbmNob3IoMCwgMC41LCAtMSwgMCwgXCJMZWZ0TWlkZGxlXCIpO1xuICAgIF9jdXJyeUFuY2hvcigxLCAwLjUsIDEsIDAsIFwiUmlnaHRNaWRkbGVcIik7XG5cbiAgICBfY3VycnlBbmNob3IoMC41LCAwLCAwLCAtMSwgXCJUb3BcIik7XG4gICAgX2N1cnJ5QW5jaG9yKDAuNSwgMSwgMCwgMSwgXCJCb3R0b21cIik7XG4gICAgX2N1cnJ5QW5jaG9yKDAsIDAuNSwgLTEsIDAsIFwiTGVmdFwiKTtcbiAgICBfY3VycnlBbmNob3IoMSwgMC41LCAxLCAwLCBcIlJpZ2h0XCIpO1xuICAgIF9jdXJyeUFuY2hvcigwLjUsIDAuNSwgMCwgMCwgXCJDZW50ZXJcIik7XG4gICAgX2N1cnJ5QW5jaG9yKDEsIDAsIDAsIC0xLCBcIlRvcFJpZ2h0XCIpO1xuICAgIF9jdXJyeUFuY2hvcigxLCAxLCAwLCAxLCBcIkJvdHRvbVJpZ2h0XCIpO1xuICAgIF9jdXJyeUFuY2hvcigwLCAwLCAwLCAtMSwgXCJUb3BMZWZ0XCIpO1xuICAgIF9jdXJyeUFuY2hvcigwLCAxLCAwLCAxLCBcIkJvdHRvbUxlZnRcIik7XG5cbi8vIC0tLS0tLS0gZHluYW1pYyBhbmNob3JzIC0tLS0tLS0tLS0tLS0tLS0tLS0gICAgXG5cbiAgICAvLyBkZWZhdWx0IGR5bmFtaWMgYW5jaG9ycyBjaG9vc2VzIGZyb20gVG9wLCBSaWdodCwgQm90dG9tLCBMZWZ0XG4gICAgX2pwLkRlZmF1bHRzLkR5bmFtaWNBbmNob3JzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zLmpzUGx1bWJJbnN0YW5jZS5tYWtlQW5jaG9ycyhbXCJUb3BDZW50ZXJcIiwgXCJSaWdodE1pZGRsZVwiLCBcIkJvdHRvbUNlbnRlclwiLCBcIkxlZnRNaWRkbGVcIl0sIHBhcmFtcy5lbGVtZW50SWQsIHBhcmFtcy5qc1BsdW1iSW5zdGFuY2UpO1xuICAgIH07XG5cbiAgICAvLyBkZWZhdWx0IGR5bmFtaWMgYW5jaG9ycyBib3VuZCB0byBuYW1lICdBdXRvRGVmYXVsdCdcbiAgICBfanAuQW5jaG9ycy5BdXRvRGVmYXVsdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIGEgPSBwYXJhbXMuanNQbHVtYkluc3RhbmNlLm1ha2VEeW5hbWljQW5jaG9yKF9qcC5EZWZhdWx0cy5EeW5hbWljQW5jaG9ycyhwYXJhbXMpKTtcbiAgICAgICAgYS50eXBlID0gXCJBdXRvRGVmYXVsdFwiO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4vLyAtLS0tLS0tIGNvbnRpbnVvdXMgYW5jaG9ycyAtLS0tLS0tLS0tLS0tLS0tLS0tICAgIFxuXG4gICAgdmFyIF9jdXJyeUNvbnRpbnVvdXNBbmNob3IgPSBmdW5jdGlvbiAodHlwZSwgZmFjZXMpIHtcbiAgICAgICAgX2pwLkFuY2hvcnNbdHlwZV0gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHBhcmFtcy5qc1BsdW1iSW5zdGFuY2UubWFrZUFuY2hvcihbXCJDb250aW51b3VzXCIsIHsgZmFjZXM6IGZhY2VzIH1dLCBwYXJhbXMuZWxlbWVudElkLCBwYXJhbXMuanNQbHVtYkluc3RhbmNlKTtcbiAgICAgICAgICAgIGEudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgX2pwLkFuY2hvcnMuQ29udGludW91cyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5qc1BsdW1iSW5zdGFuY2UuY29udGludW91c0FuY2hvckZhY3RvcnkuZ2V0KHBhcmFtcyk7XG4gICAgfTtcblxuICAgIF9jdXJyeUNvbnRpbnVvdXNBbmNob3IoXCJDb250aW51b3VzTGVmdFwiLCBbXCJsZWZ0XCJdKTtcbiAgICBfY3VycnlDb250aW51b3VzQW5jaG9yKFwiQ29udGludW91c1RvcFwiLCBbXCJ0b3BcIl0pO1xuICAgIF9jdXJyeUNvbnRpbnVvdXNBbmNob3IoXCJDb250aW51b3VzQm90dG9tXCIsIFtcImJvdHRvbVwiXSk7XG4gICAgX2N1cnJ5Q29udGludW91c0FuY2hvcihcIkNvbnRpbnVvdXNSaWdodFwiLCBbXCJyaWdodFwiXSk7XG5cbi8vIC0tLS0tLS0gcG9zaXRpb24gYXNzaWduIGFuY2hvcnMgLS0tLS0tLS0tLS0tLS0tLS0tLSAgICBcblxuICAgIC8vIHRoaXMgYW5jaG9yIHR5cGUgbGV0cyB5b3UgYXNzaWduIHRoZSBwb3NpdGlvbiBhdCBjb25uZWN0aW9uIHRpbWUuXG4gICAgX2N1cnJ5QW5jaG9yKDAsIDAsIDAsIDAsIFwiQXNzaWduXCIsIGZ1bmN0aW9uIChhbmNob3IsIHBhcmFtcykge1xuICAgICAgICAvLyBmaW5kIHdoYXQgdG8gdXNlIGFzIHRoZSBcInBvc2l0aW9uIGZpbmRlclwiLiB0aGUgdXNlciBtYXkgaGF2ZSBzdXBwbGllZCBhIFN0cmluZyB3aGljaCByZXByZXNlbnRzXG4gICAgICAgIC8vIHRoZSBpZCBvZiBhIHBvc2l0aW9uIGZpbmRlciBpbiBqc1BsdW1iLkFuY2hvclBvc2l0aW9uRmluZGVycywgb3IgdGhlIHVzZXIgbWF5IGhhdmUgc3VwcGxpZWQgdGhlXG4gICAgICAgIC8vIHBvc2l0aW9uIGZpbmRlciBhcyBhIGZ1bmN0aW9uLiAgd2UgZmluZCBvdXQgd2hhdCB0byB1c2UgYW5kIHRoZW4gc2V0IGl0IG9uIHRoZSBhbmNob3IuXG4gICAgICAgIHZhciBwZiA9IHBhcmFtcy5wb3NpdGlvbiB8fCBcIkZpeGVkXCI7XG4gICAgICAgIGFuY2hvci5wb3NpdGlvbkZpbmRlciA9IHBmLmNvbnN0cnVjdG9yID09IFN0cmluZyA/IHBhcmFtcy5qc1BsdW1iSW5zdGFuY2UuQW5jaG9yUG9zaXRpb25GaW5kZXJzW3BmXSA6IHBmO1xuICAgICAgICAvLyBhbHdheXMgc2V0IHRoZSBjb25zdHJ1Y3RvciBwYXJhbXM7IHRoZSBwb3NpdGlvbiBmaW5kZXIgbWlnaHQgbmVlZCB0aGVtIGxhdGVyICh0aGUgR3JpZCBvbmUgZG9lcyxcbiAgICAgICAgLy8gZm9yIGV4YW1wbGUpXG4gICAgICAgIGFuY2hvci5jb25zdHJ1Y3RvclBhcmFtcyA9IHBhcmFtcztcbiAgICB9KTtcblxuICAgIC8vIHRoZXNlIGFyZSB0aGUgZGVmYXVsdCBhbmNob3IgcG9zaXRpb25zIGZpbmRlcnMsIHdoaWNoIGFyZSB1c2VkIGJ5IHRoZSBtYWtlVGFyZ2V0IGZ1bmN0aW9uLiAgc3VwcGx5aW5nXG4gICAgLy8gYSBwb3NpdGlvbiBmaW5kZXIgYXJndW1lbnQgdG8gdGhhdCBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNwZWNpZnkgd2hlcmUgdGhlIHJlc3VsdGluZyBhbmNob3Igd2lsbFxuICAgIC8vIGJlIGxvY2F0ZWRcbiAgICByb290LmpzUGx1bWJJbnN0YW5jZS5wcm90b3R5cGUuQW5jaG9yUG9zaXRpb25GaW5kZXJzID0ge1xuICAgICAgICBcIkZpeGVkXCI6IGZ1bmN0aW9uIChkcCwgZXAsIGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gWyAoZHAubGVmdCAtIGVwLmxlZnQpIC8gZXNbMF0sIChkcC50b3AgLSBlcC50b3ApIC8gZXNbMV0gXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJHcmlkXCI6IGZ1bmN0aW9uIChkcCwgZXAsIGVzLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IGRwLmxlZnQgLSBlcC5sZWZ0LCBkeSA9IGRwLnRvcCAtIGVwLnRvcCxcbiAgICAgICAgICAgICAgICBneCA9IGVzWzBdIC8gKHBhcmFtcy5ncmlkWzBdKSwgZ3kgPSBlc1sxXSAvIChwYXJhbXMuZ3JpZFsxXSksXG4gICAgICAgICAgICAgICAgbXggPSBNYXRoLmZsb29yKGR4IC8gZ3gpLCBteSA9IE1hdGguZmxvb3IoZHkgLyBneSk7XG4gICAgICAgICAgICByZXR1cm4gWyAoKG14ICogZ3gpICsgKGd4IC8gMikpIC8gZXNbMF0sICgobXkgKiBneSkgKyAoZ3kgLyAyKSkgLyBlc1sxXSBdO1xuICAgICAgICB9XG4gICAgfTtcblxuLy8gLS0tLS0tLSBwZXJpbWV0ZXIgYW5jaG9ycyAtLS0tLS0tLS0tLS0tLS0tLS0tICAgIFxuXG4gICAgX2pwLkFuY2hvcnMuUGVyaW1ldGVyID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHZhciBhbmNob3JDb3VudCA9IHBhcmFtcy5hbmNob3JDb3VudCB8fCA2MCxcbiAgICAgICAgICAgIHNoYXBlID0gcGFyYW1zLnNoYXBlO1xuXG4gICAgICAgIGlmICghc2hhcGUpIHRocm93IG5ldyBFcnJvcihcIm5vIHNoYXBlIHN1cHBsaWVkIHRvIFBlcmltZXRlciBBbmNob3IgdHlwZVwiKTtcblxuICAgICAgICB2YXIgX2NpcmNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IDAuNSwgc3RlcCA9IE1hdGguUEkgKiAyIC8gYW5jaG9yQ291bnQsIGN1cnJlbnQgPSAwLCBhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNob3JDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gciArIChyICogTWF0aC5zaW4oY3VycmVudCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHIgKyAociAqIE1hdGguY29zKGN1cnJlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFsgeCwgeSwgMCwgMCBdKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcGF0aCA9IGZ1bmN0aW9uIChzZWdtZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBhbmNob3JzUGVyRmFjZSA9IGFuY2hvckNvdW50IC8gc2VnbWVudHMubGVuZ3RoLCBhID0gW10sXG4gICAgICAgICAgICAgICAgICAgIF9jb21wdXRlRmFjZSA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgZnJhY3Rpb25hbExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yc1BlckZhY2UgPSBhbmNob3JDb3VudCAqIGZyYWN0aW9uYWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSAoeDIgLSB4MSkgLyBhbmNob3JzUGVyRmFjZSwgZHkgPSAoeTIgLSB5MSkgLyBhbmNob3JzUGVyRmFjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jaG9yc1BlckZhY2U7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSArIChkeCAqIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgKyAoZHkgKiBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgX2NvbXB1dGVGYWNlLmFwcGx5KG51bGwsIHNlZ21lbnRzW2ldKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaGFwZSA9IGZ1bmN0aW9uIChmYWNlcykge1xuICAgICAgICAgICAgICAgIHZhciBzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzLnB1c2goW2ZhY2VzW2ldWzBdLCBmYWNlc1tpXVsxXSwgZmFjZXNbaV1bMl0sIGZhY2VzW2ldWzNdLCAxIC8gZmFjZXMubGVuZ3RoXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfcGF0aChzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc2hhcGUoW1xuICAgICAgICAgICAgICAgICAgICBbIDAsIDAsIDEsIDAgXSxcbiAgICAgICAgICAgICAgICAgICAgWyAxLCAwLCAxLCAxIF0sXG4gICAgICAgICAgICAgICAgICAgIFsgMSwgMSwgMCwgMSBdLFxuICAgICAgICAgICAgICAgICAgICBbIDAsIDEsIDAsIDAgXVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB2YXIgX3NoYXBlcyA9IHtcbiAgICAgICAgICAgICAgICBcIkNpcmNsZVwiOiBfY2lyY2xlLFxuICAgICAgICAgICAgICAgIFwiRWxsaXBzZVwiOiBfY2lyY2xlLFxuICAgICAgICAgICAgICAgIFwiRGlhbW9uZFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2hhcGUoW1xuICAgICAgICAgICAgICAgICAgICAgICAgWyAwLjUsIDAsIDEsIDAuNSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgWyAxLCAwLjUsIDAuNSwgMSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgWyAwLjUsIDEsIDAsIDAuNSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgWyAwLCAwLjUsIDAuNSwgMCBdXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJSZWN0YW5nbGVcIjogX3JlY3RhbmdsZSxcbiAgICAgICAgICAgICAgICBcIlNxdWFyZVwiOiBfcmVjdGFuZ2xlLFxuICAgICAgICAgICAgICAgIFwiVHJpYW5nbGVcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NoYXBlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFsgMC41LCAwLCAxLCAxIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbIDEsIDEsIDAsIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsgMCwgMSwgMC41LCAwXVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiUGF0aFwiOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBwYXJhbXMucG9pbnRzLCBwID0gW10sIHRsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IE1hdGguc3FydChNYXRoLnBvdyhwb2ludHNbaV1bMl0gLSBwb2ludHNbaV1bMF0pICsgTWF0aC5wb3cocG9pbnRzW2ldWzNdIC0gcG9pbnRzW2ldWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bCArPSBsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5wdXNoKFtwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSwgcG9pbnRzW2kgKyAxXVswXSwgcG9pbnRzW2kgKyAxXVsxXSwgbF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcFtqXVs0XSA9IHBbal1bNF0gLyB0bDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3BhdGgocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yb3RhdGUgPSBmdW5jdGlvbiAocG9pbnRzLCBhbW91bnRJbkRlZ3JlZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IFtdLCB0aGV0YSA9IGFtb3VudEluRGVncmVlcyAvIDE4MCAqIE1hdGguUEk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF94ID0gcG9pbnRzW2ldWzBdIC0gMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgX3kgPSBwb2ludHNbaV1bMV0gLSAwLjU7XG5cbiAgICAgICAgICAgICAgICAgICAgby5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjUgKyAoKF94ICogTWF0aC5jb3ModGhldGEpKSAtIChfeSAqIE1hdGguc2luKHRoZXRhKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuNSArICgoX3ggKiBNYXRoLnNpbih0aGV0YSkpICsgKF95ICogTWF0aC5jb3ModGhldGEpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbaV1bMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbaV1bM11cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoIV9zaGFwZXNbc2hhcGVdKSB0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSBbXCIgKyBzaGFwZSArIFwiXSBpcyB1bmtub3duIGJ5IFBlcmltZXRlciBBbmNob3IgdHlwZVwiKTtcblxuICAgICAgICB2YXIgZGEgPSBfc2hhcGVzW3NoYXBlXShwYXJhbXMpO1xuICAgICAgICBpZiAocGFyYW1zLnJvdGF0aW9uKSBkYSA9IF9yb3RhdGUoZGEsIHBhcmFtcy5yb3RhdGlvbik7XG4gICAgICAgIHZhciBhID0gcGFyYW1zLmpzUGx1bWJJbnN0YW5jZS5tYWtlRHluYW1pY0FuY2hvcihkYSk7XG4gICAgICAgIGEudHlwZSA9IFwiUGVyaW1ldGVyXCI7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG4vKlxuICoganNQbHVtYlxuICogXG4gKiBUaXRsZTpqc1BsdW1iIDIuMS4wXG4gKiBcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHZpc3VhbGx5IGNvbm5lY3QgZWxlbWVudHMgb24gYW4gSFRNTCBwYWdlLCB1c2luZyBTVkcuXG4gKiBcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgZGVmYXVsdCBDb25uZWN0b3JzLCBFbmRwb2ludCBhbmQgT3ZlcmxheSBkZWZpbml0aW9ucy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE2IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqIFxuICogaHR0cDovL2pzcGx1bWJ0b29sa2l0LmNvbVxuICogaHR0cDovL2dpdGh1Yi5jb20vc3BvcnJpdHQvanNwbHVtYlxuICogXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXG4gKi9cbjtcbihmdW5jdGlvbiAoKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcm9vdCA9IHRoaXMsIF9qcCA9IHJvb3QuanNQbHVtYiwgX2p1ID0gcm9vdC5qc1BsdW1iVXRpbCwgX2pnID0gcm9vdC5CaWx0b25nO1xuXG4gICAgX2pwLlNlZ21lbnRzID0ge1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIENsYXNzOiBBYnN0cmFjdFNlZ21lbnRcbiAgICAgICAgICogQSBDb25uZWN0b3IgaXMgbWFkZSB1cCBvZiAxLi5OIFNlZ21lbnRzLCBlYWNoIG9mIHdoaWNoIGhhcyBhIFR5cGUsIHN1Y2ggYXMgJ1N0cmFpZ2h0JywgJ0FyYycsXG4gICAgICAgICAqICdCZXppZXInLiBUaGlzIGlzIG5ldyBmcm9tIDEuNC4yLCBhbmQgZ2l2ZXMgdXMgYSBsb3QgbW9yZSBmbGV4aWJpbGl0eSB3aGVuIGRyYXdpbmcgY29ubmVjdGlvbnM6IHRoaW5ncyBzdWNoXG4gICAgICAgICAqIGFzIHJvdW5kZWQgY29ybmVycyBmb3IgZmxvd2NoYXJ0IGNvbm5lY3RvcnMsIGZvciBleGFtcGxlLCBvciBhIHN0cmFpZ2h0IGxpbmUgc3R1YiBmb3IgQmV6aWVyIGNvbm5lY3Rpb25zLCBhcmVcbiAgICAgICAgICogbXVjaCBlYXNpZXIgdG8gZG8gbm93LlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIFNlZ21lbnQgaXMgcmVzcG9uc2libGUgZm9yIHByb3ZpZGluZyBjb29yZGluYXRlcyBmb3IgcGFpbnRpbmcgaXQsIGFuZCBhbHNvIG11c3QgYmUgYWJsZSB0byByZXBvcnQgaXRzIGxlbmd0aC5cbiAgICAgICAgICogXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdFNlZ21lbnQ6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZ1bmN0aW9uOiBmaW5kQ2xvc2VzdFBvaW50T25QYXRoXG4gICAgICAgICAgICAgKiBGaW5kcyB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGlzIHNlZ21lbnQgdG8gdGhlIGdpdmVuIFt4LCB5XSxcbiAgICAgICAgICAgICAqIHJldHVybmluZyBib3RoIHRoZSB4IGFuZCB5IG9mIHRoZSBwb2ludCBwbHVzIGl0cyBkaXN0YW5jZSBmcm9tXG4gICAgICAgICAgICAgKiB0aGUgc3VwcGxpZWQgcG9pbnQsIGFuZCBpdHMgbG9jYXRpb24gYWxvbmcgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgICAgICAgICAqIHBhdGggaW5zY3JpYmVkIGJ5IHRoZSBzZWdtZW50LiAgVGhpcyBpbXBsZW1lbnRhdGlvbiByZXR1cm5zXG4gICAgICAgICAgICAgKiBJbmZpbml0eSBmb3IgZGlzdGFuY2UgYW5kIG51bGwgdmFsdWVzIGZvciBldmVyeXRoaW5nIGVsc2U7XG4gICAgICAgICAgICAgKiBzdWJjbGFzc2VzIGFyZSBleHBlY3RlZCB0byBvdmVycmlkZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5maW5kQ2xvc2VzdFBvaW50T25QYXRoID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICAgICAgeDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgeTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbDogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtaW5YOiBNYXRoLm1pbihwYXJhbXMueDEsIHBhcmFtcy54MiksXG4gICAgICAgICAgICAgICAgICAgIG1pblk6IE1hdGgubWluKHBhcmFtcy55MSwgcGFyYW1zLnkyKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4WDogTWF0aC5tYXgocGFyYW1zLngxLCBwYXJhbXMueDIpLFxuICAgICAgICAgICAgICAgICAgICBtYXhZOiBNYXRoLm1heChwYXJhbXMueTEsIHBhcmFtcy55MilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgU3RyYWlnaHQ6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBfc3VwZXIgPSBfanAuU2VnbWVudHMuQWJzdHJhY3RTZWdtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgbGVuZ3RoLCBtLCBtMiwgeDEsIHgyLCB5MSwgeTIsXG4gICAgICAgICAgICAgICAgX3JlY2FsYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIDIpICsgTWF0aC5wb3coeTIgLSB5MSwgMikpO1xuICAgICAgICAgICAgICAgICAgICBtID0gX2pnLmdyYWRpZW50KHt4OiB4MSwgeTogeTF9LCB7eDogeDIsIHk6IHkyfSk7XG4gICAgICAgICAgICAgICAgICAgIG0yID0gLTEgLyBtO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiU3RyYWlnaHRcIjtcblxuICAgICAgICAgICAgdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmdldEdyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4MTogeDEsIHkxOiB5MSwgeDI6IHgyLCB5MjogeTIgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICAgICAgICAgIHgxID0gY29vcmRzLngxO1xuICAgICAgICAgICAgICAgIHkxID0gY29vcmRzLnkxO1xuICAgICAgICAgICAgICAgIHgyID0gY29vcmRzLngyO1xuICAgICAgICAgICAgICAgIHkyID0gY29vcmRzLnkyO1xuICAgICAgICAgICAgICAgIF9yZWNhbGMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNldENvb3JkaW5hdGVzKHt4MTogcGFyYW1zLngxLCB5MTogcGFyYW1zLnkxLCB4MjogcGFyYW1zLngyLCB5MjogcGFyYW1zLnkyfSk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1pblg6IE1hdGgubWluKHgxLCB4MiksXG4gICAgICAgICAgICAgICAgICAgIG1pblk6IE1hdGgubWluKHkxLCB5MiksXG4gICAgICAgICAgICAgICAgICAgIG1heFg6IE1hdGgubWF4KHgxLCB4MiksXG4gICAgICAgICAgICAgICAgICAgIG1heFk6IE1hdGgubWF4KHkxLCB5MilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgc2VnbWVudCdzIHBhdGggdGhhdCBpcyAnbG9jYXRpb24nIGFsb25nIHRoZSBsZW5ndGggb2YgdGhlIHBhdGgsIHdoZXJlICdsb2NhdGlvbicgaXMgYSBkZWNpbWFsIGZyb21cbiAgICAgICAgICAgICAqIDAgdG8gMSBpbmNsdXNpdmUuIGZvciB0aGUgc3RyYWlnaHQgbGluZSBzZWdtZW50IHRoaXMgaXMgc2ltcGxlIG1hdGhzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBvaW50T25QYXRoID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gMCAmJiAhYWJzb2x1dGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IHgxLCB5OiB5MSB9O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvY2F0aW9uID09IDEgJiYgIWFic29sdXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiB4MiwgeTogeTIgfTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBhYnNvbHV0ZSA/IGxvY2F0aW9uID4gMCA/IGxvY2F0aW9uIDogbGVuZ3RoICsgbG9jYXRpb24gOiBsb2NhdGlvbiAqIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9qZy5wb2ludE9uTGluZSh7eDogeDEsIHk6IHkxfSwge3g6IHgyLCB5OiB5Mn0sIGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmV0dXJucyB0aGUgZ3JhZGllbnQgb2YgdGhlIHNlZ21lbnQgYXQgdGhlIGdpdmVuIHBvaW50IC0gd2hpY2ggZm9yIHVzIGlzIGNvbnN0YW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50QXRQb2ludCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBzZWdtZW50J3MgcGF0aCB0aGF0IGlzICdkaXN0YW5jZScgYWxvbmcgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCBmcm9tICdsb2NhdGlvbicsIHdoZXJlXG4gICAgICAgICAgICAgKiAnbG9jYXRpb24nIGlzIGEgZGVjaW1hbCBmcm9tIDAgdG8gMSBpbmNsdXNpdmUsIGFuZCAnZGlzdGFuY2UnIGlzIGEgbnVtYmVyIG9mIHBpeGVscy5cbiAgICAgICAgICAgICAqIHRoaXMgaGFuZHMgb2ZmIHRvIGpzUGx1bWJVdGlsIHRvIGRvIHRoZSBtYXRocywgc3VwcGx5aW5nIHR3byBwb2ludHMgYW5kIHRoZSBkaXN0YW5jZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wb2ludEFsb25nUGF0aEZyb20gPSBmdW5jdGlvbiAobG9jYXRpb24sIGRpc3RhbmNlLCBhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5wb2ludE9uUGF0aChsb2NhdGlvbiwgYWJzb2x1dGUpLFxuICAgICAgICAgICAgICAgICAgICBmYXJBd2F5UG9pbnQgPSBkaXN0YW5jZSA8PSAwID8ge3g6IHgxLCB5OiB5MX0gOiB7eDogeDIsIHk6IHkyIH07XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICBsb2NhdGlvbiA9PSAxID8ge1xuICAgICAgICAgICAgICAgICB4OngxICsgKCh4MiAtIHgxKSAqIDEwKSxcbiAgICAgICAgICAgICAgICAgeTp5MSArICgoeTEgLSB5MikgKiAxMClcbiAgICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPD0gMCAmJiBNYXRoLmFicyhkaXN0YW5jZSkgPiAxKSBkaXN0YW5jZSAqPSAtMTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfamcucG9pbnRPbkxpbmUocCwgZmFyQXdheVBvaW50LCBkaXN0YW5jZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBpcyBjIGJldHdlZW4gYSBhbmQgYj9cbiAgICAgICAgICAgIHZhciB3aXRoaW4gPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjID49IE1hdGgubWluKGEsIGIpICYmIGMgPD0gTWF0aC5tYXgoYSwgYik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZmluZCB3aGljaCBvZiBhIGFuZCBiIGlzIGNsb3Nlc3QgdG8gY1xuICAgICAgICAgICAgdmFyIGNsb3Nlc3QgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhjIC0gYSkgPCBNYXRoLmFicyhjIC0gYikgPyBhIDogYjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgIEZ1bmN0aW9uOiBmaW5kQ2xvc2VzdFBvaW50T25QYXRoXG4gICAgICAgICAgICAgRmluZHMgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhpcyBzZWdtZW50IHRvIFt4LHldLiBTZWVcbiAgICAgICAgICAgICBub3RlcyBvbiB0aGlzIG1ldGhvZCBpbiBBYnN0cmFjdFNlZ21lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZmluZENsb3Nlc3RQb2ludE9uUGF0aCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgICAgIHg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGw6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICAgICAgICAgIHkyOiB5MlxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAobSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQueSA9IHkxO1xuICAgICAgICAgICAgICAgICAgICBvdXQueCA9IHdpdGhpbih4MSwgeDIsIHgpID8geCA6IGNsb3Nlc3QoeDEsIHgyLCB4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobSA9PSBJbmZpbml0eSB8fCBtID09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQueCA9IHgxO1xuICAgICAgICAgICAgICAgICAgICBvdXQueSA9IHdpdGhpbih5MSwgeTIsIHkpID8geSA6IGNsb3Nlc3QoeTEsIHkyLCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsb3Nlc3QgcG9pbnQgbGllcyBvbiBub3JtYWwgZnJvbSBnaXZlbiBwb2ludCB0byB0aGlzIGxpbmUuICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB5MSAtIChtICogeDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSB5IC0gKG0yICogeCksXG4gICAgICAgICAgICAgICAgICAgIC8vIHkxID0gbS54MSArIGIgYW5kIHkxID0gbTIueDEgKyBiMlxuICAgICAgICAgICAgICAgICAgICAvLyBzbyBtLngxICsgYiA9IG0yLngxICsgYjJcbiAgICAgICAgICAgICAgICAgICAgLy8geDEobSAtIG0yKSA9IGIyIC0gYlxuICAgICAgICAgICAgICAgICAgICAvLyB4MSA9IChiMiAtIGIpIC8gKG0gLSBtMilcbiAgICAgICAgICAgICAgICAgICAgICAgIF94MSA9IChiMiAtIGIpIC8gKG0gLSBtMiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfeTEgPSAobSAqIF94MSkgKyBiO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dC54ID0gd2l0aGluKHgxLCB4MiwgX3gxKSA/IF94MSA6IGNsb3Nlc3QoeDEsIHgyLCBfeDEpOy8vX3gxO1xuICAgICAgICAgICAgICAgICAgICBvdXQueSA9IHdpdGhpbih5MSwgeTIsIF95MSkgPyBfeTEgOiBjbG9zZXN0KHkxLCB5MiwgX3kxKTsvL195MTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZnJhY3Rpb25JblNlZ21lbnQgPSBfamcubGluZUxlbmd0aChbIG91dC54LCBvdXQueSBdLCBbIHgxLCB5MSBdKTtcbiAgICAgICAgICAgICAgICBvdXQuZCA9IF9qZy5saW5lTGVuZ3RoKFt4LCB5XSwgW291dC54LCBvdXQueV0pO1xuICAgICAgICAgICAgICAgIG91dC5sID0gZnJhY3Rpb25JblNlZ21lbnQgLyBsZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgIEFyYyBTZWdtZW50LiBZb3UgbmVlZCB0byBzdXBwbHk6XG5cbiAgICAgICAgIHIgICAtICAgcmFkaXVzXG4gICAgICAgICBjeCAgLSAgIGNlbnRlciB4IGZvciB0aGUgYXJjXG4gICAgICAgICBjeSAgLSAgIGNlbnRlciB5IGZvciB0aGUgYXJjXG4gICAgICAgICBhYyAgLSAgIHdoZXRoZXIgdGhlIGFyYyBpcyBhbnRpY2xvY2t3aXNlIG9yIG5vdC4gZGVmYXVsdCBpcyBjbG9ja3dpc2UuXG5cbiAgICAgICAgIGFuZCB0aGVuIGVpdGhlcjpcblxuICAgICAgICAgc3RhcnRBbmdsZSAgLSAgIHN0YXJ0QW5nbGUgZm9yIHRoZSBhcmMuXG4gICAgICAgICBlbmRBbmdsZSAgICAtICAgZW5kQW5nbGUgZm9yIHRoZSBhcmMuXG5cbiAgICAgICAgIG9yOlxuXG4gICAgICAgICB4MSAgICAgICAgICAtICAgeCBmb3Igc3RhcnQgcG9pbnRcbiAgICAgICAgIHkxICAgICAgICAgIC0gICB5IGZvciBzdGFydCBwb2ludFxuICAgICAgICAgeDIgICAgICAgICAgLSAgIHggZm9yIGVuZCBwb2ludFxuICAgICAgICAgeTIgICAgICAgICAgLSAgIHkgZm9yIGVuZCBwb2ludFxuXG4gICAgICAgICAqL1xuICAgICAgICBBcmM6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBfc3VwZXIgPSBfanAuU2VnbWVudHMuQWJzdHJhY3RTZWdtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgX2NhbGNBbmdsZSA9IGZ1bmN0aW9uIChfeCwgX3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9qZy50aGV0YShbcGFyYW1zLmN4LCBwYXJhbXMuY3ldLCBbX3gsIF95XSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfY2FsY0FuZ2xlRm9yTG9jYXRpb24gPSBmdW5jdGlvbiAoc2VnbWVudCwgbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQuYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhID0gc2VnbWVudC5zdGFydEFuZ2xlIDwgc2VnbWVudC5lbmRBbmdsZSA/IHNlZ21lbnQuc3RhcnRBbmdsZSArIFRXT19QSSA6IHNlZ21lbnQuc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gTWF0aC5hYnMoc2EgLSBzZWdtZW50LmVuZEFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzYSAtIChzICogbG9jYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVhID0gc2VnbWVudC5lbmRBbmdsZSA8IHNlZ21lbnQuc3RhcnRBbmdsZSA/IHNlZ21lbnQuZW5kQW5nbGUgKyBUV09fUEkgOiBzZWdtZW50LmVuZEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNzID0gTWF0aC5hYnMoZWEgLSBzZWdtZW50LnN0YXJ0QW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VnbWVudC5zdGFydEFuZ2xlICsgKHNzICogbG9jYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBUV09fUEkgPSAyICogTWF0aC5QSTtcblxuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBwYXJhbXMucjtcbiAgICAgICAgICAgIHRoaXMuYW50aWNsb2Nrd2lzZSA9IHBhcmFtcy5hYztcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiQXJjXCI7XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuc3RhcnRBbmdsZSAmJiBwYXJhbXMuZW5kQW5nbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QW5nbGUgPSBwYXJhbXMuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZEFuZ2xlID0gcGFyYW1zLmVuZEFuZ2xlO1xuICAgICAgICAgICAgICAgIHRoaXMueDEgPSBwYXJhbXMuY3ggKyAodGhpcy5yYWRpdXMgKiBNYXRoLmNvcyhwYXJhbXMuc3RhcnRBbmdsZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMueTEgPSBwYXJhbXMuY3kgKyAodGhpcy5yYWRpdXMgKiBNYXRoLnNpbihwYXJhbXMuc3RhcnRBbmdsZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMueDIgPSBwYXJhbXMuY3ggKyAodGhpcy5yYWRpdXMgKiBNYXRoLmNvcyhwYXJhbXMuZW5kQW5nbGUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnkyID0gcGFyYW1zLmN5ICsgKHRoaXMucmFkaXVzICogTWF0aC5zaW4ocGFyYW1zLmVuZEFuZ2xlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QW5nbGUgPSBfY2FsY0FuZ2xlKHBhcmFtcy54MSwgcGFyYW1zLnkxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZEFuZ2xlID0gX2NhbGNBbmdsZShwYXJhbXMueDIsIHBhcmFtcy55Mik7XG4gICAgICAgICAgICAgICAgdGhpcy54MSA9IHBhcmFtcy54MTtcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0gcGFyYW1zLnkxO1xuICAgICAgICAgICAgICAgIHRoaXMueDIgPSBwYXJhbXMueDI7XG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHBhcmFtcy55MjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZW5kQW5nbGUgPCAwKSB0aGlzLmVuZEFuZ2xlICs9IFRXT19QSTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0QW5nbGUgPCAwKSB0aGlzLnN0YXJ0QW5nbGUgKz0gVFdPX1BJO1xuXG4gICAgICAgICAgICAvLyBzZWdtZW50IGlzIHVzZWQgYnkgdm1sICAgICBcbiAgICAgICAgICAgIC8vdGhpcy5zZWdtZW50ID0gX2pnLnF1YWRyYW50KFt0aGlzLngxLCB0aGlzLnkxXSwgW3RoaXMueDIsIHRoaXMueTJdKTtcblxuICAgICAgICAgICAgLy8gd2Ugbm93IGhhdmUgc3RhcnRBbmdsZSBhbmQgZW5kQW5nbGUgYXMgcG9zaXRpdmUgbnVtYmVycywgbWVhbmluZyB0aGVcbiAgICAgICAgICAgIC8vIGFic29sdXRlIGRpZmZlcmVuY2UgKHxkfCkgYmV0d2VlbiB0aGVtIGlzIHRoZSBzd2VlcCAocykgb2YgdGhpcyBhcmMsIHVubGVzcyB0aGVcbiAgICAgICAgICAgIC8vIGFyYyBpcyAnYW50aWNsb2Nrd2lzZScgaW4gd2hpY2ggY2FzZSAncycgaXMgZ2l2ZW4gYnkgMlBJIC0gfGR8LlxuXG4gICAgICAgICAgICB2YXIgZWEgPSB0aGlzLmVuZEFuZ2xlIDwgdGhpcy5zdGFydEFuZ2xlID8gdGhpcy5lbmRBbmdsZSArIFRXT19QSSA6IHRoaXMuZW5kQW5nbGU7XG4gICAgICAgICAgICB0aGlzLnN3ZWVwID0gTWF0aC5hYnMoZWEgLSB0aGlzLnN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYW50aWNsb2Nrd2lzZSkgdGhpcy5zd2VlcCA9IFRXT19QSSAtIHRoaXMuc3dlZXA7XG4gICAgICAgICAgICB2YXIgY2lyY3VtZmVyZW5jZSA9IDIgKiBNYXRoLlBJICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgZnJhYyA9IHRoaXMuc3dlZXAgLyBUV09fUEksXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gY2lyY3VtZmVyZW5jZSAqIGZyYWM7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtaW5YOiBwYXJhbXMuY3ggLSBwYXJhbXMucixcbiAgICAgICAgICAgICAgICAgICAgbWF4WDogcGFyYW1zLmN4ICsgcGFyYW1zLnIsXG4gICAgICAgICAgICAgICAgICAgIG1pblk6IHBhcmFtcy5jeSAtIHBhcmFtcy5yLFxuICAgICAgICAgICAgICAgICAgICBtYXhZOiBwYXJhbXMuY3kgKyBwYXJhbXMuclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgVkVSWV9TTUFMTF9WQUxVRSA9IDAuMDAwMDAwMDAwMSxcbiAgICAgICAgICAgICAgICBnZW50bGVSb3VuZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gTWF0aC5mbG9vcihuKSwgciA9IE1hdGguY2VpbChuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gLSBmIDwgVkVSWV9TTUFMTF9WQUxVRSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyIC0gbiA8IFZFUllfU01BTExfVkFMVUUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgc2VnbWVudCdzIHBhdGggdGhhdCBpcyAnbG9jYXRpb24nIGFsb25nIHRoZSBsZW5ndGggb2YgdGhlIHBhdGgsIHdoZXJlICdsb2NhdGlvbicgaXMgYSBkZWNpbWFsIGZyb21cbiAgICAgICAgICAgICAqIDAgdG8gMSBpbmNsdXNpdmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucG9pbnRPblBhdGggPSBmdW5jdGlvbiAobG9jYXRpb24sIGFic29sdXRlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogdGhpcy54MSwgeTogdGhpcy55MSwgdGhldGE6IHRoaXMuc3RhcnRBbmdsZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2NhdGlvbiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IHRoaXMueDIsIHk6IHRoaXMueTIsIHRoZXRhOiB0aGlzLmVuZEFuZ2xlIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gLyBsZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gX2NhbGNBbmdsZUZvckxvY2F0aW9uKHRoaXMsIGxvY2F0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgX3ggPSBwYXJhbXMuY3ggKyAocGFyYW1zLnIgKiBNYXRoLmNvcyhhbmdsZSkpLFxuICAgICAgICAgICAgICAgICAgICBfeSA9IHBhcmFtcy5jeSArIChwYXJhbXMuciAqIE1hdGguc2luKGFuZ2xlKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBnZW50bGVSb3VuZChfeCksIHk6IGdlbnRsZVJvdW5kKF95KSwgdGhldGE6IGFuZ2xlIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJldHVybnMgdGhlIGdyYWRpZW50IG9mIHRoZSBzZWdtZW50IGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudEF0UG9pbnQgPSBmdW5jdGlvbiAobG9jYXRpb24sIGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50T25QYXRoKGxvY2F0aW9uLCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBfamcubm9ybWFsKFsgcGFyYW1zLmN4LCBwYXJhbXMuY3kgXSwgW3AueCwgcC55IF0pO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hbnRpY2xvY2t3aXNlICYmIChtID09IEluZmluaXR5IHx8IG0gPT0gLUluZmluaXR5KSkgbSAqPSAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucG9pbnRBbG9uZ1BhdGhGcm9tID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBkaXN0YW5jZSwgYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRPblBhdGgobG9jYXRpb24sIGFic29sdXRlKSxcbiAgICAgICAgICAgICAgICAgICAgYXJjU3BhbiA9IGRpc3RhbmNlIC8gY2lyY3VtZmVyZW5jZSAqIDIgKiBNYXRoLlBJLFxuICAgICAgICAgICAgICAgICAgICBkaXIgPSB0aGlzLmFudGljbG9ja3dpc2UgPyAtMSA6IDEsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBwLnRoZXRhICsgKGRpciAqIGFyY1NwYW4pLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFggPSBwYXJhbXMuY3ggKyAodGhpcy5yYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WSA9IHBhcmFtcy5jeSArICh0aGlzLnJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7eDogc3RhcnRYLCB5OiBzdGFydFl9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBCZXppZXI6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VydmUgPSBbXG4gICAgICAgICAgICAgICAgeyB4OiBwYXJhbXMueDEsIHk6IHBhcmFtcy55MX0sXG4gICAgICAgICAgICAgICAgeyB4OiBwYXJhbXMuY3AxeCwgeTogcGFyYW1zLmNwMXkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHBhcmFtcy5jcDJ4LCB5OiBwYXJhbXMuY3AyeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogcGFyYW1zLngyLCB5OiBwYXJhbXMueTIgfVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlciA9IF9qcC5TZWdtZW50cy5BYnN0cmFjdFNlZ21lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIGFsdGhvdWdoIHRoaXMgaXMgbm90IGEgc3RyaWN0bHkgcmlnb3JvdXMgZGV0ZXJtaW5hdGlvbiBvZiBib3VuZHNcbiAgICAgICAgICAgIC8vIG9mIGEgYmV6aWVyIGN1cnZlLCBpdCB3b3JrcyBmb3IgdGhlIHR5cGVzIG9mIGN1cnZlcyB0aGF0IHRoaXMgc2VnbWVudFxuICAgICAgICAgICAgLy8gdHlwZSBwcm9kdWNlcy5cbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0ge1xuICAgICAgICAgICAgICAgIG1pblg6IE1hdGgubWluKHBhcmFtcy54MSwgcGFyYW1zLngyLCBwYXJhbXMuY3AxeCwgcGFyYW1zLmNwMngpLFxuICAgICAgICAgICAgICAgIG1pblk6IE1hdGgubWluKHBhcmFtcy55MSwgcGFyYW1zLnkyLCBwYXJhbXMuY3AxeSwgcGFyYW1zLmNwMnkpLFxuICAgICAgICAgICAgICAgIG1heFg6IE1hdGgubWF4KHBhcmFtcy54MSwgcGFyYW1zLngyLCBwYXJhbXMuY3AxeCwgcGFyYW1zLmNwMngpLFxuICAgICAgICAgICAgICAgIG1heFk6IE1hdGgubWF4KHBhcmFtcy55MSwgcGFyYW1zLnkyLCBwYXJhbXMuY3AxeSwgcGFyYW1zLmNwMnkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBcIkJlemllclwiO1xuXG4gICAgICAgICAgICB2YXIgX3RyYW5zbGF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gKF9jdXJ2ZSwgbG9jYXRpb24sIGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKVxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHJvb3QuanNCZXppZXIubG9jYXRpb25BbG9uZ0N1cnZlRnJvbShfY3VydmUsIGxvY2F0aW9uID4gMCA/IDAgOiAxLCBsb2NhdGlvbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBzZWdtZW50J3MgcGF0aCB0aGF0IGlzICdsb2NhdGlvbicgYWxvbmcgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCwgd2hlcmUgJ2xvY2F0aW9uJyBpcyBhIGRlY2ltYWwgZnJvbVxuICAgICAgICAgICAgICogMCB0byAxIGluY2x1c2l2ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wb2ludE9uUGF0aCA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IF90cmFuc2xhdGVMb2NhdGlvbih0aGlzLmN1cnZlLCBsb2NhdGlvbiwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByb290LmpzQmV6aWVyLnBvaW50T25DdXJ2ZSh0aGlzLmN1cnZlLCBsb2NhdGlvbik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJldHVybnMgdGhlIGdyYWRpZW50IG9mIHRoZSBzZWdtZW50IGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudEF0UG9pbnQgPSBmdW5jdGlvbiAobG9jYXRpb24sIGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBfdHJhbnNsYXRlTG9jYXRpb24odGhpcy5jdXJ2ZSwgbG9jYXRpb24sIGFic29sdXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdC5qc0Jlemllci5ncmFkaWVudEF0UG9pbnQodGhpcy5jdXJ2ZSwgbG9jYXRpb24pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5wb2ludEFsb25nUGF0aEZyb20gPSBmdW5jdGlvbiAobG9jYXRpb24sIGRpc3RhbmNlLCBhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gX3RyYW5zbGF0ZUxvY2F0aW9uKHRoaXMuY3VydmUsIGxvY2F0aW9uLCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QuanNCZXppZXIucG9pbnRBbG9uZ0N1cnZlRnJvbSh0aGlzLmN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QuanNCZXppZXIuZ2V0TGVuZ3RoKHRoaXMuY3VydmUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICBDbGFzczogQWJzdHJhY3RDb21wb25lbnRcbiAgICAgU3VwZXJjbGFzcyBmb3IgQWJzdHJhY3RDb25uZWN0b3IgYW5kIEFic3RyYWN0RW5kcG9pbnQuXG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0Q29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5ib3VuZHMgPSB7IG1pblg6IEluZmluaXR5LCBtaW5ZOiBJbmZpbml0eSwgbWF4WDogLUluZmluaXR5LCBtYXhZOiAtSW5maW5pdHkgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXNldEJvdW5kcygpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIENsYXNzOiBBYnN0cmFjdENvbm5lY3RvclxuICAgICAqIFN1cGVyY2xhc3MgZm9yIGFsbCBDb25uZWN0b3JzOyBoZXJlIGlzIHdoZXJlIFNlZ21lbnRzIGFyZSBtYW5hZ2VkLiAgVGhpcyBpcyBleHBvc2VkIG9uIGpzUGx1bWIganVzdCBzbyBpdFxuICAgICAqIGNhbiBiZSBhY2Nlc3NlZCBmcm9tIG90aGVyIGZpbGVzLiBZb3Ugc2hvdWxkIG5vdCB0cnkgdG8gaW5zdGFudGlhdGUgb25lIG9mIHRoZXNlIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogV2hlbiB0aGlzIGNsYXNzIGlzIGFza2VkIGZvciBhIHBvaW50T25QYXRoLCBvciBncmFkaWVudCBldGMsIGl0IG11c3QgZmlyc3QgZmlndXJlIG91dCB3aGljaCBzZWdtZW50IHRvIGRpc3BhdGNoXG4gICAgICogdGhhdCByZXF1ZXN0IHRvLiBUaGlzIGlzIGRvbmUgYnkga2VlcGluZyB0cmFjayBvZiB0aGUgdG90YWwgY29ubmVjdG9yIGxlbmd0aCBhcyBzZWdtZW50cyBhcmUgYWRkZWQsIGFuZCBhbHNvXG4gICAgICogdGhlaXIgY3VtdWxhdGl2ZSByYXRpb3MgdG8gdGhlIHRvdGFsIGxlbmd0aC4gIFRoZW4gd2hlbiB0aGUgcmlnaHQgc2VnbWVudCBpcyBmb3VuZCBpdCBpcyBhIHNpbXBsZSBjYXNlIG9mIGRpc3BhdGNoaW5nXG4gICAgICogdGhlIHJlcXVlc3QgdG8gaXQgKGFuZCBhZGp1c3RpbmcgJ2xvY2F0aW9uJyBzbyB0aGF0IGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhhdCBzZWdtZW50LilcbiAgICAgKi9cbiAgICBfanAuQ29ubmVjdG9ycy5BYnN0cmFjdENvbm5lY3RvciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcblxuICAgICAgICBBYnN0cmFjdENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IFtdLFxuICAgICAgICAgICAgdG90YWxMZW5ndGggPSAwLFxuICAgICAgICAgICAgc2VnbWVudFByb3BvcnRpb25zID0gW10sXG4gICAgICAgICAgICBzZWdtZW50UHJvcG9ydGlvbmFsTGVuZ3RocyA9IFtdLFxuICAgICAgICAgICAgc3R1YiA9IHBhcmFtcy5zdHViIHx8IDAsXG4gICAgICAgICAgICBzb3VyY2VTdHViID0gX2p1LmlzQXJyYXkoc3R1YikgPyBzdHViWzBdIDogc3R1YixcbiAgICAgICAgICAgIHRhcmdldFN0dWIgPSBfanUuaXNBcnJheShzdHViKSA/IHN0dWJbMV0gOiBzdHViLFxuICAgICAgICAgICAgZ2FwID0gcGFyYW1zLmdhcCB8fCAwLFxuICAgICAgICAgICAgc291cmNlR2FwID0gX2p1LmlzQXJyYXkoZ2FwKSA/IGdhcFswXSA6IGdhcCxcbiAgICAgICAgICAgIHRhcmdldEdhcCA9IF9qdS5pc0FycmF5KGdhcCkgPyBnYXBbMV0gOiBnYXAsXG4gICAgICAgICAgICB1c2VyUHJvdmlkZWRTZWdtZW50cyA9IG51bGwsXG4gICAgICAgICAgICBlZGl0ZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIHBhaW50SW5mbyA9IG51bGwsXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG51bGwsXG4gICAgICAgICAgICBlZGl0YWJsZSA9IHBhcmFtcy5lZGl0YWJsZSAhPT0gZmFsc2UgJiYganNQbHVtYi5Db25uZWN0b3JFZGl0b3JzICE9IG51bGwgJiYganNQbHVtYi5Db25uZWN0b3JFZGl0b3JzW3RoaXMudHlwZV0gIT0gbnVsbDtcblxuICAgICAgICB2YXIgX3NldEdlb21ldHJ5ID0gdGhpcy5zZXRHZW9tZXRyeSA9IGZ1bmN0aW9uKGcsIGludGVybmFsbHlDb21wdXRlZCkge1xuICAgICAgICAgICAgZWRpdGVkID0gKCFpbnRlcm5hbGx5Q29tcHV0ZWQpO1xuICAgICAgICAgICAgZ2VvbWV0cnkgPSBnO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgX2dldEdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaGFzQmVlbkVkaXRlZCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZWRpdGVkOyB9O1xuICAgICAgICB0aGlzLmlzRWRpdGluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5lZGl0b3IgIT0gbnVsbCAmJiB0aGlzLmVkaXRvci5pc0FjdGl2ZSgpOyB9O1xuICAgICAgICB0aGlzLnNldEVkaXRhYmxlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBjb25uZWN0b3IgaGFzIGFuIGVkaXRvciBhbHJlYWR5LCBvclxuICAgICAgICAgICAgLy8gaWYgYW4gZWRpdG9yIGZvciB0aGlzIGNvbm5lY3RvcidzIHR5cGUgaXMgYXZhaWxhYmxlLCBvclxuICAgICAgICAgICAgLy8gaWYgdGhlIGNoaWxkIGRlY2xhcmVzIGFuIG92ZXJyaWRlU2V0RWRpdGFibGUgYW5kIGl0IGRvZXMgbm90IHJldHVybiBmYWxzZSwgZWRpdGFibGUgaXMgdHJ1ZS5cbiAgICAgICAgICAgIGlmIChlICYmIGpzUGx1bWIuQ29ubmVjdG9yRWRpdG9ycyAhPSBudWxsICYmIGpzUGx1bWIuQ29ubmVjdG9yRWRpdG9yc1t0aGlzLnR5cGVdICE9IG51bGwgJiYgKHRoaXMub3ZlcnJpZGVTZXRFZGl0YWJsZSA9PSBudWxsIHx8IHRoaXMub3ZlcnJpZGVTZXRFZGl0YWJsZSgpKSkge1xuICAgICAgICAgICAgICAgIGVkaXRhYmxlID0gZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlZGl0YWJsZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc0VkaXRhYmxlID0gZnVuY3Rpb24oKSB7IHJldHVybiBlZGl0YWJsZTsgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb246IGZpbmRTZWdtZW50Rm9yUG9pbnRcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2VnbWVudCB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIFt4LHldLFxuICAgICAgICAgKiBudWxsIGlmIG5vdGhpbmcgZm91bmQuICBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBKU1xuICAgICAgICAgKiBvYmplY3Qgd2l0aDpcbiAgICAgICAgICpcbiAgICAgICAgICogICBkICAgLSAgIGRpc3RhbmNlIGZyb20gc2VnbWVudFxuICAgICAgICAgKiAgIGwgICAtICAgcHJvcG9ydGlvbmFsIGxvY2F0aW9uIGluIHNlZ21lbnRcbiAgICAgICAgICogICB4ICAgLSAgIHggcG9pbnQgb24gdGhlIHNlZ21lbnRcbiAgICAgICAgICogICB5ICAgLSAgIHkgcG9pbnQgb24gdGhlIHNlZ21lbnRcbiAgICAgICAgICogICBzICAgLSAgIHRoZSBzZWdtZW50IGl0c2VsZi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmluZFNlZ21lbnRGb3JQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0geyBkOiBJbmZpbml0eSwgczogbnVsbCwgeDogbnVsbCwgeTogbnVsbCwgbDogbnVsbCB9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBfcyA9IHNlZ21lbnRzW2ldLmZpbmRDbG9zZXN0UG9pbnRPblBhdGgoeCwgeSk7XG4gICAgICAgICAgICAgICAgaWYgKF9zLmQgPCBvdXQuZCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQuZCA9IF9zLmQ7XG4gICAgICAgICAgICAgICAgICAgIG91dC5sID0gX3MubDtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnggPSBfcy54O1xuICAgICAgICAgICAgICAgICAgICBvdXQueSA9IF9zLnk7XG4gICAgICAgICAgICAgICAgICAgIG91dC5zID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIG91dC54MSA9IF9zLngxO1xuICAgICAgICAgICAgICAgICAgICBvdXQueDIgPSBfcy54MjtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnkxID0gX3MueTE7XG4gICAgICAgICAgICAgICAgICAgIG91dC55MiA9IF9zLnkyO1xuICAgICAgICAgICAgICAgICAgICBvdXQuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX3VwZGF0ZVNlZ21lbnRQcm9wb3J0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyTG9jID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbCA9IHNlZ21lbnRzW2ldLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50UHJvcG9ydGlvbmFsTGVuZ3Roc1tpXSA9IHNsIC8gdG90YWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRQcm9wb3J0aW9uc1tpXSA9IFtjdXJMb2MsIChjdXJMb2MgKz0gKHNsIC8gdG90YWxMZW5ndGgpKSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmV0dXJucyBbc2VnbWVudCwgcHJvcG9ydGlvbiBvZiB0cmF2ZWwgaW4gc2VnbWVudCwgc2VnbWVudCBpbmRleF0gZm9yIHRoZSBzZWdtZW50XG4gICAgICAgICAgICAgKiB0aGF0IGNvbnRhaW5zIHRoZSBwb2ludCB3aGljaCBpcyAnbG9jYXRpb24nIGRpc3RhbmNlIGFsb25nIHRoZSBlbnRpcmUgcGF0aCwgd2hlcmVcbiAgICAgICAgICAgICAqICdsb2NhdGlvbicgaXMgYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmUuIGluIHRoaXMgY29ubmVjdG9yIHR5cGUsIHBhdGhzXG4gICAgICAgICAgICAgKiBhcmUgbWFkZSB1cCBvZiBhIGxpc3Qgb2Ygc2VnbWVudHMsIGVhY2ggb2Ygd2hpY2ggY29udHJpYnV0ZXMgc29tZSBmcmFjdGlvbiB0b1xuICAgICAgICAgICAgICogdGhlIHRvdGFsIGxlbmd0aC5cbiAgICAgICAgICAgICAqIEZyb20gMS4zLjEwIHRoaXMgYWxzbyBzdXBwb3J0cyB0aGUgJ2Fic29sdXRlJyBwcm9wZXJ0eSwgd2hpY2ggbGV0cyB1cyBzcGVjaWZ5IGEgbG9jYXRpb25cbiAgICAgICAgICAgICAqIGFzIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBpbiBwaXhlbHMsIHJhdGhlciB0aGFuIGEgcHJvcG9ydGlvbiBvZiB0aGUgdG90YWwgcGF0aC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2ZpbmRTZWdtZW50Rm9yTG9jYXRpb24gPSBmdW5jdGlvbiAobG9jYXRpb24sIGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gPiAwID8gbG9jYXRpb24gLyB0b3RhbExlbmd0aCA6ICh0b3RhbExlbmd0aCArIGxvY2F0aW9uKSAvIHRvdGFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gc2VnbWVudFByb3BvcnRpb25zLmxlbmd0aCAtIDEsIGluU2VnbWVudFByb3BvcnRpb24gPSAxO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudFByb3BvcnRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50UHJvcG9ydGlvbnNbaV1bMV0gPj0gbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b2RvIGlzIHRoaXMgY29ycmVjdCBmb3IgYWxsIGNvbm5lY3RvciBwYXRoIHR5cGVzP1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5TZWdtZW50UHJvcG9ydGlvbiA9IGxvY2F0aW9uID09IDEgPyAxIDogbG9jYXRpb24gPT09IDAgPyAwIDogKGxvY2F0aW9uIC0gc2VnbWVudFByb3BvcnRpb25zW2ldWzBdKSAvIHNlZ21lbnRQcm9wb3J0aW9uYWxMZW5ndGhzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc2VnbWVudDogc2VnbWVudHNbaWR4XSwgcHJvcG9ydGlvbjogaW5TZWdtZW50UHJvcG9ydGlvbiwgaW5kZXg6IGlkeCB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hZGRTZWdtZW50ID0gZnVuY3Rpb24gKGNvbm4sIHR5cGUsIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMueDEgPT0gcGFyYW1zLngyICYmIHBhcmFtcy55MSA9PSBwYXJhbXMueTIpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG5ldyBfanAuU2VnbWVudHNbdHlwZV0ocGFyYW1zKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHMpO1xuICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IHMuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgY29ubi51cGRhdGVCb3VuZHMocyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NsZWFyU2VnbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGggPSBzZWdtZW50cy5sZW5ndGggPSBzZWdtZW50UHJvcG9ydGlvbnMubGVuZ3RoID0gc2VnbWVudFByb3BvcnRpb25hbExlbmd0aHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRTZWdtZW50cyA9IGZ1bmN0aW9uIChfc2Vncykge1xuICAgICAgICAgICAgdXNlclByb3ZpZGVkU2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3NlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB1c2VyUHJvdmlkZWRTZWdtZW50cy5wdXNoKF9zZWdzW2ldKTtcbiAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBfc2Vnc1tpXS5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfcHJlcGFyZUNvbXB1dGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IHBhcmFtcy5saW5lV2lkdGg7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IF9qZy5xdWFkcmFudChwYXJhbXMuc291cmNlUG9zLCBwYXJhbXMudGFyZ2V0UG9zKSxcbiAgICAgICAgICAgICAgICBzd2FwWCA9IHBhcmFtcy50YXJnZXRQb3NbMF0gPCBwYXJhbXMuc291cmNlUG9zWzBdLFxuICAgICAgICAgICAgICAgIHN3YXBZID0gcGFyYW1zLnRhcmdldFBvc1sxXSA8IHBhcmFtcy5zb3VyY2VQb3NbMV0sXG4gICAgICAgICAgICAgICAgbHcgPSBwYXJhbXMubGluZVdpZHRoIHx8IDEsXG4gICAgICAgICAgICAgICAgc28gPSBwYXJhbXMuc291cmNlRW5kcG9pbnQuYW5jaG9yLmdldE9yaWVudGF0aW9uKHBhcmFtcy5zb3VyY2VFbmRwb2ludCksXG4gICAgICAgICAgICAgICAgdG8gPSBwYXJhbXMudGFyZ2V0RW5kcG9pbnQuYW5jaG9yLmdldE9yaWVudGF0aW9uKHBhcmFtcy50YXJnZXRFbmRwb2ludCksXG4gICAgICAgICAgICAgICAgeCA9IHN3YXBYID8gcGFyYW1zLnRhcmdldFBvc1swXSA6IHBhcmFtcy5zb3VyY2VQb3NbMF0sXG4gICAgICAgICAgICAgICAgeSA9IHN3YXBZID8gcGFyYW1zLnRhcmdldFBvc1sxXSA6IHBhcmFtcy5zb3VyY2VQb3NbMV0sXG4gICAgICAgICAgICAgICAgdyA9IE1hdGguYWJzKHBhcmFtcy50YXJnZXRQb3NbMF0gLSBwYXJhbXMuc291cmNlUG9zWzBdKSxcbiAgICAgICAgICAgICAgICBoID0gTWF0aC5hYnMocGFyYW1zLnRhcmdldFBvc1sxXSAtIHBhcmFtcy5zb3VyY2VQb3NbMV0pO1xuXG4gICAgICAgICAgICAvLyBpZiBlaXRoZXIgYW5jaG9yIGRvZXMgbm90IGhhdmUgYW4gb3JpZW50YXRpb24gc2V0LCB3ZSBkZXJpdmUgb25lIGZyb20gdGhlaXIgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHBvc2l0aW9ucy4gIHdlIGZpeCB0aGUgYXhpcyB0byBiZSB0aGUgb25lIGluIHdoaWNoIHRoZSB0d28gZWxlbWVudHMgYXJlIGZ1cnRoZXIgYXBhcnQsIGFuZFxuICAgICAgICAgICAgLy8gcG9pbnQgZWFjaCBhbmNob3IgYXQgdGhlIG90aGVyIGVsZW1lbnQuICB0aGlzIGlzIGFsc28gdXNlZCB3aGVuIGRyYWdnaW5nIGEgbmV3IGNvbm5lY3Rpb24uXG4gICAgICAgICAgICBpZiAoc29bMF0gPT09IDAgJiYgc29bMV0gPT09IDAgfHwgdG9bMF0gPT09IDAgJiYgdG9bMV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB3ID4gaCA/IDAgOiAxLCBvSW5kZXggPSBbMSwgMF1baW5kZXhdO1xuICAgICAgICAgICAgICAgIHNvID0gW107XG4gICAgICAgICAgICAgICAgdG8gPSBbXTtcbiAgICAgICAgICAgICAgICBzb1tpbmRleF0gPSBwYXJhbXMuc291cmNlUG9zW2luZGV4XSA+IHBhcmFtcy50YXJnZXRQb3NbaW5kZXhdID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIHRvW2luZGV4XSA9IHBhcmFtcy5zb3VyY2VQb3NbaW5kZXhdID4gcGFyYW1zLnRhcmdldFBvc1tpbmRleF0gPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgc29bb0luZGV4XSA9IDA7XG4gICAgICAgICAgICAgICAgdG9bb0luZGV4XSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzeCA9IHN3YXBYID8gdyArIChzb3VyY2VHYXAgKiBzb1swXSkgOiBzb3VyY2VHYXAgKiBzb1swXSxcbiAgICAgICAgICAgICAgICBzeSA9IHN3YXBZID8gaCArIChzb3VyY2VHYXAgKiBzb1sxXSkgOiBzb3VyY2VHYXAgKiBzb1sxXSxcbiAgICAgICAgICAgICAgICB0eCA9IHN3YXBYID8gdGFyZ2V0R2FwICogdG9bMF0gOiB3ICsgKHRhcmdldEdhcCAqIHRvWzBdKSxcbiAgICAgICAgICAgICAgICB0eSA9IHN3YXBZID8gdGFyZ2V0R2FwICogdG9bMV0gOiBoICsgKHRhcmdldEdhcCAqIHRvWzFdKSxcbiAgICAgICAgICAgICAgICBvUHJvZHVjdCA9ICgoc29bMF0gKiB0b1swXSkgKyAoc29bMV0gKiB0b1sxXSkpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHN4OiBzeCwgc3k6IHN5LCB0eDogdHgsIHR5OiB0eSwgbHc6IGx3LFxuICAgICAgICAgICAgICAgIHhTcGFuOiBNYXRoLmFicyh0eCAtIHN4KSxcbiAgICAgICAgICAgICAgICB5U3BhbjogTWF0aC5hYnModHkgLSBzeSksXG4gICAgICAgICAgICAgICAgbXg6IChzeCArIHR4KSAvIDIsXG4gICAgICAgICAgICAgICAgbXk6IChzeSArIHR5KSAvIDIsXG4gICAgICAgICAgICAgICAgc286IHNvLCB0bzogdG8sIHg6IHgsIHk6IHksIHc6IHcsIGg6IGgsXG4gICAgICAgICAgICAgICAgc2VnbWVudDogc2VnbWVudCxcbiAgICAgICAgICAgICAgICBzdGFydFN0dWJYOiBzeCArIChzb1swXSAqIHNvdXJjZVN0dWIpLFxuICAgICAgICAgICAgICAgIHN0YXJ0U3R1Ylk6IHN5ICsgKHNvWzFdICogc291cmNlU3R1YiksXG4gICAgICAgICAgICAgICAgZW5kU3R1Ylg6IHR4ICsgKHRvWzBdICogdGFyZ2V0U3R1YiksXG4gICAgICAgICAgICAgICAgZW5kU3R1Ylk6IHR5ICsgKHRvWzFdICogdGFyZ2V0U3R1YiksXG4gICAgICAgICAgICAgICAgaXNYR3JlYXRlclRoYW5TdHViVGltZXMyOiBNYXRoLmFicyhzeCAtIHR4KSA+IChzb3VyY2VTdHViICsgdGFyZ2V0U3R1YiksXG4gICAgICAgICAgICAgICAgaXNZR3JlYXRlclRoYW5TdHViVGltZXMyOiBNYXRoLmFicyhzeSAtIHR5KSA+IChzb3VyY2VTdHViICsgdGFyZ2V0U3R1YiksXG4gICAgICAgICAgICAgICAgb3Bwb3NpdGU6IG9Qcm9kdWN0ID09IC0xLFxuICAgICAgICAgICAgICAgIHBlcnBlbmRpY3VsYXI6IG9Qcm9kdWN0ID09PSAwLFxuICAgICAgICAgICAgICAgIG9ydGhvZ29uYWw6IG9Qcm9kdWN0ID09IDEsXG4gICAgICAgICAgICAgICAgc291cmNlQXhpczogc29bMF0gPT09IDAgPyBcInlcIiA6IFwieFwiLFxuICAgICAgICAgICAgICAgIHBvaW50czogW3gsIHksIHcsIGgsIHN4LCBzeSwgdHgsIHR5IF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHQuYW5jaG9yT3JpZW50YXRpb24gPSByZXN1bHQub3Bwb3NpdGUgPyBcIm9wcG9zaXRlXCIgOiByZXN1bHQub3J0aG9nb25hbCA/IFwib3J0aG9nb25hbFwiIDogXCJwZXJwZW5kaWN1bGFyXCI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0U2VnbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICAgICAgdmFyIHNlZ0JvdW5kcyA9IHNlZ21lbnQuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcy5taW5YID0gTWF0aC5taW4odGhpcy5ib3VuZHMubWluWCwgc2VnQm91bmRzLm1pblgpO1xuICAgICAgICAgICAgdGhpcy5ib3VuZHMubWF4WCA9IE1hdGgubWF4KHRoaXMuYm91bmRzLm1heFgsIHNlZ0JvdW5kcy5tYXhYKTtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzLm1pblkgPSBNYXRoLm1pbih0aGlzLmJvdW5kcy5taW5ZLCBzZWdCb3VuZHMubWluWSk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcy5tYXhZID0gTWF0aC5tYXgodGhpcy5ib3VuZHMubWF4WSwgc2VnQm91bmRzLm1heFkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkdW1wU2VnbWVudHNUb0NvbnNvbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNFR01FTlRTOlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzZWdtZW50c1tpXS50eXBlLCBzZWdtZW50c1tpXS5nZXRMZW5ndGgoKSwgc2VnbWVudFByb3BvcnRpb25zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBvaW50T25QYXRoID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBhYnNvbHV0ZSkge1xuICAgICAgICAgICAgdmFyIHNlZyA9IF9maW5kU2VnbWVudEZvckxvY2F0aW9uKGxvY2F0aW9uLCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICByZXR1cm4gc2VnLnNlZ21lbnQgJiYgc2VnLnNlZ21lbnQucG9pbnRPblBhdGgoc2VnLnByb3BvcnRpb24sIGZhbHNlKSB8fCBbMCwgMF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ncmFkaWVudEF0UG9pbnQgPSBmdW5jdGlvbiAobG9jYXRpb24sIGFic29sdXRlKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gX2ZpbmRTZWdtZW50Rm9yTG9jYXRpb24obG9jYXRpb24sIGFic29sdXRlKTtcbiAgICAgICAgICAgIHJldHVybiBzZWcuc2VnbWVudCAmJiBzZWcuc2VnbWVudC5ncmFkaWVudEF0UG9pbnQoc2VnLnByb3BvcnRpb24sIGZhbHNlKSB8fCAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucG9pbnRBbG9uZ1BhdGhGcm9tID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBkaXN0YW5jZSwgYWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBfZmluZFNlZ21lbnRGb3JMb2NhdGlvbihsb2NhdGlvbiwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgLy8gVE9ETyB3aGF0IGhhcHBlbnMgaWYgdGhpcyBjcm9zc2VzIHRvIHRoZSBuZXh0IHNlZ21lbnQ/XG4gICAgICAgICAgICByZXR1cm4gc2VnLnNlZ21lbnQgJiYgc2VnLnNlZ21lbnQucG9pbnRBbG9uZ1BhdGhGcm9tKHNlZy5wcm9wb3J0aW9uLCBkaXN0YW5jZSwgZmFsc2UpIHx8IFswLCAwXTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNvbXB1dGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICBwYWludEluZm8gPSBfcHJlcGFyZUNvbXB1dGUuY2FsbCh0aGlzLCBwYXJhbXMpO1xuXG4gICAgICAgICAgICBfY2xlYXJTZWdtZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZShwYWludEluZm8sIHBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLnggPSBwYWludEluZm8ucG9pbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy55ID0gcGFpbnRJbmZvLnBvaW50c1sxXTtcbiAgICAgICAgICAgIHRoaXMudyA9IHBhaW50SW5mby5wb2ludHNbMl07XG4gICAgICAgICAgICB0aGlzLmggPSBwYWludEluZm8ucG9pbnRzWzNdO1xuICAgICAgICAgICAgdGhpcy5zZWdtZW50ID0gcGFpbnRJbmZvLnNlZ21lbnQ7XG4gICAgICAgICAgICBfdXBkYXRlU2VnbWVudFByb3BvcnRpb25zKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZFNlZ21lbnQ6IF9hZGRTZWdtZW50LFxuICAgICAgICAgICAgcHJlcGFyZUNvbXB1dGU6IF9wcmVwYXJlQ29tcHV0ZSxcbiAgICAgICAgICAgIHNvdXJjZVN0dWI6IHNvdXJjZVN0dWIsXG4gICAgICAgICAgICB0YXJnZXRTdHViOiB0YXJnZXRTdHViLFxuICAgICAgICAgICAgbWF4U3R1YjogTWF0aC5tYXgoc291cmNlU3R1YiwgdGFyZ2V0U3R1YiksXG4gICAgICAgICAgICBzb3VyY2VHYXA6IHNvdXJjZUdhcCxcbiAgICAgICAgICAgIHRhcmdldEdhcDogdGFyZ2V0R2FwLFxuICAgICAgICAgICAgbWF4R2FwOiBNYXRoLm1heChzb3VyY2VHYXAsIHRhcmdldEdhcCksXG4gICAgICAgICAgICBzZXRHZW9tZXRyeTpfc2V0R2VvbWV0cnksXG4gICAgICAgICAgICBnZXRHZW9tZXRyeTpfZ2V0R2VvbWV0cnlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RDb25uZWN0b3IsIEFic3RyYWN0Q29tcG9uZW50KTtcblxuICAgIC8qKlxuICAgICAqIENsYXNzOiBDb25uZWN0b3JzLlN0cmFpZ2h0XG4gICAgICogVGhlIFN0cmFpZ2h0IGNvbm5lY3RvciBkcmF3cyBhIHNpbXBsZSBzdHJhaWdodCBsaW5lIGJldHdlZW4gdGhlIHR3byBhbmNob3IgcG9pbnRzLiAgSXQgZG9lcyBub3QgaGF2ZSBhbnkgY29uc3RydWN0b3IgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICB2YXIgU3RyYWlnaHQgPSBfanAuQ29ubmVjdG9ycy5TdHJhaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50eXBlID0gXCJTdHJhaWdodFwiO1xuICAgICAgICB2YXIgX3N1cGVyID0gX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RDb25uZWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICB0aGlzLl9jb21wdXRlID0gZnVuY3Rpb24gKHBhaW50SW5mbywgXykge1xuICAgICAgICAgICAgX3N1cGVyLmFkZFNlZ21lbnQodGhpcywgXCJTdHJhaWdodFwiLCB7eDE6IHBhaW50SW5mby5zeCwgeTE6IHBhaW50SW5mby5zeSwgeDI6IHBhaW50SW5mby5zdGFydFN0dWJYLCB5MjogcGFpbnRJbmZvLnN0YXJ0U3R1Yll9KTtcbiAgICAgICAgICAgIF9zdXBlci5hZGRTZWdtZW50KHRoaXMsIFwiU3RyYWlnaHRcIiwge3gxOiBwYWludEluZm8uc3RhcnRTdHViWCwgeTE6IHBhaW50SW5mby5zdGFydFN0dWJZLCB4MjogcGFpbnRJbmZvLmVuZFN0dWJYLCB5MjogcGFpbnRJbmZvLmVuZFN0dWJZfSk7XG4gICAgICAgICAgICBfc3VwZXIuYWRkU2VnbWVudCh0aGlzLCBcIlN0cmFpZ2h0XCIsIHt4MTogcGFpbnRJbmZvLmVuZFN0dWJYLCB5MTogcGFpbnRJbmZvLmVuZFN0dWJZLCB4MjogcGFpbnRJbmZvLnR4LCB5MjogcGFpbnRJbmZvLnR5fSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfanUuZXh0ZW5kKF9qcC5Db25uZWN0b3JzLlN0cmFpZ2h0LCBfanAuQ29ubmVjdG9ycy5BYnN0cmFjdENvbm5lY3Rvcik7XG4gICAgX2pwLnJlZ2lzdGVyQ29ubmVjdG9yVHlwZShTdHJhaWdodCwgXCJTdHJhaWdodFwiKTtcblxuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBPRiBDT05ORUNUT1IgVFlQRVMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORFBPSU5UIFRZUEVTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIF9qcC5FbmRwb2ludHMuQWJzdHJhY3RFbmRwb2ludCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgQWJzdHJhY3RDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNvbXB1dGUgPSB0aGlzLmNvbXB1dGUgPSBmdW5jdGlvbiAoYW5jaG9yUG9pbnQsIG9yaWVudGF0aW9uLCBlbmRwb2ludFN0eWxlLCBjb25uZWN0b3JQYWludFN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gdGhpcy5fY29tcHV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy54ID0gb3V0WzBdO1xuICAgICAgICAgICAgdGhpcy55ID0gb3V0WzFdO1xuICAgICAgICAgICAgdGhpcy53ID0gb3V0WzJdO1xuICAgICAgICAgICAgdGhpcy5oID0gb3V0WzNdO1xuICAgICAgICAgICAgdGhpcy5ib3VuZHMubWluWCA9IHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzLm1pblkgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcy5tYXhYID0gdGhpcy54ICsgdGhpcy53O1xuICAgICAgICAgICAgdGhpcy5ib3VuZHMubWF4WSA9IHRoaXMueSArIHRoaXMuaDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21wdXRlOiBjb21wdXRlLFxuICAgICAgICAgICAgY3NzQ2xhc3M6IHBhcmFtcy5jc3NDbGFzc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQsIEFic3RyYWN0Q29tcG9uZW50KTtcblxuICAgIC8qKlxuICAgICAqIENsYXNzOiBFbmRwb2ludHMuRG90XG4gICAgICogQSByb3VuZCBlbmRwb2ludCwgd2l0aCBkZWZhdWx0IHJhZGl1cyAxMCBwaXhlbHMuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbjogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKiAgICByYWRpdXMgICAgLSAgICByYWRpdXMgb2YgdGhlIGVuZHBvaW50LiAgZGVmYXVsdHMgdG8gMTAgcGl4ZWxzLlxuICAgICAqL1xuICAgIF9qcC5FbmRwb2ludHMuRG90ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkRvdFwiO1xuICAgICAgICB2YXIgX3N1cGVyID0gX2pwLkVuZHBvaW50cy5BYnN0cmFjdEVuZHBvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSBwYXJhbXMucmFkaXVzIHx8IDEwO1xuICAgICAgICB0aGlzLmRlZmF1bHRPZmZzZXQgPSAwLjUgKiB0aGlzLnJhZGl1cztcbiAgICAgICAgdGhpcy5kZWZhdWx0SW5uZXJSYWRpdXMgPSB0aGlzLnJhZGl1cyAvIDM7XG5cbiAgICAgICAgdGhpcy5fY29tcHV0ZSA9IGZ1bmN0aW9uIChhbmNob3JQb2ludCwgb3JpZW50YXRpb24sIGVuZHBvaW50U3R5bGUsIGNvbm5lY3RvclBhaW50U3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gZW5kcG9pbnRTdHlsZS5yYWRpdXMgfHwgdGhpcy5yYWRpdXM7XG4gICAgICAgICAgICB2YXIgeCA9IGFuY2hvclBvaW50WzBdIC0gdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgeSA9IGFuY2hvclBvaW50WzFdIC0gdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgdyA9IHRoaXMucmFkaXVzICogMixcbiAgICAgICAgICAgICAgICBoID0gdGhpcy5yYWRpdXMgKiAyO1xuXG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRTdHlsZS5zdHJva2VTdHlsZSkge1xuICAgICAgICAgICAgICAgIHZhciBsdyA9IGVuZHBvaW50U3R5bGUubGluZVdpZHRoIHx8IDE7XG4gICAgICAgICAgICAgICAgeCAtPSBsdztcbiAgICAgICAgICAgICAgICB5IC09IGx3O1xuICAgICAgICAgICAgICAgIHcgKz0gKGx3ICogMik7XG4gICAgICAgICAgICAgICAgaCArPSAobHcgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbIHgsIHksIHcsIGgsIHRoaXMucmFkaXVzIF07XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfanUuZXh0ZW5kKF9qcC5FbmRwb2ludHMuRG90LCBfanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQpO1xuXG4gICAgX2pwLkVuZHBvaW50cy5SZWN0YW5nbGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiUmVjdGFuZ2xlXCI7XG4gICAgICAgIHZhciBfc3VwZXIgPSBfanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB0aGlzLndpZHRoID0gcGFyYW1zLndpZHRoIHx8IDIwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQgfHwgMjA7XG5cbiAgICAgICAgdGhpcy5fY29tcHV0ZSA9IGZ1bmN0aW9uIChhbmNob3JQb2ludCwgb3JpZW50YXRpb24sIGVuZHBvaW50U3R5bGUsIGNvbm5lY3RvclBhaW50U3R5bGUpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGVuZHBvaW50U3R5bGUud2lkdGggfHwgdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBlbmRwb2ludFN0eWxlLmhlaWdodCB8fCB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICB4ID0gYW5jaG9yUG9pbnRbMF0gLSAod2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICB5ID0gYW5jaG9yUG9pbnRbMV0gLSAoaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgICAgIHJldHVybiBbIHgsIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuRW5kcG9pbnRzLlJlY3RhbmdsZSwgX2pwLkVuZHBvaW50cy5BYnN0cmFjdEVuZHBvaW50KTtcblxuICAgIHZhciBET01FbGVtZW50RW5kcG9pbnQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIF9qcC5qc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5kaXNwbGF5RWxlbWVudHMgPSBbXTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoRE9NRWxlbWVudEVuZHBvaW50LCBfanAuanNQbHVtYlVJQ29tcG9uZW50LCB7XG4gICAgICAgIGdldERpc3BsYXlFbGVtZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIuZGlzcGxheUVsZW1lbnRzO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmREaXNwbGF5RWxlbWVudDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmRpc3BsYXlFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3M6IEVuZHBvaW50cy5JbWFnZVxuICAgICAqIERyYXdzIGFuIGltYWdlIGFzIHRoZSBFbmRwb2ludC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbjogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKiAgICBzcmMgICAgLSAgICBsb2NhdGlvbiBvZiB0aGUgaW1hZ2UgdG8gdXNlLlxuXG4gICAgIFRPRE86IG11bHRpcGxlIHJlZmVyZW5jZXMgdG8gc2VsZi4gbm90IHN1cmUgcXVpdGUgaG93IHRvIGdldCByaWQgb2YgdGhlbSBlbnRpcmVseS4gcGVyaGFwcyBzZWxmID0gbnVsbCBpbiB0aGUgY2xlYW51cFxuICAgICBmdW5jdGlvbiB3aWxsIHN1ZmZpY2VcblxuICAgICBUT0RPIHRoaXMgY2xhc3Mgc3RpbGwgbWlnaHQgbGVhayBtZW1vcnkuXG5cbiAgICAgKi9cbiAgICBfanAuRW5kcG9pbnRzLkltYWdlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuXG4gICAgICAgIHRoaXMudHlwZSA9IFwiSW1hZ2VcIjtcbiAgICAgICAgRE9NRWxlbWVudEVuZHBvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIF9qcC5FbmRwb2ludHMuQWJzdHJhY3RFbmRwb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHZhciBfb25sb2FkID0gcGFyYW1zLm9ubG9hZCxcbiAgICAgICAgICAgIHNyYyA9IHBhcmFtcy5zcmMgfHwgcGFyYW1zLnVybCxcbiAgICAgICAgICAgIGNsYXp6ID0gcGFyYW1zLmNzc0NsYXNzID8gXCIgXCIgKyBwYXJhbXMuY3NzQ2xhc3MgOiBcIlwiO1xuXG4gICAgICAgIHRoaXMuX2pzUGx1bWIuaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIucmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanNQbHVtYi53aWR0aFRvVXNlID0gcGFyYW1zLndpZHRoO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmhlaWdodFRvVXNlID0gcGFyYW1zLmhlaWdodDtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5lbmRwb2ludCA9IHBhcmFtcy5lbmRwb2ludDtcblxuICAgICAgICB0aGlzLl9qc1BsdW1iLmltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi53aWR0aFRvVXNlID0gdGhpcy5fanNQbHVtYi53aWR0aFRvVXNlIHx8IHRoaXMuX2pzUGx1bWIuaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuaGVpZ2h0VG9Vc2UgPSB0aGlzLl9qc1BsdW1iLmhlaWdodFRvVXNlIHx8IHRoaXMuX2pzUGx1bWIuaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoX29ubG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBfb25sb2FkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICBGdW5jdGlvbjogc2V0SW1hZ2VcbiAgICAgICAgIFNldHMgdGhlIEltYWdlIHRvIHVzZSBpbiB0aGlzIEVuZHBvaW50LlxuXG4gICAgICAgICBQYXJhbWV0ZXJzOlxuICAgICAgICAgaW1nICAgICAgICAgLSAgIG1heSBiZSBhIFVSTCBvciBhbiBJbWFnZSBvYmplY3RcbiAgICAgICAgIG9ubG9hZCAgICAgIC0gICBvcHRpb25hbDsgYSBjYWxsYmFjayB0byBleGVjdXRlIG9uY2UgdGhlIGltYWdlIGhhcyBsb2FkZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmVuZHBvaW50LnNldEltYWdlID0gZnVuY3Rpb24gKF9pbWcsIG9ubG9hZCkge1xuICAgICAgICAgICAgdmFyIHMgPSBfaW1nLmNvbnN0cnVjdG9yID09IFN0cmluZyA/IF9pbWcgOiBfaW1nLnNyYztcbiAgICAgICAgICAgIF9vbmxvYWQgPSBvbmxvYWQ7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmltZy5zcmMgPSBzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdGhpcy5fanNQbHVtYi5pbWcuc3JjKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2pzUGx1bWIuZW5kcG9pbnQuc2V0SW1hZ2Uoc3JjLCBfb25sb2FkKTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZSA9IGZ1bmN0aW9uIChhbmNob3JQb2ludCwgb3JpZW50YXRpb24sIGVuZHBvaW50U3R5bGUsIGNvbm5lY3RvclBhaW50U3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBhbmNob3JQb2ludDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iLnJlYWR5KSByZXR1cm4gW2FuY2hvclBvaW50WzBdIC0gdGhpcy5fanNQbHVtYi53aWR0aFRvVXNlIC8gMiwgYW5jaG9yUG9pbnRbMV0gLSB0aGlzLl9qc1BsdW1iLmhlaWdodFRvVXNlIC8gMixcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLndpZHRoVG9Vc2UsIHRoaXMuX2pzUGx1bWIuaGVpZ2h0VG9Vc2VdO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY2FudmFzID0ganNQbHVtYi5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOlwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIG1hcmdpbjowLFxuICAgICAgICAgICAgcGFkZGluZzowLFxuICAgICAgICAgICAgb3V0bGluZTowXG4gICAgICAgIH0sIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZW5kcG9pbnRDbGFzcyArIGNsYXp6KTtcblxuICAgICAgICBpZiAodGhpcy5fanNQbHVtYi53aWR0aFRvVXNlKSB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB0aGlzLl9qc1BsdW1iLndpZHRoVG9Vc2UpO1xuICAgICAgICBpZiAodGhpcy5fanNQbHVtYi5oZWlnaHRUb1VzZSkgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHRoaXMuX2pzUGx1bWIuaGVpZ2h0VG9Vc2UpO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmFwcGVuZEVsZW1lbnQodGhpcy5jYW52YXMpO1xuXG4gICAgICAgIHRoaXMuYWN0dWFsbHlQYWludCA9IGZ1bmN0aW9uIChkLCBzdHlsZSwgYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2pzUGx1bWIuZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fanNQbHVtYi5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdGhpcy5fanNQbHVtYi5pbWcuc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmREaXNwbGF5RWxlbWVudCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuYW5jaG9yUG9pbnRbMF0gLSAodGhpcy5fanNQbHVtYi53aWR0aFRvVXNlIC8gMiksXG4gICAgICAgICAgICAgICAgICAgIHkgPSB0aGlzLmFuY2hvclBvaW50WzFdIC0gKHRoaXMuX2pzUGx1bWIuaGVpZ2h0VG9Vc2UgLyAyKTtcbiAgICAgICAgICAgICAgICBfanUuc2l6ZUVsZW1lbnQodGhpcy5jYW52YXMsIHgsIHksIHRoaXMuX2pzUGx1bWIud2lkdGhUb1VzZSwgdGhpcy5fanNQbHVtYi5oZWlnaHRUb1VzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wYWludCA9IGZ1bmN0aW9uIChzdHlsZSwgYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYiAhPSBudWxsKSB7ICAvLyBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYi5yZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbGx5UGFpbnQoc3R5bGUsIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb290LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWludChzdHlsZSwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAyMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLkVuZHBvaW50cy5JbWFnZSwgWyBET01FbGVtZW50RW5kcG9pbnQsIF9qcC5FbmRwb2ludHMuQWJzdHJhY3RFbmRwb2ludCBdLCB7XG4gICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5kZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW52YXMpIHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKiBDbGFzczogRW5kcG9pbnRzLkJsYW5rXG4gICAgICogQW4gRW5kcG9pbnQgdGhhdCBwYWludHMgbm90aGluZyAodmlzaWJsZSkgb24gdGhlIHNjcmVlbi4gIFN1cHBvcnRzIGNzc0NsYXNzIGFuZCBob3ZlckNsYXNzIHBhcmFtZXRlcnMgbGlrZSBhbGwgRW5kcG9pbnRzLlxuICAgICAqL1xuICAgIF9qcC5FbmRwb2ludHMuQmxhbmsgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfc3VwZXIgPSBfanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJCbGFua1wiO1xuICAgICAgICBET01FbGVtZW50RW5kcG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZSA9IGZ1bmN0aW9uIChhbmNob3JQb2ludCwgb3JpZW50YXRpb24sIGVuZHBvaW50U3R5bGUsIGNvbm5lY3RvclBhaW50U3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbYW5jaG9yUG9pbnRbMF0sIGFuY2hvclBvaW50WzFdLCAxMCwgMF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNsYXp6ID0gcGFyYW1zLmNzc0NsYXNzID8gXCIgXCIgKyBwYXJhbXMuY3NzQ2xhc3MgOiBcIlwiO1xuXG4gICAgICAgIHRoaXMuY2FudmFzID0ganNQbHVtYi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgICAgIHdpZHRoOiBcIjFweFwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjFweFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgICAgICB9LCB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmVuZHBvaW50Q2xhc3MgKyBjbGF6eik7XG5cbiAgICAgICAgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5hcHBlbmRFbGVtZW50KHRoaXMuY2FudmFzKTtcblxuICAgICAgICB0aGlzLnBhaW50ID0gZnVuY3Rpb24gKHN0eWxlLCBhbmNob3IpIHtcbiAgICAgICAgICAgIF9qdS5zaXplRWxlbWVudCh0aGlzLmNhbnZhcywgdGhpcy54LCB0aGlzLnksIHRoaXMudywgdGhpcy5oKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLkVuZHBvaW50cy5CbGFuaywgW19qcC5FbmRwb2ludHMuQWJzdHJhY3RFbmRwb2ludCwgRE9NRWxlbWVudEVuZHBvaW50XSwge1xuICAgICAgICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICAqIENsYXNzOiBFbmRwb2ludHMuVHJpYW5nbGVcbiAgICAgKiBBIHRyaWFuZ3VsYXIgRW5kcG9pbnQuXG4gICAgICovXG4gICAgLypcbiAgICAgKiBGdW5jdGlvbjogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKiBcdHdpZHRoXHQtXHR3aWR0aCBvZiB0aGUgdHJpYW5nbGUncyBiYXNlLiAgZGVmYXVsdHMgdG8gNTUgcGl4ZWxzLlxuICAgICAqIFx0aGVpZ2h0XHQtXHRoZWlnaHQgb2YgdGhlIHRyaWFuZ2xlIGZyb20gYmFzZSB0byBhcGV4LiAgZGVmYXVsdHMgdG8gNTUgcGl4ZWxzLlxuICAgICAqL1xuICAgIF9qcC5FbmRwb2ludHMuVHJpYW5nbGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiVHJpYW5nbGVcIjtcbiAgICAgICAgX2pwLkVuZHBvaW50cy5BYnN0cmFjdEVuZHBvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7ICB9O1xuICAgICAgICBwYXJhbXMud2lkdGggPSBwYXJhbXMud2lkdGggfHwgNTU7XG4gICAgICAgIHBhcmFtcy5oZWlnaHQgPSBwYXJhbXMuaGVpZ2h0IHx8IDU1O1xuICAgICAgICB0aGlzLndpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2NvbXB1dGUgPSBmdW5jdGlvbiAoYW5jaG9yUG9pbnQsIG9yaWVudGF0aW9uLCBlbmRwb2ludFN0eWxlLCBjb25uZWN0b3JQYWludFN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBlbmRwb2ludFN0eWxlLndpZHRoIHx8IHNlbGYud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gZW5kcG9pbnRTdHlsZS5oZWlnaHQgfHwgc2VsZi5oZWlnaHQsXG4gICAgICAgICAgICAgICAgeCA9IGFuY2hvclBvaW50WzBdIC0gKHdpZHRoIC8gMiksXG4gICAgICAgICAgICAgICAgeSA9IGFuY2hvclBvaW50WzFdIC0gKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgcmV0dXJuIFsgeCwgeSwgd2lkdGgsIGhlaWdodCBdO1xuICAgICAgICB9O1xuICAgIH07XG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRU5EIE9GIEVORFBPSU5UIFRZUEVTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogT1ZFUkxBWSBERUZJTklUSU9OUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgICBcblxuICAgIHZhciBBYnN0cmFjdE92ZXJsYXkgPSBfanAuT3ZlcmxheXMuQWJzdHJhY3RPdmVybGF5ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzQXBwZW5kZWRBdFRvcExldmVsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBwYXJhbXMuY29tcG9uZW50O1xuICAgICAgICB0aGlzLmxvYyA9IHBhcmFtcy5sb2NhdGlvbiA9PSBudWxsID8gMC41IDogcGFyYW1zLmxvY2F0aW9uO1xuICAgICAgICB0aGlzLmVuZHBvaW50TG9jID0gcGFyYW1zLmVuZHBvaW50TG9jYXRpb24gPT0gbnVsbCA/IFsgMC41LCAwLjVdIDogcGFyYW1zLmVuZHBvaW50TG9jYXRpb247XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHBhcmFtcy52aXNpYmxlICE9PSBmYWxzZTtcbiAgICB9O1xuICAgIEFic3RyYWN0T3ZlcmxheS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50TG9jID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhdHRhY2g6ZnVuY3Rpb24oaW5zdGFuY2UpIHtcblxuICAgICAgICB9LFxuICAgICAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSB2YWw7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5yZXBhaW50KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzVmlzaWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZTtcbiAgICAgICAgfSxcbiAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWaXNpYmxlKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBpbmNyZW1lbnRMb2NhdGlvbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgdGhpcy5sb2MgKz0gYW1vdW50O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVwYWludCgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRMb2NhdGlvbjogZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHRoaXMubG9jID0gbDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnJlcGFpbnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYztcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlRnJvbTpmdW5jdGlvbigpIHsgfVxuICAgIH07XG5cblxuICAgIC8qXG4gICAgICogQ2xhc3M6IE92ZXJsYXlzLkFycm93XG4gICAgICpcbiAgICAgKiBBbiBhcnJvdyBvdmVybGF5LCBkZWZpbmVkIGJ5IGZvdXIgcG9pbnRzOiB0aGUgaGVhZCwgdGhlIHR3byBzaWRlcyBvZiB0aGUgdGFpbCwgYW5kIGEgJ2ZvbGRiYWNrJyBwb2ludCBhdCBzb21lIGRpc3RhbmNlIGFsb25nIHRoZSBsZW5ndGhcbiAgICAgKiBvZiB0aGUgYXJyb3cgdGhhdCBsaW5lcyBmcm9tIGVhY2ggdGFpbCBwb2ludCBjb252ZXJnZSBpbnRvLiAgVGhlIGZvbGRiYWNrIHBvaW50IGlzIGRlZmluZWQgdXNpbmcgYSBkZWNpbWFsIHRoYXQgaW5kaWNhdGVzIHNvbWUgZnJhY3Rpb25cbiAgICAgKiBvZiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJvdyBhbmQgaGFzIGEgZGVmYXVsdCB2YWx1ZSBvZiAwLjYyMy4gIEEgZm9sZGJhY2sgcG9pbnQgdmFsdWUgb2YgMSB3b3VsZCBtZWFuIHRoYXQgdGhlIGFycm93IGhhZCBhIHN0cmFpZ2h0IGxpbmVcbiAgICAgKiBhY3Jvc3MgdGhlIHRhaWwuXG4gICAgICovXG4gICAgLypcbiAgICAgKiBGdW5jdGlvbjogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKiBcdGxlbmd0aCAtIGRpc3RhbmNlIGluIHBpeGVscyBmcm9tIGhlYWQgdG8gdGFpbCBiYXNlbGluZS4gZGVmYXVsdCAyMC5cbiAgICAgKiBcdHdpZHRoIC0gd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSB0YWlsIGJhc2VsaW5lLiBkZWZhdWx0IDIwLlxuICAgICAqIFx0ZmlsbFN0eWxlIC0gc3R5bGUgdG8gdXNlIHdoZW4gZmlsbGluZyB0aGUgYXJyb3cuICBkZWZhdWx0cyB0byBcImJsYWNrXCIuXG4gICAgICogXHRzdHJva2VTdHlsZSAtIHN0eWxlIHRvIHVzZSB3aGVuIHN0cm9raW5nIHRoZSBhcnJvdy4gZGVmYXVsdHMgdG8gbnVsbCwgd2hpY2ggbWVhbnMgdGhlIGFycm93IGlzIG5vdCBzdHJva2VkLlxuICAgICAqIFx0bGluZVdpZHRoIC0gbGluZSB3aWR0aCB0byB1c2Ugd2hlbiBzdHJva2luZyB0aGUgYXJyb3cuIGRlZmF1bHRzIHRvIDEsIGJ1dCBvbmx5IHVzZWQgaWYgc3Ryb2tlU3R5bGUgaXMgbm90IG51bGwuXG4gICAgICogXHRmb2xkYmFjayAtIGRpc3RhbmNlIChhcyBhIGRlY2ltYWwgZnJvbSAwIHRvIDEgaW5jbHVzaXZlKSBhbG9uZyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJvdyBtYXJraW5nIHRoZSBwb2ludCB0aGUgdGFpbCBwb2ludHMgc2hvdWxkIGZvbGQgYmFjayB0by4gIGRlZmF1bHRzIHRvIDAuNjIzLlxuICAgICAqIFx0bG9jYXRpb24gLSBkaXN0YW5jZSAoYXMgYSBkZWNpbWFsIGZyb20gMCB0byAxIGluY2x1c2l2ZSkgbWFya2luZyB3aGVyZSB0aGUgYXJyb3cgc2hvdWxkIHNpdCBvbiB0aGUgY29ubmVjdG9yLiBkZWZhdWx0cyB0byAwLjUuXG4gICAgICogXHRkaXJlY3Rpb24gLSBpbmRpY2F0ZXMgdGhlIGRpcmVjdGlvbiB0aGUgYXJyb3cgcG9pbnRzIGluLiB2YWxpZCB2YWx1ZXMgYXJlIC0xIGFuZCAxOyAxIGlzIGRlZmF1bHQuXG4gICAgICovXG4gICAgX2pwLk92ZXJsYXlzLkFycm93ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkFycm93XCI7XG4gICAgICAgIEFic3RyYWN0T3ZlcmxheS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlzQXBwZW5kZWRBdFRvcExldmVsID0gZmFsc2U7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgICAgICB0aGlzLmxlbmd0aCA9IHBhcmFtcy5sZW5ndGggfHwgMjA7XG4gICAgICAgIHRoaXMud2lkdGggPSBwYXJhbXMud2lkdGggfHwgMjA7XG4gICAgICAgIHRoaXMuaWQgPSBwYXJhbXMuaWQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSAocGFyYW1zLmRpcmVjdGlvbiB8fCAxKSA8IDAgPyAtMSA6IDEsXG4gICAgICAgICAgICBwYWludFN0eWxlID0gcGFyYW1zLnBhaW50U3R5bGUgfHwgeyBsaW5lV2lkdGg6IDEgfSxcbiAgICAgICAgLy8gaG93IGZhciBhbG9uZyB0aGUgYXJyb3cgdGhlIGxpbmVzIGZvbGRpbmcgYmFjayBpbiBjb21lIHRvLiBkZWZhdWx0IGlzIDYyLjMlLlxuICAgICAgICAgICAgZm9sZGJhY2sgPSBwYXJhbXMuZm9sZGJhY2sgfHwgMC42MjM7XG5cbiAgICAgICAgdGhpcy5jb21wdXRlTWF4U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLndpZHRoICogMS41O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZWxlbWVudENyZWF0ZWQgPSBmdW5jdGlvbihwLCBjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHA7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmV2ZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcGFyYW1zLmV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBqc1BsdW1iLm9uKHAsIGksIHBhcmFtcy5ldmVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBjdXJyZW50Q29ubmVjdGlvblBhaW50U3R5bGUpIHtcblxuICAgICAgICAgICAgdmFyIGh4eSwgbWlkLCB0eHksIHRhaWwsIGN4eTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQucG9pbnRBbG9uZ1BhdGhGcm9tKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2p1LmlzU3RyaW5nKHRoaXMubG9jKSB8fCB0aGlzLmxvYyA+IDEgfHwgdGhpcy5sb2MgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsID0gcGFyc2VJbnQodGhpcy5sb2MsIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21Mb2MgPSB0aGlzLmxvYyA8IDAgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgaHh5ID0gY29tcG9uZW50LnBvaW50QWxvbmdQYXRoRnJvbShmcm9tTG9jLCBsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG1pZCA9IGNvbXBvbmVudC5wb2ludEFsb25nUGF0aEZyb20oZnJvbUxvYywgbCAtIChkaXJlY3Rpb24gKiB0aGlzLmxlbmd0aCAvIDIpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHR4eSA9IF9qZy5wb2ludE9uTGluZShoeHksIG1pZCwgdGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxvYyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGh4eSA9IGNvbXBvbmVudC5wb2ludE9uUGF0aCh0aGlzLmxvYyk7XG4gICAgICAgICAgICAgICAgICAgIG1pZCA9IGNvbXBvbmVudC5wb2ludEFsb25nUGF0aEZyb20odGhpcy5sb2MsIC0odGhpcy5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgdHh5ID0gX2pnLnBvaW50T25MaW5lKGh4eSwgbWlkLCB0aGlzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF8gPSB0eHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eHkgPSBoeHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoeHkgPSBfO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9jID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4eSA9IGNvbXBvbmVudC5wb2ludE9uUGF0aCh0aGlzLmxvYyk7XG4gICAgICAgICAgICAgICAgICAgIG1pZCA9IGNvbXBvbmVudC5wb2ludEFsb25nUGF0aEZyb20odGhpcy5sb2MsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaHh5ID0gX2pnLnBvaW50T25MaW5lKHR4eSwgbWlkLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfXyA9IHR4eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4eSA9IGh4eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh4eSA9IF9fO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoeHkgPSBjb21wb25lbnQucG9pbnRBbG9uZ1BhdGhGcm9tKHRoaXMubG9jLCBkaXJlY3Rpb24gKiB0aGlzLmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBtaWQgPSBjb21wb25lbnQucG9pbnRPblBhdGgodGhpcy5sb2MpO1xuICAgICAgICAgICAgICAgICAgICB0eHkgPSBfamcucG9pbnRPbkxpbmUoaHh5LCBtaWQsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YWlsID0gX2pnLnBlcnBlbmRpY3VsYXJMaW5lVG8oaHh5LCB0eHksIHRoaXMud2lkdGgpO1xuICAgICAgICAgICAgICAgIGN4eSA9IF9qZy5wb2ludE9uTGluZShoeHksIHR4eSwgZm9sZGJhY2sgKiB0aGlzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZCA9IHsgaHh5OiBoeHksIHRhaWw6IHRhaWwsIGN4eTogY3h5IH0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlID0gcGFpbnRTdHlsZS5zdHJva2VTdHlsZSB8fCBjdXJyZW50Q29ubmVjdGlvblBhaW50U3R5bGUuc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZSA9IHBhaW50U3R5bGUuZmlsbFN0eWxlIHx8IGN1cnJlbnRDb25uZWN0aW9uUGFpbnRTdHlsZS5zdHJva2VTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gcGFpbnRTdHlsZS5saW5lV2lkdGggfHwgY3VycmVudENvbm5lY3Rpb25QYWludFN0eWxlLmxpbmVXaWR0aDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBkOiBkLFxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0cm9rZVN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IGZpbGxTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgbWluWDogTWF0aC5taW4oaHh5LngsIHRhaWxbMF0ueCwgdGFpbFsxXS54KSxcbiAgICAgICAgICAgICAgICAgICAgbWF4WDogTWF0aC5tYXgoaHh5LngsIHRhaWxbMF0ueCwgdGFpbFsxXS54KSxcbiAgICAgICAgICAgICAgICAgICAgbWluWTogTWF0aC5taW4oaHh5LnksIHRhaWxbMF0ueSwgdGFpbFsxXS55KSxcbiAgICAgICAgICAgICAgICAgICAgbWF4WTogTWF0aC5tYXgoaHh5LnksIHRhaWxbMF0ueSwgdGFpbFsxXS55KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHJldHVybiB7Y29tcG9uZW50OiBjb21wb25lbnQsIG1pblg6IDAsIG1heFg6IDAsIG1pblk6IDAsIG1heFk6IDB9O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuT3ZlcmxheXMuQXJyb3csIEFic3RyYWN0T3ZlcmxheSwge1xuICAgICAgICB1cGRhdGVGcm9tOmZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gZC5sZW5ndGggfHwgdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZC53aWR0aHx8IHRoaXMud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGQuZGlyZWN0aW9uICE9IG51bGwgPyBkLmRpcmVjdGlvbiA6IHRoaXMuZGlyZWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5mb2xkYmFjayA9IGQuZm9sZGJhY2t8fCB0aGlzLmZvbGRiYWNrO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICAqIENsYXNzOiBPdmVybGF5cy5QbGFpbkFycm93XG4gICAgICpcbiAgICAgKiBBIGJhc2ljIGFycm93LiAgVGhpcyBpcyBpbiBmYWN0IGp1c3Qgb25lIGluc3RhbmNlIG9mIHRoZSBtb3JlIGdlbmVyaWMgY2FzZSBpbiB3aGljaCB0aGUgdGFpbCBmb2xkcyBiYWNrIG9uIGl0c2VsZiB0byBzb21lXG4gICAgICogcG9pbnQgYWxvbmcgdGhlIGxlbmd0aCBvZiB0aGUgYXJyb3c6IGluIHRoaXMgY2FzZSwgdGhhdCBmb2xkYmFjayBwb2ludCBpcyB0aGUgZnVsbCBsZW5ndGggb2YgdGhlIGFycm93LiAgc28gaXQganVzdCBkb2VzXG4gICAgICogYSAnY2FsbCcgdG8gQXJyb3cgd2l0aCBmb2xkYmFjayBzZXQgYXBwcm9wcmlhdGVseS5cbiAgICAgKi9cbiAgICAvKlxuICAgICAqIEZ1bmN0aW9uOiBDb25zdHJ1Y3RvclxuICAgICAqIFNlZSA8T3ZlcmxheXMuQXJyb3c+IGZvciBhbGxvd2VkIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBfanAuT3ZlcmxheXMuUGxhaW5BcnJvdyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgcCA9IF9qcC5leHRlbmQocGFyYW1zLCB7Zm9sZGJhY2s6IDF9KTtcbiAgICAgICAgX2pwLk92ZXJsYXlzLkFycm93LmNhbGwodGhpcywgcCk7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiUGxhaW5BcnJvd1wiO1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuT3ZlcmxheXMuUGxhaW5BcnJvdywgX2pwLk92ZXJsYXlzLkFycm93KTtcblxuICAgIC8qXG4gICAgICogQ2xhc3M6IE92ZXJsYXlzLkRpYW1vbmRcbiAgICAgKiBcbiAgICAgKiBBIGRpYW1vbmQuIExpa2UgUGxhaW5BcnJvdywgdGhpcyBpcyBhIGNvbmNyZXRlIGNhc2Ugb2YgdGhlIG1vcmUgZ2VuZXJpYyBjYXNlIG9mIHRoZSB0YWlsIHBvaW50cyBjb252ZXJnaW5nIG9uIHNvbWUgcG9pbnQuLi5pdCBqdXN0XG4gICAgICogaGFwcGVucyB0aGF0IGluIHRoaXMgY2FzZSwgdGhhdCBwb2ludCBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgdGhlIGFycm93LlxuICAgICAqXG4gICAgICogICAgICB0aGlzIGNvdWxkIHByb2JhYmx5IGRvIHdpdGggc29tZSBoZWxwIHdpdGggcG9zaXRpb25pbmcuLi5kdWUgdG8gdGhlIHdheSBpdCByZXVzZXMgdGhlIEFycm93IHBhaW50IGNvZGUsIHdoYXQgQXJyb3cgdGhpbmtzIGlzIHRoZVxuICAgICAqICAgICAgY2VudGVyIGlzIGFjdHVhbGx5IDEvNCBvZiB0aGUgd2F5IGFsb25nIGZvciB0aGlzIGd1eS4gIGJ1dCB3ZSBkb24ndCBoYXZlIGFueSBrbm93bGVkZ2Ugb2YgcGl4ZWxzIGF0IHRoaXMgcG9pbnQsIHNvIHdlJ3JlIGtpbmQgb2ZcbiAgICAgKiAgICAgIHN0dWNrIHdoZW4gaXQgY29tZXMgdG8gaGVscGluZyBvdXQgdGhlIEFycm93IGNsYXNzLiBwb3NzaWJseSB3ZSBjb3VsZCBwYXNzIGluIGEgJ3RyYW5zcG9zZScgcGFyYW1ldGVyIG9yIHNvbWV0aGluZy4gdGhlIHZhbHVlXG4gICAgICogICAgICB3b3VsZCBiZSAtbC80IGluIHRoaXMgY2FzZSAtIG1vdmUgYWxvbmcgb25lIHF1YXJ0ZXIgb2YgdGhlIHRvdGFsIGxlbmd0aC5cbiAgICAgKi9cbiAgICAvKlxuICAgICAqIEZ1bmN0aW9uOiBDb25zdHJ1Y3RvclxuICAgICAqIFNlZSA8T3ZlcmxheXMuQXJyb3c+IGZvciBhbGxvd2VkIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBfanAuT3ZlcmxheXMuRGlhbW9uZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgbCA9IHBhcmFtcy5sZW5ndGggfHwgNDAsXG4gICAgICAgICAgICBwID0ganNQbHVtYi5leHRlbmQocGFyYW1zLCB7bGVuZ3RoOiBsIC8gMiwgZm9sZGJhY2s6IDJ9KTtcbiAgICAgICAgX2pwLk92ZXJsYXlzLkFycm93LmNhbGwodGhpcywgcCk7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiRGlhbW9uZFwiO1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuT3ZlcmxheXMuRGlhbW9uZCwgX2pwLk92ZXJsYXlzLkFycm93KTtcblxuICAgIHZhciBfZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGZvcmNlUmVmcmVzaCkge1xuICAgICAgICBpZiAoY29tcG9uZW50Ll9qc1BsdW1iLmNhY2hlZERpbWVuc2lvbnMgPT0gbnVsbCB8fCBmb3JjZVJlZnJlc2gpXG4gICAgICAgICAgICBjb21wb25lbnQuX2pzUGx1bWIuY2FjaGVkRGltZW5zaW9ucyA9IGNvbXBvbmVudC5nZXREaW1lbnNpb25zKCk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQuX2pzUGx1bWIuY2FjaGVkRGltZW5zaW9ucztcbiAgICB9O1xuXG4gICAgLy8gYWJzdHJhY3Qgc3VwZXJjbGFzcyBmb3Igb3ZlcmxheXMgdGhhdCBhZGQgYW4gZWxlbWVudCB0byB0aGUgRE9NLlxuICAgIHZhciBBYnN0cmFjdERPTU92ZXJsYXkgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIF9qcC5qc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgQWJzdHJhY3RPdmVybGF5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gaGFuZCBvZmYgZmlyZWQgZXZlbnRzIHRvIGFzc29jaWF0ZWQgY29tcG9uZW50LlxuICAgICAgICB2YXIgX2YgPSB0aGlzLmZpcmU7XG4gICAgICAgIHRoaXMuZmlyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHRoaXMuY29tcG9uZW50LmZpcmUuYXBwbHkodGhpcy5jb21wb25lbnQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kZXRhY2hlZD1mYWxzZTtcbiAgICAgICAgdGhpcy5pZCA9IHBhcmFtcy5pZDtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5kaXYgPSBudWxsO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmluaXRpYWxpc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIuY29tcG9uZW50ID0gcGFyYW1zLmNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5jYWNoZWREaW1lbnNpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5jcmVhdGUgPSBwYXJhbXMuY3JlYXRlO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmluaXRpYWxseUludmlzaWJsZSA9IHBhcmFtcy52aXNpYmxlID09PSBmYWxzZTtcblxuICAgICAgICB0aGlzLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYi5kaXYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXYgPSB0aGlzLl9qc1BsdW1iLmRpdiA9IGpzUGx1bWIuZ2V0RWxlbWVudCh0aGlzLl9qc1BsdW1iLmNyZWF0ZSh0aGlzLl9qc1BsdW1iLmNvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgICAgICBkaXYuY2xhc3NOYW1lID0gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5vdmVybGF5Q2xhc3MgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmNzc0NsYXNzID8gdGhpcy5jc3NDbGFzcyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY3NzQ2xhc3MgPyBwYXJhbXMuY3NzQ2xhc3MgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmFwcGVuZEVsZW1lbnQoZGl2KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldElkKGRpdik7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkaXY7XG5cbiAgICAgICAgICAgICAgICAvLyBpbiBJRSB0aGUgdG9wIGxlZnQgY29ybmVyIGlzIHdoYXQgaXQgcGxhY2VkIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uLiAgVGhpcyB3aWxsIG5vdFxuICAgICAgICAgICAgICAgIC8vIGJlIGZpeGVkLiBJRTggaXMgbm90IGdvaW5nIHRvIGJlIHN1cHBvcnRlZCBmb3IgbXVjaCBsb25nZXIuXG4gICAgICAgICAgICAgICAgdmFyIHRzID0gXCJ0cmFuc2xhdGUoLTUwJSwgLTUwJSlcIjtcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHM7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLm1velRyYW5zZm9ybSA9IHRzO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5tc1RyYW5zZm9ybSA9IHRzO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5vVHJhbnNmb3JtID0gdHM7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRzO1xuXG4gICAgICAgICAgICAgICAgLy8gd3JpdGUgdGhlIHJlbGF0ZWQgY29tcG9uZW50IGludG8gdGhlIGNyZWF0ZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgIGRpdi5fanNQbHVtYiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnZpc2libGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIuZGl2O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZHJhdyA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGN1cnJlbnRDb25uZWN0aW9uUGFpbnRTdHlsZSwgYWJzb2x1dGVQb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIHRkID0gX2dldERpbWVuc2lvbnModGhpcyk7XG4gICAgICAgICAgICBpZiAodGQgIT0gbnVsbCAmJiB0ZC5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBjeHkgPSB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICAgICAgICAgIC8vIGFic29sdXRlUG9zaXRpb24gd291bGQgaGF2ZSBiZWVuIHNldCBieSBhIGNhbGwgdG8gY29ubmVjdGlvbi5zZXRBYnNvbHV0ZU92ZXJsYXlQb3NpdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGVQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjeHkgPSB7IHg6IGFic29sdXRlUG9zaXRpb25bMF0sIHk6IGFic29sdXRlUG9zaXRpb25bMV0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50LnBvaW50T25QYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2MgPSB0aGlzLmxvYywgYWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9qdS5pc1N0cmluZyh0aGlzLmxvYykgfHwgdGhpcy5sb2MgPCAwIHx8IHRoaXMubG9jID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jID0gcGFyc2VJbnQodGhpcy5sb2MsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjeHkgPSBjb21wb25lbnQucG9pbnRPblBhdGgobG9jLCBhYnNvbHV0ZSk7ICAvLyBhIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NUb1VzZSA9IHRoaXMubG9jLmNvbnN0cnVjdG9yID09IEFycmF5ID8gdGhpcy5sb2MgOiB0aGlzLmVuZHBvaW50TG9jO1xuICAgICAgICAgICAgICAgICAgICBjeHkgPSB7IHg6IGxvY1RvVXNlWzBdICogY29tcG9uZW50LncsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBsb2NUb1VzZVsxXSAqIGNvbXBvbmVudC5oIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG1pbnggPSBjeHkueCAtICh0ZFswXSAvIDIpLFxuICAgICAgICAgICAgICAgICAgICBtaW55ID0gY3h5LnkgLSAodGRbMV0gLyAyKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBkOiB7IG1pbng6IG1pbngsIG1pbnk6IG1pbnksIHRkOiB0ZCwgY3h5OiBjeHkgfSxcbiAgICAgICAgICAgICAgICAgICAgbWluWDogbWlueCxcbiAgICAgICAgICAgICAgICAgICAgbWF4WDogbWlueCArIHRkWzBdLFxuICAgICAgICAgICAgICAgICAgICBtaW5ZOiBtaW55LFxuICAgICAgICAgICAgICAgICAgICBtYXhZOiBtaW55ICsgdGRbMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSByZXR1cm4ge21pblg6IDAsIG1heFg6IDAsIG1pblk6IDAsIG1heFk6IDB9O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChBYnN0cmFjdERPTU92ZXJsYXksIFtfanAuanNQbHVtYlVJQ29tcG9uZW50LCBBYnN0cmFjdE92ZXJsYXldLCB7XG4gICAgICAgIGdldERpbWVuc2lvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbMSwxXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYi5kaXYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmRpdi5zdHlsZS5kaXNwbGF5ID0gc3RhdGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAvLyBpZiBpbml0aWFsbHkgaW52aXNpYmxlLCBkaW1lbnNpb25zIGFyZSAwLDAgYW5kIG5ldmVyIGdldCB1cGRhdGVkXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICYmIHRoaXMuX2pzUGx1bWIuaW5pdGlhbGx5SW52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9nZXREaW1lbnNpb25zKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5yZXBhaW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuaW5pdGlhbGx5SW52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiBGdW5jdGlvbjogY2xlYXJDYWNoZWREaW1lbnNpb25zXG4gICAgICAgICAqIENsZWFycyB0aGUgY2FjaGVkIGRpbWVuc2lvbnMgZm9yIHRoZSBsYWJlbC4gQXMgYSBwZXJmb3JtYW5jZSBlbmhhbmNlbWVudCwgbGFiZWwgZGltZW5zaW9ucyBhcmVcbiAgICAgICAgICogY2FjaGVkIGZyb20gMS4zLjEyIG9ud2FyZHMuIFRoZSBjYWNoZSBpcyBjbGVhcmVkIHdoZW4geW91IGNoYW5nZSB0aGUgbGFiZWwgdGV4dCwgb2YgY291cnNlLCBidXRcbiAgICAgICAgICogdGhlcmUgYXJlIG90aGVyIHJlYXNvbnMgd2h5IHRoZSB0ZXh0IGRpbWVuc2lvbnMgbWlnaHQgY2hhbmdlIC0gaWYgeW91IG1ha2UgYSBjaGFuZ2UgdGhyb3VnaCBDU1MsIGZvclxuICAgICAgICAgKiBleGFtcGxlLCB5b3UgbWlnaHQgY2hhbmdlIHRoZSBmb250IHNpemUuICBpbiB0aGF0IGNhc2UgeW91IHNob3VsZCBleHBsaWNpdGx5IGNhbGwgdGhpcyBtZXRob2QuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckNhY2hlZERpbWVuc2lvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuY2FjaGVkRGltZW5zaW9ucyA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuZGl2ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5kaXYuX2pzUGx1bWIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLnJlbW92ZUVsZW1lbnQodGhpcy5fanNQbHVtYi5kaXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBhIGZvcmNlZCBjbGVhbnVwLCBqdXN0IGRldGFjaCBjaGlsZCBmcm9tIHBhcmVudCBmb3Igbm93LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iICYmIHRoaXMuX2pzUGx1bWIuZGl2ICYmIHRoaXMuX2pzUGx1bWIuZGl2LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fanNQbHVtYi5kaXYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG4gICAgICAgIHJlYXR0YWNoOmZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYi5kaXYgIT0gbnVsbCkgaW5zdGFuY2UuZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQodGhpcy5fanNQbHVtYi5kaXYpO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBjb21wdXRlTWF4U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRkID0gX2dldERpbWVuc2lvbnModGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGRbMF0sIHRkWzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFpbnQ6IGZ1bmN0aW9uIChwLCBjb250YWluZXJFeHRlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2pzUGx1bWIuaW5pdGlhbGlzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBwLmNvbXBvbmVudC5hcHBlbmREaXNwbGF5RWxlbWVudCh0aGlzLl9qc1BsdW1iLmRpdik7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5pbml0aWFsaXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGV0YWNoZWQpIHRoaXMuX2pzUGx1bWIuZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fanNQbHVtYi5kaXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5kaXYuc3R5bGUubGVmdCA9IChwLmNvbXBvbmVudC54ICsgcC5kLm1pbngpICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5kaXYuc3R5bGUudG9wID0gKHAuY29tcG9uZW50LnkgKyBwLmQubWlueSkgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogQ2xhc3M6IE92ZXJsYXlzLkN1c3RvbVxuICAgICAqIEEgQ3VzdG9tIG92ZXJsYXkuIFlvdSBzdXBwbHkgYSAnY3JlYXRlJyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHNvbWUgRE9NIGVsZW1lbnQsIGFuZCBqc1BsdW1iIHBvc2l0aW9ucyBpdC5cbiAgICAgKiBUaGUgJ2NyZWF0ZScgZnVuY3Rpb24gaXMgcGFzc2VkIGEgQ29ubmVjdGlvbiBvciBFbmRwb2ludC5cbiAgICAgKi9cbiAgICAvKlxuICAgICAqIEZ1bmN0aW9uOiBDb25zdHJ1Y3RvclxuICAgICAqIFxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogXHRjcmVhdGUgLSBmdW5jdGlvbiBmb3IganNQbHVtYiB0byBjYWxsIHRoYXQgcmV0dXJucyBhIERPTSBlbGVtZW50LlxuICAgICAqIFx0bG9jYXRpb24gLSBkaXN0YW5jZSAoYXMgYSBkZWNpbWFsIGZyb20gMCB0byAxIGluY2x1c2l2ZSkgbWFya2luZyB3aGVyZSB0aGUgbGFiZWwgc2hvdWxkIHNpdCBvbiB0aGUgY29ubmVjdG9yLiBkZWZhdWx0cyB0byAwLjUuXG4gICAgICogXHRpZCAtIG9wdGlvbmFsIGlkIHRvIHVzZSBmb3IgbGF0ZXIgcmV0cmlldmFsIG9mIHRoaXMgb3ZlcmxheS5cbiAgICAgKiBcdFxuICAgICAqL1xuICAgIF9qcC5PdmVybGF5cy5DdXN0b20gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiQ3VzdG9tXCI7XG4gICAgICAgIEFic3RyYWN0RE9NT3ZlcmxheS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuT3ZlcmxheXMuQ3VzdG9tLCBBYnN0cmFjdERPTU92ZXJsYXkpO1xuXG4gICAgX2pwLk92ZXJsYXlzLkd1aWRlTGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi5sZW5ndGggPSA1MDtcbiAgICAgICAgc2VsZi5saW5lV2lkdGggPSA1O1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkd1aWRlTGluZXNcIjtcbiAgICAgICAgQWJzdHJhY3RPdmVybGF5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIF9qcC5qc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5kcmF3ID0gZnVuY3Rpb24gKGNvbm5lY3RvciwgY3VycmVudENvbm5lY3Rpb25QYWludFN0eWxlKSB7XG5cbiAgICAgICAgICAgIHZhciBoZWFkID0gY29ubmVjdG9yLnBvaW50QWxvbmdQYXRoRnJvbShzZWxmLmxvYywgc2VsZi5sZW5ndGggLyAyKSxcbiAgICAgICAgICAgICAgICBtaWQgPSBjb25uZWN0b3IucG9pbnRPblBhdGgoc2VsZi5sb2MpLFxuICAgICAgICAgICAgICAgIHRhaWwgPSBfamcucG9pbnRPbkxpbmUoaGVhZCwgbWlkLCBzZWxmLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgdGFpbExpbmUgPSBfamcucGVycGVuZGljdWxhckxpbmVUbyhoZWFkLCB0YWlsLCA0MCksXG4gICAgICAgICAgICAgICAgaGVhZExpbmUgPSBfamcucGVycGVuZGljdWxhckxpbmVUbyh0YWlsLCBoZWFkLCAyMCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yOiBjb25uZWN0b3IsXG4gICAgICAgICAgICAgICAgaGVhZDogaGVhZCxcbiAgICAgICAgICAgICAgICB0YWlsOiB0YWlsLFxuICAgICAgICAgICAgICAgIGhlYWRMaW5lOiBoZWFkTGluZSxcbiAgICAgICAgICAgICAgICB0YWlsTGluZTogdGFpbExpbmUsXG4gICAgICAgICAgICAgICAgbWluWDogTWF0aC5taW4oaGVhZC54LCB0YWlsLngsIGhlYWRMaW5lWzBdLngsIGhlYWRMaW5lWzFdLngpLFxuICAgICAgICAgICAgICAgIG1pblk6IE1hdGgubWluKGhlYWQueSwgdGFpbC55LCBoZWFkTGluZVswXS55LCBoZWFkTGluZVsxXS55KSxcbiAgICAgICAgICAgICAgICBtYXhYOiBNYXRoLm1heChoZWFkLngsIHRhaWwueCwgaGVhZExpbmVbMF0ueCwgaGVhZExpbmVbMV0ueCksXG4gICAgICAgICAgICAgICAgbWF4WTogTWF0aC5tYXgoaGVhZC55LCB0YWlsLnksIGhlYWRMaW5lWzBdLnksIGhlYWRMaW5lWzFdLnkpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRoaXMuY2xlYW51cCA9IGZ1bmN0aW9uKCkgeyB9OyAgLy8gbm90aGluZyB0byBjbGVhbiB1cCBmb3IgR3VpZGVMaW5lc1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIENsYXNzOiBPdmVybGF5cy5MYWJlbFxuXG4gICAgICovXG4gICAgLypcbiAgICAgKiBGdW5jdGlvbjogQ29uc3RydWN0b3JcbiAgICAgKiBcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqIFx0Y3NzQ2xhc3MgLSBvcHRpb25hbCBjc3MgY2xhc3Mgc3RyaW5nIHRvIGFwcGVuZCB0byBjc3MgY2xhc3MuIFRoaXMgc3RyaW5nIGlzIGFwcGVuZGVkIFwiYXMtaXNcIiwgc28geW91IGNhbiBvZiBjb3Vyc2UgaGF2ZSBtdWx0aXBsZSBjbGFzc2VzXG4gICAgICogICAgICAgICAgICAgZGVmaW5lZC4gIFRoaXMgcGFyYW1ldGVyIGlzIHByZWZlcnJlZCB0byB1c2luZyBsYWJlbFN0eWxlLCBib3JkZXJXaWR0aCBhbmQgYm9yZGVyU3R5bGUuXG4gICAgICogXHRsYWJlbCAtIHRoZSBsYWJlbCB0byBwYWludC4gIE1heSBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZy4gIE5vdGhpbmcgd2lsbCBiZSBwYWludGVkIGlmIHlvdXIgbGFiZWwgaXMgbnVsbCBvciB5b3VyXG4gICAgICogICAgICAgICBsYWJlbCBmdW5jdGlvbiByZXR1cm5zIG51bGwuICBlbXB0eSBzdHJpbmdzIF93aWxsXyBiZSBwYWludGVkLlxuICAgICAqIFx0bG9jYXRpb24gLSBkaXN0YW5jZSAoYXMgYSBkZWNpbWFsIGZyb20gMCB0byAxIGluY2x1c2l2ZSkgbWFya2luZyB3aGVyZSB0aGUgbGFiZWwgc2hvdWxkIHNpdCBvbiB0aGUgY29ubmVjdG9yLiBkZWZhdWx0cyB0byAwLjUuXG4gICAgICogXHRpZCAtIG9wdGlvbmFsIGlkIHRvIHVzZSBmb3IgbGF0ZXIgcmV0cmlldmFsIG9mIHRoaXMgb3ZlcmxheS5cbiAgICAgKiBcbiAgICAgKiBcdFxuICAgICAqL1xuICAgIF9qcC5PdmVybGF5cy5MYWJlbCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5sYWJlbFN0eWxlID0gcGFyYW1zLmxhYmVsU3R5bGU7XG5cbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSBudWxsLCBsYWJlbEhlaWdodCA9IG51bGwsIGxhYmVsVGV4dCA9IG51bGwsIGxhYmVsUGFkZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuY3NzQ2xhc3MgPSB0aGlzLmxhYmVsU3R5bGUgIT0gbnVsbCA/IHRoaXMubGFiZWxTdHlsZS5jc3NDbGFzcyA6IG51bGw7XG4gICAgICAgIHZhciBwID0gX2pwLmV4dGVuZCh7XG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNQbHVtYi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgfX0sIHBhcmFtcyk7XG4gICAgICAgIF9qcC5PdmVybGF5cy5DdXN0b20uY2FsbCh0aGlzLCBwKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJMYWJlbFwiO1xuICAgICAgICB0aGlzLmxhYmVsID0gcGFyYW1zLmxhYmVsIHx8IFwiXCI7XG4gICAgICAgIHRoaXMubGFiZWxUZXh0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxTdHlsZSkge1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLmxhYmVsU3R5bGUuZm9udCA9IHRoaXMubGFiZWxTdHlsZS5mb250IHx8IFwiMTJweCBzYW5zLXNlcmlmXCI7XG4gICAgICAgICAgICBlbC5zdHlsZS5mb250ID0gdGhpcy5sYWJlbFN0eWxlLmZvbnQ7XG4gICAgICAgICAgICBlbC5zdHlsZS5jb2xvciA9IHRoaXMubGFiZWxTdHlsZS5jb2xvciB8fCBcImJsYWNrXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbFN0eWxlLmZpbGxTdHlsZSkgZWwuc3R5bGUuYmFja2dyb3VuZCA9IHRoaXMubGFiZWxTdHlsZS5maWxsU3R5bGU7XG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbFN0eWxlLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkU3R5bGUgPSB0aGlzLmxhYmVsU3R5bGUuYm9yZGVyU3R5bGUgPyB0aGlzLmxhYmVsU3R5bGUuYm9yZGVyU3R5bGUgOiBcImJsYWNrXCI7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuYm9yZGVyID0gdGhpcy5sYWJlbFN0eWxlLmJvcmRlcldpZHRoICsgXCJweCBzb2xpZCBcIiArIGRTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxhYmVsU3R5bGUucGFkZGluZykgZWwuc3R5bGUucGFkZGluZyA9IHRoaXMubGFiZWxTdHlsZS5wYWRkaW5nO1xuICAgICAgICB9XG5cbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLk92ZXJsYXlzLkxhYmVsLCBfanAuT3ZlcmxheXMuQ3VzdG9tLCB7XG4gICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxUZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNzc0NsYXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsU3R5bGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qXG4gICAgICAgICAqIEZ1bmN0aW9uOiBzZXRMYWJlbFxuICAgICAgICAgKiBzZXRzIHRoZSBsYWJlbCdzLCB1bSwgbGFiZWwuICB5b3Ugd291bGQgdGhpbmsgaSdkIGNhbGwgdGhpcyBmdW5jdGlvblxuICAgICAgICAgKiAnc2V0VGV4dCcsIGJ1dCB5b3UgY2FuIHBhc3MgZWl0aGVyIGEgRnVuY3Rpb24gb3IgYSBTdHJpbmcgdG8gdGhpcywgc29cbiAgICAgICAgICogaXQgbWFrZXMgbW9yZSBzZW5zZSBhcyAnc2V0TGFiZWwnLiBUaGlzIHVzZXMgaW5uZXJIVE1MIG9uIHRoZSBsYWJlbCBkaXYsIHNvIGtlZXBcbiAgICAgICAgICogdGhhdCBpbiBtaW5kIGlmIHlvdSBuZWVkIGVzY2FwZWQgSFRNTC5cbiAgICAgICAgICovXG4gICAgICAgIHNldExhYmVsOiBmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IGw7XG4gICAgICAgICAgICB0aGlzLmxhYmVsVGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnJlcGFpbnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RGltZW5zaW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBBYnN0cmFjdERPTU92ZXJsYXkucHJvdG90eXBlLmdldERpbWVuc2lvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMubGFiZWwgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGx0ID0gdGhpcy5sYWJlbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS5pbm5lckhUTUwgPSBsdC5yZXBsYWNlKC9cXHJcXG4vZywgXCI8YnIvPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhYmVsVGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFiZWxUZXh0ID0gdGhpcy5sYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRFbGVtZW50KCkuaW5uZXJIVE1MID0gdGhpcy5sYWJlbFRleHQucmVwbGFjZSgvXFxyXFxuL2csIFwiPGJyLz5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVGcm9tOmZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmKGQubGFiZWwpIHRoaXMuc2V0TGFiZWwoZC5sYWJlbCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFTkQgT0YgT1ZFUkxBWSBERUZJTklUSU9OUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qXG4gKiBqc1BsdW1iXG4gKlxuICogVGl0bGU6anNQbHVtYiAyLjEuMFxuICpcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHZpc3VhbGx5IGNvbm5lY3QgZWxlbWVudHMgb24gYW4gSFRNTCBwYWdlLCB1c2luZyBTVkcuXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBiYXNlIGNsYXNzIGZvciBsaWJyYXJ5IGFkYXB0ZXJzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTYganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxuICpcbiAqIGh0dHA6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHA6Ly9naXRodWIuY29tL3Nwb3JyaXR0L2pzcGx1bWJcbiAqXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJvb3QgPSB0aGlzLFxuICAgICAgICBfanAgPSByb290LmpzUGx1bWI7XG5cbiAgICB2YXIgX2dldEV2ZW50TWFuYWdlciA9IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBlID0gaW5zdGFuY2UuX21vdHRsZTtcbiAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICBlID0gaW5zdGFuY2UuX21vdHRsZSA9IG5ldyByb290Lk1vdHRsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG5cbiAgICBfanAuZXh0ZW5kKHJvb3QuanNQbHVtYkluc3RhbmNlLnByb3RvdHlwZSwge1xuICAgICAgICBnZXRFdmVudE1hbmFnZXI6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldEV2ZW50TWFuYWdlcih0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgb24gOiBmdW5jdGlvbihlbCwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBoZXJlIHdlIHdvdWxkIGxpa2UgdG8gbWFwIHRoZSB0YXAgZXZlbnQgaWYgd2Uga25vdyBpdHNcbiAgICAgICAgICAgIC8vIGFuIGludGVybmFsIGJpbmQgdG8gYSBjbGljay4gd2UgaGF2ZSB0byBrbm93IGl0cyBpbnRlcm5hbCBiZWNhdXNlIG9ubHlcbiAgICAgICAgICAgIC8vIHRoZW4gY2FuIHdlIGJlIHN1cmUgdGhhdCB0aGUgVVAgZXZlbnQgd29udCBiZSBjb25zdW1lZCAodGFwIGlzIGEgc3ludGhlc2l6ZWRcbiAgICAgICAgICAgIC8vIGV2ZW50IGZyb20gYSBtb3VzZWRvd24gZm9sbG93ZWQgYnkgYSBtb3VzZXVwKS5cbiAgICAgICAgICAgIC8vZXZlbnQgPSB7IFwiY2xpY2tcIjpcInRhcFwiLCBcImRibGNsaWNrXCI6XCJkYmx0YXBcIn1bZXZlbnRdIHx8IGV2ZW50O1xuICAgICAgICAgICAgdGhpcy5nZXRFdmVudE1hbmFnZXIoKS5vbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIG9mZiA6IGZ1bmN0aW9uKGVsLCBldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRNYW5hZ2VyKCkub2ZmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbn0pLmNhbGwodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzKTtcbjsoZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgcm9vdCA9IHRoaXMsXG4gICAgICAgIF9qdSA9IHJvb3QuanNQbHVtYlV0aWwsXG4gICAgICAgIF9qcGkgPSByb290LmpzUGx1bWJJbnN0YW5jZTtcblxuICAgIHZhciBHUk9VUF9DT0xMQVBTRURfQ0xBU1MgPSBcImpzcGx1bWItZ3JvdXAtY29sbGFwc2VkXCI7XG4gICAgdmFyIEdST1VQX0VYUEFOREVEX0NMQVNTID0gXCJqc3BsdW1iLWdyb3VwLWV4cGFuZGVkXCI7XG4gICAgdmFyIEdST1VQX0NPTlRBSU5FUl9TRUxFQ1RPUiA9IFwiW2pzcGx1bWItZ3JvdXAtY29udGVudF1cIjtcbiAgICB2YXIgRUxFTUVOVF9EUkFHR0FCTEVfRVZFTlQgPSBcImVsZW1lbnREcmFnZ2FibGVcIjtcbiAgICB2YXIgU1RPUCA9IFwic3RvcFwiO1xuICAgIHZhciBSRVZFUlQgPSBcInJldmVydFwiO1xuICAgIHZhciBHUk9VUF9NQU5BR0VSID0gXCJfZ3JvdXBNYW5hZ2VyXCI7XG4gICAgdmFyIEdST1VQID0gXCJfanNQbHVtYkdyb3VwXCI7XG4gICAgdmFyIEdST1VQX0RSQUdfU0NPUEUgPSBcIl9qc1BsdW1iR3JvdXBEcmFnXCI7XG4gICAgdmFyIEVWVF9DSElMRF9BRERFRCA9IFwiZ3JvdXA6YWRkTWVtYmVyXCI7XG4gICAgdmFyIEVWVF9DSElMRF9SRU1PVkVEID0gXCJncm91cDpyZW1vdmVNZW1iZXJcIjtcbiAgICB2YXIgRVZUX0dST1VQX0FEREVEID0gXCJncm91cDphZGRcIjtcbiAgICB2YXIgRVZUX0dST1VQX1JFTU9WRUQgPSBcImdyb3VwOnJlbW92ZVwiO1xuICAgIHZhciBFVlRfRVhQQU5EID0gXCJncm91cDpleHBhbmRcIjtcbiAgICB2YXIgRVZUX0NPTExBUFNFID0gXCJncm91cDpjb2xsYXBzZVwiO1xuXG4gICAgdmFyIEdyb3VwTWFuYWdlciA9IGZ1bmN0aW9uKF9qc1BsdW1iKSB7XG4gICAgICAgIHZhciBfbWFuYWdlZEdyb3VwcyA9IHt9LCBfY29ubmVjdGlvblNvdXJjZU1hcCA9IHt9LCBfY29ubmVjdGlvblRhcmdldE1hcCA9IHt9LCBzZWxmID0gdGhpcztcblxuICAgICAgICBfanNQbHVtYi5iaW5kKFwiY29ubmVjdGlvblwiLCBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBpZiAocC5zb3VyY2VbR1JPVVBdICE9IG51bGwgJiYgcC50YXJnZXRbR1JPVVBdICE9IG51bGwgJiYgcC5zb3VyY2VbR1JPVVBdID09PSBwLnRhcmdldFtHUk9VUF0pIHtcbiAgICAgICAgICAgICAgICBfY29ubmVjdGlvblNvdXJjZU1hcFtwLmNvbm5lY3Rpb24uaWRdID0gcC5zb3VyY2VbR1JPVVBdO1xuICAgICAgICAgICAgICAgIF9jb25uZWN0aW9uVGFyZ2V0TWFwW3AuY29ubmVjdGlvbi5pZF0gPSBwLnNvdXJjZVtHUk9VUF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocC5zb3VyY2VbR1JPVVBdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2p1LnN1Z2dlc3QocC5zb3VyY2VbR1JPVVBdLmNvbm5lY3Rpb25zLnNvdXJjZSwgcC5jb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgX2Nvbm5lY3Rpb25Tb3VyY2VNYXBbcC5jb25uZWN0aW9uLmlkXSA9IHAuc291cmNlW0dST1VQXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHAudGFyZ2V0W0dST1VQXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qdS5zdWdnZXN0KHAudGFyZ2V0W0dST1VQXS5jb25uZWN0aW9ucy50YXJnZXQsIHAuY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIF9jb25uZWN0aW9uVGFyZ2V0TWFwW3AuY29ubmVjdGlvbi5pZF0gPSBwLnRhcmdldFtHUk9VUF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBfY2xlYW51cERldGFjaGVkQ29ubmVjdGlvbihjb25uKSB7XG4gICAgICAgICAgICBkZWxldGUgY29ubi5wcm94aWVzO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2Nvbm5lY3Rpb25Tb3VyY2VNYXBbY29ubi5pZF0sIGY7XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGYgPSBmdW5jdGlvbihjKSB7IHJldHVybiBjLmlkID09PSBjb25uLmlkOyB9O1xuICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24oZ3JvdXAuY29ubmVjdGlvbnMuc291cmNlLCBmKTtcbiAgICAgICAgICAgICAgICBfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGdyb3VwLmNvbm5lY3Rpb25zLnRhcmdldCwgZik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9jb25uZWN0aW9uU291cmNlTWFwW2Nvbm4uaWRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cCA9IF9jb25uZWN0aW9uVGFyZ2V0TWFwW2Nvbm4uaWRdO1xuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmID0gZnVuY3Rpb24oYykgeyByZXR1cm4gYy5pZCA9PT0gY29ubi5pZDsgfTtcbiAgICAgICAgICAgICAgICBfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGdyb3VwLmNvbm5lY3Rpb25zLnNvdXJjZSwgZik7XG4gICAgICAgICAgICAgICAgX2p1LnJlbW92ZVdpdGhGdW5jdGlvbihncm91cC5jb25uZWN0aW9ucy50YXJnZXQsIGYpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfY29ubmVjdGlvblRhcmdldE1hcFtjb25uLmlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9qc1BsdW1iLmJpbmQoXCJjb25uZWN0aW9uRGV0YWNoZWRcIiwgZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgX2NsZWFudXBEZXRhY2hlZENvbm5lY3Rpb24ocC5jb25uZWN0aW9uKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2pzUGx1bWIuYmluZChcImNvbm5lY3Rpb25Nb3ZlZFwiLCBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICB2YXIgY29ubk1hcCA9IHAuaW5kZXggPT09IDAgPyBfY29ubmVjdGlvblNvdXJjZU1hcCA6IF9jb25uZWN0aW9uVGFyZ2V0TWFwO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gY29ubk1hcFtwLmNvbm5lY3Rpb24uaWRdO1xuICAgICAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBncm91cC5jb25uZWN0aW9uc1twLmluZGV4ID09PSAwID8gXCJzb3VyY2VcIiA6IFwidGFyZ2V0XCJdO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBsaXN0LmluZGV4T2YocC5jb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEdyb3VwID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIF9qc1BsdW1iLmFkZENsYXNzKGdyb3VwLmVsLCBHUk9VUF9FWFBBTkRFRF9DTEFTUyk7XG4gICAgICAgICAgICBfbWFuYWdlZEdyb3Vwc1tncm91cC5pZF0gPSBncm91cDtcbiAgICAgICAgICAgIGdyb3VwLm1hbmFnZXIgPSB0aGlzO1xuICAgICAgICAgICAgX3VwZGF0ZUNvbm5lY3Rpb25zRm9yR3JvdXAoZ3JvdXApO1xuICAgICAgICAgICAgX2pzUGx1bWIuZmlyZShFVlRfR1JPVVBfQURERUQsIHsgZ3JvdXA6Z3JvdXAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRUb0dyb3VwID0gZnVuY3Rpb24oZ3JvdXAsIGVsLCBkb05vdEZpcmVFdmVudCkge1xuICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgICAgIGdyb3VwLmFkZChlbCwgZG9Ob3RGaXJlRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbUdyb3VwID0gZnVuY3Rpb24oZ3JvdXAsIGVsLCBkb05vdEZpcmVFdmVudCkge1xuICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCwgbnVsbCwgZG9Ob3RGaXJlRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0R3JvdXAgPSBmdW5jdGlvbihncm91cElkKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cElkO1xuICAgICAgICAgICAgaWYgKF9qdS5pc1N0cmluZyhncm91cElkKSkge1xuICAgICAgICAgICAgICAgIGdyb3VwID0gX21hbmFnZWRHcm91cHNbZ3JvdXBJZF07XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBzdWNoIGdyb3VwIFtcIiArIGdyb3VwSWQgKyBcIl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBkZWxldGVNZW1iZXJzKSB7XG4gICAgICAgICAgICBncm91cCA9IHRoaXMuZ2V0R3JvdXAoZ3JvdXApO1xuICAgICAgICAgICAgdGhpcy5leHBhbmRHcm91cChncm91cCwgdHJ1ZSk7IC8vIHRoaXMgcmVpbnN0YXRlcyBhbnkgb3JpZ2luYWwgY29ubmVjdGlvbnMgYW5kIHJlbW92ZXMgYWxsIHByb3hpZXMsIGJ1dCBkb2VzIG5vdCBmaXJlIGFuIGV2ZW50LlxuICAgICAgICAgICAgZ3JvdXBbZGVsZXRlTWVtYmVycyA/IFwicmVtb3ZlQWxsXCIgOiBcIm9ycGhhbkFsbFwiXSgpO1xuICAgICAgICAgICAgX2pzUGx1bWIucmVtb3ZlKGdyb3VwLmdldEVsKCkpO1xuICAgICAgICAgICAgZGVsZXRlIF9tYW5hZ2VkR3JvdXBzW2dyb3VwLmlkXTtcbiAgICAgICAgICAgIGRlbGV0ZSBfanNQbHVtYi5fZ3JvdXBzW2dyb3VwLmlkXTtcbiAgICAgICAgICAgIF9qc1BsdW1iLmZpcmUoRVZUX0dST1VQX1JFTU9WRUQsIHsgZ3JvdXA6Z3JvdXAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxHcm91cHMgPSBmdW5jdGlvbihkZWxldGVNZW1iZXJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBnIGluIF9tYW5hZ2VkR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVHcm91cChfbWFuYWdlZEdyb3Vwc1tnXSwgZGVsZXRlTWVtYmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gX3NldFZpc2libGUoZ3JvdXAsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbSA9IGdyb3VwLmdldE1lbWJlcnMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIF9qc1BsdW1iW3N0YXRlID8gXCJzaG93XCIgOiBcImhpZGVcIl0obVtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2NvbGxhcHNlQ29ubmVjdGlvbiA9IHRoaXMuY29sbGFwc2VDb25uZWN0aW9uID0gZnVuY3Rpb24oYywgaW5kZXgsIGdyb3VwKSB7XG5cbiAgICAgICAgICAgIHZhciBwcm94eUVwLCBncm91cEVsID0gZ3JvdXAuZ2V0RWwoKSwgZ3JvdXBFbElkID0gX2pzUGx1bWIuZ2V0SWQoZ3JvdXBFbCksXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFbGVtZW50SWQgPSBjLmVuZHBvaW50c1tpbmRleF0uZWxlbWVudElkO1xuXG4gICAgICAgICAgICBjLnByb3hpZXMgPSBjLnByb3hpZXMgfHwgW107XG4gICAgICAgICAgICBpZihjLnByb3hpZXNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcHJveHlFcCA9IGMucHJveGllc1tpbmRleF0uZXA7XG4gICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJveHlFcCA9IF9qc1BsdW1iLmFkZEVuZHBvaW50KGdyb3VwRWwsIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6Z3JvdXAuZ2V0RW5kcG9pbnQoYywgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICBhbmNob3I6Z3JvdXAuZ2V0QW5jaG9yKGMsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczp7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Byb3h5RW5kcG9pbnQ6dHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcHJveHlFcC5fZm9yY2VEZWxldGVPbkRldGFjaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3IgdGhpcyBpbmRleCwgc3Rhc2ggcHJveHkgaW5mbzogdGhlIG5ldyBFUCwgdGhlIG9yaWdpbmFsIEVQLlxuICAgICAgICAgICAgYy5wcm94aWVzW2luZGV4XSA9IHsgZXA6cHJveHlFcCwgb3JpZ2luYWxFcDogYy5lbmRwb2ludHNbaW5kZXhdIH07XG5cbiAgICAgICAgICAgIC8vIGFuZCBhZHZpc2UgdGhlIGFuY2hvciBtYW5hZ2VyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHdoeSBhcmUgdGhlcmUgdHdvIGRpZmZlcmVudGx5IG5hbWVkIG1ldGhvZHM/IFdoeSBpcyB0aGVyZSBub3Qgb25lIG1ldGhvZCB0aGF0IHNheXMgXCJzb21lIGVuZCBvZiB0aGlzXG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvbiBjaGFuZ2VkICh5b3UgZ2l2ZSB0aGUgaW5kZXgpLCBhbmQgaGVyZSdzIHRoZSBuZXcgZWxlbWVudCBhbmQgZWxlbWVudCBpZC5cIlxuICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFuY2hvck1hbmFnZXIuc291cmNlQ2hhbmdlZChvcmlnaW5hbEVsZW1lbnRJZCwgZ3JvdXBFbElkLCBjLCBncm91cEVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFuY2hvck1hbmFnZXIudXBkYXRlT3RoZXJFbmRwb2ludChjLmVuZHBvaW50c1swXS5lbGVtZW50SWQsIG9yaWdpbmFsRWxlbWVudElkLCBncm91cEVsSWQsIGMpO1xuICAgICAgICAgICAgICAgIGMudGFyZ2V0ID0gZ3JvdXBFbDtcbiAgICAgICAgICAgICAgICBjLnRhcmdldElkID0gZ3JvdXBFbElkO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIGRldGFjaCB0aGUgb3JpZ2luYWwgRVAgZnJvbSB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIGMucHJveGllc1tpbmRleF0ub3JpZ2luYWxFcC5kZXRhY2hGcm9tQ29ubmVjdGlvbihjLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gc2V0IHRoZSBwcm94eSBhcyB0aGUgbmV3IGVwXG4gICAgICAgICAgICBwcm94eUVwLmNvbm5lY3Rpb25zID0gWyBjIF07XG4gICAgICAgICAgICBjLmVuZHBvaW50c1tpbmRleF0gPSBwcm94eUVwO1xuXG4gICAgICAgICAgICBjLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jb2xsYXBzZUdyb3VwID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIGdyb3VwID0gdGhpcy5nZXRHcm91cChncm91cCk7XG4gICAgICAgICAgICBpZiAoZ3JvdXAgPT0gbnVsbCB8fCBncm91cC5jb2xsYXBzZWQpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBncm91cEVsID0gZ3JvdXAuZ2V0RWwoKTtcblxuICAgICAgICAgICAgLy8gdG9kbyByZW1vdmUgb2xkIHByb3h5IGVuZHBvaW50cyBmaXJzdCwganVzdCBpbiBjYXNlP1xuICAgICAgICAgICAgLy9ncm91cC5wcm94aWVzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIC8vIGhpZGUgYWxsIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICBfc2V0VmlzaWJsZShncm91cCwgZmFsc2UpO1xuXG4gICAgICAgICAgICBpZiAoZ3JvdXAuc2hvdWxkUHJveHkoKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbGxhcHNlcyBhbGwgY29ubmVjdGlvbnMgaW4gYSBncm91cC5cbiAgICAgICAgICAgICAgICB2YXIgX2NvbGxhcHNlU2V0ID0gZnVuY3Rpb24gKGNvbm5zLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGNvbm5zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbGxhcHNlQ29ubmVjdGlvbihjLCBpbmRleCwgZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIHNldHVwIHByb3hpZXMgZm9yIHNvdXJjZXMgYW5kIHRhcmdldHNcbiAgICAgICAgICAgICAgICBfY29sbGFwc2VTZXQoZ3JvdXAuY29ubmVjdGlvbnMuc291cmNlLCAwKTtcbiAgICAgICAgICAgICAgICBfY29sbGFwc2VTZXQoZ3JvdXAuY29ubmVjdGlvbnMudGFyZ2V0LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JvdXAuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIF9qc1BsdW1iLnJlbW92ZUNsYXNzKGdyb3VwRWwsIEdST1VQX0VYUEFOREVEX0NMQVNTKTtcbiAgICAgICAgICAgIF9qc1BsdW1iLmFkZENsYXNzKGdyb3VwRWwsIEdST1VQX0NPTExBUFNFRF9DTEFTUyk7XG4gICAgICAgICAgICBfanNQbHVtYi5yZXZhbGlkYXRlKGdyb3VwRWwpO1xuICAgICAgICAgICAgX2pzUGx1bWIuZmlyZShFVlRfQ09MTEFQU0UsIHsgZ3JvdXA6Z3JvdXAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZXhwYW5kQ29ubmVjdGlvbiA9IHRoaXMuZXhwYW5kQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGMsIGluZGV4LCBncm91cCkge1xuXG4gICAgICAgICAgICAvLyBpZiBubyBwcm94aWVzIG9yIG5vbmUgZm9yIHRoaXMgZW5kIG9mIHRoZSBjb25uZWN0aW9uLCBhYm9ydC5cbiAgICAgICAgICAgIGlmIChjLnByb3hpZXMgPT0gbnVsbCB8fCBjLnByb3hpZXNbaW5kZXhdID09IG51bGwpIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIGdyb3VwRWxJZCA9IF9qc1BsdW1iLmdldElkKGdyb3VwLmdldEVsKCkpLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRWxlbWVudCA9IGMucHJveGllc1tpbmRleF0ub3JpZ2luYWxFcC5lbGVtZW50LFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRWxlbWVudElkID0gYy5wcm94aWVzW2luZGV4XS5vcmlnaW5hbEVwLmVsZW1lbnRJZDtcblxuICAgICAgICAgICAgYy5lbmRwb2ludHNbaW5kZXhdID0gYy5wcm94aWVzW2luZGV4XS5vcmlnaW5hbEVwO1xuICAgICAgICAgICAgLy8gYW5kIGFkdmlzZSB0aGUgYW5jaG9yIG1hbmFnZXJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gd2h5IGFyZSB0aGVyZSB0d28gZGlmZmVyZW50bHkgbmFtZWQgbWV0aG9kcz8gV2h5IGlzIHRoZXJlIG5vdCBvbmUgbWV0aG9kIHRoYXQgc2F5cyBcInNvbWUgZW5kIG9mIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0aW9uIGNoYW5nZWQgKHlvdSBnaXZlIHRoZSBpbmRleCksIGFuZCBoZXJlJ3MgdGhlIG5ldyBlbGVtZW50IGFuZCBlbGVtZW50IGlkLlwiXG4gICAgICAgICAgICAgICAgX2pzUGx1bWIuYW5jaG9yTWFuYWdlci5zb3VyY2VDaGFuZ2VkKGdyb3VwRWxJZCwgb3JpZ2luYWxFbGVtZW50SWQsIGMsIG9yaWdpbmFsRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnVwZGF0ZU90aGVyRW5kcG9pbnQoYy5lbmRwb2ludHNbMF0uZWxlbWVudElkLCBncm91cEVsSWQsIG9yaWdpbmFsRWxlbWVudElkLCBjKTtcbiAgICAgICAgICAgICAgICBjLnRhcmdldCA9IG9yaWdpbmFsRWxlbWVudDtcbiAgICAgICAgICAgICAgICBjLnRhcmdldElkID0gb3JpZ2luYWxFbGVtZW50SWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRldGFjaCB0aGUgcHJveHkgRVAgZnJvbSB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIGMucHJveGllc1tpbmRleF0uZXAuZGV0YWNoRnJvbUNvbm5lY3Rpb24oYywgbnVsbCwgdHJ1ZSk7XG5cblxuICAgICAgICAgICAgYy5wcm94aWVzW2luZGV4XS5vcmlnaW5hbEVwLmFkZENvbm5lY3Rpb24oYyk7XG5cbiAgICAgICAgICAgIC8vIGNsZWFudXBcbiAgICAgICAgICAgIGRlbGV0ZSBjLnByb3hpZXNbaW5kZXhdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZXhwYW5kR3JvdXAgPSBmdW5jdGlvbihncm91cCwgZG9Ob3RGaXJlRXZlbnQpIHtcblxuICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcblxuICAgICAgICAgICAgaWYgKGdyb3VwID09IG51bGwgfHwgIWdyb3VwLmNvbGxhcHNlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGdyb3VwRWwgPSBncm91cC5nZXRFbCgpO1xuXG4gICAgICAgICAgICBfc2V0VmlzaWJsZShncm91cCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChncm91cC5zaG91bGRQcm94eSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGFwc2VzIGFsbCBjb25uZWN0aW9ucyBpbiBhIGdyb3VwLlxuICAgICAgICAgICAgICAgIHZhciBfZXhwYW5kU2V0ID0gZnVuY3Rpb24gKGNvbm5zLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGNvbm5zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V4cGFuZENvbm5lY3Rpb24oYywgaW5kZXgsIGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBzZXR1cCBwcm94aWVzIGZvciBzb3VyY2VzIGFuZCB0YXJnZXRzXG4gICAgICAgICAgICAgICAgX2V4cGFuZFNldChncm91cC5jb25uZWN0aW9ucy5zb3VyY2UsIDApO1xuICAgICAgICAgICAgICAgIF9leHBhbmRTZXQoZ3JvdXAuY29ubmVjdGlvbnMudGFyZ2V0LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JvdXAuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBfanNQbHVtYi5hZGRDbGFzcyhncm91cEVsLCBHUk9VUF9FWFBBTkRFRF9DTEFTUyk7XG4gICAgICAgICAgICBfanNQbHVtYi5yZW1vdmVDbGFzcyhncm91cEVsLCBHUk9VUF9DT0xMQVBTRURfQ0xBU1MpO1xuICAgICAgICAgICAgX2pzUGx1bWIucmV2YWxpZGF0ZShncm91cEVsKTtcbiAgICAgICAgICAgIHRoaXMucmVwYWludEdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgIGlmICghZG9Ob3RGaXJlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfanNQbHVtYi5maXJlKEVWVF9FWFBBTkQsIHsgZ3JvdXA6IGdyb3VwfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXBhaW50R3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgIHZhciBtID0gZ3JvdXAuZ2V0TWVtYmVycygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2pzUGx1bWIucmV2YWxpZGF0ZShtW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUT0RPIHJlZmFjdG9yIHRoaXMgd2l0aCB0aGUgY29kZSB0aGF0IHJlc3BvbmRzIHRvIGBjb25uZWN0aW9uYCBldmVudHMuXG4gICAgICAgIGZ1bmN0aW9uIF91cGRhdGVDb25uZWN0aW9uc0Zvckdyb3VwKGdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IGdyb3VwLmdldE1lbWJlcnMoKTtcbiAgICAgICAgICAgIHZhciBjMSA9IF9qc1BsdW1iLmdldENvbm5lY3Rpb25zKHtzb3VyY2U6bWVtYmVyc30sIHRydWUpO1xuICAgICAgICAgICAgdmFyIGMyID0gX2pzUGx1bWIuZ2V0Q29ubmVjdGlvbnMoe3RhcmdldDptZW1iZXJzfSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc2VkID0ge307XG4gICAgICAgICAgICBncm91cC5jb25uZWN0aW9ucy5zb3VyY2UubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGdyb3VwLmNvbm5lY3Rpb25zLnRhcmdldC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdmFyIG9uZVNldCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZFtjW2ldLmlkXSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZFtjW2ldLmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjW2ldLnNvdXJjZS5fanNQbHVtYkdyb3VwID09PSBncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNbaV0udGFyZ2V0Ll9qc1BsdW1iR3JvdXAgIT09IGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAuY29ubmVjdGlvbnMuc291cmNlLnB1c2goY1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29ubmVjdGlvblNvdXJjZU1hcFtjW2ldLmlkXSA9IGdyb3VwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNbaV0udGFyZ2V0Ll9qc1BsdW1iR3JvdXAgPT09IGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cC5jb25uZWN0aW9ucy50YXJnZXQucHVzaChjW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb25uZWN0aW9uVGFyZ2V0TWFwW2NbaV0uaWRdID0gZ3JvdXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb25lU2V0KGMxKTsgb25lU2V0KGMyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvbnNGb3JHcm91cCA9IF91cGRhdGVDb25uZWN0aW9uc0Zvckdyb3VwO1xuICAgICAgICB0aGlzLnJlZnJlc2hBbGxHcm91cHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGcgaW4gX21hbmFnZWRHcm91cHMpIHtcbiAgICAgICAgICAgICAgICBfdXBkYXRlQ29ubmVjdGlvbnNGb3JHcm91cChfbWFuYWdlZEdyb3Vwc1tnXSk7XG4gICAgICAgICAgICAgICAgX2pzUGx1bWIuZHJhZ01hbmFnZXIudXBkYXRlT2Zmc2V0cyhfanNQbHVtYi5nZXRJZChfbWFuYWdlZEdyb3Vwc1tnXS5lbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7anNQbHVtYkluc3RhbmNlfSBfanNQbHVtYiBBc3NvY2lhdGVkIGpzUGx1bWIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyYW1zLmVsIFRoZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIEdyb3VwLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmlkXSBPcHRpb25hbCBJRCBmb3IgdGhlIEdyb3VwLiBBIFVVSUQgd2lsbCBiZSBhc3NpZ25lZCBhcyB0aGUgR3JvdXAncyBJRCBpZiB5b3UgZG8gbm90IHByb3ZpZGUgb25lLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5jb25zdHJhaW49ZmFsc2VdIElmIHRydWUsIGNoaWxkIGVsZW1lbnRzIHdpbGwgbm90IGJlIGFibGUgdG8gYmUgZHJhZ2dlZCBvdXRzaWRlIG9mIHRoZSBHcm91cCBjb250YWluZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLnJldmVydD10cnVlXSBCeSBkZWZhdWx0LCBjaGlsZCBlbGVtZW50cyByZXZlcnQgdG8gdGhlIGNvbnRhaW5lciBpZiBkcmFnZ2VkIG91dHNpZGUuIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgc2V0dGluZyBgcmV2ZXJ0OmZhbHNlYC4gVGhpcyBiZWhhdmlvdXIgaXMgYWxzbyBvdmVycmlkZGVuIGlmIHlvdSBzZXQgYG9ycGhhbmAgb3IgYHBydW5lYC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMub3JwaGFuPWZhbHNlXSBJZiB0cnVlLCBjaGlsZCBlbGVtZW50cyBkcm9wcGVkIG91dHNpZGUgb2YgdGhlIEdyb3VwIGNvbnRhaW5lciB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR3JvdXAgKGJ1dCBub3QgZnJvbSB0aGUgRE9NKS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMucHJ1bmU9ZmFsc2VdIElmIHRydWUsIGNoaWxkIGVsZW1lbnRzIGRyb3BwZWQgb3V0c2lkZSBvZiB0aGUgR3JvdXAgY29udGFpbmVyIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBHcm91cCBhbmQgYWxzbyBmcm9tIHRoZSBET00uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmRyb3BPdmVycmlkZT1mYWxzZV0gSWYgdHJ1ZSwgYSBjaGlsZCBlbGVtZW50IHRoYXQgaGFzIGJlZW4gZHJvcHBlZCBvbnRvIHNvbWUgb3RoZXIgR3JvdXAgd2lsbCBub3QgYmUgc3ViamVjdCB0byB0aGUgY29udHJvbHMgaW1wb3NlZCBieSBgcHJ1bmVgLCBgcmV2ZXJ0YCBvciBgb3JwaGFuYC5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgR3JvdXAgPSBmdW5jdGlvbihfanNQbHVtYiwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGVsID0gcGFyYW1zLmVsO1xuICAgICAgICB0aGlzLmdldEVsID0gZnVuY3Rpb24oKSB7IHJldHVybiBlbDsgfTtcbiAgICAgICAgdGhpcy5pZCA9IHBhcmFtcy5pZCB8fCBfanUudXVpZCgpO1xuICAgICAgICBlbC5faXNKc1BsdW1iR3JvdXAgPSB0cnVlO1xuICAgICAgICB2YXIgZGEgPSBfanNQbHVtYi5nZXRTZWxlY3RvcihlbCwgR1JPVVBfQ09OVEFJTkVSX1NFTEVDVE9SKTtcbiAgICAgICAgdmFyIGRyYWdBcmVhID0gZGEgJiYgZGEubGVuZ3RoID4gMCA/IGRhWzBdIDogZWw7XG4gICAgICAgIHZhciBnaG9zdCA9IHBhcmFtcy5naG9zdCA9PT0gdHJ1ZTtcbiAgICAgICAgdmFyIGNvbnN0cmFpbiA9IGdob3N0IHx8IChwYXJhbXMuY29uc3RyYWluID09PSB0cnVlKTtcbiAgICAgICAgdmFyIHJldmVydCA9IHBhcmFtcy5yZXZlcnQgIT09IGZhbHNlO1xuICAgICAgICB2YXIgb3JwaGFuID0gcGFyYW1zLm9ycGhhbiA9PT0gdHJ1ZTtcbiAgICAgICAgdmFyIHBydW5lID0gcGFyYW1zLnBydW5lID09PSB0cnVlO1xuICAgICAgICB2YXIgZHJvcE92ZXJyaWRlID0gcGFyYW1zLmRyb3BPdmVycmlkZSA9PT0gdHJ1ZTtcbiAgICAgICAgdmFyIHByb3hpZWQgPSBwYXJhbXMucHJveGllZCAhPT0gZmFsc2U7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zID0geyBzb3VyY2U6W10sIHRhcmdldDpbXSwgaW50ZXJuYWw6W10gfTtcblxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uLCBhbmQgZ2V0RW5kcG9pbnQgYmVsb3csIGFyZSBzdHVicyBmb3IgYSBmdXR1cmUgc2V0dXAgaW4gd2hpY2ggd2UgY2FuIGNob29zZSBlbmRwb2ludFxuICAgICAgICAvLyBhbmQgYW5jaG9yIGJhc2VkIHVwb24gdGhlIGNvbm5lY3Rpb24gYW5kIHRoZSBpbmRleCAoc291cmNlL3RhcmdldCkgb2YgdGhlIGVuZHBvaW50IHRvIGJlIHByb3hpZWQuXG4gICAgICAgIHRoaXMuZ2V0QW5jaG9yID0gZnVuY3Rpb24oY29ubiwgZW5kcG9pbnRJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5hbmNob3IgfHwgXCJDb250aW51b3VzXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRFbmRwb2ludCA9IGZ1bmN0aW9uKGNvbm4sIGVuZHBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZW5kcG9pbnQgfHwgWyBcIkRvdFwiLCB7IHJhZGl1czoxMCB9XTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAocGFyYW1zLmRyYWdnYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgICAgIHN0b3A6ZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmZpcmUoXCJncm91cERyYWdTdG9wXCIsIGpzUGx1bWIuZXh0ZW5kKHBhcmFtcywge2dyb3VwOnNlbGZ9KSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzY29wZTpHUk9VUF9EUkFHX1NDT1BFXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5kcmFnT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJvb3QuanNQbHVtYi5leHRlbmQob3B0cywgcGFyYW1zLmRyYWdPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9qc1BsdW1iLmRyYWdnYWJsZShwYXJhbXMuZWwsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuZHJvcHBhYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgX2pzUGx1bWIuZHJvcHBhYmxlKHBhcmFtcy5lbCwge1xuICAgICAgICAgICAgICAgIGRyb3A6ZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBNYW5hZ2VyID0gX2pzUGx1bWIuZ2V0R3JvdXBNYW5hZ2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZWwgPSBwLmRyYWcuZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZWwuX2lzSnNQbHVtYkdyb3VwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50R3JvdXAgPSBfZWwuX2pzUGx1bWJHcm91cDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYWxyZWFkeSBhIG1lbWJlciBvZiB0aGlzIGdyb3VwLCBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50R3JvdXAgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbHBvcyA9IF9qc1BsdW1iLmdldE9mZnNldChfZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwb3MgPSBzZWxmLmNvbGxhcHNlZCA/IF9qc1BsdW1iLmdldE9mZnNldChlbCwgdHJ1ZSkgOiBfanNQbHVtYi5nZXRPZmZzZXQoZHJhZ0FyZWEsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIHRyYW5zZmVyIHRvIHRoaXMgZ3JvdXAuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEdyb3VwLm92ZXJyaWRlRHJvcChfZWwsIHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnJlbW92ZShfZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwTWFuYWdlci51cGRhdGVDb25uZWN0aW9uc0Zvckdyb3VwKGN1cnJlbnRHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZChfZWwsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlRHJvcHBlZENvbm5lY3Rpb25zID0gZnVuY3Rpb24obGlzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2lkeCA9IGluZGV4ID09IDAgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LmVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnNldFZpc2libGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5lbmRwb2ludHNbb2lkeF0uZWxlbWVudC5fanNQbHVtYkdyb3VwID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmVuZHBvaW50c1tvaWR4XS5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwTWFuYWdlci5leHBhbmRDb25uZWN0aW9uKGMsIG9pZHgsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5lbmRwb2ludHNbaW5kZXhdLnNldFZpc2libGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBNYW5hZ2VyLmNvbGxhcHNlQ29ubmVjdGlvbihjLCBpbmRleCwgc2VsZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZURyb3BwZWRDb25uZWN0aW9ucyhfanNQbHVtYi5zZWxlY3Qoe3NvdXJjZTogX2VsfSksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZURyb3BwZWRDb25uZWN0aW9ucyhfanNQbHVtYi5zZWxlY3Qoe3RhcmdldDogX2VsfSksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxJZCA9IF9qc1BsdW1iLmdldElkKF9lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5kcmFnTWFuYWdlci5zZXRQYXJlbnQoX2VsLCBlbElkLCBlbCwgX2pzUGx1bWIuZ2V0SWQoZWwpLCBlbHBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5zZXRQb3NpdGlvbihfZWwsIHtsZWZ0OmVscG9zLmxlZnQgLSBjcG9zLmxlZnQsIHRvcDplbHBvcy50b3AgLSBjcG9zLnRvcH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZHJhZ01hbmFnZXIucmV2YWxpZGF0ZVBhcmVudChfZWwsIGVsSWQsIGVscG9zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBNYW5hZ2VyLnVwZGF0ZUNvbm5lY3Rpb25zRm9yR3JvdXAoc2VsZik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZmlyZShFVlRfQ0hJTERfQURERUQsIHtncm91cDogc2VsZiwgZWw6IF9lbH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2VhY2ggPSBmdW5jdGlvbihfZWwsIGZuKSB7XG4gICAgICAgICAgICB2YXIgZWxzID0gX2VsLm5vZGVUeXBlID09IG51bGwgPyAgX2VsIDogWyBfZWwgXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm4oZWxzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm92ZXJyaWRlRHJvcCA9IGZ1bmN0aW9uKF9lbCwgdGFyZ2V0R3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBkcm9wT3ZlcnJpZGUgJiYgKHJldmVydCB8fCBwcnVuZSB8fCBvcnBoYW4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkID0gZnVuY3Rpb24oX2VsLCBkb05vdEZpcmVFdmVudCkge1xuICAgICAgICAgICAgX2VhY2goX2VsLCBmdW5jdGlvbihfX2VsKSB7XG4gICAgICAgICAgICAgICAgX19lbC5fanNQbHVtYkdyb3VwID0gc2VsZjtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKF9lbCk7XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBpZiBkcmFnZ2FibGUgYW5kIGFkZCBoYW5kbGVycyBpZiBzby5cbiAgICAgICAgICAgICAgICBpZiAoX2pzUGx1bWIuaXNBbHJlYWR5RHJhZ2dhYmxlKF9fZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9iaW5kRHJhZ0hhbmRsZXJzKF9fZWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfX2VsLnBhcmVudE5vZGUgIT0gZHJhZ0FyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0FyZWEuYXBwZW5kQ2hpbGQoX19lbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFkb05vdEZpcmVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5maXJlKEVWVF9DSElMRF9BRERFRCwge2dyb3VwOiBzZWxmLCBlbDogX19lbH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKGVsLCBtYW5pcHVsYXRlRE9NLCBkb05vdEZpcmVFdmVudCkge1xuICAgICAgICAgICAgX2VhY2goZWwsIGZ1bmN0aW9uKF9fZWwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX19lbC5fanNQbHVtYkdyb3VwO1xuICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24oZWxlbWVudHMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPT09IF9fZWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hbmlwdWxhdGVET00pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHsgc2VsZi5lbC5yZW1vdmVDaGlsZChfX2VsKTsgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3VuYmluZERyYWdIYW5kbGVycyhfX2VsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvTm90RmlyZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmZpcmUoRVZUX0NISUxEX1JFTU9WRUQsIHtncm91cDogc2VsZiwgZWw6IF9fZWx9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfanNQbHVtYi5yZW1vdmUoZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcnBoYW5BbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfb3JwaGFuKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0TWVtYmVycyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZWxlbWVudHM7IH07XG5cbiAgICAgICAgZWxbR1JPVVBdID0gdGhpcztcblxuICAgICAgICBfanNQbHVtYi5iaW5kKEVMRU1FTlRfRFJBR0dBQkxFX0VWRU5ULCBmdW5jdGlvbihkcmFnUGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBpZiBpdHMgZm9yIHRoZSBjdXJyZW50IGdyb3VwLFxuICAgICAgICAgICAgaWYgKGRyYWdQYXJhbXMuZWwuX2pzUGx1bWJHcm91cCA9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgX2JpbmREcmFnSGFuZGxlcnMoZHJhZ1BhcmFtcy5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gX2ZpbmRQYXJlbnQoX2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gX2VsLm9mZnNldFBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9pc0luc2lkZVBhcmVudChfZWwsIHBvcykge1xuICAgICAgICAgICAgdmFyIHAgPSBfZmluZFBhcmVudChfZWwpLFxuICAgICAgICAgICAgICAgIHMgPSBfanNQbHVtYi5nZXRTaXplKHApLFxuICAgICAgICAgICAgICAgIHNzID0gX2pzUGx1bWIuZ2V0U2l6ZShfZWwpLFxuICAgICAgICAgICAgICAgIGxlZnRFZGdlID0gcG9zWzBdLFxuICAgICAgICAgICAgICAgIHJpZ2h0RWRnZSA9IGxlZnRFZGdlICsgc3NbMF0sXG4gICAgICAgICAgICAgICAgdG9wRWRnZSA9IHBvc1sxXSxcbiAgICAgICAgICAgICAgICBib3R0b21FZGdlID0gdG9wRWRnZSArIHNzWzFdO1xuXG4gICAgICAgICAgICByZXR1cm4gcmlnaHRFZGdlID4gMCAmJiBsZWZ0RWRnZSA8IHNbMF0gJiYgYm90dG9tRWRnZSA+IDAgJiYgdG9wRWRnZSA8IHNbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBvcnBoYW5pbmcgYW4gZWxlbWVudCBtZWFucyB0YWtpbmcgaXQgb3V0IG9mIHRoZSBncm91cCBhbmQgYWRkaW5nIGl0IHRvIHRoZSBtYWluIGpzcGx1bWIgY29udGFpbmVyLlxuICAgICAgICAvL1xuICAgICAgICBmdW5jdGlvbiBfb3JwaGFuKF9lbCkge1xuICAgICAgICAgICAgdmFyIGlkID0gX2pzUGx1bWIuZ2V0SWQoX2VsKTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBfanNQbHVtYi5nZXRPZmZzZXQoX2VsKTtcbiAgICAgICAgICAgIF9lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9lbCk7XG4gICAgICAgICAgICBfanNQbHVtYi5nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZChfZWwpO1xuICAgICAgICAgICAgX2pzUGx1bWIuc2V0UG9zaXRpb24oX2VsLCBwb3MpO1xuICAgICAgICAgICAgZGVsZXRlIF9lbC5fanNQbHVtYkdyb3VwO1xuICAgICAgICAgICAgX3VuYmluZERyYWdIYW5kbGVycyhfZWwpO1xuICAgICAgICAgICAgX2pzUGx1bWIuZHJhZ01hbmFnZXIuY2xlYXJQYXJlbnQoX2VsLCBpZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyByZW1vdmUgYW4gZWxlbWVudCBmcm9tIHRoZSBncm91cCwgdGhlbiBlaXRoZXIgcHJ1bmUgaXQgZnJvbSB0aGUganNwbHVtYiBpbnN0YW5jZSwgb3IganVzdCBvcnBoYW4gaXQuXG4gICAgICAgIC8vXG4gICAgICAgIGZ1bmN0aW9uIF9wcnVuZU9yT3JwaGFuKHApIHtcbiAgICAgICAgICAgIGlmICghX2lzSW5zaWRlUGFyZW50KHAuZWwsIHAucG9zKSkge1xuICAgICAgICAgICAgICAgIHAuZWwuX2pzUGx1bWJHcm91cC5yZW1vdmUocC5lbCk7XG4gICAgICAgICAgICAgICAgaWYgKHBydW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnJlbW92ZShwLmVsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfb3JwaGFuKHAuZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHJlZHJhd3MgdGhlIGVsZW1lbnRcbiAgICAgICAgLy9cbiAgICAgICAgZnVuY3Rpb24gX3JldmFsaWRhdGUoX2VsKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfanNQbHVtYi5nZXRJZChfZWwpO1xuICAgICAgICAgICAgX2pzUGx1bWIucmV2YWxpZGF0ZShfZWwpO1xuICAgICAgICAgICAgX2pzUGx1bWIuZHJhZ01hbmFnZXIucmV2YWxpZGF0ZVBhcmVudChfZWwsIGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHVuYmluZCB0aGUgZ3JvdXAgc3BlY2lmaWMgZHJhZy9yZXZlcnQgaGFuZGxlcnMuXG4gICAgICAgIC8vXG4gICAgICAgIGZ1bmN0aW9uIF91bmJpbmREcmFnSGFuZGxlcnMoX2VsKSB7XG4gICAgICAgICAgICBpZiAocHJ1bmUgfHwgb3JwaGFuKSB7XG4gICAgICAgICAgICAgICAgX2VsLl9rYXRhdm9yaW9EcmFnLm9mZihTVE9QLCBfcHJ1bmVPck9ycGhhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBydW5lICYmICFvcnBoYW4gJiYgcmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgX2VsLl9rYXRhdm9yaW9EcmFnLm9mZihSRVZFUlQsIF9yZXZhbGlkYXRlKTtcbiAgICAgICAgICAgICAgICBfZWwuX2thdGF2b3Jpb0RyYWcuc2V0UmV2ZXJ0KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2JpbmREcmFnSGFuZGxlcnMoX2VsKSB7XG4gICAgICAgICAgICBpZiAocHJ1bmUgfHwgb3JwaGFuKSB7XG4gICAgICAgICAgICAgICAgX2VsLl9rYXRhdm9yaW9EcmFnLm9uKFNUT1AsIF9wcnVuZU9yT3JwaGFuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbikge1xuICAgICAgICAgICAgICAgIF9lbC5fa2F0YXZvcmlvRHJhZy5zZXRDb25zdHJhaW4odHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnaG9zdCkge1xuICAgICAgICAgICAgICAgIF9lbC5fa2F0YXZvcmlvRHJhZy5zZXRVc2VHaG9zdFByb3h5KHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXBydW5lICYmICFvcnBoYW4gJiYgcmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgX2VsLl9rYXRhdm9yaW9EcmFnLm9uKFJFVkVSVCwgX3JldmFsaWRhdGUpO1xuICAgICAgICAgICAgICAgIF9lbC5fa2F0YXZvcmlvRHJhZy5zZXRSZXZlcnQoZnVuY3Rpb24oX19lbCwgcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhX2lzSW5zaWRlUGFyZW50KF9fZWwsIHBvcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNob3VsZFByb3h5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJveGllZDtcbiAgICAgICAgfTtcblxuICAgICAgICBfanNQbHVtYi5nZXRHcm91cE1hbmFnZXIoKS5hZGRHcm91cCh0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGdyb3VwIHRvIHRoZSBqc1BsdW1iIGluc3RhbmNlLlxuICAgICAqIEBtZXRob2QgYWRkR3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHJldHVybiB7R3JvdXB9IFRoZSBuZXdseSBjcmVhdGVkIEdyb3VwLlxuICAgICAqL1xuICAgIF9qcGkucHJvdG90eXBlLmFkZEdyb3VwID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBqID0gdGhpcztcbiAgICAgICAgai5fZ3JvdXBzID0gai5fZ3JvdXBzIHx8IHt9O1xuICAgICAgICBpZiAoai5fZ3JvdXBzW3BhcmFtcy5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBjcmVhdGUgR3JvdXAgW1wiICsgcGFyYW1zLmlkICsgXCJdOyBhIEdyb3VwIHdpdGggdGhhdCBJRCBleGlzdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5lbFtHUk9VUF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBjcmVhdGUgR3JvdXAgW1wiICsgcGFyYW1zLmlkICsgXCJdOyB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBhbHJlYWR5IGEgR3JvdXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3VwID0gbmV3IEdyb3VwKGosIHBhcmFtcyk7XG4gICAgICAgIGouX2dyb3Vwc1tncm91cC5pZF0gPSBncm91cDtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZWxlbWVudCB0byBhIGdyb3VwLlxuICAgICAqIEBtZXRob2QgYWRkVG9Hcm91cFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cCBHcm91cCwgb3IgSUQgb2YgdGhlIGdyb3VwLCB0byBhZGQgdGhlIGVsZW1lbnQgdG8uXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50IHRvIGFkZCB0byB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgX2pwaS5wcm90b3R5cGUuYWRkVG9Hcm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBlbCwgZG9Ob3RGaXJlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRHcm91cE1hbmFnZXIoKS5hZGRUb0dyb3VwKGdyb3VwLCBlbCwgZG9Ob3RGaXJlRXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZWxlbWVudCBmcm9tIGEgZ3JvdXAuXG4gICAgICogQG1ldGhvZCByZW1vdmVGcm9tR3JvdXBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXAgR3JvdXAsIG9yIElEIG9mIHRoZSBncm91cCwgdG8gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20uXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50IHRvIGFkZCB0byB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgX2pwaS5wcm90b3R5cGUucmVtb3ZlRnJvbUdyb3VwID0gZnVuY3Rpb24oZ3JvdXAsIGVsLCBkb05vdEZpcmVFdmVudCkge1xuICAgICAgICB0aGlzLmdldEdyb3VwTWFuYWdlcigpLnJlbW92ZUZyb21Hcm91cChncm91cCwgZWwsIGRvTm90RmlyZUV2ZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZ3JvdXAsIGFuZCBvcHRpb25hbGx5IHJlbW92ZSBpdHMgbWVtYmVycyBmcm9tIHRoZSBqc1BsdW1iIGluc3RhbmNlLlxuICAgICAqIEBtZXRob2QgcmVtb3ZlR3JvdXBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xHcm91cH0gZ3JvdXAgR3JvdXAgdG8gZGVsZXRlLCBvciBJRCBvZiBHcnJ1cCB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGVsZXRlTWVtYmVycz1mYWxzZV0gSWYgdHJ1ZSwgZ3JvdXAgbWVtYmVycyB3aWxsIGJlIHJlbW92ZWQgYWxvbmcgd2l0aCB0aGUgZ3JvdXAuIE90aGVyd2lzZSB0aGV5IHdpbGxcbiAgICAgKiBqdXN0IGJlICdvcnBoYW5lZCcgKHJldHVybmVkIHRvIHRoZSBtYWluIGNvbnRhaW5lcikuXG4gICAgICovXG4gICAgX2pwaS5wcm90b3R5cGUucmVtb3ZlR3JvdXAgPSBmdW5jdGlvbihncm91cCwgZGVsZXRlTWVtYmVycykge1xuICAgICAgICB0aGlzLmdldEdyb3VwTWFuYWdlcigpLnJlbW92ZUdyb3VwKGdyb3VwLCBkZWxldGVNZW1iZXJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBncm91cHMsIGFuZCBvcHRpb25hbGx5IHJlbW92ZSB0aGVpciBtZW1iZXJzIGZyb20gdGhlIGpzUGx1bWIgaW5zdGFuY2UuXG4gICAgICogQG1ldGhvZCByZW1vdmVBbGxHcm91cFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlbGV0ZU1lbWJlcnM9ZmFsc2VdIElmIHRydWUsIGdyb3VwIG1lbWJlcnMgd2lsbCBiZSByZW1vdmVkIGFsb25nIHdpdGggdGhlIGdyb3Vwcy4gT3RoZXJ3aXNlIHRoZXkgd2lsbFxuICAgICAqIGp1c3QgYmUgJ29ycGhhbmVkJyAocmV0dXJuZWQgdG8gdGhlIG1haW4gY29udGFpbmVyKS5cbiAgICAgKi9cbiAgICBfanBpLnByb3RvdHlwZS5yZW1vdmVBbGxHcm91cHMgPSBmdW5jdGlvbihkZWxldGVNZW1iZXJzKSB7XG4gICAgICAgIHRoaXMuZ2V0R3JvdXBNYW5hZ2VyKCkucmVtb3ZlQWxsR3JvdXBzKGRlbGV0ZU1lbWJlcnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBncm91cFxuICAgICAqIEBtZXRob2QgZ2V0R3JvdXBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBJZCBJRCBvZiB0aGUgZ3JvdXAgdG8gZ2V0XG4gICAgICovXG4gICAgX2pwaS5wcm90b3R5cGUuZ2V0R3JvdXAgPSBmdW5jdGlvbihncm91cElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyb3VwTWFuYWdlcigpLmdldEdyb3VwKGdyb3VwSWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGEgZ3JvdXAgZWxlbWVudC4ganNQbHVtYiBkb2Vzbid0IGRvIFwiZXZlcnl0aGluZ1wiIGZvciB5b3UgaGVyZSwgYmVjYXVzZSB3aGF0IGl0IG1lYW5zIHRvIGV4cGFuZCBhIEdyb3VwXG4gICAgICogd2lsbCB2YXJ5IGZyb20gYXBwbGljYXRpb24gdG8gYXBwbGljYXRpb24uIGpzUGx1bWIgZG9lcyB0aGVzZSB0aGluZ3M6XG4gICAgICpcbiAgICAgKiAtIEhpZGVzIGFueSBjb25uZWN0aW9ucyB0aGF0IGFyZSBpbnRlcm5hbCB0byB0aGUgZ3JvdXAgKGNvbm5lY3Rpb25zIGJldHdlZW4gbWVtYmVycywgYW5kIGNvbm5lY3Rpb25zIGZyb20gbWVtYmVyIG9mXG4gICAgICogdGhlIGdyb3VwIHRvIHRoZSBncm91cCBpdHNlbGYpXG4gICAgICogLSBQcm94aWVzIGFsbCBjb25uZWN0aW9ucyBmb3Igd2hpY2ggdGhlIHNvdXJjZSBvciB0YXJnZXQgaXMgYSBtZW1iZXIgb2YgdGhlIGdyb3VwLlxuICAgICAqIC0gSGlkZXMgdGhlIHByb3hpZWQgY29ubmVjdGlvbnMuXG4gICAgICogLSBBZGRzIHRoZSBqc3BsdW1iLWdyb3VwLWV4cGFuZGVkIGNsYXNzIHRvIHRoZSBncm91cCdzIGVsZW1lbnRcbiAgICAgKiAtIFJlbW92ZXMgdGhlIGpzcGx1bWItZ3JvdXAtY29sbGFwc2VkIGNsYXNzIGZyb20gdGhlIGdyb3VwJ3MgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZXhwYW5kR3JvdXBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xHcm91cH0gZ3JvdXAgR3JvdXAgdG8gZXhwYW5kLCBvciBJRCBvZiBHcm91cCB0byBleHBhbmQuXG4gICAgICovXG4gICAgX2pwaS5wcm90b3R5cGUuZXhwYW5kR3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgICB0aGlzLmdldEdyb3VwTWFuYWdlcigpLmV4cGFuZEdyb3VwKGdyb3VwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGEgZ3JvdXAgZWxlbWVudC4ganNQbHVtYiBkb2Vzbid0IGRvIFwiZXZlcnl0aGluZ1wiIGZvciB5b3UgaGVyZSwgYmVjYXVzZSB3aGF0IGl0IG1lYW5zIHRvIGNvbGxhcHNlIGEgR3JvdXBcbiAgICAgKiB3aWxsIHZhcnkgZnJvbSBhcHBsaWNhdGlvbiB0byBhcHBsaWNhdGlvbi4ganNQbHVtYiBkb2VzIHRoZXNlIHRoaW5nczpcbiAgICAgKlxuICAgICAqIC0gU2hvd3MgYW55IGNvbm5lY3Rpb25zIHRoYXQgYXJlIGludGVybmFsIHRvIHRoZSBncm91cCAoY29ubmVjdGlvbnMgYmV0d2VlbiBtZW1iZXJzLCBhbmQgY29ubmVjdGlvbnMgZnJvbSBtZW1iZXIgb2ZcbiAgICAgKiB0aGUgZ3JvdXAgdG8gdGhlIGdyb3VwIGl0c2VsZilcbiAgICAgKiAtIFJlbW92ZXMgcHJveGllcyBmb3IgYWxsIGNvbm5lY3Rpb25zIGZvciB3aGljaCB0aGUgc291cmNlIG9yIHRhcmdldCBpcyBhIG1lbWJlciBvZiB0aGUgZ3JvdXAuXG4gICAgICogLSBTaG93cyB0aGUgcHJldmlvdXNseSBwcm94aWVkIGNvbm5lY3Rpb25zLlxuICAgICAqIC0gQWRkcyB0aGUganNwbHVtYi1ncm91cC1jb2xsYXBzZWQgY2xhc3MgdG8gdGhlIGdyb3VwJ3MgZWxlbWVudFxuICAgICAqIC0gUmVtb3ZlcyB0aGUganNwbHVtYi1ncm91cC1leHBhbmRlZCBjbGFzcyBmcm9tIHRoZSBncm91cCdzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGV4cGFuZEdyb3VwXG4gICAgICogQHBhcmFtIHtTdHJpbmd8R3JvdXB9IGdyb3VwIEdyb3VwIHRvIGV4cGFuZCwgb3IgSUQgb2YgR3JvdXAgdG8gZXhwYW5kLlxuICAgICAqL1xuICAgIF9qcGkucHJvdG90eXBlLmNvbGxhcHNlR3JvdXAgPSBmdW5jdGlvbihncm91cElkKSB7XG4gICAgICAgIHRoaXMuZ2V0R3JvdXBNYW5hZ2VyKCkuY29sbGFwc2VHcm91cChncm91cElkKTtcbiAgICB9O1xuXG5cbiAgICBfanBpLnByb3RvdHlwZS5yZXBhaW50R3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgICB0aGlzLmdldEdyb3VwTWFuYWdlcigpLnJlcGFpbnRHcm91cChncm91cCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBvciBleHBhbmRzIGEgZ3JvdXAgZWxlbWVudCBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuIFNlZSBub3RlcyBpbiB0aGUgY29sbGFwc2VHcm91cCBhbmQgZXhwYW5kR3JvdXAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0b2dnbGVHcm91cFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEdyb3VwfSBncm91cCBHcm91cCB0byBleHBhbmQvY29sbGFwc2UsIG9yIElEIG9mIEdyb3VwIHRvIGV4cGFuZC9jb2xsYXBzZS5cbiAgICAgKi9cbiAgICBfanBpLnByb3RvdHlwZS50b2dnbGVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGdyb3VwID0gdGhpcy5nZXRHcm91cE1hbmFnZXIoKS5nZXRHcm91cChncm91cCk7XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdldEdyb3VwTWFuYWdlcigpW2dyb3VwLmNvbGxhcHNlZCA/IFwiZXhwYW5kR3JvdXBcIiA6IFwiY29sbGFwc2VHcm91cFwiXShncm91cCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBsYXp5IGluaXQgYSBncm91cCBtYW5hZ2VyIGZvciB0aGUgZ2l2ZW4ganNwbHVtYiBpbnN0YW5jZS5cbiAgICAvL1xuICAgIF9qcGkucHJvdG90eXBlLmdldEdyb3VwTWFuYWdlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWdyID0gdGhpc1tHUk9VUF9NQU5BR0VSXTtcbiAgICAgICAgaWYgKG1nciA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZ3IgPSB0aGlzW0dST1VQX01BTkFHRVJdID0gbmV3IEdyb3VwTWFuYWdlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWdyO1xuICAgIH07XG5cbiAgICBfanBpLnByb3RvdHlwZS5yZW1vdmVHcm91cE1hbmFnZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbR1JPVVBfTUFOQUdFUl07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEdyb3VwIHRoYXQgdGhlIGdpdmVuIGVsZW1lbnQgYmVsb25ncyB0bywgbnVsbCBpZiBub25lLlxuICAgICAqIEBtZXRob2QgZ2V0R3JvdXBGb3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbCBFbGVtZW50LCBvciBlbGVtZW50IElELlxuICAgICAqIEByZXR1cm5zIHtHcm91cH0gQSBHcm91cCwgaWYgZm91bmQsIG9yIG51bGwuXG4gICAgICovXG4gICAgX2pwaS5wcm90b3R5cGUuZ2V0R3JvdXBGb3IgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICBlbCA9IHRoaXMuZ2V0RWxlbWVudChlbCk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsW0dST1VQXTtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pLmNhbGwodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzKTtcblxuXG4vKlxuICoganNQbHVtYlxuICogXG4gKiBUaXRsZTpqc1BsdW1iIDIuMS4wXG4gKiBcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHZpc3VhbGx5IGNvbm5lY3QgZWxlbWVudHMgb24gYW4gSFRNTCBwYWdlLCB1c2luZyBTVkcuXG4gKiBcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgJ2Zsb3djaGFydCcgY29ubmVjdG9ycywgY29uc2lzdGluZyBvZiB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBsaW5lIHNlZ21lbnRzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTYganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxuICogXG4gKiBodHRwOi8vanNwbHVtYnRvb2xraXQuY29tXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9zcG9ycml0dC9qc3BsdW1iXG4gKiBcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMMiBsaWNlbnNlcy5cbiAqL1xuO1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciByb290ID0gdGhpcywgX2pwID0gcm9vdC5qc1BsdW1iLCBfanUgPSByb290LmpzUGx1bWJVdGlsO1xuXG4gICAgdmFyIEZsb3djaGFydCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gXCJGbG93Y2hhcnRcIjtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICBwYXJhbXMuc3R1YiA9IHBhcmFtcy5zdHViID09IG51bGwgPyAzMCA6IHBhcmFtcy5zdHViO1xuICAgICAgICB2YXIgc2VnbWVudHMsXG4gICAgICAgICAgICBfc3VwZXIgPSBfanAuQ29ubmVjdG9ycy5BYnN0cmFjdENvbm5lY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgbWlkcG9pbnQgPSBwYXJhbXMubWlkcG9pbnQgPT0gbnVsbCA/IDAuNSA6IHBhcmFtcy5taWRwb2ludCxcbiAgICAgICAgICAgIGFsd2F5c1Jlc3BlY3RTdHVicyA9IHBhcmFtcy5hbHdheXNSZXNwZWN0U3R1YnMgPT09IHRydWUsXG4gICAgICAgICAgICBsYXN0eCA9IG51bGwsIGxhc3R5ID0gbnVsbCwgbGFzdE9yaWVudGF0aW9uLFxuICAgICAgICAgICAgY29ybmVyUmFkaXVzID0gcGFyYW1zLmNvcm5lclJhZGl1cyAhPSBudWxsID8gcGFyYW1zLmNvcm5lclJhZGl1cyA6IDAsXG5cbiAgICAgICAgICAgIC8vIFRPRE8gbm93IGNvbW1vbiBiZXR3ZWVuIHRoaXMgYW5kIEFic3RyYWN0QmV6aWVyRWRpdG9yOyByZWZhY3RvciBpbnRvIHN1cGVyY2xhc3M/XG4gICAgICAgICAgICBsb29wYmFja1JhZGl1cyA9IHBhcmFtcy5sb29wYmFja1JhZGl1cyB8fCAyNSxcbiAgICAgICAgICAgIGlzTG9vcGJhY2tDdXJyZW50bHkgPSBmYWxzZSxcblxuICAgICAgICAgICAgc2duID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbiA8IDAgPyAtMSA6IG4gPT09IDAgPyAwIDogMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGhlbHBlciBtZXRob2QgdG8gYWRkIGEgc2VnbWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWRkU2VnbWVudCA9IGZ1bmN0aW9uIChzZWdtZW50cywgeCwgeSwgcGFpbnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3R4ID09IHggJiYgbGFzdHkgPT0geSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBseCA9IGxhc3R4ID09IG51bGwgPyBwYWludEluZm8uc3ggOiBsYXN0eCxcbiAgICAgICAgICAgICAgICAgICAgbHkgPSBsYXN0eSA9PSBudWxsID8gcGFpbnRJbmZvLnN5IDogbGFzdHksXG4gICAgICAgICAgICAgICAgICAgIG8gPSBseCA9PSB4ID8gXCJ2XCIgOiBcImhcIixcbiAgICAgICAgICAgICAgICAgICAgc2dueCA9IHNnbih4IC0gbHgpLFxuICAgICAgICAgICAgICAgICAgICBzZ255ID0gc2duKHkgLSBseSk7XG5cbiAgICAgICAgICAgICAgICBsYXN0eCA9IHg7XG4gICAgICAgICAgICAgICAgbGFzdHkgPSB5O1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goW2x4LCBseSwgeCwgeSwgbywgc2dueCwgc2dueV0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlZ0xlbmd0aCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhzWzBdIC0gc1syXSwgMikgKyBNYXRoLnBvdyhzWzFdIC0gc1szXSwgMikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jbG9uZUFycmF5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBbXTtcbiAgICAgICAgICAgICAgICBfYS5wdXNoLmFwcGx5KF9hLCBhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2E7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd3JpdGVTZWdtZW50cyA9IGZ1bmN0aW9uIChjb25uLCBzZWdtZW50cywgcGFpbnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBudWxsLCBuZXh0O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQgfHwgX2Nsb25lQXJyYXkoc2VnbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gX2Nsb25lQXJyYXkoc2VnbWVudHNbaSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcm5lclJhZGl1cyA+IDAgJiYgY3VycmVudFs0XSAhPSBuZXh0WzRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFkaXVzVG9Vc2UgPSBNYXRoLm1pbihjb3JuZXJSYWRpdXMsIHNlZ0xlbmd0aChjdXJyZW50KSwgc2VnTGVuZ3RoKG5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGFuZ2xlLiBhZGp1c3QgY3VycmVudCBzZWdtZW50J3MgZW5kIHBvaW50LCBhbmQgbmV4dCBzZWdtZW50J3Mgc3RhcnQgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WzJdIC09IGN1cnJlbnRbNV0gKiByYWRpdXNUb1VzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRbM10gLT0gY3VycmVudFs2XSAqIHJhZGl1c1RvVXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFswXSArPSBuZXh0WzVdICogcmFkaXVzVG9Vc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0WzFdICs9IG5leHRbNl0gKiByYWRpdXNUb1VzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYyA9IChjdXJyZW50WzZdID09IG5leHRbNV0gJiYgbmV4dFs1XSA9PSAxKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGN1cnJlbnRbNl0gPT0gbmV4dFs1XSAmJiBuZXh0WzVdID09PSAwKSAmJiBjdXJyZW50WzVdICE9IG5leHRbNl0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyZW50WzZdID09IG5leHRbNV0gJiYgbmV4dFs1XSA9PSAtMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2dueSA9IG5leHRbMV0gPiBjdXJyZW50WzNdID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNnbnggPSBuZXh0WzBdID4gY3VycmVudFsyXSA/IDEgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZ25FcXVhbCA9IHNnbnkgPT0gc2dueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCA9IChzZ25FcXVhbCAmJiBhYyB8fCAoIXNnbkVxdWFsICYmICFhYykpID8gbmV4dFswXSA6IGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3kgPSAoc2duRXF1YWwgJiYgYWMgfHwgKCFzZ25FcXVhbCAmJiAhYWMpKSA/IGN1cnJlbnRbM10gOiBuZXh0WzFdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3VwZXIuYWRkU2VnbWVudChjb25uLCBcIlN0cmFpZ2h0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MTogY3VycmVudFswXSwgeTE6IGN1cnJlbnRbMV0sIHgyOiBjdXJyZW50WzJdLCB5MjogY3VycmVudFszXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdXBlci5hZGRTZWdtZW50KGNvbm4sIFwiQXJjXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiByYWRpdXNUb1VzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MTogY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MTogY3VycmVudFszXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MjogbmV4dFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MjogbmV4dFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjOiBhY1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkeCArIGR5IGFyZSB1c2VkIHRvIGFkanVzdCBmb3IgbGluZSB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IChjdXJyZW50WzJdID09IGN1cnJlbnRbMF0pID8gMCA6IChjdXJyZW50WzJdID4gY3VycmVudFswXSkgPyAocGFpbnRJbmZvLmx3IC8gMikgOiAtKHBhaW50SW5mby5sdyAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gKGN1cnJlbnRbM10gPT0gY3VycmVudFsxXSkgPyAwIDogKGN1cnJlbnRbM10gPiBjdXJyZW50WzFdKSA/IChwYWludEluZm8ubHcgLyAyKSA6IC0ocGFpbnRJbmZvLmx3IC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3VwZXIuYWRkU2VnbWVudChjb25uLCBcIlN0cmFpZ2h0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MTogY3VycmVudFswXSAtIGR4LCB5MTogY3VycmVudFsxXSAtIGR5LCB4MjogY3VycmVudFsyXSArIGR4LCB5MjogY3VycmVudFszXSArIGR5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYXN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmFkZFNlZ21lbnQoY29ubiwgXCJTdHJhaWdodFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MTogbmV4dFswXSwgeTE6IG5leHRbMV0sIHgyOiBuZXh0WzJdLCB5MjogbmV4dFszXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2NvbXB1dGUgPSBmdW5jdGlvbiAocGFpbnRJbmZvLCBwYXJhbXMpIHtcblxuICAgICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGxhc3R4ID0gbnVsbDtcbiAgICAgICAgICAgIGxhc3R5ID0gbnVsbDtcbiAgICAgICAgICAgIGxhc3RPcmllbnRhdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICAgIHZhciBjb21tb25TdHViQ2FsY3VsYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyBwYWludEluZm8uc3RhcnRTdHViWCwgcGFpbnRJbmZvLnN0YXJ0U3R1YlksIHBhaW50SW5mby5lbmRTdHViWCwgcGFpbnRJbmZvLmVuZFN0dWJZIF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0dWJDYWxjdWxhdG9ycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGVycGVuZGljdWxhcjogY29tbW9uU3R1YkNhbGN1bGF0b3IsXG4gICAgICAgICAgICAgICAgICAgIG9ydGhvZ29uYWw6IGNvbW1vblN0dWJDYWxjdWxhdG9yLFxuICAgICAgICAgICAgICAgICAgICBvcHBvc2l0ZTogZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaSA9IHBhaW50SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBheGlzID09IFwieFwiID8gMCA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlSW5Qcm94aW1pdHkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAocGkuc29baWR4XSA9PSAxICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIChwaS5zdGFydFN0dWJYID4gcGkuZW5kU3R1YlgpICYmIChwaS50eCA+IHBpLnN0YXJ0U3R1YlgpICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIChwaS5zeCA+IHBpLmVuZFN0dWJYKSAmJiAocGkudHggPiBwaS5zeCkpKSkpIHx8XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIChwaS5zb1tpZHhdID09IC0xICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAocGkuc3RhcnRTdHViWCA8IHBpLmVuZFN0dWJYKSAmJiAocGkudHggPCBwaS5zdGFydFN0dWJYKSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggKHBpLnN4IDwgcGkuZW5kU3R1YlgpICYmIChwaS50eCA8IHBpLnN4KSkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAocGkuc29baWR4XSA9PSAxICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIChwaS5zdGFydFN0dWJZID4gcGkuZW5kU3R1YlkpICYmIChwaS50eSA+IHBpLnN0YXJ0U3R1YlkpICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIChwaS5zeSA+IHBpLmVuZFN0dWJZKSAmJiAocGkudHkgPiBwaS5zeSkpKSkpIHx8XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIChwaS5zb1tpZHhdID09IC0xICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAocGkuc3RhcnRTdHViWSA8IHBpLmVuZFN0dWJZKSAmJiAocGkudHkgPCBwaS5zdGFydFN0dWJZKSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggKHBpLnN5IDwgcGkuZW5kU3R1YlkpICYmIChwaS50eSA8IHBpLnN5KSkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFsd2F5c1Jlc3BlY3RTdHVicyAmJiBhcmVJblByb3hpbWl0eVtheGlzXSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IFsocGFpbnRJbmZvLnN4ICsgcGFpbnRJbmZvLnR4KSAvIDIsIHBhaW50SW5mby5zdGFydFN0dWJZLCAocGFpbnRJbmZvLnN4ICsgcGFpbnRJbmZvLnR4KSAvIDIsIHBhaW50SW5mby5lbmRTdHViWV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiBbcGFpbnRJbmZvLnN0YXJ0U3R1YlgsIChwYWludEluZm8uc3kgKyBwYWludEluZm8udHkpIC8gMiwgcGFpbnRJbmZvLmVuZFN0dWJYLCAocGFpbnRJbmZvLnN5ICsgcGFpbnRJbmZvLnR5KSAvIDJdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHBhaW50SW5mby5zdGFydFN0dWJYLCBwYWludEluZm8uc3RhcnRTdHViWSwgcGFpbnRJbmZvLmVuZFN0dWJYLCBwYWludEluZm8uZW5kU3R1YlkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBTdHVicy5cbiAgICAgICAgICAgIHZhciBzdHVicyA9IHN0dWJDYWxjdWxhdG9yc1twYWludEluZm8uYW5jaG9yT3JpZW50YXRpb25dKHBhaW50SW5mby5zb3VyY2VBeGlzKSxcbiAgICAgICAgICAgICAgICBpZHggPSBwYWludEluZm8uc291cmNlQXhpcyA9PSBcInhcIiA/IDAgOiAxLFxuICAgICAgICAgICAgICAgIG9pZHggPSBwYWludEluZm8uc291cmNlQXhpcyA9PSBcInhcIiA/IDEgOiAwLFxuICAgICAgICAgICAgICAgIHNzID0gc3R1YnNbaWR4XSxcbiAgICAgICAgICAgICAgICBvc3MgPSBzdHVic1tvaWR4XSxcbiAgICAgICAgICAgICAgICBlcyA9IHN0dWJzW2lkeCArIDJdLFxuICAgICAgICAgICAgICAgIG9lcyA9IHN0dWJzW29pZHggKyAyXTtcblxuICAgICAgICAgICAgLy8gYWRkIHRoZSBzdGFydCBzdHViIHNlZ21lbnQuIHVzZSBzdHVicyBmb3IgbG9vcGJhY2sgYXMgaXQgd2lsbCBsb29rIGJldHRlciwgd2l0aCB0aGUgbG9vcCBzcGFjZWRcbiAgICAgICAgICAgIC8vIGF3YXkgZnJvbSB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgIGFkZFNlZ21lbnQoc2VnbWVudHMsIHN0dWJzWzBdLCBzdHVic1sxXSwgcGFpbnRJbmZvKTtcblxuICAgICAgICAgICAgLy8gaWYgaXRzIGEgbG9vcGJhY2sgYW5kIHdlIHNob3VsZCB0cmVhdCBpdCBkaWZmZXJlbnRseS5cbiAgICAgICAgICAgIGlmIChmYWxzZSAmJnBhcmFtcy5zb3VyY2VQb3NbMF0gPT0gcGFyYW1zLnRhcmdldFBvc1swXSAmJiBwYXJhbXMuc291cmNlUG9zWzFdID09IHBhcmFtcy50YXJnZXRQb3NbMV0pIHtcblxuICAgICAgICAgICAgICAgIC8vIHdlIHVzZSBsb29wYmFja1JhZGl1cyBoZXJlLCBhcyBzdGF0ZW1hY2hpbmUgY29ubmVjdG9ycyBkby5cbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBnbyByYWRpdXMgdG8gdGhlIGxlZnQgZnJvbSBzdHVic1swXSwgdGhlbiB1cHdhcmRzIGJ5IDIqcmFkaXVzLCB0byB0aGUgcmlnaHQgYnkgMipyYWRpdXMsXG4gICAgICAgICAgICAgICAgLy8gZG93biBieSAyKnJhZGl1cywgbGVmdCBieSByYWRpdXMuXG4gICAgICAgICAgICAgICAgYWRkU2VnbWVudChzZWdtZW50cywgc3R1YnNbMF0gLSBsb29wYmFja1JhZGl1cywgc3R1YnNbMV0sIHBhaW50SW5mbyk7XG4gICAgICAgICAgICAgICAgYWRkU2VnbWVudChzZWdtZW50cywgc3R1YnNbMF0gLSBsb29wYmFja1JhZGl1cywgc3R1YnNbMV0gLSAoMiAqIGxvb3BiYWNrUmFkaXVzKSwgcGFpbnRJbmZvKTtcbiAgICAgICAgICAgICAgICBhZGRTZWdtZW50KHNlZ21lbnRzLCBzdHVic1swXSArIGxvb3BiYWNrUmFkaXVzLCBzdHVic1sxXSAtICgyICogbG9vcGJhY2tSYWRpdXMpLCBwYWludEluZm8pO1xuICAgICAgICAgICAgICAgIGFkZFNlZ21lbnQoc2VnbWVudHMsIHN0dWJzWzBdICsgbG9vcGJhY2tSYWRpdXMsIHN0dWJzWzFdLCBwYWludEluZm8pO1xuICAgICAgICAgICAgICAgIGFkZFNlZ21lbnQoc2VnbWVudHMsIHN0dWJzWzBdLCBzdHVic1sxXSwgcGFpbnRJbmZvKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cblxuICAgICAgICAgICAgICAgIHZhciBtaWR4ID0gcGFpbnRJbmZvLnN0YXJ0U3R1YlggKyAoKHBhaW50SW5mby5lbmRTdHViWCAtIHBhaW50SW5mby5zdGFydFN0dWJYKSAqIG1pZHBvaW50KSxcbiAgICAgICAgICAgICAgICAgICAgbWlkeSA9IHBhaW50SW5mby5zdGFydFN0dWJZICsgKChwYWludEluZm8uZW5kU3R1YlkgLSBwYWludEluZm8uc3RhcnRTdHViWSkgKiBtaWRwb2ludCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3JpZW50YXRpb25zID0geyB4OiBbIDAsIDEgXSwgeTogWyAxLCAwIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgbGluZUNhbGN1bGF0b3JzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVycGVuZGljdWxhcjogZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBwYWludEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIFsgMSwgMiwgMywgNCBdLCBudWxsLCBbIDIsIDEsIDQsIDMgXSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBbIDQsIDMsIDIsIDEgXSwgbnVsbCwgWyAzLCA0LCAxLCAyIF0gXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIFsgMywgMiwgMSwgNCBdLCBudWxsLCBbIDIsIDMsIDQsIDEgXSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBbIDQsIDEsIDIsIDMgXSwgbnVsbCwgWyAxLCA0LCAzLCAyIF0gXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHVicyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IFsgWyBwaS5zdGFydFN0dWJYLCBwaS5lbmRTdHViWCBdLCBudWxsLCBbIHBpLmVuZFN0dWJYLCBwaS5zdGFydFN0dWJYIF0gXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IFsgWyBwaS5zdGFydFN0dWJZLCBwaS5lbmRTdHViWSBdLCBudWxsLCBbIHBpLmVuZFN0dWJZLCBwaS5zdGFydFN0dWJZIF0gXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRMaW5lcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IFsgWyBtaWR4LCBwaS5zdGFydFN0dWJZIF0sIFsgbWlkeCwgcGkuZW5kU3R1YlkgXSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogWyBbIHBpLnN0YXJ0U3R1YlgsIG1pZHkgXSwgWyBwaS5lbmRTdHViWCwgbWlkeSBdIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNUb0VuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IFsgWyBwaS5lbmRTdHViWCwgcGkuc3RhcnRTdHViWSBdIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBbIFsgcGkuc3RhcnRTdHViWCwgcGkuZW5kU3R1YlkgXSBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VG9FbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBbIFsgcGkuc3RhcnRTdHViWCwgcGkuZW5kU3R1YlkgXSwgWyBwaS5lbmRTdHViWCwgcGkuZW5kU3R1YlkgXSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogWyBbIHBpLmVuZFN0dWJYLCBwaS5zdGFydFN0dWJZIF0sIFsgcGkuZW5kU3R1YlgsIHBpLmVuZFN0dWJZIF0gXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRvTWlkVG9FbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBbIFsgcGkuc3RhcnRTdHViWCwgbWlkeSBdLCBbIHBpLmVuZFN0dWJYLCBtaWR5IF0sIFsgcGkuZW5kU3R1YlgsIHBpLmVuZFN0dWJZIF0gXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IFsgWyBtaWR4LCBwaS5zdGFydFN0dWJZIF0sIFsgbWlkeCwgcGkuZW5kU3R1YlkgXSwgWyBwaS5lbmRTdHViWCwgcGkuZW5kU3R1YlkgXSBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyU3R1YnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBbIHBpLnN0YXJ0U3R1YlksIHBpLmVuZFN0dWJZIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBbIHBpLnN0YXJ0U3R1YlgsIHBpLmVuZFN0dWJYIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29JZHggPSBvcmllbnRhdGlvbnNbYXhpc11bMF0sIHRvSWR4ID0gb3JpZW50YXRpb25zW2F4aXNdWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc28gPSBwaS5zb1tzb0lkeF0gKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdG8gPSBwaS50b1t0b0lkeF0gKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlckZsaXBwZWQgPSAocGkudG9bdG9JZHhdID09IC0xICYmIChvdGhlclN0dWJzW2F4aXNdWzFdIDwgb3RoZXJTdHVic1theGlzXVswXSkpIHx8IChwaS50b1t0b0lkeF0gPT0gMSAmJiAob3RoZXJTdHVic1theGlzXVsxXSA+IG90aGVyU3R1YnNbYXhpc11bMF0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R1YjEgPSBzdHVic1theGlzXVtfc29dWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHViMiA9IHN0dWJzW2F4aXNdW19zb11bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRJbmRleGVzID0gc2lzW2F4aXNdW19zb11bX3RvXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaS5zZWdtZW50ID09IHNlZ21lbnRJbmRleGVzWzNdIHx8IChwaS5zZWdtZW50ID09IHNlZ21lbnRJbmRleGVzWzJdICYmIG90aGVyRmxpcHBlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pZExpbmVzW2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwaS5zZWdtZW50ID09IHNlZ21lbnRJbmRleGVzWzJdICYmIHN0dWIyIDwgc3R1YjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzVG9FbmRbYXhpc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwaS5zZWdtZW50ID09IHNlZ21lbnRJbmRleGVzWzJdICYmIHN0dWIyID49IHN0dWIxKSB8fCAocGkuc2VnbWVudCA9PSBzZWdtZW50SW5kZXhlc1sxXSAmJiAhb3RoZXJGbGlwcGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRUb01pZFRvRW5kW2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwaS5zZWdtZW50ID09IHNlZ21lbnRJbmRleGVzWzBdIHx8IChwaS5zZWdtZW50ID09IHNlZ21lbnRJbmRleGVzWzFdICYmIG90aGVyRmxpcHBlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0VG9FbmRbYXhpc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ydGhvZ29uYWw6IGZ1bmN0aW9uIChheGlzLCBzdGFydFN0dWIsIG90aGVyU3RhcnRTdHViLCBlbmRTdHViLCBvdGhlckVuZFN0dWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBwYWludEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiBwaS5zb1swXSA9PSAtMSA/IE1hdGgubWluKHN0YXJ0U3R1YiwgZW5kU3R1YikgOiBNYXRoLm1heChzdGFydFN0dWIsIGVuZFN0dWIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IHBpLnNvWzFdID09IC0xID8gTWF0aC5taW4oc3RhcnRTdHViLCBlbmRTdHViKSA6IE1hdGgubWF4KHN0YXJ0U3R1YiwgZW5kU3R1YilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVtheGlzXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIGV4dGVudCwgb3RoZXJTdGFydFN0dWIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgZXh0ZW50LCBvdGhlckVuZFN0dWIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgZW5kU3R1Yiwgb3RoZXJFbmRTdHViIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgb3RoZXJTdGFydFN0dWIsIGV4dGVudCBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBvdGhlckVuZFN0dWIsIGV4dGVudCBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBvdGhlckVuZFN0dWIsIGVuZFN0dWIgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHBvc2l0ZTogZnVuY3Rpb24gKGF4aXMsIHNzLCBvc3MsIGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpID0gcGFpbnRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlckF4aXMgPSB7XCJ4XCI6IFwieVwiLCBcInlcIjogXCJ4XCJ9W2F4aXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW0gPSB7XCJ4XCI6IFwiaGVpZ2h0XCIsIFwieVwiOiBcIndpZHRoXCJ9W2F4aXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJhdG9yID0gcGlbXCJpc1wiICsgYXhpcy50b1VwcGVyQ2FzZSgpICsgXCJHcmVhdGVyVGhhblN0dWJUaW1lczJcIl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnNvdXJjZUVuZHBvaW50LmVsZW1lbnRJZCA9PSBwYXJhbXMudGFyZ2V0RW5kcG9pbnQuZWxlbWVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdmFsID0gb3NzICsgKCgxIC0gcGFyYW1zLnNvdXJjZUVuZHBvaW50LmFuY2hvcltvdGhlckF4aXNdKSAqIHBhcmFtcy5zb3VyY2VJbmZvW2RpbV0pICsgX3N1cGVyLm1heFN0dWI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInhcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgc3MsIF92YWwgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIGVzLCBfdmFsIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgX3ZhbCwgc3MgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIF92YWwsIGVzIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVtheGlzXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghY29tcGFyYXRvciB8fCAocGkuc29baWR4XSA9PSAxICYmIHNzID4gZXMpIHx8IChwaS5zb1tpZHhdID09IC0xICYmIHNzIDwgZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInhcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgc3MsIG1pZHkgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIGVzLCBtaWR5IF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgbWlkeCwgc3MgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIG1pZHgsIGVzIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHBpLnNvW2lkeF0gPT0gMSAmJiBzcyA8IGVzKSB8fCAocGkuc29baWR4XSA9PSAtMSAmJiBzcyA+IGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIG1pZHgsIHBpLnN5IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBtaWR4LCBwaS50eSBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIHBpLnN4LCBtaWR5IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBwaS50eCwgbWlkeSBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1bYXhpc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSB0aGUgcmVzdCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgICAgIHZhciBwID0gbGluZUNhbGN1bGF0b3JzW3BhaW50SW5mby5hbmNob3JPcmllbnRhdGlvbl0ocGFpbnRJbmZvLnNvdXJjZUF4aXMsIHNzLCBvc3MsIGVzLCBvZXMpO1xuICAgICAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU2VnbWVudChzZWdtZW50cywgcFtpXVswXSwgcFtpXVsxXSwgcGFpbnRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGxpbmUgdG8gZW5kIHN0dWJcbiAgICAgICAgICAgICAgICBhZGRTZWdtZW50KHNlZ21lbnRzLCBzdHVic1syXSwgc3R1YnNbM10sIHBhaW50SW5mbyk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZW5kIHN0dWIgdG8gZW5kIChjb21tb24pXG4gICAgICAgICAgICBhZGRTZWdtZW50KHNlZ21lbnRzLCBwYWludEluZm8udHgsIHBhaW50SW5mby50eSwgcGFpbnRJbmZvKTtcblxuICAgICAgICAgICAgLy8gd3JpdGUgb3V0IHRoZSBzZWdtZW50cy5cbiAgICAgICAgICAgIHdyaXRlU2VnbWVudHModGhpcywgc2VnbWVudHMsIHBhaW50SW5mbyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyp0aGlzLmdldFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2xhc3QgPSBudWxsLCBfbGFzdEF4aXMgPSBudWxsLCBzID0gW10sIHNlZ3MgPSBzZWdtZW50cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzW2ldLCBheGlzID0gc2VnWzRdLCBheGlzSW5kZXggPSAoYXhpcyA9PSBcInZcIiA/IDMgOiAyKTtcbiAgICAgICAgICAgICAgICBpZiAoX2xhc3QgIT0gbnVsbCAmJiBfbGFzdEF4aXMgPT09IGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX2xhc3RbYXhpc0luZGV4XSA9IHNlZ1theGlzSW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ1swXSAhPSBzZWdbMl0gfHwgc2VnWzFdICE9IHNlZ1szXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogWyBzZWdbMF0sIHNlZ1sxXSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogWyBzZWdbMl0sIHNlZ1szXSBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sYXN0ID0gc2VnO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xhc3RBeGlzID0gc2VnWzRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07Ki9cbiAgICB9O1xuXG4gICAgX2p1LmV4dGVuZChGbG93Y2hhcnQsIF9qcC5Db25uZWN0b3JzLkFic3RyYWN0Q29ubmVjdG9yKTtcbiAgICBfanAucmVnaXN0ZXJDb25uZWN0b3JUeXBlKEZsb3djaGFydCwgXCJGbG93Y2hhcnRcIik7XG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG4vKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBjb2RlIGZvciB0aGUgQmV6aWVyIGNvbm5lY3RvciB0eXBlLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTUganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxuICogXG4gKiBodHRwczovL2pzcGx1bWJ0b29sa2l0LmNvbVxuICogaHR0cDovL2dpdGh1Yi5jb20vc3BvcnJpdHQvanNwbHVtYlxuICogXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXG4gKi9cbjtcbihmdW5jdGlvbiAoKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcm9vdCA9IHRoaXMsIF9qcCA9IHJvb3QuanNQbHVtYiwgX2p1ID0gcm9vdC5qc1BsdW1iVXRpbDtcblxuICAgIF9qcC5Db25uZWN0b3JzLkFic3RyYWN0QmV6aWVyQ29ubmVjdG9yID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgdmFyIHNob3dMb29wYmFjayA9IHBhcmFtcy5zaG93TG9vcGJhY2sgIT09IGZhbHNlLFxuICAgICAgICAgICAgY3VydmluZXNzID0gcGFyYW1zLmN1cnZpbmVzcyB8fCAxMCxcbiAgICAgICAgICAgIG1hcmdpbiA9IHBhcmFtcy5tYXJnaW4gfHwgNSxcbiAgICAgICAgICAgIHByb3hpbWl0eUxpbWl0ID0gcGFyYW1zLnByb3hpbWl0eUxpbWl0IHx8IDgwLFxuICAgICAgICAgICAgY2xvY2t3aXNlID0gcGFyYW1zLm9yaWVudGF0aW9uICYmIHBhcmFtcy5vcmllbnRhdGlvbiA9PT0gXCJjbG9ja3dpc2VcIixcbiAgICAgICAgICAgIGxvb3BiYWNrUmFkaXVzID0gcGFyYW1zLmxvb3BiYWNrUmFkaXVzIHx8IDI1LFxuICAgICAgICAgICAgaXNMb29wYmFja0N1cnJlbnRseSA9IGZhbHNlLFxuICAgICAgICAgICAgX3N1cGVyO1xuXG4gICAgICAgIHRoaXMub3ZlcnJpZGVTZXRFZGl0YWJsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gIWlzTG9vcGJhY2tDdXJyZW50bHk7IH07XG5cbiAgICAgICAgdGhpcy5fY29tcHV0ZSA9IGZ1bmN0aW9uIChwYWludEluZm8sIHApIHtcblxuICAgICAgICAgICAgdmFyIHNwID0gcC5zb3VyY2VQb3MsXG4gICAgICAgICAgICAgICAgdHAgPSBwLnRhcmdldFBvcyxcbiAgICAgICAgICAgICAgICBfdyA9IE1hdGguYWJzKHNwWzBdIC0gdHBbMF0pLFxuICAgICAgICAgICAgICAgIF9oID0gTWF0aC5hYnMoc3BbMV0gLSB0cFsxXSk7XG5cbiAgICAgICAgICAgIGlmICghc2hvd0xvb3BiYWNrIHx8IChwLnNvdXJjZUVuZHBvaW50LmVsZW1lbnRJZCAhPT0gcC50YXJnZXRFbmRwb2ludC5lbGVtZW50SWQpKSB7XG4gICAgICAgICAgICAgICAgaXNMb29wYmFja0N1cnJlbnRseSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVCZXppZXIocGFpbnRJbmZvLCBwLCBzcCwgdHAsIF93LCBfaCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzTG9vcGJhY2tDdXJyZW50bHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGEgbG9vcGJhY2sgY29ubmVjdG9yLiAgZHJhdyBhbiBhcmMgZnJvbSBvbmUgYW5jaG9yIHRvIHRoZSBvdGhlci5cbiAgICAgICAgICAgICAgICB2YXIgeDEgPSBwLnNvdXJjZVBvc1swXSwgeTEgPSBwLnNvdXJjZVBvc1sxXSAtIG1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgY3ggPSB4MSwgY3kgPSB5MSAtIGxvb3BiYWNrUmFkaXVzLFxuICAgICAgICAgICAgICAgIC8vIGNhbnZhcyBzaXppbmcgc3R1ZmYsIHRvIGVuc3VyZSB0aGUgd2hvbGUgcGFpbnRlZCBhcmVhIGlzIHZpc2libGUuXG4gICAgICAgICAgICAgICAgICAgIF94ID0gY3ggLSBsb29wYmFja1JhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgX3kgPSBjeSAtIGxvb3BiYWNrUmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgX3cgPSAyICogbG9vcGJhY2tSYWRpdXM7XG4gICAgICAgICAgICAgICAgX2ggPSAyICogbG9vcGJhY2tSYWRpdXM7XG5cbiAgICAgICAgICAgICAgICBwYWludEluZm8ucG9pbnRzWzBdID0gX3g7XG4gICAgICAgICAgICAgICAgcGFpbnRJbmZvLnBvaW50c1sxXSA9IF95O1xuICAgICAgICAgICAgICAgIHBhaW50SW5mby5wb2ludHNbMl0gPSBfdztcbiAgICAgICAgICAgICAgICBwYWludEluZm8ucG9pbnRzWzNdID0gX2g7XG5cbiAgICAgICAgICAgICAgICAvLyBBREQgQU4gQVJDIFNFR01FTlQuXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFkZFNlZ21lbnQodGhpcywgXCJBcmNcIiwge1xuICAgICAgICAgICAgICAgICAgICBsb29wYmFjazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgeDE6ICh4MSAtIF94KSArIDQsXG4gICAgICAgICAgICAgICAgICAgIHkxOiB5MSAtIF95LFxuICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogMiAqIE1hdGguUEksXG4gICAgICAgICAgICAgICAgICAgIHI6IGxvb3BiYWNrUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBhYzogIWNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICAgICAgeDI6ICh4MSAtIF94KSAtIDQsXG4gICAgICAgICAgICAgICAgICAgIHkyOiB5MSAtIF95LFxuICAgICAgICAgICAgICAgICAgICBjeDogY3ggLSBfeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IGN5IC0gX3lcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfc3VwZXIgPSBfanAuQ29ubmVjdG9ycy5BYnN0cmFjdENvbm5lY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gX3N1cGVyO1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuQ29ubmVjdG9ycy5BYnN0cmFjdEJlemllckNvbm5lY3RvciwgX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RDb25uZWN0b3IpO1xuXG4gICAgdmFyIEJlemllciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkJlemllclwiO1xuXG4gICAgICAgIHZhciBfc3VwZXIgPSBfanAuQ29ubmVjdG9ycy5BYnN0cmFjdEJlemllckNvbm5lY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgbWFqb3JBbmNob3IgPSBwYXJhbXMuY3VydmluZXNzIHx8IDE1MCxcbiAgICAgICAgICAgIG1pbm9yQW5jaG9yID0gMTA7XG5cbiAgICAgICAgdGhpcy5nZXRDdXJ2aW5lc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFqb3JBbmNob3I7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fZmluZENvbnRyb2xQb2ludCA9IGZ1bmN0aW9uIChwb2ludCwgc291cmNlQW5jaG9yUG9zaXRpb24sIHRhcmdldEFuY2hvclBvc2l0aW9uLCBzb3VyY2VFbmRwb2ludCwgdGFyZ2V0RW5kcG9pbnQsIHNvbywgdG9vKSB7XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgdGhlIHR3byBhbmNob3JzIGFyZSBwZXJwZW5kaWN1bGFyIHRvIGVhY2ggb3RoZXIgaW4gdGhlaXIgb3JpZW50YXRpb24uICB3ZSBzd2FwIHRoZSBjb250cm9sXG4gICAgICAgICAgICAvLyBwb2ludHMgYXJvdW5kIGlmIHNvIChjb2RlIGNvdWxkIGJlIHRpZ2h0ZW5lZCB1cClcbiAgICAgICAgICAgIHZhciBwZXJwZW5kaWN1bGFyID0gc29vWzBdICE9IHRvb1swXSB8fCBzb29bMV0gPT0gdG9vWzFdLFxuICAgICAgICAgICAgICAgIHAgPSBbXTtcblxuICAgICAgICAgICAgaWYgKCFwZXJwZW5kaWN1bGFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvb1swXSA9PT0gMCkgLy8gWFxuICAgICAgICAgICAgICAgICAgICBwLnB1c2goc291cmNlQW5jaG9yUG9zaXRpb25bMF0gPCB0YXJnZXRBbmNob3JQb3NpdGlvblswXSA/IHBvaW50WzBdICsgbWlub3JBbmNob3IgOiBwb2ludFswXSAtIG1pbm9yQW5jaG9yKTtcbiAgICAgICAgICAgICAgICBlbHNlIHAucHVzaChwb2ludFswXSAtIChtYWpvckFuY2hvciAqIHNvb1swXSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNvb1sxXSA9PT0gMCkgLy8gWVxuICAgICAgICAgICAgICAgICAgICBwLnB1c2goc291cmNlQW5jaG9yUG9zaXRpb25bMV0gPCB0YXJnZXRBbmNob3JQb3NpdGlvblsxXSA/IHBvaW50WzFdICsgbWlub3JBbmNob3IgOiBwb2ludFsxXSAtIG1pbm9yQW5jaG9yKTtcbiAgICAgICAgICAgICAgICBlbHNlIHAucHVzaChwb2ludFsxXSArIChtYWpvckFuY2hvciAqIHRvb1sxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1swXSA9PT0gMCkgLy8gWFxuICAgICAgICAgICAgICAgICAgICBwLnB1c2godGFyZ2V0QW5jaG9yUG9zaXRpb25bMF0gPCBzb3VyY2VBbmNob3JQb3NpdGlvblswXSA/IHBvaW50WzBdICsgbWlub3JBbmNob3IgOiBwb2ludFswXSAtIG1pbm9yQW5jaG9yKTtcbiAgICAgICAgICAgICAgICBlbHNlIHAucHVzaChwb2ludFswXSArIChtYWpvckFuY2hvciAqIHRvb1swXSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRvb1sxXSA9PT0gMCkgLy8gWVxuICAgICAgICAgICAgICAgICAgICBwLnB1c2godGFyZ2V0QW5jaG9yUG9zaXRpb25bMV0gPCBzb3VyY2VBbmNob3JQb3NpdGlvblsxXSA/IHBvaW50WzFdICsgbWlub3JBbmNob3IgOiBwb2ludFsxXSAtIG1pbm9yQW5jaG9yKTtcbiAgICAgICAgICAgICAgICBlbHNlIHAucHVzaChwb2ludFsxXSArIChtYWpvckFuY2hvciAqIHNvb1sxXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9jb21wdXRlQmV6aWVyID0gZnVuY3Rpb24gKHBhaW50SW5mbywgcCwgc3AsIHRwLCBfdywgX2gpIHtcblxuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpLCBfQ1AsIF9DUDIsXG4gICAgICAgICAgICAgICAgX3N4ID0gc3BbMF0gPCB0cFswXSA/IF93IDogMCxcbiAgICAgICAgICAgICAgICBfc3kgPSBzcFsxXSA8IHRwWzFdID8gX2ggOiAwLFxuICAgICAgICAgICAgICAgIF90eCA9IHNwWzBdIDwgdHBbMF0gPyAwIDogX3csXG4gICAgICAgICAgICAgICAgX3R5ID0gc3BbMV0gPCB0cFsxXSA/IDAgOiBfaDtcblxuICAgICAgICAgICAgaWYgKCh0aGlzLmhhc0JlZW5FZGl0ZWQoKSB8fCB0aGlzLmlzRWRpdGluZygpKSAmJiBnZW9tZXRyeSAhPSBudWxsICYmIGdlb21ldHJ5LmNvbnRyb2xQb2ludHMgIT0gbnVsbCAmJiBnZW9tZXRyeS5jb250cm9sUG9pbnRzWzBdICE9IG51bGwgJiYgZ2VvbWV0cnkuY29udHJvbFBvaW50c1sxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX0NQID0gZ2VvbWV0cnkuY29udHJvbFBvaW50c1swXTtcbiAgICAgICAgICAgICAgICBfQ1AyID0gZ2VvbWV0cnkuY29udHJvbFBvaW50c1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9DUCA9IHRoaXMuX2ZpbmRDb250cm9sUG9pbnQoW19zeCwgX3N5XSwgc3AsIHRwLCBwLnNvdXJjZUVuZHBvaW50LCBwLnRhcmdldEVuZHBvaW50LCBwYWludEluZm8uc28sIHBhaW50SW5mby50byk7XG4gICAgICAgICAgICAgICAgX0NQMiA9IHRoaXMuX2ZpbmRDb250cm9sUG9pbnQoW190eCwgX3R5XSwgdHAsIHNwLCBwLnRhcmdldEVuZHBvaW50LCBwLnNvdXJjZUVuZHBvaW50LCBwYWludEluZm8udG8sIHBhaW50SW5mby5zbyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9zdXBlci5zZXRHZW9tZXRyeSh7Y29udHJvbFBvaW50czpbX0NQLCBfQ1AyXX0sIHRydWUpO1xuXG4gICAgICAgICAgICBfc3VwZXIuYWRkU2VnbWVudCh0aGlzLCBcIkJlemllclwiLCB7XG4gICAgICAgICAgICAgICAgeDE6IF9zeCwgeTE6IF9zeSwgeDI6IF90eCwgeTI6IF90eSxcbiAgICAgICAgICAgICAgICBjcDF4OiBfQ1BbMF0sIGNwMXk6IF9DUFsxXSwgY3AyeDogX0NQMlswXSwgY3AyeTogX0NQMlsxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cblxuICAgIH07XG5cbiAgICBfanUuZXh0ZW5kKEJlemllciwgX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RCZXppZXJDb25uZWN0b3IpO1xuICAgIF9qcC5yZWdpc3RlckNvbm5lY3RvclR5cGUoQmV6aWVyLCBcIkJlemllclwiKTtcblxufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgc3RhdGUgbWFjaGluZSBjb25uZWN0b3JzLCB3aGljaCBleHRlbmQgQWJzdHJhY3RCZXppZXJDb25uZWN0b3IuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNSBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXG4gKiBcbiAqIGh0dHBzOi8vanNwbHVtYnRvb2xraXQuY29tXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9zcG9ycml0dC9qc3BsdW1iXG4gKiBcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMMiBsaWNlbnNlcy5cbiAqL1xuO1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciByb290ID0gdGhpcywgX2pwID0gcm9vdC5qc1BsdW1iLCBfanUgPSByb290LmpzUGx1bWJVdGlsO1xuXG4gICAgdmFyIF9zZWdtZW50ID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICBpZiAoeDEgPD0geDIgJiYgeTIgPD0geTEpIHJldHVybiAxO1xuICAgICAgICAgICAgZWxzZSBpZiAoeDEgPD0geDIgJiYgeTEgPD0geTIpIHJldHVybiAyO1xuICAgICAgICAgICAgZWxzZSBpZiAoeDIgPD0geDEgJiYgeTIgPj0geTEpIHJldHVybiAzO1xuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH0sXG5cbiAgICAvLyB0aGUgY29udHJvbCBwb2ludCB3ZSB3aWxsIHVzZSBkZXBlbmRzIG9uIHRoZSBmYWNlcyB0byB3aGljaCBlYWNoIGVuZCBvZiB0aGUgY29ubmVjdGlvbiBpcyBhc3NpZ25lZCwgc3BlY2lmaWNhbGx5IHdoZXRoZXIgb3Igbm90IHRoZVxuICAgIC8vIHR3byBmYWNlcyBhcmUgcGFyYWxsZWwgb3IgcGVycGVuZGljdWxhci4gIGlmIHRoZXkgYXJlIHBhcmFsbGVsIHRoZW4gdGhlIGNvbnRyb2wgcG9pbnQgbGllcyBvbiB0aGUgbWlkcG9pbnQgb2YgdGhlIGF4aXMgaW4gd2hpY2ggdGhleVxuICAgIC8vIGFyZSBwYXJlbGxlbCBhbmQgdmFyaWVzIG9ubHkgaW4gdGhlIG90aGVyIGF4aXM7IHRoaXMgdmFyaWF0aW9uIGlzIHByb3BvcnRpb25hbCB0byB0aGUgZGlzdGFuY2UgdGhhdCB0aGUgYW5jaG9yIHBvaW50cyBsaWUgZnJvbSB0aGVcbiAgICAvLyBjZW50ZXIgb2YgdGhhdCBmYWNlLiAgaWYgdGhlIHR3byBmYWNlcyBhcmUgcGVycGVuZGljdWxhciB0aGVuIHRoZSBjb250cm9sIHBvaW50IGlzIGF0IHNvbWUgZGlzdGFuY2UgZnJvbSBib3RoIHRoZSBtaWRwb2ludHM7IHRoZSBhbW91bnQgYW5kXG4gICAgLy8gZGlyZWN0aW9uIGFyZSBkZXBlbmRlbnQgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSB0d28gZWxlbWVudHMuICdzZWcnLCBwYXNzZWQgaW4gdG8gdGhpcyBtZXRob2QsIHRlbGxzIHlvdSB3aGljaCBzZWdtZW50IHRoZSB0YXJnZXQgZWxlbWVudFxuICAgIC8vIGxpZXMgaW4gd2l0aCByZXNwZWN0IHRvIHRoZSBzb3VyY2U6IDEgaXMgdG9wIHJpZ2h0LCAyIGlzIGJvdHRvbSByaWdodCwgMyBpcyBib3R0b20gbGVmdCwgNCBpcyB0b3AgbGVmdC5cbiAgICAvL1xuICAgIC8vIHNvdXJjZVBvcyBhbmQgdGFyZ2V0UG9zIGFyZSBhcnJheXMgb2YgaW5mbyBhYm91dCB3aGVyZSBvbiB0aGUgc291cmNlIGFuZCB0YXJnZXQgZWFjaCBhbmNob3IgaXMgbG9jYXRlZC4gIHRoZWlyIGNvbnRlbnRzIGFyZTpcbiAgICAvL1xuICAgIC8vIDAgLSBhYnNvbHV0ZSB4XG4gICAgLy8gMSAtIGFic29sdXRlIHlcbiAgICAvLyAyIC0gcHJvcG9ydGlvbmFsIHggaW4gZWxlbWVudCAoMCBpcyBsZWZ0IGVkZ2UsIDEgaXMgcmlnaHQgZWRnZSlcbiAgICAvLyAzIC0gcHJvcG9ydGlvbmFsIHkgaW4gZWxlbWVudCAoMCBpcyB0b3AgZWRnZSwgMSBpcyBib3R0b20gZWRnZSlcbiAgICAvL1xuICAgICAgICBfZmluZENvbnRyb2xQb2ludCA9IGZ1bmN0aW9uIChtaWR4LCBtaWR5LCBzZWdtZW50LCBzb3VyY2VFZGdlLCB0YXJnZXRFZGdlLCBkeCwgZHksIGRpc3RhbmNlLCBwcm94aW1pdHlMaW1pdCkge1xuICAgICAgICAgICAgLy8gVE9ETyAobWF5YmUpXG4gICAgICAgICAgICAvLyAtIGlmIGFuY2hvciBwb3MgaXMgMC41LCBtYWtlIHRoZSBjb250cm9sIHBvaW50IHRha2UgaW50byBhY2NvdW50IHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudHMuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPD0gcHJveGltaXR5TGltaXQpIHJldHVybiBbbWlkeCwgbWlkeV07XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZUVkZ2VbM10gPD0gMCAmJiB0YXJnZXRFZGdlWzNdID49IDEpIHJldHVybiBbIG1pZHggKyAoc291cmNlRWRnZVsyXSA8IDAuNSA/IC0xICogZHggOiBkeCksIG1pZHkgXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VFZGdlWzJdID49IDEgJiYgdGFyZ2V0RWRnZVsyXSA8PSAwKSByZXR1cm4gWyBtaWR4LCBtaWR5ICsgKHNvdXJjZUVkZ2VbM10gPCAwLjUgPyAtMSAqIGR5IDogZHkpIF07XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gWyBtaWR4ICsgKC0xICogZHgpICwgbWlkeSArICgtMSAqIGR5KSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VnbWVudCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VFZGdlWzNdID49IDEgJiYgdGFyZ2V0RWRnZVszXSA8PSAwKSByZXR1cm4gWyBtaWR4ICsgKHNvdXJjZUVkZ2VbMl0gPCAwLjUgPyAtMSAqIGR4IDogZHgpLCBtaWR5IF07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlRWRnZVsyXSA+PSAxICYmIHRhcmdldEVkZ2VbMl0gPD0gMCkgcmV0dXJuIFsgbWlkeCwgbWlkeSArIChzb3VyY2VFZGdlWzNdIDwgMC41ID8gLTEgKiBkeSA6IGR5KSBdO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIFsgbWlkeCArIGR4LCBtaWR5ICsgKC0xICogZHkpIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWdtZW50ID09PSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZUVkZ2VbM10gPj0gMSAmJiB0YXJnZXRFZGdlWzNdIDw9IDApIHJldHVybiBbIG1pZHggKyAoc291cmNlRWRnZVsyXSA8IDAuNSA/IC0xICogZHggOiBkeCksIG1pZHkgXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VFZGdlWzJdIDw9IDAgJiYgdGFyZ2V0RWRnZVsyXSA+PSAxKSByZXR1cm4gWyBtaWR4LCBtaWR5ICsgKHNvdXJjZUVkZ2VbM10gPCAwLjUgPyAtMSAqIGR5IDogZHkpIF07XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gWyBtaWR4ICsgKC0xICogZHgpICwgbWlkeSArICgtMSAqIGR5KSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VnbWVudCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VFZGdlWzNdIDw9IDAgJiYgdGFyZ2V0RWRnZVszXSA+PSAxKSByZXR1cm4gWyBtaWR4ICsgKHNvdXJjZUVkZ2VbMl0gPCAwLjUgPyAtMSAqIGR4IDogZHgpLCBtaWR5IF07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlRWRnZVsyXSA8PSAwICYmIHRhcmdldEVkZ2VbMl0gPj0gMSkgcmV0dXJuIFsgbWlkeCwgbWlkeSArIChzb3VyY2VFZGdlWzNdIDwgMC41ID8gLTEgKiBkeSA6IGR5KSBdO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIFsgbWlkeCArIGR4ICwgbWlkeSArICgtMSAqIGR5KSBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICB2YXIgU3RhdGVNYWNoaW5lID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHRoaXMudHlwZSA9IFwiU3RhdGVNYWNoaW5lXCI7XG5cbiAgICAgICAgdmFyIF9zdXBlciA9IF9qcC5Db25uZWN0b3JzLkFic3RyYWN0QmV6aWVyQ29ubmVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICBjdXJ2aW5lc3MgPSBwYXJhbXMuY3VydmluZXNzIHx8IDEwLFxuICAgICAgICAgICAgbWFyZ2luID0gcGFyYW1zLm1hcmdpbiB8fCA1LFxuICAgICAgICAgICAgcHJveGltaXR5TGltaXQgPSBwYXJhbXMucHJveGltaXR5TGltaXQgfHwgODAsXG4gICAgICAgICAgICBjbG9ja3dpc2UgPSBwYXJhbXMub3JpZW50YXRpb24gJiYgcGFyYW1zLm9yaWVudGF0aW9uID09PSBcImNsb2Nrd2lzZVwiLFxuICAgICAgICAgICAgX2NvbnRyb2xQb2ludDtcblxuICAgICAgICB0aGlzLl9jb21wdXRlQmV6aWVyID0gZnVuY3Rpb24ocGFpbnRJbmZvLCBwYXJhbXMsIHNwLCB0cCwgdywgaCkge1xuICAgICAgICAgICAgdmFyIF9zeCA9IHBhcmFtcy5zb3VyY2VQb3NbMF0gPCBwYXJhbXMudGFyZ2V0UG9zWzBdID8gMCA6IHcsXG4gICAgICAgICAgICAgICAgX3N5ID0gcGFyYW1zLnNvdXJjZVBvc1sxXSA8IHBhcmFtcy50YXJnZXRQb3NbMV0gPyAwIDogaCxcbiAgICAgICAgICAgICAgICBfdHggPSBwYXJhbXMuc291cmNlUG9zWzBdIDwgcGFyYW1zLnRhcmdldFBvc1swXSA/IHcgOiAwLFxuICAgICAgICAgICAgICAgIF90eSA9IHBhcmFtcy5zb3VyY2VQb3NbMV0gPCBwYXJhbXMudGFyZ2V0UG9zWzFdID8gaCA6IDA7XG5cbiAgICAgICAgICAgIC8vIG5vdyBhZGp1c3QgZm9yIHRoZSBtYXJnaW5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuc291cmNlUG9zWzJdID09PSAwKSBfc3ggLT0gbWFyZ2luO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5zb3VyY2VQb3NbMl0gPT09IDEpIF9zeCArPSBtYXJnaW47XG4gICAgICAgICAgICBpZiAocGFyYW1zLnNvdXJjZVBvc1szXSA9PT0gMCkgX3N5IC09IG1hcmdpbjtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuc291cmNlUG9zWzNdID09PSAxKSBfc3kgKz0gbWFyZ2luO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy50YXJnZXRQb3NbMl0gPT09IDApIF90eCAtPSBtYXJnaW47XG4gICAgICAgICAgICBpZiAocGFyYW1zLnRhcmdldFBvc1syXSA9PT0gMSkgX3R4ICs9IG1hcmdpbjtcbiAgICAgICAgICAgIGlmIChwYXJhbXMudGFyZ2V0UG9zWzNdID09PSAwKSBfdHkgLT0gbWFyZ2luO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy50YXJnZXRQb3NbM10gPT09IDEpIF90eSArPSBtYXJnaW47XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGVzZSBjb25uZWN0b3JzIGFyZSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlcywgaGF2aW5nIGEgc2luZ2xlIGNvbnRyb2wgcG9pbnQuIGlmIGJvdGggYW5jaG9yc1xuICAgICAgICAgICAgLy8gYXJlIGxvY2F0ZWQgYXQgMC41IG9uIHRoZWlyIHJlc3BlY3RpdmUgZmFjZXMsIHRoZSBjb250cm9sIHBvaW50IGlzIHNldCB0byB0aGUgbWlkcG9pbnQgYW5kIHlvdVxuICAgICAgICAgICAgLy8gZ2V0IGEgc3RyYWlnaHQgbGluZS4gIHRoaXMgaXMgYWxzbyB0aGUgY2FzZSBpZiB0aGUgdHdvIGFuY2hvcnMgYXJlIHdpdGhpbiAncHJveGltaXR5TGltaXQnLCBzaW5jZVxuICAgICAgICAgICAgLy8gaXQgc2VlbXMgdG8gbWFrZSBnb29kIGFlc3RoZXRpYyBzZW5zZSB0byBkbyB0aGF0LiBvdXRzaWRlIG9mIHRoYXQsIHRoZSBjb250cm9sIHBvaW50IGlzIHBvc2l0aW9uZWRcbiAgICAgICAgICAgIC8vIGF0ICdjdXJ2aW5lc3MnIHBpeGVscyBhd2F5IGFsb25nIHRoZSBub3JtYWwgdG8gdGhlIHN0cmFpZ2h0IGxpbmUgY29ubmVjdGluZyB0aGUgdHdvIGFuY2hvcnMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdGhlcmUgbWF5IGJlIHR3byBpbXByb3ZlbWVudHMgdG8gdGhpcy4gIGZpcnN0bHksIHdlIG1pZ2h0IGFjdHVhbGx5IHN1cHBvcnQgdGhlIG5vdGlvbiBvZiBhdm9pZGluZyBub2Rlc1xuICAgICAgICAgICAgLy8gaW4gdGhlIFVJLCBvciBhdCBsZWFzdCBtYWtpbmcgYSBnb29kIGVmZm9ydCBhdCBkb2luZyBzby4gIGlmIGEgY29ubmVjdGlvbiB3b3VsZCBwYXNzIHVuZGVybmVhdGggc29tZSBub2RlLFxuICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUsIHdlIG1pZ2h0IGluY3JlYXNlIHRoZSBkaXN0YW5jZSB0aGUgY29udHJvbCBwb2ludCBpcyBhd2F5IGZyb20gdGhlIG1pZHBvaW50IGluIGEgYmlkIHRvXG4gICAgICAgICAgICAvLyBzdGVlciBpdCBhcm91bmQgdGhhdCBub2RlLiAgdGhpcyB3aWxsIHdvcmsgd2l0aGluIGxpbWl0cywgYnV0IGkgdGhpbmsgdGhvc2UgbGltaXRzIHdvdWxkIGFsc28gYmUgdGhlIGxpa2VseVxuICAgICAgICAgICAgLy8gbGltaXRzIGZvciwgb25jZSBhZ2FpbiwgYWVzdGhldGljIGdvb2Qgc2Vuc2UgaW4gdGhlIGxheW91dCBvZiBhIGNoYXJ0IHVzaW5nIHRoZXNlIGNvbm5lY3RvcnMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdGhlIHNlY29uZCBwb3NzaWJsZSBjaGFuZ2UgaXMgYWN0dWFsbHkgdHdvIHBvc3NpYmxlIGNoYW5nZXM6IGZpcnN0bHksIGl0IGlzIHBvc3NpYmxlIHdlIHNob3VsZCBncmFkdWFsbHlcbiAgICAgICAgICAgIC8vIGRlY3JlYXNlIHRoZSAnY3VydmluZXNzJyBhcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYW5jaG9ycyBkZWNyZWFzZXM7IHN0YXJ0IHRhaWxpbmcgaXQgb2ZmIHRvIDAgYXQgc29tZVxuICAgICAgICAgICAgLy8gcG9pbnQgKHdoaWNoIHNob3VsZCBiZSBjb25maWd1cmFibGUpLiAgc2Vjb25kbHksIHdlIG1pZ2h0IHNsaWdodGx5IGluY3JlYXNlIHRoZSAnY3VydmluZXNzJyBmb3IgY29ubmVjdG9yc1xuICAgICAgICAgICAgLy8gd2l0aCByZXNwZWN0IHRvIGhvdyBmYXIgdGhlaXIgYW5jaG9yIGlzIGZyb20gdGhlIGNlbnRlciBvZiBpdHMgcmVzcGVjdGl2ZSBmYWNlLiB0aGlzIGNvdWxkIGVpdGhlciBsb29rIGNvb2wsXG4gICAgICAgICAgICAvLyBvciBzdHVwaWQsIGFuZCBtYXkgaW5kZWVkIHdvcmsgb25seSBpbiBhIHdheSB0aGF0IGlzIHNvIHN1YnRsZSBhcyB0byBoYXZlIGJlZW4gYSB3YXN0ZSBvZiB0aW1lLlxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgdmFyIF9taWR4ID0gKF9zeCArIF90eCkgLyAyLFxuICAgICAgICAgICAgICAgIF9taWR5ID0gKF9zeSArIF90eSkgLyAyLFxuICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBfc2VnbWVudChfc3gsIF9zeSwgX3R4LCBfdHkpLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KF90eCAtIF9zeCwgMikgKyBNYXRoLnBvdyhfdHkgLSBfc3ksIDIpKSxcbiAgICAgICAgICAgICAgICBjcDF4LCBjcDJ4LCBjcDF5LCBjcDJ5LFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gX3N1cGVyLmdldEdlb21ldHJ5KCk7XG5cbiAgICAgICAgICAgIGlmICgodGhpcy5oYXNCZWVuRWRpdGVkKCkgfHwgdGhpcy5pc0VkaXRpbmcoKSkgJiYgZ2VvbWV0cnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNwMXggPSBnZW9tZXRyeS5jb250cm9sUG9pbnRzWzBdWzBdO1xuICAgICAgICAgICAgICAgIGNwMXkgPSBnZW9tZXRyeS5jb250cm9sUG9pbnRzWzBdWzFdO1xuICAgICAgICAgICAgICAgIGNwMnggPSBnZW9tZXRyeS5jb250cm9sUG9pbnRzWzFdWzBdO1xuICAgICAgICAgICAgICAgIGNwMnkgPSBnZW9tZXRyeS5jb250cm9sUG9pbnRzWzFdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjb250cm9sIHBvaW50LiAgdGhpcyBjb2RlIHdpbGwgYmUgd2hlcmUgd2UnbGwgcHV0IGluIGEgcnVkaW1lbnRhcnkgZWxlbWVudCBhdm9pZGFuY2Ugc2NoZW1lOyBpdFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgd29yayBieSBleHRlbmRpbmcgdGhlIGNvbnRyb2wgcG9pbnQgdG8gZm9yY2UgdGhlIGN1cnZlIHRvIGJlLCB1bSwgY3Vydmllci5cbiAgICAgICAgICAgICAgICBfY29udHJvbFBvaW50ID0gX2ZpbmRDb250cm9sUG9pbnQoX21pZHgsXG4gICAgICAgICAgICAgICAgICAgIF9taWR5LFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuc291cmNlUG9zLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0UG9zLFxuICAgICAgICAgICAgICAgICAgICBjdXJ2aW5lc3MsIGN1cnZpbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHByb3hpbWl0eUxpbWl0KTtcblxuICAgICAgICAgICAgICAgIGNwMXggPSBfY29udHJvbFBvaW50WzBdO1xuICAgICAgICAgICAgICAgIGNwMnggPSBfY29udHJvbFBvaW50WzBdO1xuICAgICAgICAgICAgICAgIGNwMXkgPSBfY29udHJvbFBvaW50WzFdO1xuICAgICAgICAgICAgICAgIGNwMnkgPSBfY29udHJvbFBvaW50WzFdO1xuXG4gICAgICAgICAgICAgICAgX3N1cGVyLnNldEdlb21ldHJ5KHtjb250cm9sUG9pbnRzOltfY29udHJvbFBvaW50LCBfY29udHJvbFBvaW50XX0sIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfc3VwZXIuYWRkU2VnbWVudCh0aGlzLCBcIkJlemllclwiLCB7XG4gICAgICAgICAgICAgICAgeDE6IF90eCwgeTE6IF90eSwgeDI6IF9zeCwgeTI6IF9zeSxcbiAgICAgICAgICAgICAgICBjcDF4OiBjcDF4LCBjcDF5OiBjcDF5LFxuICAgICAgICAgICAgICAgIGNwMng6IGNwMngsIGNwMnk6IGNwMnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBfanUuZXh0ZW5kKFN0YXRlTWFjaGluZSwgX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RCZXppZXJDb25uZWN0b3IpO1xuICAgIF9qcC5yZWdpc3RlckNvbm5lY3RvclR5cGUoU3RhdGVNYWNoaW5lLCBcIlN0YXRlTWFjaGluZVwiKTtcblxufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuLypcbiAqIGpzUGx1bWJcbiAqIFxuICogVGl0bGU6anNQbHVtYiAyLjEuMFxuICogXG4gKiBQcm92aWRlcyBhIHdheSB0byB2aXN1YWxseSBjb25uZWN0IGVsZW1lbnRzIG9uIGFuIEhUTUwgcGFnZSwgdXNpbmcgU1ZHLlxuICogXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIFNWRyByZW5kZXJlcnMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNiBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXG4gKiBcbiAqIGh0dHA6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHA6Ly9naXRodWIuY29tL3Nwb3JyaXR0L2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG47XG4oZnVuY3Rpb24gKCkge1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKiBTVkcgdXRpbGl0eSBtZXRob2RzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHRcblxuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciByb290ID0gdGhpcywgX2pwID0gcm9vdC5qc1BsdW1iLCBfanUgPSByb290LmpzUGx1bWJVdGlsO1xuXG4gICAgdmFyIHN2Z0F0dHJpYnV0ZU1hcCA9IHtcbiAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwic3Ryb2tlLWxpbmVqb2luXCIsXG4gICAgICAgICAgICBcInN0cm9rZS1kYXNob2Zmc2V0XCI6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJzdHJva2UtbGluZWNhcFwiXG4gICAgICAgIH0sXG4gICAgICAgIFNUUk9LRV9EQVNIQVJSQVkgPSBcInN0cm9rZS1kYXNoYXJyYXlcIixcbiAgICAgICAgREFTSFNUWUxFID0gXCJkYXNoc3R5bGVcIixcbiAgICAgICAgTElORUFSX0dSQURJRU5UID0gXCJsaW5lYXJHcmFkaWVudFwiLFxuICAgICAgICBSQURJQUxfR1JBRElFTlQgPSBcInJhZGlhbEdyYWRpZW50XCIsXG4gICAgICAgIERFRlMgPSBcImRlZnNcIixcbiAgICAgICAgRklMTCA9IFwiZmlsbFwiLFxuICAgICAgICBTVE9QID0gXCJzdG9wXCIsXG4gICAgICAgIFNUUk9LRSA9IFwic3Ryb2tlXCIsXG4gICAgICAgIFNUUk9LRV9XSURUSCA9IFwic3Ryb2tlLXdpZHRoXCIsXG4gICAgICAgIFNUWUxFID0gXCJzdHlsZVwiLFxuICAgICAgICBOT05FID0gXCJub25lXCIsXG4gICAgICAgIEpTUExVTUJfR1JBRElFTlQgPSBcImpzcGx1bWJfZ3JhZGllbnRfXCIsXG4gICAgICAgIExJTkVfV0lEVEggPSBcImxpbmVXaWR0aFwiLFxuICAgICAgICBucyA9IHtcbiAgICAgICAgICAgIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgICAgICAgeGh0bWw6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiXG4gICAgICAgIH0sXG4gICAgICAgIF9hdHRyID0gZnVuY3Rpb24gKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gYXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShpLCBcIlwiICsgYXR0cmlidXRlc1tpXSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9ub2RlID0gZnVuY3Rpb24gKG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgICAgICAgYXR0cmlidXRlcy52ZXJzaW9uID0gXCIxLjFcIjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMueG1sbnMgPSBucy54aHRtbDtcbiAgICAgICAgICAgIHJldHVybiBqc1BsdW1iLmNyZWF0ZUVsZW1lbnROUyhucy5zdmcsIG5hbWUsIG51bGwsIG51bGwsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9LFxuICAgICAgICBfcG9zID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6XCIgKyBkWzBdICsgXCJweDt0b3A6XCIgKyBkWzFdICsgXCJweFwiO1xuICAgICAgICB9LFxuICAgICAgICBfY2xlYXJHcmFkaWVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBlbHMgPSBwYXJlbnQucXVlcnlTZWxlY3RvckFsbChcIiBkZWZzLGxpbmVhckdyYWRpZW50LHJhZGlhbEdyYWRpZW50XCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgZWxzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxzW2ldKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3VwZGF0ZUdyYWRpZW50ID0gZnVuY3Rpb24gKHBhcmVudCwgbm9kZSwgc3R5bGUsIGRpbWVuc2lvbnMsIHVpQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBKU1BMVU1CX0dSQURJRU5UICsgdWlDb21wb25lbnQuX2pzUGx1bWIuaW5zdGFuY2UuaWRzdGFtcCgpO1xuICAgICAgICAgICAgLy8gZmlyc3QgY2xlYXIgb3V0IGFueSBleGlzdGluZyBncmFkaWVudFxuICAgICAgICAgICAgX2NsZWFyR3JhZGllbnQocGFyZW50KTtcbiAgICAgICAgICAgIC8vIHRoaXMgY2hlY2tzIGZvciBhbiAnb2Zmc2V0JyBwcm9wZXJ0eSBpbiB0aGUgZ3JhZGllbnQsIGFuZCBpbiB0aGUgYWJzZW5jZSBvZiBpdCwgYXNzdW1lc1xuICAgICAgICAgICAgLy8gd2Ugd2FudCBhIGxpbmVhciBncmFkaWVudC4gaWYgaXQncyB0aGVyZSwgd2UgY3JlYXRlIGEgcmFkaWFsIGdyYWRpZW50LlxuICAgICAgICAgICAgLy8gaXQgaXMgcG9zc2libGUgdGhhdCBhIG1vcmUgZXhwbGljaXQgbWVhbnMgb2YgZGVmaW5pbmcgdGhlIGdyYWRpZW50IHR5cGUgd291bGQgYmVcbiAgICAgICAgICAgIC8vIGJldHRlci4gcmVseWluZyBvbiAnb2Zmc2V0JyBtZWFucyB0aGF0IHdlIGNhbiBuZXZlciBoYXZlIGEgcmFkaWFsIGdyYWRpZW50IHRoYXQgdXNlc1xuICAgICAgICAgICAgLy8gc29tZSBkZWZhdWx0IG9mZnNldCwgZm9yIGluc3RhbmNlLlxuICAgICAgICAgICAgLy8gaXNzdWUgMjQ0IHN1Z2dlc3RlZCB0aGUgJ2dyYWRpZW50VW5pdHMnIGF0dHJpYnV0ZTsgd2l0aG91dCB0aGlzLCBzdHJhaWdodC9mbG93Y2hhcnQgY29ubmVjdG9ycyB3aXRoIGdyYWRpZW50cyB3b3VsZFxuICAgICAgICAgICAgLy8gbm90IHNob3cgZ3JhZGllbnRzIHdoZW4gdGhlIGxpbmUgd2FzIHBlcmZlY3RseSBob3Jpem9udGFsIG9yIHZlcnRpY2FsLlxuICAgICAgICAgICAgdmFyIGc7XG4gICAgICAgICAgICBpZiAoIXN0eWxlLmdyYWRpZW50Lm9mZnNldClcbiAgICAgICAgICAgICAgICBnID0gX25vZGUoTElORUFSX0dSQURJRU5ULCB7aWQ6IGlkLCBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJ9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBnID0gX25vZGUoUkFESUFMX0dSQURJRU5ULCB7IGlkOiBpZCB9KTtcblxuICAgICAgICAgICAgdmFyIGRlZnMgPSBfbm9kZShERUZTKTtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChkZWZzKTtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZyk7XG5cbiAgICAgICAgICAgIC8vIHRoZSBzdmcgcmFkaWFsIGdyYWRpZW50IHNlZW1zIHRvIHRyZWF0IHN0b3BzIGluIHRoZSByZXZlcnNlXG4gICAgICAgICAgICAvLyBvcmRlciB0byBob3cgY2FudmFzIGRvZXMgaXQuICBzbyB3ZSB3YW50IHRvIGtlZXAgYWxsIHRoZSBtYXRocyB0aGUgc2FtZSwgYnV0XG4gICAgICAgICAgICAvLyBpdGVyYXRlIHRoZSBhY3R1YWwgc3R5bGUgZGVjbGFyYXRpb25zIGluIHJldmVyc2Ugb3JkZXIsIGlmIHRoZSB4IGluZGV4ZXMgYXJlIG5vdCBpbiBvcmRlci5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGUuZ3JhZGllbnQuc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVUb1VzZSA9IHVpQ29tcG9uZW50LnNlZ21lbnQgPT0gMSB8fCB1aUNvbXBvbmVudC5zZWdtZW50ID09IDIgPyBpIDogc3R5bGUuZ3JhZGllbnQuc3RvcHMubGVuZ3RoIC0gMSAtIGksXG4gICAgICAgICAgICAgICAgICAgIC8vc3RvcENvbG9yID0gX2p1LmNvbnZlcnRTdHlsZShzdHlsZS5ncmFkaWVudC5zdG9wc1tzdHlsZVRvVXNlXVsxXSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIHN0b3BDb2xvciA9IHN0eWxlLmdyYWRpZW50LnN0b3BzW3N0eWxlVG9Vc2VdWzFdLFxuICAgICAgICAgICAgICAgICAgICBzID0gX25vZGUoU1RPUCwge1wib2Zmc2V0XCI6IE1hdGguZmxvb3Ioc3R5bGUuZ3JhZGllbnQuc3RvcHNbaV1bMF0gKiAxMDApICsgXCIlXCIsIFwic3RvcC1jb2xvclwiOiBzdG9wQ29sb3J9KTtcblxuICAgICAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXBwbHlHcmFkaWVudFRvID0gc3R5bGUuc3Ryb2tlU3R5bGUgPyBTVFJPS0UgOiBGSUxMO1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXBwbHlHcmFkaWVudFRvLCBcInVybCgjXCIgKyBpZCArIFwiKVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2FwcGx5U3R5bGVzID0gZnVuY3Rpb24gKHBhcmVudCwgbm9kZSwgc3R5bGUsIGRpbWVuc2lvbnMsIHVpQ29tcG9uZW50KSB7XG5cbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKEZJTEwsIHN0eWxlLmZpbGxTdHlsZSA/IHN0eWxlLmZpbGxTdHlsZSA6IE5PTkUpO1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoU1RST0tFLCBzdHlsZS5zdHJva2VTdHlsZSA/IHN0eWxlLnN0cm9rZVN0eWxlIDogTk9ORSk7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5ncmFkaWVudCkge1xuICAgICAgICAgICAgICAgIF91cGRhdGVHcmFkaWVudChwYXJlbnQsIG5vZGUsIHN0eWxlLCBkaW1lbnNpb25zLCB1aUNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgY2xlYXIgYW55IGV4aXN0aW5nIGdyYWRpZW50XG4gICAgICAgICAgICAgICAgX2NsZWFyR3JhZGllbnQocGFyZW50KTtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShTVFlMRSwgXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShTVFJPS0VfV0lEVEgsIHN0eWxlLmxpbmVXaWR0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluIFNWRyB0aGVyZSBpcyBhIHN0cm9rZS1kYXNoYXJyYXkgYXR0cmlidXRlIHdlIGNhbiBzZXQsIGFuZCBpdHMgc3ludGF4IGxvb2tzIGxpa2VcbiAgICAgICAgICAgIC8vIHRoZSBzeW50YXggaW4gVk1MIGJ1dCBpcyBhY3R1YWxseSBraW5kIG9mIG5hc3R5OiB2YWx1ZXMgYXJlIGdpdmVuIGluIHRoZSBwaXhlbFxuICAgICAgICAgICAgLy8gY29vcmRpbmF0ZSBzcGFjZSwgd2hlcmVhcyBpbiBWTUwgdGhleSBhcmUgbXVsdGlwbGVzIG9mIHRoZSB3aWR0aCBvZiB0aGUgc3Ryb2tlZFxuICAgICAgICAgICAgLy8gbGluZSwgd2hpY2ggbWFrZXMgYSBsb3QgbW9yZSBzZW5zZS4gIGZvciB0aGF0IHJlYXNvbiwganNQbHVtYiBpcyBzdXBwb3J0aW5nIGJvdGhcbiAgICAgICAgICAgIC8vIHRoZSBuYXRpdmUgc3ZnICdzdHJva2UtZGFzaGFycmF5JyBhdHRyaWJ1dGUsIGFuZCBhbHNvIHRoZSAnZGFzaHN0eWxlJyBjb25jZXB0IGZyb21cbiAgICAgICAgICAgIC8vIFZNTCwgd2hpY2ggd2lsbCBiZSB0aGUgcHJlZmVycmVkIG1ldGhvZC4gIHRoZSBjb2RlIGJlbG93IHRoaXMgY29udmVydHMgYSBkYXNoc3R5bGVcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBnaXZlbiBpbiB0ZXJtcyBvZiBzdHJva2Ugd2lkdGggaW50byBhIHBpeGVsIHJlcHJlc2VudGF0aW9uLCBieSB1c2luZyB0aGVcbiAgICAgICAgICAgIC8vIHN0cm9rZSdzIGxpbmVXaWR0aC5cbiAgICAgICAgICAgIGlmIChzdHlsZVtEQVNIU1RZTEVdICYmIHN0eWxlW0xJTkVfV0lEVEhdICYmICFzdHlsZVtTVFJPS0VfREFTSEFSUkFZXSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXAgPSBzdHlsZVtEQVNIU1RZTEVdLmluZGV4T2YoXCIsXCIpID09IC0xID8gXCIgXCIgOiBcIixcIixcbiAgICAgICAgICAgICAgICAgICAgcGFydHMgPSBzdHlsZVtEQVNIU1RZTEVdLnNwbGl0KHNlcCksXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVG9Vc2UgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUb1VzZSArPSAoTWF0aC5mbG9vcihwICogc3R5bGUubGluZVdpZHRoKSArIHNlcCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoU1RST0tFX0RBU0hBUlJBWSwgc3R5bGVUb1VzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHlsZVtTVFJPS0VfREFTSEFSUkFZXSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFNUUk9LRV9EQVNIQVJSQVksIHN0eWxlW1NUUk9LRV9EQVNIQVJSQVldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXh0cmEgYXR0cmlidXRlcyBzdWNoIGFzIGpvaW4gdHlwZSwgZGFzaCBvZmZzZXQuXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHN2Z0F0dHJpYnV0ZU1hcCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZVtpXSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShzdmdBdHRyaWJ1dGVNYXBbaV0sIHN0eWxlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hcHBlbmRBdEluZGV4ID0gZnVuY3Rpb24gKHN2ZywgcGF0aCwgaWR4KSB7XG4gICAgICAgICAgICBpZiAoc3ZnLmNoaWxkTm9kZXMubGVuZ3RoID4gaWR4KSB7XG4gICAgICAgICAgICAgICAgc3ZnLmluc2VydEJlZm9yZShwYXRoLCBzdmcuY2hpbGROb2Rlc1tpZHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Ugc3ZnLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgIHV0aWxpdHkgbWV0aG9kcyBmb3Igb3RoZXIgb2JqZWN0cyB0byB1c2UuXG4gICAgICovXG4gICAgX2p1LnN2ZyA9IHtcbiAgICAgICAgbm9kZTogX25vZGUsXG4gICAgICAgIGF0dHI6IF9hdHRyLFxuICAgICAgICBwb3M6IF9wb3NcbiAgICB9O1xuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKiogLyBTVkcgdXRpbGl0eSBtZXRob2RzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAvKlxuICAgICAqIEJhc2UgY2xhc3MgZm9yIFNWRyBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIHZhciBTdmdDb21wb25lbnQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBwb2ludGVyRXZlbnRzU3BlYyA9IHBhcmFtcy5wb2ludGVyRXZlbnRzU3BlYyB8fCBcImFsbFwiLCByZW5kZXJlciA9IHt9O1xuXG4gICAgICAgIF9qcC5qc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcywgcGFyYW1zLm9yaWdpbmFsQXJncyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdmcgPSBudWxsO1xuICAgICAgICB0aGlzLmJnQ2FudmFzID0gbnVsbDtcblxuICAgICAgICB2YXIgY2xhenogPSBwYXJhbXMuY3NzQ2xhc3MgKyBcIiBcIiArIChwYXJhbXMub3JpZ2luYWxBcmdzWzBdLmNzc0NsYXNzIHx8IFwiXCIpLFxuICAgICAgICAgICAgc3ZnUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIFwic3R5bGVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcIndpZHRoXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogMCxcbiAgICAgICAgICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IHBvaW50ZXJFdmVudHNTcGVjLFxuICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3ZnID0gX25vZGUoXCJzdmdcIiwgc3ZnUGFyYW1zKTtcblxuICAgICAgICBpZiAocGFyYW1zLnVzZURpdldyYXBwZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0ganNQbHVtYi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcG9zaXRpb24gOiBcImFic29sdXRlXCIgfSk7XG4gICAgICAgICAgICBfanUuc2l6ZUVsZW1lbnQodGhpcy5jYW52YXMsIDAsIDAsIDEsIDEpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuY2xhc3NOYW1lID0gY2xheno7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfYXR0cih0aGlzLnN2ZywgeyBcImNsYXNzXCI6IGNsYXp6IH0pO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLnN2ZztcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtcy5fanNQbHVtYi5hcHBlbmRFbGVtZW50KHRoaXMuY2FudmFzLCBwYXJhbXMub3JpZ2luYWxBcmdzWzBdLnBhcmVudCk7XG4gICAgICAgIGlmIChwYXJhbXMudXNlRGl2V3JhcHBlcikgdGhpcy5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5zdmcpO1xuXG4gICAgICAgIHZhciBkaXNwbGF5RWxlbWVudHMgPSBbIHRoaXMuY2FudmFzIF07XG4gICAgICAgIHRoaXMuZ2V0RGlzcGxheUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlFbGVtZW50cztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFwcGVuZERpc3BsYXlFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBkaXNwbGF5RWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wYWludCA9IGZ1bmN0aW9uIChzdHlsZSwgYW5jaG9yLCBleHRlbnRzKSB7XG4gICAgICAgICAgICBpZiAoc3R5bGUgIT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHh5ID0gWyB0aGlzLngsIHRoaXMueSBdLCB3aCA9IFsgdGhpcy53LCB0aGlzLmggXSwgcDtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnRzLnhtaW4gPCAwKSB4eVswXSArPSBleHRlbnRzLnhtaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnRzLnltaW4gPCAwKSB4eVsxXSArPSBleHRlbnRzLnltaW47XG4gICAgICAgICAgICAgICAgICAgIHdoWzBdID0gZXh0ZW50cy54bWF4ICsgKChleHRlbnRzLnhtaW4gPCAwKSA/IC1leHRlbnRzLnhtaW4gOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgd2hbMV0gPSBleHRlbnRzLnltYXggKyAoKGV4dGVudHMueW1pbiA8IDApID8gLWV4dGVudHMueW1pbiA6IDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMudXNlRGl2V3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICBfanUuc2l6ZUVsZW1lbnQodGhpcy5jYW52YXMsIHh5WzBdLCB4eVsxXSwgd2hbMF0sIHdoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgeHlbMF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB4eVsxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBfcG9zKFsgMCwgMCBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBwID0gX3BvcyhbIHh5WzBdLCB4eVsxXSBdKTtcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnBhaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICBfYXR0cih0aGlzLnN2Zywge1xuICAgICAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHAsXG4gICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogd2hbMF0gfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogd2hbMV0gfHwgMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW5kZXJlcjogcmVuZGVyZXJcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgX2p1LmV4dGVuZChTdmdDb21wb25lbnQsIF9qcC5qc1BsdW1iVUlDb21wb25lbnQsIHtcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2UgfHwgdGhpcy50eXBlSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcykgdGhpcy5jYW52YXMuX2pzUGx1bWIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN2ZykgdGhpcy5zdmcuX2pzUGx1bWIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJnQ2FudmFzKSB0aGlzLmJnQ2FudmFzLl9qc1BsdW1iID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iZ0NhbnZhcyAmJiB0aGlzLmJnQ2FudmFzLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zdmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IGEgZm9yY2VkIGNsZWFudXAsIGp1c3QgZGV0YWNoIGZyb20gRE9NIGZvciBub3cuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnBhcmVudE5vZGUpIHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJnQ2FudmFzICYmIHRoaXMuYmdDYW52YXMucGFyZW50Tm9kZSkgdGhpcy5iZ0NhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmdDYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWF0dGFjaDpmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGMgPSBpbnN0YW5jZS5nZXRDb250YWluZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlID09IG51bGwpIGMuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmdDYW52YXMgJiYgdGhpcy5iZ0NhbnZhcy5wYXJlbnROb2RlID09IG51bGwpIGMuYXBwZW5kQ2hpbGQodGhpcy5iZ0NhbnZhcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFZpc2libGU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gdiA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICAqIEJhc2UgY2xhc3MgZm9yIFNWRyBjb25uZWN0b3JzLlxuICAgICAqL1xuICAgIF9qcC5Db25uZWN0b3JSZW5kZXJlcnMuc3ZnID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBfc3VwZXIgPSBTdmdDb21wb25lbnQuYXBwbHkodGhpcywgW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHBhcmFtcy5fanNQbHVtYi5jb25uZWN0b3JDbGFzcyArICh0aGlzLmlzRWRpdGFibGUoKSA/IFwiIFwiICsgcGFyYW1zLl9qc1BsdW1iLmVkaXRhYmxlQ29ubmVjdG9yQ2xhc3MgOiBcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxBcmdzOiBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHNTcGVjOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWI6IHBhcmFtcy5fanNQbHVtYlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgIHZhciBfc3VwZXJTZXRFZGl0YWJsZSA9IHRoaXMuc2V0RWRpdGFibGU7XG4gICAgICAgIHRoaXMuc2V0RWRpdGFibGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyU2V0RWRpdGFibGUuYXBwbHkodGhpcywgW2VdKTtcbiAgICAgICAgICAgIGpzUGx1bWJbcmVzdWx0ID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiXSh0aGlzLmNhbnZhcywgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5lZGl0YWJsZUNvbm5lY3RvckNsYXNzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfc3VwZXIucmVuZGVyZXIucGFpbnQgPSBmdW5jdGlvbiAoc3R5bGUsIGFuY2hvciwgZXh0ZW50cykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudHMgPSBzZWxmLmdldFNlZ21lbnRzKCksIHAgPSBcIlwiLCBvZmZzZXQgPSBbMCwgMF07XG4gICAgICAgICAgICBpZiAoZXh0ZW50cy54bWluIDwgMCkgb2Zmc2V0WzBdID0gLWV4dGVudHMueG1pbjtcbiAgICAgICAgICAgIGlmIChleHRlbnRzLnltaW4gPCAwKSBvZmZzZXRbMV0gPSAtZXh0ZW50cy55bWluO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHBhdGggZnJvbSBzZWdtZW50cy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgKz0gX2pwLlNlZ21lbnRzLnN2Zy5TZWdtZW50UmVuZGVyZXIuZ2V0UGF0aChzZWdtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHAgKz0gXCIgXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkOiBwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIG9mZnNldFswXSArIFwiLFwiICsgb2Zmc2V0WzFdICsgXCIpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IHBhcmFtc1tcInBvaW50ZXItZXZlbnRzXCJdIHx8IFwidmlzaWJsZVN0cm9rZVwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVTdHlsZSA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGQgPSBbc2VsZi54LCBzZWxmLnksIHNlbGYudywgc2VsZi5oXTtcblxuICAgICAgICAgICAgICAgIC8vIG91dGxpbmUgc3R5bGUuICBhY3R1YWxseSBtZWFucyBkcmF3aW5nIGFuIHN2ZyBvYmplY3QgdW5kZXJuZWF0aCB0aGUgbWFpbiBvbmUuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLm91dGxpbmVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0bGluZVdpZHRoID0gc3R5bGUub3V0bGluZVdpZHRoIHx8IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lU3Ryb2tlV2lkdGggPSBzdHlsZS5saW5lV2lkdGggKyAoMiAqIG91dGxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVTdHlsZSA9IF9qcC5leHRlbmQoe30sIHN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG91dGxpbmVTdHlsZS5ncmFkaWVudDtcbiAgICAgICAgICAgICAgICAgICAgb3V0bGluZVN0eWxlLnN0cm9rZVN0eWxlID0gc3R5bGUub3V0bGluZUNvbG9yO1xuICAgICAgICAgICAgICAgICAgICBvdXRsaW5lU3R5bGUubGluZVdpZHRoID0gb3V0bGluZVN0cm9rZVdpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJnUGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJnUGF0aCA9IF9ub2RlKFwicGF0aFwiLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qcC5hZGRDbGFzcyhzZWxmLmJnUGF0aCwgX2pwLmNvbm5lY3Rvck91dGxpbmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYXBwZW5kQXRJbmRleChzZWxmLnN2Zywgc2VsZi5iZ1BhdGgsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2F0dHIoc2VsZi5iZ1BhdGgsIGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2FwcGx5U3R5bGVzKHNlbGYuc3ZnLCBzZWxmLmJnUGF0aCwgb3V0bGluZVN0eWxlLCBkLCBzZWxmKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5wYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXRoID0gX25vZGUoXCJwYXRoXCIsIGEpO1xuICAgICAgICAgICAgICAgICAgICBfYXBwZW5kQXRJbmRleChzZWxmLnN2Zywgc2VsZi5wYXRoLCBzdHlsZS5vdXRsaW5lQ29sb3IgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfYXR0cihzZWxmLnBhdGgsIGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9hcHBseVN0eWxlcyhzZWxmLnN2Zywgc2VsZi5wYXRoLCBzdHlsZSwgZCwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfanUuZXh0ZW5kKF9qcC5Db25uZWN0b3JSZW5kZXJlcnMuc3ZnLCBTdmdDb21wb25lbnQpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIHN2ZyBzZWdtZW50IHJlbmRlcmVyICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHRcblxuICAgIF9qcC5TZWdtZW50cy5zdmcgPSB7XG4gICAgICAgIFNlZ21lbnRSZW5kZXJlcjoge1xuICAgICAgICAgICAgZ2V0UGF0aDogZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgXCJTdHJhaWdodFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHNlZ21lbnQuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk0gXCIgKyBkLngxICsgXCIgXCIgKyBkLnkxICsgXCIgTCBcIiArIGQueDIgKyBcIiBcIiArIGQueTI7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiQmV6aWVyXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gc2VnbWVudC5wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJNIFwiICsgZC54MSArIFwiIFwiICsgZC55MSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgQyBcIiArIGQuY3AxeCArIFwiIFwiICsgZC5jcDF5ICsgXCIgXCIgKyBkLmNwMnggKyBcIiBcIiArIGQuY3AyeSArIFwiIFwiICsgZC54MiArIFwiIFwiICsgZC55MjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJBcmNcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBzZWdtZW50LnBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWYgPSBzZWdtZW50LnN3ZWVwID4gTWF0aC5QSSA/IDEgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNmID0gc2VnbWVudC5hbnRpY2xvY2t3aXNlID8gMCA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk1cIiArIHNlZ21lbnQueDEgKyBcIiBcIiArIHNlZ21lbnQueTEgKyBcIiBBIFwiICsgc2VnbWVudC5yYWRpdXMgKyBcIiBcIiArIGQuciArIFwiIDAgXCIgKyBsYWYgKyBcIixcIiArIHNmICsgXCIgXCIgKyBzZWdtZW50LngyICsgXCIgXCIgKyBzZWdtZW50LnkyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlbc2VnbWVudC50eXBlXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAvc3ZnIHNlZ21lbnRzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAvKlxuICAgICAqIEJhc2UgY2xhc3MgZm9yIFNWRyBlbmRwb2ludHMuXG4gICAgICovXG4gICAgdmFyIFN2Z0VuZHBvaW50ID0gX2pwLlN2Z0VuZHBvaW50ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgX3N1cGVyID0gU3ZnQ29tcG9uZW50LmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjc3NDbGFzczogcGFyYW1zLl9qc1BsdW1iLmVuZHBvaW50Q2xhc3MsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxBcmdzOiBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50c1NwZWM6IFwiYWxsXCIsXG4gICAgICAgICAgICAgICAgdXNlRGl2V3JhcHBlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBfanNQbHVtYjogcGFyYW1zLl9qc1BsdW1iXG4gICAgICAgICAgICB9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIF9zdXBlci5yZW5kZXJlci5wYWludCA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBfanAuZXh0ZW5kKHt9LCBzdHlsZSk7XG4gICAgICAgICAgICBpZiAocy5vdXRsaW5lQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBzLnN0cm9rZVdpZHRoID0gcy5vdXRsaW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgcy5zdHJva2VTdHlsZSA9IHMub3V0bGluZUNvbG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLm1ha2VOb2RlKHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3ZnLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnVwZGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZSh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2FwcGx5U3R5bGVzKHRoaXMuc3ZnLCB0aGlzLm5vZGUsIHMsIFsgdGhpcy54LCB0aGlzLnksIHRoaXMudywgdGhpcy5oIF0sIHRoaXMpO1xuICAgICAgICAgICAgX3Bvcyh0aGlzLm5vZGUsIFsgdGhpcy54LCB0aGlzLnkgXSk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgIH07XG4gICAgX2p1LmV4dGVuZChTdmdFbmRwb2ludCwgU3ZnQ29tcG9uZW50KTtcblxuICAgIC8qXG4gICAgICogU1ZHIERvdCBFbmRwb2ludFxuICAgICAqL1xuICAgIF9qcC5FbmRwb2ludHMuc3ZnLkRvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX2pwLkVuZHBvaW50cy5Eb3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgU3ZnRW5kcG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tYWtlTm9kZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9ub2RlKFwiY2lyY2xlXCIsIHtcbiAgICAgICAgICAgICAgICBcImN4XCI6IHRoaXMudyAvIDIsXG4gICAgICAgICAgICAgICAgXCJjeVwiOiB0aGlzLmggLyAyLFxuICAgICAgICAgICAgICAgIFwiclwiOiB0aGlzLnJhZGl1c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBfYXR0cihub2RlLCB7XG4gICAgICAgICAgICAgICAgXCJjeFwiOiB0aGlzLncgLyAyLFxuICAgICAgICAgICAgICAgIFwiY3lcIjogdGhpcy5oIC8gMixcbiAgICAgICAgICAgICAgICBcInJcIjogdGhpcy5yYWRpdXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuRW5kcG9pbnRzLnN2Zy5Eb3QsIFtfanAuRW5kcG9pbnRzLkRvdCwgU3ZnRW5kcG9pbnRdKTtcblxuICAgIC8qXG4gICAgICogU1ZHIFJlY3RhbmdsZSBFbmRwb2ludFxuICAgICAqL1xuICAgIF9qcC5FbmRwb2ludHMuc3ZnLlJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX2pwLkVuZHBvaW50cy5SZWN0YW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgU3ZnRW5kcG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tYWtlTm9kZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9ub2RlKFwicmVjdFwiLCB7XG4gICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiB0aGlzLncsXG4gICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogdGhpcy5oXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIF9hdHRyKG5vZGUsIHtcbiAgICAgICAgICAgICAgICBcIndpZHRoXCI6IHRoaXMudyxcbiAgICAgICAgICAgICAgICBcImhlaWdodFwiOiB0aGlzLmhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuRW5kcG9pbnRzLnN2Zy5SZWN0YW5nbGUsIFtfanAuRW5kcG9pbnRzLlJlY3RhbmdsZSwgU3ZnRW5kcG9pbnRdKTtcblxuICAgIC8qXG4gICAgICogU1ZHIEltYWdlIEVuZHBvaW50IGlzIHRoZSBkZWZhdWx0IGltYWdlIGVuZHBvaW50LlxuICAgICAqL1xuICAgIF9qcC5FbmRwb2ludHMuc3ZnLkltYWdlID0gX2pwLkVuZHBvaW50cy5JbWFnZTtcbiAgICAvKlxuICAgICAqIEJsYW5rIGVuZHBvaW50IGluIHN2ZyByZW5kZXJlciBpcyB0aGUgZGVmYXVsdCBCbGFuayBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBfanAuRW5kcG9pbnRzLnN2Zy5CbGFuayA9IF9qcC5FbmRwb2ludHMuQmxhbms7XG4gICAgLypcbiAgICAgKiBMYWJlbCBvdmVybGF5IGluIHN2ZyByZW5kZXJlciBpcyB0aGUgZGVmYXVsdCBMYWJlbCBvdmVybGF5LlxuICAgICAqL1xuICAgIF9qcC5PdmVybGF5cy5zdmcuTGFiZWwgPSBfanAuT3ZlcmxheXMuTGFiZWw7XG4gICAgLypcbiAgICAgKiBDdXN0b20gb3ZlcmxheSBpbiBzdmcgcmVuZGVyZXIgaXMgdGhlIGRlZmF1bHQgQ3VzdG9tIG92ZXJsYXkuXG4gICAgICovXG4gICAgX2pwLk92ZXJsYXlzLnN2Zy5DdXN0b20gPSBfanAuT3ZlcmxheXMuQ3VzdG9tO1xuXG4gICAgdmFyIEFic3RyYWN0U3ZnQXJyb3dPdmVybGF5ID0gZnVuY3Rpb24gKHN1cGVyY2xhc3MsIG9yaWdpbmFsQXJncykge1xuICAgICAgICBzdXBlcmNsYXNzLmFwcGx5KHRoaXMsIG9yaWdpbmFsQXJncyk7XG4gICAgICAgIF9qcC5qc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcywgb3JpZ2luYWxBcmdzKTtcbiAgICAgICAgdGhpcy5pc0FwcGVuZGVkQXRUb3BMZXZlbCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMucGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFpbnQgPSBmdW5jdGlvbiAocGFyYW1zLCBjb250YWluZXJFeHRlbnRzKSB7XG4gICAgICAgICAgICAvLyBvbmx5IGRyYXdzIG9uIGNvbm5lY3Rpb25zLCBub3QgZW5kcG9pbnRzLlxuICAgICAgICAgICAgaWYgKHBhcmFtcy5jb21wb25lbnQuc3ZnICYmIGNvbnRhaW5lckV4dGVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gX25vZGUoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJhbGxcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvbXBvbmVudC5zdmcuYXBwZW5kQ2hpbGQodGhpcy5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudENyZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudENyZWF0ZWQodGhpcy5wYXRoLCBwYXJhbXMuY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzID0gcGFyYW1zLmNvbXBvbmVudC5zdmc7IC8vIGZvciB0aGUgc2FrZSBvZiBjb21wbGV0ZW5lc3M7IHRoaXMgYmVoYXZlcyB0aGUgc2FtZSBhcyBvdGhlciBvdmVybGF5c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2xhenogPSBvcmlnaW5hbEFyZ3MgJiYgKG9yaWdpbmFsQXJncy5sZW5ndGggPT0gMSkgPyAob3JpZ2luYWxBcmdzWzBdLmNzc0NsYXNzIHx8IFwiXCIpIDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gWzAsIDBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lckV4dGVudHMueG1pbiA8IDApIG9mZnNldFswXSA9IC1jb250YWluZXJFeHRlbnRzLnhtaW47XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lckV4dGVudHMueW1pbiA8IDApIG9mZnNldFsxXSA9IC1jb250YWluZXJFeHRlbnRzLnltaW47XG5cbiAgICAgICAgICAgICAgICBfYXR0cih0aGlzLnBhdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJkXCI6IG1ha2VQYXRoKHBhcmFtcy5kKSxcbiAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBjbGF6eixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBwYXJhbXMuc3Ryb2tlU3R5bGUgPyBwYXJhbXMuc3Ryb2tlU3R5bGUgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBwYXJhbXMuZmlsbFN0eWxlID8gcGFyYW1zLmZpbGxTdHlsZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBvZmZzZXRbMF0gKyBcIixcIiArIG9mZnNldFsxXSArIFwiKVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtYWtlUGF0aCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzTmFOKGQuY3h5LngpIHx8IGlzTmFOKGQuY3h5LnkpKSA/IFwiXCIgOiBcIk1cIiArIGQuaHh5LnggKyBcIixcIiArIGQuaHh5LnkgK1xuICAgICAgICAgICAgICAgIFwiIExcIiArIGQudGFpbFswXS54ICsgXCIsXCIgKyBkLnRhaWxbMF0ueSArXG4gICAgICAgICAgICAgICAgXCIgTFwiICsgZC5jeHkueCArIFwiLFwiICsgZC5jeHkueSArXG4gICAgICAgICAgICAgICAgXCIgTFwiICsgZC50YWlsWzFdLnggKyBcIixcIiArIGQudGFpbFsxXS55ICtcbiAgICAgICAgICAgICAgICBcIiBMXCIgKyBkLmh4eS54ICsgXCIsXCIgKyBkLmh4eS55O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYW5zZmVyID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmNhbnZhcyAmJiB0aGlzLnBhdGggJiYgdGhpcy5wYXRoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGgucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBhdGgpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoQWJzdHJhY3RTdmdBcnJvd092ZXJsYXksIFtfanAuanNQbHVtYlVJQ29tcG9uZW50LCBfanAuT3ZlcmxheXMuQWJzdHJhY3RPdmVybGF5XSwge1xuICAgICAgICBjbGVhbnVwOiBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5yZW1vdmVFbGVtZW50KHRoaXMucGF0aCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXRoLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGgucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWF0dGFjaDpmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGF0aCAmJiB0aGlzLmNhbnZhcyAmJiB0aGlzLnBhdGgucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMucGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFZpc2libGU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXRoICE9IG51bGwpICh0aGlzLnBhdGguc3R5bGUuZGlzcGxheSA9ICh2ID8gXCJibG9ja1wiIDogXCJub25lXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2pwLk92ZXJsYXlzLnN2Zy5BcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQWJzdHJhY3RTdmdBcnJvd092ZXJsYXkuYXBwbHkodGhpcywgW19qcC5PdmVybGF5cy5BcnJvdywgYXJndW1lbnRzXSk7XG4gICAgfTtcbiAgICBfanUuZXh0ZW5kKF9qcC5PdmVybGF5cy5zdmcuQXJyb3csIFsgX2pwLk92ZXJsYXlzLkFycm93LCBBYnN0cmFjdFN2Z0Fycm93T3ZlcmxheSBdKTtcblxuICAgIF9qcC5PdmVybGF5cy5zdmcuUGxhaW5BcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQWJzdHJhY3RTdmdBcnJvd092ZXJsYXkuYXBwbHkodGhpcywgW19qcC5PdmVybGF5cy5QbGFpbkFycm93LCBhcmd1bWVudHNdKTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLk92ZXJsYXlzLnN2Zy5QbGFpbkFycm93LCBbIF9qcC5PdmVybGF5cy5QbGFpbkFycm93LCBBYnN0cmFjdFN2Z0Fycm93T3ZlcmxheSBdKTtcblxuICAgIF9qcC5PdmVybGF5cy5zdmcuRGlhbW9uZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQWJzdHJhY3RTdmdBcnJvd092ZXJsYXkuYXBwbHkodGhpcywgW19qcC5PdmVybGF5cy5EaWFtb25kLCBhcmd1bWVudHNdKTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLk92ZXJsYXlzLnN2Zy5EaWFtb25kLCBbIF9qcC5PdmVybGF5cy5EaWFtb25kLCBBYnN0cmFjdFN2Z0Fycm93T3ZlcmxheSBdKTtcblxuICAgIC8vIGEgdGVzdFxuICAgIF9qcC5PdmVybGF5cy5zdmcuR3VpZGVMaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBudWxsLCBzZWxmID0gdGhpcywgcDFfMSwgcDFfMjtcbiAgICAgICAgX2pwLk92ZXJsYXlzLkd1aWRlTGluZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5wYWludCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNvbnRhaW5lckV4dGVudHMpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gX25vZGUoXCJwYXRoXCIpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25uZWN0b3Iuc3ZnLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoTGlzdGVuZXJzKHBhdGgsIHBhcmFtcy5jb25uZWN0b3IpO1xuICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoTGlzdGVuZXJzKHBhdGgsIHNlbGYpO1xuXG4gICAgICAgICAgICAgICAgcDFfMSA9IF9ub2RlKFwicGF0aFwiKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29ubmVjdG9yLnN2Zy5hcHBlbmRDaGlsZChwMV8xKTtcbiAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaExpc3RlbmVycyhwMV8xLCBwYXJhbXMuY29ubmVjdG9yKTtcbiAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaExpc3RlbmVycyhwMV8xLCBzZWxmKTtcblxuICAgICAgICAgICAgICAgIHAxXzIgPSBfbm9kZShcInBhdGhcIik7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbm5lY3Rvci5zdmcuYXBwZW5kQ2hpbGQocDFfMik7XG4gICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hMaXN0ZW5lcnMocDFfMiwgcGFyYW1zLmNvbm5lY3Rvcik7XG4gICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hMaXN0ZW5lcnMocDFfMiwgc2VsZik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBbMCwgMF07XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyRXh0ZW50cy54bWluIDwgMCkgb2Zmc2V0WzBdID0gLWNvbnRhaW5lckV4dGVudHMueG1pbjtcbiAgICAgICAgICAgIGlmIChjb250YWluZXJFeHRlbnRzLnltaW4gPCAwKSBvZmZzZXRbMV0gPSAtY29udGFpbmVyRXh0ZW50cy55bWluO1xuXG4gICAgICAgICAgICBfYXR0cihwYXRoLCB7XG4gICAgICAgICAgICAgICAgXCJkXCI6IG1ha2VQYXRoKHBhcmFtcy5oZWFkLCBwYXJhbXMudGFpbCksXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcInJlZFwiLFxuICAgICAgICAgICAgICAgIGZpbGw6IG51bGwsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIG9mZnNldFswXSArIFwiLFwiICsgb2Zmc2V0WzFdICsgXCIpXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfYXR0cihwMV8xLCB7XG4gICAgICAgICAgICAgICAgXCJkXCI6IG1ha2VQYXRoKHBhcmFtcy50YWlsTGluZVswXSwgcGFyYW1zLnRhaWxMaW5lWzFdKSxcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiYmx1ZVwiLFxuICAgICAgICAgICAgICAgIGZpbGw6IG51bGwsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIG9mZnNldFswXSArIFwiLFwiICsgb2Zmc2V0WzFdICsgXCIpXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfYXR0cihwMV8yLCB7XG4gICAgICAgICAgICAgICAgXCJkXCI6IG1ha2VQYXRoKHBhcmFtcy5oZWFkTGluZVswXSwgcGFyYW1zLmhlYWRMaW5lWzFdKSxcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiZ3JlZW5cIixcbiAgICAgICAgICAgICAgICBmaWxsOiBudWxsLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBvZmZzZXRbMF0gKyBcIixcIiArIG9mZnNldFsxXSArIFwiKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWFrZVBhdGggPSBmdW5jdGlvbiAoZDEsIGQyKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNIFwiICsgZDEueCArIFwiLFwiICsgZDEueSArXG4gICAgICAgICAgICAgICAgXCIgTFwiICsgZDIueCArIFwiLFwiICsgZDIueTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLk92ZXJsYXlzLnN2Zy5HdWlkZUxpbmVzLCBfanAuT3ZlcmxheXMuR3VpZGVMaW5lcyk7XG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qXG4gKiBqc1BsdW1iXG4gKiBcbiAqIFRpdGxlOmpzUGx1bWIgMi4xLjBcbiAqIFxuICogUHJvdmlkZXMgYSB3YXkgdG8gdmlzdWFsbHkgY29ubmVjdCBlbGVtZW50cyBvbiBhbiBIVE1MIHBhZ2UsIHVzaW5nIFNWRy5cbiAqIFxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSAndmFuaWxsYScgYWRhcHRlciAtIGhhdmluZyBubyBleHRlcm5hbCBkZXBlbmRlbmNpZXMgb3RoZXIgdGhhbiBidW5kbGVkIGxpYnMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNiBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXG4gKiBcbiAqIGh0dHA6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHA6Ly9naXRodWIuY29tL3Nwb3JyaXR0L2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG47XG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJvb3QgPSB0aGlzLCBfanAgPSByb290LmpzUGx1bWIsIF9qdSA9IHJvb3QuanNQbHVtYlV0aWwsXG4gICAgICAgIF9qayA9IHJvb3QuS2F0YXZvcmlvLCBfamcgPSByb290LkJpbHRvbmc7XG5cbiAgICB2YXIgX2dldERyYWdNYW5hZ2VyID0gZnVuY3Rpb24gKGluc3RhbmNlLCBjYXRlZ29yeSkge1xuXG4gICAgICAgIGNhdGVnb3J5ID0gY2F0ZWdvcnkgfHwgXCJtYWluXCI7XG4gICAgICAgIHZhciBrZXkgPSBcIl9rYXRhdm9yaW9fXCIgKyBjYXRlZ29yeTtcbiAgICAgICAgdmFyIGsgPSBpbnN0YW5jZVtrZXldLFxuICAgICAgICAgICAgZSA9IGluc3RhbmNlLmdldEV2ZW50TWFuYWdlcigpO1xuXG4gICAgICAgIGlmICghaykge1xuICAgICAgICAgICAgayA9IG5ldyBfamsoe1xuICAgICAgICAgICAgICAgIGJpbmQ6IGUub24sXG4gICAgICAgICAgICAgICAgdW5iaW5kOiBlLm9mZixcbiAgICAgICAgICAgICAgICBnZXRTaXplOiBqc1BsdW1iLmdldFNpemUsXG4gICAgICAgICAgICAgICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCwgcmVsYXRpdmVUb1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIG5lc3RlZCBkcmFnZ2FibGUgdGhlbiBjb21wdXRlIHRoZSBvZmZzZXQgYWdhaW5zdCBpdHMgb3duIG9mZnNldFBhcmVudCwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgYWdhaW5zdCB0aGUgQ29udGFpbmVyJ3Mgb3JpZ2luLiBzZWUgYWxzbyB0aGUgZ2V0VUlQb3NpdGlvbiBtZXRob2QgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gaW5zdGFuY2UuZ2V0T2Zmc2V0KGVsLCByZWxhdGl2ZVRvUm9vdCwgZWwuX2thdGF2b3Jpb0RyYWcgPyBlbC5vZmZzZXRQYXJlbnQgOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtvLmxlZnQsIG8udG9wXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoZWwsIHh5KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmxlZnQgPSB4eVswXSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUudG9wID0geHlbMV0gKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhZGRDbGFzczoganNQbHVtYi5hZGRDbGFzcyxcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzczoganNQbHVtYi5yZW1vdmVDbGFzcyxcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzOiBfamcuaW50ZXJzZWN0cyxcbiAgICAgICAgICAgICAgICBpbmRleE9mOiBmdW5jdGlvbihsLCBpKSB7IHJldHVybiBsLmluZGV4T2YoaSk7IH0sXG4gICAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgICAgIG5vU2VsZWN0OiBpbnN0YW5jZS5kcmFnU2VsZWN0Q2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZTogXCJqc3BsdW1iLWRyb3BwYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IFwianNwbHVtYi1kcmFnZ2FibGVcIixcbiAgICAgICAgICAgICAgICAgICAgZHJhZzogXCJqc3BsdW1iLWRyYWdcIixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IFwianNwbHVtYi1kcmFnLXNlbGVjdGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogXCJqc3BsdW1iLWRyYWctYWN0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgIGhvdmVyOiBcImpzcGx1bWItZHJhZy1ob3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBnaG9zdFByb3h5OlwianNwbHVtYi1naG9zdC1wcm94eVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnN0YW5jZVtrZXldID0gaztcbiAgICAgICAgICAgIGluc3RhbmNlLmJpbmQoXCJ6b29tXCIsIGsuc2V0Wm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGs7XG4gICAgfTtcblxuICAgIHZhciBfYW5pbVByb3BzID0gZnVuY3Rpb24gKG8sIHApIHtcbiAgICAgICAgdmFyIF9vbmUgPSBmdW5jdGlvbiAocE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwW3BOYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9qdS5pc1N0cmluZyhwW3BOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBwW3BOYW1lXS5tYXRjaCgvLT0vKSA/IC0xIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBwW3BOYW1lXS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvW3BOYW1lXSArIChtICogdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHBbcE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBvW3BOYW1lXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFsgX29uZShcImxlZnRcIiksIF9vbmUoXCJ0b3BcIikgXTtcbiAgICB9O1xuXG4gICAgX2pwLmV4dGVuZChyb290LmpzUGx1bWJJbnN0YW5jZS5wcm90b3R5cGUsIHtcblxuICAgICAgICBhbmltYXRpb25TdXBwb3J0ZWQ6dHJ1ZSxcbiAgICAgICAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAvLyBoZXJlIHdlIHBsdWNrIHRoZSBmaXJzdCBlbnRyeSBpZiBlbCB3YXMgYSBsaXN0IG9mIGVudHJpZXMuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBteSBmYXZvdXJpdGUgdGhpbmcgdG8gZG8sIGJ1dCBwcmV2aW91cyB2ZXJzaW9ucyBvZlxuICAgICAgICAgICAgLy8ganNwbHVtYiBzdXBwb3J0ZWQganF1ZXJ5IHNlbGVjdG9ycywgYW5kIGl0IGlzIHBvc3NpYmxlIGEgc2VsZWN0b3JcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgcGFzc2VkIGluIGhlcmUuXG4gICAgICAgICAgICBlbCA9IHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIiA/IGVsIDogZWwubGVuZ3RoICE9IG51bGwgJiYgZWwuZW5jdHlwZSA9PSBudWxsID8gZWxbMF0gOiBlbDtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbCkgOiBlbDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIF9nZXREcmFnTWFuYWdlcih0aGlzKS5lbGVtZW50UmVtb3ZlZChlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRNYW5hZ2VyKCkucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzIGFkYXB0ZXIgc3VwcG9ydHMgYSBydWRpbWVudGFyeSBhbmltYXRpb24gZnVuY3Rpb24uIG5vIGVhc2luZyBpcyBzdXBwb3J0ZWQuICBvbmx5XG4gICAgICAgIC8vIGxlZnQvdG9wIHByb3BlcnRpZXMgYXJlIHN1cHBvcnRlZC4gcHJvcGVydHkgZGVsdGEgYXJncyBhcmUgZXhwZWN0ZWQgdG8gYmUgaW4gdGhlIGZvcm1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gKz14Lnh4eHhcbiAgICAgICAgLy9cbiAgICAgICAgLy8gb3JcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLT14Lnh4eHhcbiAgICAgICAgLy9cbiAgICAgICAgZG9BbmltYXRlOiBmdW5jdGlvbiAoZWwsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLmdldE9mZnNldChlbCksXG4gICAgICAgICAgICAgICAgYXAgPSBfYW5pbVByb3BzKG8sIHByb3BlcnRpZXMpLFxuICAgICAgICAgICAgICAgIGxkaXN0ID0gYXBbMF0gLSBvLmxlZnQsXG4gICAgICAgICAgICAgICAgdGRpc3QgPSBhcFsxXSAtIG8udG9wLFxuICAgICAgICAgICAgICAgIGQgPSBvcHRpb25zLmR1cmF0aW9uIHx8IDI1MCxcbiAgICAgICAgICAgICAgICBzdGVwID0gMTUsIHN0ZXBzID0gZCAvIHN0ZXAsXG4gICAgICAgICAgICAgICAgbGluYyA9IChzdGVwIC8gZCkgKiBsZGlzdCxcbiAgICAgICAgICAgICAgICB0aW5jID0gKHN0ZXAgLyBkKSAqIHRkaXN0LFxuICAgICAgICAgICAgICAgIGlkeCA9IDAsXG4gICAgICAgICAgICAgICAgX2ludCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAganNQbHVtYi5zZXRQb3NpdGlvbihlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogby5sZWZ0ICsgKGxpbmMgKiAoaWR4ICsgMSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBvLnRvcCArICh0aW5jICogKGlkeCArIDEpKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RlcCAhPSBudWxsKSBvcHRpb25zLnN0ZXAoaWR4LCBNYXRoLmNlaWwoc3RlcHMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggPj0gc3RlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKF9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29tcGxldGUgIT0gbnVsbCkgb3B0aW9ucy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgc3RlcCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIERSQUcvRFJPUFxuICAgICAgICBkZXN0cm95RHJhZ2dhYmxlOiBmdW5jdGlvbiAoZWwsIGNhdGVnb3J5KSB7XG4gICAgICAgICAgICBfZ2V0RHJhZ01hbmFnZXIodGhpcywgY2F0ZWdvcnkpLmRlc3Ryb3lEcmFnZ2FibGUoZWwpO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95RHJvcHBhYmxlOiBmdW5jdGlvbiAoZWwsIGNhdGVnb3J5KSB7XG4gICAgICAgICAgICBfZ2V0RHJhZ01hbmFnZXIodGhpcywgY2F0ZWdvcnkpLmRlc3Ryb3lEcm9wcGFibGUoZWwpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0RHJhZ2dhYmxlOiBmdW5jdGlvbiAoZWwsIG9wdGlvbnMsIGNhdGVnb3J5KSB7XG4gICAgICAgICAgICBfZ2V0RHJhZ01hbmFnZXIodGhpcywgY2F0ZWdvcnkpLmRyYWdnYWJsZShlbCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXREcm9wcGFibGU6IGZ1bmN0aW9uIChlbCwgb3B0aW9ucywgY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIF9nZXREcmFnTWFuYWdlcih0aGlzLCBjYXRlZ29yeSkuZHJvcHBhYmxlKGVsLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNBbHJlYWR5RHJhZ2dhYmxlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5fa2F0YXZvcmlvRHJhZyAhPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBpc0RyYWdTdXBwb3J0ZWQ6IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRHJvcFN1cHBvcnRlZDogZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNFbGVtZW50RHJhZ2dhYmxlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsID0ganNQbHVtYi5nZXRFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIHJldHVybiBlbC5fa2F0YXZvcmlvRHJhZyAmJiBlbC5fa2F0YXZvcmlvRHJhZy5pc0VuYWJsZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RHJhZ09iamVjdDogZnVuY3Rpb24gKGV2ZW50QXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50QXJnc1swXS5kcmFnLmdldERyYWdFbGVtZW50KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERyYWdTY29wZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuX2thdGF2b3Jpb0RyYWcgJiYgZWwuX2thdGF2b3Jpb0RyYWcuc2NvcGVzLmpvaW4oXCIgXCIpIHx8IFwiXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERyb3BFdmVudDogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzWzBdLmU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFVJUG9zaXRpb246IGZ1bmN0aW9uIChldmVudEFyZ3MsIHpvb20pIHtcbiAgICAgICAgICAgIC8vIGhlcmUgdGhlIHBvc2l0aW9uIHJlcG9ydGVkIHRvIHVzIGJ5IEthdGF2b3JpbyBpcyByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCdzIG9mZnNldFBhcmVudC4gRm9yIHRvcFxuICAgICAgICAgICAgLy8gbGV2ZWwgbm9kZXMgdGhhdCBpcyBmaW5lLCBidXQgaWYgd2UgaGF2ZSBhIG5lc3RlZCBkcmFnZ2FibGUgdGhlbiBpdHMgb2Zmc2V0UGFyZW50IGlzIGFjdHVhbGx5XG4gICAgICAgICAgICAvLyBub3QgZ29pbmcgdG8gYmUgdGhlIGpzcGx1bWIgY29udGFpbmVyOyBpdCdzIGdvaW5nIHRvIGJlIHNvbWUgY2hpbGQgb2YgdGhhdCBlbGVtZW50LiBJbiB0aGF0IGNhc2VcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gYWRqdXN0IHRoZSBVSSBwb3NpdGlvbiB0byBhY2NvdW50IGZvciB0aGUgb2Zmc2V0UGFyZW50J3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIENvbnRhaW5lclxuICAgICAgICAgICAgLy8gb3JpZ2luLlxuICAgICAgICAgICAgdmFyIGVsID0gZXZlbnRBcmdzWzBdLmVsO1xuICAgICAgICAgICAgaWYgKGVsLm9mZnNldFBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmluYWxQb3MgPSBldmVudEFyZ3NbMF0uZmluYWxQb3MgfHwgZXZlbnRBcmdzWzBdLnBvcztcbiAgICAgICAgICAgIHZhciBwID0geyBsZWZ0OmZpbmFsUG9zWzBdLCB0b3A6ZmluYWxQb3NbMV0gfTtcbiAgICAgICAgICAgIGlmIChlbC5fa2F0YXZvcmlvRHJhZyAmJiBlbC5vZmZzZXRQYXJlbnQgIT09IHRoaXMuZ2V0Q29udGFpbmVyKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2MgPSB0aGlzLmdldE9mZnNldChlbC5vZmZzZXRQYXJlbnQpO1xuICAgICAgICAgICAgICAgIHAubGVmdCArPSBvYy5sZWZ0O1xuICAgICAgICAgICAgICAgIHAudG9wICs9IG9jLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICBzZXREcmFnRmlsdGVyOiBmdW5jdGlvbiAoZWwsIGZpbHRlciwgX2V4Y2x1ZGUpIHtcbiAgICAgICAgICAgIGlmIChlbC5fa2F0YXZvcmlvRHJhZykge1xuICAgICAgICAgICAgICAgIGVsLl9rYXRhdm9yaW9EcmFnLnNldEZpbHRlcihmaWx0ZXIsIF9leGNsdWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0RWxlbWVudERyYWdnYWJsZTogZnVuY3Rpb24gKGVsLCBkcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIGVsID0ganNQbHVtYi5nZXRFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIGlmIChlbC5fa2F0YXZvcmlvRHJhZylcbiAgICAgICAgICAgICAgICBlbC5fa2F0YXZvcmlvRHJhZy5zZXRFbmFibGVkKGRyYWdnYWJsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldERyYWdTY29wZTogZnVuY3Rpb24gKGVsLCBzY29wZSkge1xuICAgICAgICAgICAgaWYgKGVsLl9rYXRhdm9yaW9EcmFnKVxuICAgICAgICAgICAgICAgIGVsLl9rYXRhdm9yaW9EcmFnLmsuc2V0RHJhZ1Njb3BlKGVsLCBzY29wZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldERyb3BTY29wZTpmdW5jdGlvbihlbCwgc2NvcGUpIHtcbiAgICAgICAgICAgIGlmIChlbC5fa2F0YXZvcmlvRHJvcCAmJiBlbC5fa2F0YXZvcmlvRHJvcC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZWwuX2thdGF2b3Jpb0Ryb3BbMF0uay5zZXREcm9wU2NvcGUoZWwsIHNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkVG9Qb3NzZTpmdW5jdGlvbihlbCwgc3BlYykge1xuICAgICAgICAgICAgdmFyIHNwZWNzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIHZhciBkbSA9IF9nZXREcmFnTWFuYWdlcih0aGlzKTtcbiAgICAgICAgICAgIGpzUGx1bWIuZWFjaChlbCwgZnVuY3Rpb24oX2VsKSB7XG4gICAgICAgICAgICAgICAgX2VsID0gWyBqc1BsdW1iLmdldEVsZW1lbnQoX2VsKSBdO1xuICAgICAgICAgICAgICAgIF9lbC5wdXNoLmFwcGx5KF9lbCwgc3BlY3MgKTtcbiAgICAgICAgICAgICAgICBkbS5hZGRUb1Bvc3NlLmFwcGx5KGRtLCBfZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFBvc3NlOmZ1bmN0aW9uKGVsLCBzcGVjKSB7XG4gICAgICAgICAgICB2YXIgc3BlY3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgdmFyIGRtID0gX2dldERyYWdNYW5hZ2VyKHRoaXMpO1xuICAgICAgICAgICAganNQbHVtYi5lYWNoKGVsLCBmdW5jdGlvbihfZWwpIHtcbiAgICAgICAgICAgICAgICBfZWwgPSBbIGpzUGx1bWIuZ2V0RWxlbWVudChfZWwpIF07XG4gICAgICAgICAgICAgICAgX2VsLnB1c2guYXBwbHkoX2VsLCBzcGVjcyApO1xuICAgICAgICAgICAgICAgIGRtLnNldFBvc3NlLmFwcGx5KGRtLCBfZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUZyb21Qb3NzZTpmdW5jdGlvbihlbCwgcG9zc2VJZCkge1xuICAgICAgICAgICAgdmFyIHNwZWNzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIHZhciBkbSA9IF9nZXREcmFnTWFuYWdlcih0aGlzKTtcbiAgICAgICAgICAgIGpzUGx1bWIuZWFjaChlbCwgZnVuY3Rpb24oX2VsKSB7XG4gICAgICAgICAgICAgICAgX2VsID0gWyBqc1BsdW1iLmdldEVsZW1lbnQoX2VsKSBdO1xuICAgICAgICAgICAgICAgIF9lbC5wdXNoLmFwcGx5KF9lbCwgc3BlY3MgKTtcbiAgICAgICAgICAgICAgICBkbS5yZW1vdmVGcm9tUG9zc2UuYXBwbHkoZG0sIF9lbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlRnJvbUFsbFBvc3NlczpmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIGRtID0gX2dldERyYWdNYW5hZ2VyKHRoaXMpO1xuICAgICAgICAgICAganNQbHVtYi5lYWNoKGVsLCBmdW5jdGlvbihfZWwpIHsgZG0ucmVtb3ZlRnJvbUFsbFBvc3Nlcyhqc1BsdW1iLmdldEVsZW1lbnQoX2VsKSk7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQb3NzZVN0YXRlOmZ1bmN0aW9uKGVsLCBwb3NzZUlkLCBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIGRtID0gX2dldERyYWdNYW5hZ2VyKHRoaXMpO1xuICAgICAgICAgICAganNQbHVtYi5lYWNoKGVsLCBmdW5jdGlvbihfZWwpIHsgZG0uc2V0UG9zc2VTdGF0ZShqc1BsdW1iLmdldEVsZW1lbnQoX2VsKSwgcG9zc2VJZCwgc3RhdGUpOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ0V2ZW50czoge1xuICAgICAgICAgICAgJ3N0YXJ0JzogJ3N0YXJ0JywgJ3N0b3AnOiAnc3RvcCcsICdkcmFnJzogJ2RyYWcnLCAnc3RlcCc6ICdzdGVwJyxcbiAgICAgICAgICAgICdvdmVyJzogJ292ZXInLCAnb3V0JzogJ291dCcsICdkcm9wJzogJ2Ryb3AnLCAnY29tcGxldGUnOiAnY29tcGxldGUnLFxuICAgICAgICAgICAgJ2JlZm9yZVN0YXJ0JzonYmVmb3JlU3RhcnQnXG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1FdmVudHM6IHtcbiAgICAgICAgICAgICdzdGVwJzogXCJzdGVwXCIsICdjb21wbGV0ZSc6ICdjb21wbGV0ZSdcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcERyYWc6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLl9rYXRhdm9yaW9EcmFnKVxuICAgICAgICAgICAgICAgIGVsLl9rYXRhdm9yaW9EcmFnLmFib3J0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFRvRHJhZ1NlbGVjdGlvbjogZnVuY3Rpb24gKHNwZWMpIHtcbiAgICAgICAgICAgIF9nZXREcmFnTWFuYWdlcih0aGlzKS5zZWxlY3Qoc3BlYyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUZyb21EcmFnU2VsZWN0aW9uOiBmdW5jdGlvbiAoc3BlYykge1xuICAgICAgICAgICAgX2dldERyYWdNYW5hZ2VyKHRoaXMpLmRlc2VsZWN0KHNwZWMpO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhckRyYWdTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9nZXREcmFnTWFuYWdlcih0aGlzKS5kZXNlbGVjdEFsbCgpO1xuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZWwsIGV2ZW50LCBvcmlnaW5hbEV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB0aGlzLmdldEV2ZW50TWFuYWdlcigpLnRyaWdnZXIoZWwsIGV2ZW50LCBvcmlnaW5hbEV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZG9SZXNldDpmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGxvb2sgZm9yIGthdGF2b3JpbyBpbnN0YW5jZXMgYW5kIHJlc2V0IGVhY2ggb25lIGlmIGZvdW5kLlxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCJfa2F0YXZvcmlvX1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWFkeSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHZhciBfZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoL2NvbXBsZXRlfGxvYWRlZHxpbnRlcmFjdGl2ZS8udGVzdChkb2N1bWVudC5yZWFkeVN0YXRlKSAmJiB0eXBlb2YoZG9jdW1lbnQuYm9keSkgIT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoX2RvLCA5KTtcbiAgICAgICAgfTtcblxuICAgICAgICBfZG8oKTtcbiAgICB9O1xuICAgIHJlYWR5KF9qcC5pbml0KTtcblxufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuIl19
