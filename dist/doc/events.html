<!doctype html>
<html>
	<head>
		<title>jsPlumb Documentation - </title>
		<link rel="stylesheet" href="demo-all.css">
		<link rel="stylesheet" href="gollum-template.css">		
	</head>

	<body>
		<div id="headerWrapper">
			<div id="header">
				<div class="logo"><img src="../../logo-bw.png"></div>
				<div class="menu">
					<a href="home">DOCS</a>
					<a href="../demo/">DEMOS</a>
					<a href="../apidocs">API</a>
					<a href="../tests/all-tests.html">TESTS</a>
					<a href="mailto:hello@jsplumbtoolkit.com">CONTACT</a>
					<a href="http://github.com/sporritt/jsPlumb/">GITHUB</a>
					<a href="https://groups.google.com/forum/?fromgroups#!forum/jsplumb">DISCUSS</a>
					<a href="http://github.com/sporritt/jsPlumb/issues">ISSUES</a>
				</div>
			</div>
		</div>	
		
		<div id="main">
			<div class="nav">
				<!-- BODY -->
				<h3>Contents</h3>
<ul>
<li><a href="changelog">Changelog</a></li>
<li>Required imports and basic setup<ul>
<li><a href="home#browser">Browser Compatibility</a></li>
<li><a href="home#setup">Setup</a></li>
<li><a href="home#doctype">Doctype</a></li>
<li><a href="home#imports">Required Imports</a></li>
<li><a href="home#initializing">Initializing jsPlumb</a></li>
<li><a href="home#multiple">Multiple jsPlumb Instances</a></li>
<li><a href="home#zindex">Z-Index Considerations</a></li>
<li><a href="home#container">Where does jsPlumb add elements?</a></li>
<li><a href="home#dragging">Element Dragging</a></li>
<li><a href="home#performance">Performance</a></li>
<li><a href="zooming">Zooming</a></li>
</ul>
</li>
<li><a href="defaults">Configuring Defaults</a></li>
<li><a href="basic-concepts">Basic Concepts</a><ul>
<li><a href="anchors">Anchors</a></li>
<li><a href="connectors">Connectors</a></li>
<li><a href="endpoints">Endpoints</a></li>
<li><a href="overlays">Overlays</a></li>
</ul>
</li>
<li><a href="connections">Establishing Connections</a><ul>
<li><a href="connections#programmatic">Programmatic Connections</a></li>
<li><a href="connections#common">Reusing Common Settings</a></li>
<li><a href="connections#detaching">Detaching Programmatic Connections</a></li>
<li><a href="connections#draganddrop">Drag and Drop Connections</a></li>
<li><a href="connections#sourcesandtargets">Elements as sources &amp; targets</a></li>
<li><a href="connections#maketarget">Element Targets</a></li>
<li><a href="connections#makesource">Element Sources</a></li>
<li><a href="connections#sourcefilter">Specifying drag source area</a></li>
</ul>
</li>
<li><a href="removing">Removing Connections/Endpoints</a></li>
<li><a href="parameters">Connection &amp; Endpoint Parameters</a></li>
<li><a href="types">Connection &amp; Endpoint Types</a></li>
<li><a href="events">Events</a><ul>
<li><a href="interceptors">Interceptors</a></li>
</ul>
</li>
<li>Appearance<ul>
<li><a href="paint-styles">Styling via Paint Styles</a></li>
<li><a href="styling-via-css">Styling via CSS</a></li>
</ul>
</li>
<li><a href="querying">Querying jsPlumb</a></li>
<li><a href="animation">Animation</a></li>
<li><a href="utilities">Utility Functions</a></li>
<li><a href="loader-support">Loader Support (RequireJS)</a></li>
<li>Examples<ul>
<li><a href="connect-examples">jsPlumb.connect</a></li>
<li><a href="draggable-connections-examples">Draggable Connections</a></li>
<li><a href="miscellaneous-examples">Miscellaneous</a></li>
</ul>
</li>
<li>Development<ul>
<li><a href="development">Which files are which?</a></li>
<li><a href="Build">Building jsPlumb</a></li>
<li><a href="development-documentation">Documentation while developing</a></li>
</ul>
</li>
</ul>

				<!-- /BODY -->
			</div>
			<div class="markdown-body">
				<!-- BODY -->
				<h2>Events</h2>
<p>jsPlumb supports binding to several different events on Connections, Endpoints and Overlays, and also on the jsPlumb object itself.  </p>
<ul>
<li><a href="#jsPlumbEvents">jsPlumb Events</a><ul>
    <li><a href="#evt-connection">connection</a></li>
    <li><a href="#evt-connection-detached">connectionDetached</a></li>
    <li><a href="#evt-connection-moved">connectionMoved</a></li>
    <li><a href="#evt-click">click</a></li>
    <li><a href="#evt-dlbclick">dblclick</a></li>
    <li><a href="#evt-endpoint-click">endpointClick</a></li>
    <li><a href="#evt-endpoint-dblclick">endpointDblClick</a></li>
    <li><a href="#evt-contextmenu">contextmenu</a></li>
    <li><a href="#evt-beforedrop">beforeDrop</a></li>
    <li><a href="#evt-beforedetach">beforeDetach</a></li>
</ul></li>
<li><a href="#connectionEvents">Connection Events</a></li>
<li><a href="#endpointEvents">Endpoint Events</a></li>
<li><a href="#overlayEvents">Overlay Events</a></li>
<li><a href="#unbindingEvents">Unbinding Events</a></li>
</ul>
<p><a name="jsPlumbEvents"></a></p>
<h3>jsPlumb Events</h3>
<p>To bind an to event on jsPlumb itself (or a jsPlumb instance), use <code>jsPlumb.bind(event, callback)</code>:</p>
<pre><code>jsPlumb.bind(&quot;connection&quot;, function(info) {
   .. update your model in here, maybe.
});</code></pre>
<p>These are the events you can bind to on the jsPlumb class:</p>
<p><a name="evt-connection"></a></p>
<h5>connection(info, originalEvent)</h5>
<p>Notification a Connection was established.</p>
<p><code>info</code> is an object with the following properties:<br>    <ul>
      <li><strong>connection</strong> -     the new Connection.  you can register listeners on this etc.</li>
      <li><strong>sourceId</strong> -    id of the source element in the Connection</li>
      <li><strong>targetId</strong> -    id of the target element in the Connection</li>
      <li><strong>source</strong> -    the source element in the Connection</li>
      <li><strong>target</strong> -    the target element in the Connection</li>
      <li><strong>sourceEndpoint</strong> -    the source Endpoint in the Connection</li>
      <li><strong>targetEndpoint</strong> -    the targetEndpoint in the Connection</li>
    </ul></p>
<p><strong>Note:</strong> <code>jsPlumb.connect</code> causes this event to be fired, but there is of course no original event when a connection is established programmatically. So you can test to see if <code>originalEvent</code> is undefined to determine whether a connection was estblished using the mouse or not.</p>
<p>All of the source/target properties are actually available inside the Connection object, but - for one of those rubbish historical reasons - are provided separately because of a vagary of the <code>connectionDetached</code> callback, which is discussed below.</p>
<p><a name="evt-connection-detached"></a></p>
<h5>connectionDetached(info, originalEvent)</h5>
<p>Notification a Connection was detached.  </p>
<p>As with <code>connection</code>, the first argument to the callback is an object with the following properties:                    </p>
  <ul>
      <li><strong>connection</strong> - the Connection that was detached.</li>
      <li><strong>sourceId</strong> - id of the source element in the Connection <em>before</em> it was detached</li>
      <li><strong>targetId</strong> -    id of the target element in the Connection before it was detached</li>
      <li><strong>source</strong> -    the source element in the Connection before it was detached</li>
      <li><strong>target</strong> -    the target element in the Connection before it was detached</li>
      <li><strong>sourceEndpoint</strong> -    the source Endpoint in the Connection before it was detached</li>
      <li><strong>targetEndpoint</strong> -    the targetEndpoint in the Connection before it was detached</li>
  </ul>

<p>In the event that the Connection was new and had never been established between two Endpoints, it has a <code>pending</code> flag set on it. </p>
<p>The <code>source</code>/<code>target</code> properties are provided separately from the Connection, because this event is fired whenever a Connection is either detached and abandoned, or detached from some Endpoint and attached to another.  In the latter case, the Connection that is passed to this callback is in an indeterminate state (that is, the Endpoints are still in the state they are in when dragging, and do not reflect static reality), and so the <code>source</code>/<code>target</code> properties give you the real story.</p>
<p>The second argument is the original mouse event that caused the disconnection, if any. </p>
<p><a name="evt-connection-moved"></a></p>
<h5>connectionMoved(info, originalEvent)</h5>
<p>Notification that an existing connection&#39;s source or target endpoint was dragged to some new location. <code>info</code> contains the following properties:
    <ul>
        <li><strong>index</strong> - 0 for source endpoint, 1 for target endpoint</li>
        <li><strong>originalSourceId</strong> - id of connection source element before move</li>
        <li><strong>newSourceId</strong> - id of connection source element after move</li>
        <li><strong>originalTargetId</strong> id of connection target before move</li>
        <li><strong>newTargetId</strong> - id of connection target after move</li>
        <li><strong>originalSourceEndpoint</strong> - source endpoint before move</li>
        <li><strong>newSourceEndpoint</strong> - source endpoint after move</li>
        <li><strong>originalTargetEndpoint</strong> - target endpoint before move</li>
        <li><strong>newTargetEndpoint</strong> - target endpoint after move</li>
    </ul></p>
<p><a name="evt-connection-drag"></a></p>
<h5>connectionDrag(connection)</h5>
<p>Notification an existing Connection is being dragged. Note that when this event fires for a brand new Connection, the target of the Connection is a transient element that jsPlumb is using for dragging, and will be removed from the DOM when the Connection is subsequently either established or aborted.</p>
<p><a name="evt-connection-drag-stop"></a></p>
<h5>connectionDragStop(connection)</h5>
<p>Notification a Connection drag has stopped. This is only fired for existing Connections.</p>
<p><a name="evt-click"></a></p>
<h5>click(connection, originalEvent)</h5>
<p>Notification a Connection was clicked.</p>
<p><a name="evt-dblclick"></a></p>
<h5>dblclick(connection, originalEvent)</h5>
<p>Notification a Connection was double-clicked.</p>
<p><a name="evt-endpoint-click"></a></p>
<h5>endpointClick(endpoint, originalEvent)</h5>
<p>Notification an Endpoint was clicked.</p>
<p><a name="evt-endpoint-dblclick"></a></p>
<h5>endpointDblClick(endpoint, originalEvent)</h5>
<p>Notification an Endpoint was double-clicked.</p>
<p><a name="evt-contextmenu"></a></p>
<h5>contextmenu(component, originalEvent)</h5>
<p>A right-click on some given component.  jsPlumb will report right clicks on both Connections and Endpoints.</p>
<p><a name="evt-beforedrop"></a></p>
<h5>beforeDrop(info)</h5>
<p>This event is fired when a new or existing connection has been dropped. <code>info</code> contains the following properties:
                    <ul>
                        <li><strong>sourceId</strong> - the id of the source element in the connection</li>
                        <li><strong>targetId</strong> - the id of the target element in the connection</li>
                        <li><strong>scope</strong> - the scope of the connection</li>
                        <li><strong>connection</strong> - the actual Connection object.  You can access the &#39;endpoints&#39; array in a Connection to get the Endpoints involved in the Connection, but be aware that when a Connection is being dragged, one of these Endpoints will always be a transient Endpoint that exists only for the life of the drag. To get the Endpoint on which the Connection is being dropped, use the <code>dropEndpoint</code> member.</li>
                        <li><strong>dropEndpoint</strong> - this is the actual Endpoint on which the Connection is being dropped.  This <strong>may be null</strong>, because it will not be set if the Connection is being dropped on an element on which makeTarget has been called. </li>
                    </ul></p>
<p>If you return false (or nothing) from this callback, the new Connection is aborted and removed from the UI.                        </p>
<p><a name="evt-beforedetach"></a>        </p>
<h5>beforeDetach(connection)</h5>
<p>This event is fired when a Connection is about to be detached, for whatever reason. Your callback function is passed the Connection that the user has just detached. Returning false from this interceptor aborts the Connection detach.</p>
<p><a name="connectionEvents"></a></p>
<h3>Connection Events</h3>
<p>To bind to an event on a Connection, you also use the <code>bind</code> method:</p>
<pre><code>var connection = jsPlumb.connect({source:&quot;d1&quot;, target:&quot;d2&quot;});
connection.bind(&quot;click&quot;, function(conn) {
    console.log(&quot;you clicked on &quot;, conn);
});</code></pre>
<p>These are the Connection events to which you can bind a listener:</p>
<ul>
<li><p><code>click(connection, originalEvent)</code> - notification a Connection was clicked.</p>
</li>
<li><p><code>dblclick(connection, originalEvent)</code> - notification a Connection was double-clicked.</p>
</li>
<li><p><code>contextmenu(connection, originalEvent)</code> - a right-click on the Connection.</p>
</li>
<li><p><code>mouseenter(connection, originalEvent)</code> - notification the mouse entered the Connection&#39;s path.</p>
</li>
<li><p><code>mouseexit(connection, originalEvent)</code> - notification the mouse exited the Connection&#39;s path.</p>
</li>
<li><p><code>mousedown(connection, originalEvent)</code> - notification the mouse button was pressed on the Connection&#39;s path.</p>
</li>
<li><p><code>mouseup(connection, originalEvent)</code> - notification the mouse button was released on the Connection&#39;s path.</p>
</li>
</ul>
<p><a name="endpointEvents"></a></p>
<h3>Endpoint Events</h3>
<p>To bind to an event on a Endpoint, you again use the <code>bind</code> method:</p>
<pre><code>var endpoint = jsPlumb.addEndpoint(&quot;d1&quot;, { someOptions } );
endpoint.bind(&quot;click&quot;, function(endpoint) {
    console.log(&quot;you clicked on &quot;, endpoint);
});</code></pre>
<p>These are the Endpoint events to which you can bind a listener:</p>
<ul>
<li><p><code>click(endpoint, originalEvent)</code> - notification an Endpoint was clicked.</p>
</li>
<li><p><code>dblclick(endpoint, originalEvent)</code> - notification an Endpoint was double-clicked.</p>
</li>
<li><p><code>contextmenu(endpoint, originalEvent)</code> - a right-click on the Endpoint.</p>
</li>
<li><p><code>mouseenter(endpoint, originalEvent)</code> - notification the mouse entered the Endpoint.</p>
</li>
<li><p><code>mouseexit(endpoint, originalEvent)</code> - notification the mouse exited the Endpoint.</p>
</li>
<li><p><code>mousedown(endpoint, originalEvent)</code> - notification the mouse button was pressed on the Endpoint.</p>
</li>
<li><p><code>mouseup(endpoint, originalEvent)</code> - notification the mouse button was released on the Endpoint.</p>
</li>
<li><p><code>maxConnections(info, originalEvent)</code> - notification the user tried to drop a Connection on an Endpoint that already has the maximum number of Connections.  <code>info</code> is an object literal containing these values:</p>
<ul>
<li><strong>endpoint</strong> : Endpoint on which the Connection was dropped</li>
<li><strong>connection</strong> : The Connection the user tried to drop</li>
<li><strong>maxConnections</strong> : The value of <code>maxConnections</code> for the Endpoint</li>
</ul>
</li>
</ul>
<p><a name="overlayEvents"></a></p>
<h3>Overlay Events</h3>
<p>Registering event listeners on an Overlay is a slightly different procedure - you provide them as arguments to the Overlay&#39;s constructor.  This is because you never actually act on an Overlay object.  </p>
<p>Here&#39;s how to register a click listener on an Overlay:            </p>
<pre><code>jsPlumb.connect({
    source:&quot;el1&quot;,
    target:&quot;el2&quot;,
    overlays:[
      [ &quot;Label&quot;, {
        events:{
          click:function(labelOverlay, originalEvent) { 
            console.log(&quot;click on label overlay for :&quot; + labelOverlay.component); 
          }
        }
      }],
      [ &quot;Diamond&quot;, {
        events:{
          dblclick:function(diamondOverlay, originalEvent) { 
            console.log(&quot;double click on diamond overlay for : &quot; + diamondOverlay.component); 
          }
        }
      }]     
    ]
  });</code></pre>
<p>The related component for an Overlay is available to you as the <code>component</code> member of the Overlay.</p>
<p>Note that events registered on Diamond, Arrow or PlainArrow overlays will not fire with the Canvas renderer - they work only with the SVG and VML renderers. </p>
<p><a name="unbindingEvents"></a></p>
<h3>Unbinding Events</h3>
<p>On the jsPlumb object and on Connections and Endpoints, you can use the <code>unbind</code> method to remove a listener.  This method either takes the name of the event to unbind:</p>
<pre><code>jsPlumb.unbind(&quot;click&quot;);</code></pre>
<p>...or no argument, meaning unbind all events:</p>
<pre><code>var e = jsPlumb.addEndpoint(&quot;someDiv&quot;);
e.bind(&quot;click&quot;, function() { ... });
e.bind(&quot;dblclick&quot;, function() { ... });

...

e.unbind(&quot;click&quot;);</code></pre>

				<!-- /BODY -->
			</div>					
		</div>

	</body>		

</html>