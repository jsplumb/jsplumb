---
layout: apidoc
title:  "tests/jsPlumb-tests.js - jsplumb - Test Coverage API documentation"
date:   2014-01-01 00:00:00
yuiGridsUrl: http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css
yuiSeedUrl: http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js
projectAssets: ../assets
base: "../.."
---



<div id="doc">
    <div id="bd" class="yui3-g">
        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Mottle.html">Mottle</a></li>
            
                <li><a href="../classes/Test.html">Test</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: tests/jsPlumb-tests.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
// _jsPlumb qunit tests.

QUnit.config.reorder = false;

/**
 * @name Test
 * @class
 */

var makeContent = function (s) {
    var d = document.createElement(&quot;div&quot;);
    d.innerHTML = s;
    return d.firstChild;
};

var _length = function(obj) {
    var c = 0;
    for (var i in obj) if (obj.hasOwnProperty(i)) c++;
    return c;
};

var _head = function(obj) {
    for (var i in obj)
        return obj[i];
};

var countKeys = function(obj) {
    var i = 0;
    for (var k in obj) {
        if (obj.hasOwnProperty(k)) i++;
    }
    return i;
};

var assertEndpointCount = function (elId, count, _jsPlumb) {
    var ep = _jsPlumb.getEndpoints(elId),
        epl = ep ? ep.length : 0;
    equal(epl, count, elId + &quot; has &quot; + count + ((count &gt; 1 || count == 0) ? &quot; endpoints&quot; : &quot; endpoint&quot;));
    equal(_jsPlumb.anchorManager.getEndpointsFor(elId).length, count, &quot;anchor manager has &quot; + count + ((count &gt; 1 || count == 0) ? &quot; endpoints&quot; : &quot; endpoint&quot;) + &quot; for &quot; + elId);
};

var assertConnectionCount = function (endpoint, count) {
    equal(endpoint.connections.length, count, &quot;endpoint has &quot; + count + &quot; connections&quot;);
};

var assertConnectionByScopeCount = function (scope, count, _jsPlumb) {
    equal(_jsPlumb.select({scope: scope}).length, count, &#x27;Scope &#x27; + scope + &quot; has &quot; + count + (count &gt; 1) ? &quot;connections&quot; : &quot;connection&quot;);
};

var VERY_SMALL_NUMBER = 0.00000000001;
// helper to test that a value is the same as some target, within our tolerance
// sometimes the trigonometry stuff needs a little bit of leeway.
var within = function (val, target, _ok, msg) {
    _ok(Math.abs(val - target) &lt; VERY_SMALL_NUMBER, msg + &quot;[expected: &quot; + target + &quot; got &quot; + val + &quot;] [diff:&quot; + (Math.abs(val - target)) + &quot;]&quot;);
};

var _divs = [];
var _addDiv = function (id, parent, className, x, y, w, h) {
    var d1 = document.createElement(&quot;div&quot;);
    d1.style.position = &quot;absolute&quot;;
    if (parent) parent.appendChild(d1); else document.getElementById(&quot;container&quot;).appendChild(d1);
    d1.setAttribute(&quot;id&quot;, id);
    d1.style.left = (x != null ? x : (Math.floor(Math.random() * 1000))) + &quot;px&quot;;
    d1.style.top = (y!= null ? y : (Math.floor(Math.random() * 1000))) + &quot;px&quot;;
    if (className) d1.className = className;
    if (w) d1.style.width = w + &quot;px&quot;;
    if (h) d1.style.height = h + &quot;px&quot;;
    _divs.push(id);
    return d1;
};

var _addDraggableDiv = function (_jsPlumb, id, parent, className, x, y, w, h) {
    var d = _addDiv.apply(null, [id, parent, className, x, y, w, h]);
    _jsPlumb.draggable(d);
    return d;
};

var _addDivs = function (ids, parent) {
    for (var i = 0; i &lt; ids.length; i++)
        _addDiv(ids[i], parent);
};

var defaults = null,
    _cleanup = function (_jsPlumb) {
        _jsPlumb.reset();
        _jsPlumb.unbindContainer();
        if (_jsPlumb.select().length != 0)
            throw &quot;there are connections!&quot;;

        _jsPlumb.Defaults = defaults;

        for (var i in _divs) {
            var d = document.getElementById(_divs[i]);
            d &amp;&amp; d.parentNode.removeChild(d);
        }
        _divs.splice(0, _divs.length - 1);

        /*
        var svg = document.querySelectorAll(&quot;svg&quot;);
        for (var i = 0; i &lt; svg.length; i++) {
            svg[i].parentNode.removeChild(svg[i]);
        }*/

        document.getElementById(&quot;container&quot;).innerHTML = &quot;&quot;;
    };

var testSuite = function (renderMode, _jsPlumb) {

    var support = jsPlumbTestSupport.getInstance(_jsPlumb);

    module(&quot;jsPlumb&quot;, {
        teardown: function () {
            _cleanup(_jsPlumb);
        },
        setup: function () {
            defaults = jsPlumb.extend({}, _jsPlumb.Defaults);
            _jsPlumb.setContainer(&quot;container&quot;);
        }
    });

    // setup the container
    var container = document.createElement(&quot;div&quot;);
    container.id = &quot;container&quot;;
    document.body.appendChild(container);



    //*
/*
    test(&quot; : getElementObject&quot;, function () {
        var e = document.createElement(&quot;div&quot;);
        e.id = &quot;FOO&quot;;
        document.body.appendChild(e);
        var el = jsPlumb.getElementObject(e);
        equal(jsPlumbTestSupport.getAttribute(el, &quot;id&quot;), &quot;FOO&quot;);
    });
    */

    test(&quot; : getElement&quot;, function () {
        var e = document.createElement(&quot;div&quot;);
        e.id = &quot;FOO&quot;;
        document.body.appendChild(e);
        var e2 = jsPlumb.getElement(e);
        equal(e2.id, &quot;FOO&quot;);

        var e3 = jsPlumb.getElement(&quot;FOO&quot;);
        equal(e3.id, &quot;FOO&quot;);
    });

    test(&#x27;: _jsPlumb setup&#x27;, function () {
        ok(_jsPlumb, &quot;loaded&quot;);
    });

    test(&#x27;: getId&#x27;, function () {
        var d10 = _addDiv(&#x27;d10&#x27;);
        equal(_jsPlumb.getId(jsPlumb.getElement(d10)), &quot;d10&quot;);
    });

    test(&#x27;: create a simple endpoint&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;);
        var e = _jsPlumb.addEndpoint(&quot;d1&quot;, {});
        ok(e, &#x27;endpoint exists&#x27;);
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        ok(e.id != null, &quot;endpoint has had an id assigned&quot;);
    });

    test(&#x27;: create and remove a simple endpoint&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;);
        var ee = _jsPlumb.addEndpoint(d1, {uuid: &quot;78978597593&quot;});
        ok(ee != null, &quot;endpoint exists&quot;);
        var e = _jsPlumb.getEndpoint(&quot;78978597593&quot;);
        ok(e != null, &quot;the endpoint could be retrieved by UUID&quot;);
        ok(e.id != null, &quot;the endpoint has had an id assigned to it&quot;);
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        _jsPlumb.deleteEndpoint(ee);
        assertEndpointCount(&quot;d1&quot;, 0, _jsPlumb);
        e = _jsPlumb.getEndpoint(&quot;78978597593&quot;);
        equal(e, null, &quot;the endpoint has been deleted&quot;);
    });

    test(&#x27;endpoint with overlays&#x27;, function() {
        var d1 = _addDiv(&quot;d1&quot;);
        var e = _jsPlumb.addEndpoint(d1, {
            &quot;overlays&quot;: [[&quot;Label&quot;, {&quot;label&quot;: &quot;Label text&quot;, &quot;cssClass&quot;: &#x27;kw_port_label&#x27;, &quot;id&quot;: &quot;66&quot;}]]
        });
        var o = e.getOverlay(&quot;66&quot;);
        ok(o != null, &quot;overlay exists&quot;);
    });

    test(&#x27;: create two simple endpoints, registered using a selector&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        jsPlumb.addClass(d1, &quot;window&quot;);
        jsPlumb.addClass(d2, &quot;window&quot;);
        var endpoints = _jsPlumb.addEndpoint(jsPlumb.getSelector(&quot;.window&quot;), {});
        equal(endpoints.length, 2, &quot;endpoint added to both windows&quot;);
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
    });

    test(&#x27;: create two simple endpoints, registered using an array of element ids&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        jsPlumb.addClass(d1, &quot;window&quot;);
        jsPlumb.addClass(d2, &quot;window&quot;);
        var endpoints = _jsPlumb.addEndpoint([&quot;d1&quot;, &quot;d2&quot;], {});
        equal(endpoints.length, 2, &quot;endpoint added to both windows&quot;);
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
    });

    test(&#x27; jsPlumb.remove after element removed from DOM&#x27;, function () {
        var d = document.createElement(&quot;div&quot;);
        d.innerHTML = &#x27;&lt;div id=&quot;container2&quot;&gt;&lt;ul id=&quot;targets&quot;&gt;&lt;li id=&quot;in1&quot;&gt;input 1&lt;/li&gt;&lt;li id=&quot;in2&quot;&gt;input 2&lt;/li&gt;&lt;/ul&gt;&lt;ul id=&quot;sources&quot;&gt;&lt;li id=&quot;output&quot;&gt;output&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&#x27;;
        var container = d.firstChild;
        document.body.appendChild(jsPlumb.getElement(container));
        var e1 = _jsPlumb.addEndpoint(&quot;in1&quot;, { maxConnections: 1, isSource: false, isTarget: true, anchor: [ 0, 0.4, -1, 0 ] }),
            e2 = _jsPlumb.addEndpoint(&quot;in2&quot;, { maxConnections: 1, isSource: false, isTarget: true, anchor: [ 0, 0.4, -1, 0 ] }),
            e3 = _jsPlumb.addEndpoint(&quot;output&quot;, { isSource: true, isTarget: false, anchor: [ 1, 0.4, 1, 0 ] });

        _jsPlumb.connect({source: e3, target: e1});

        // the element gets removed out of jsplumb&#x27;s control
        var op = document.getElementById(&quot;output&quot;);
        op.parentNode.removeChild(op);

        // but you can tell jsPlumb about it after the fact
        _jsPlumb.remove(&quot;output&quot;);


        equal(_jsPlumb.selectEndpoints({element: &quot;output&quot;}).length, 0, &quot;no endpoints registered for in1&quot;);
    });

    test(&#x27;: draggable in nested element does not cause extra ids to be created&#x27;, function () {
        var d = _addDiv(&quot;d1&quot;);
        var d2 = document.createElement(&quot;div&quot;);
        d2.setAttribute(&quot;foo&quot;, &quot;ff&quot;);
        d.appendChild(d2);
        var d3 = document.createElement(&quot;div&quot;);
        d2.appendChild(d3);
        ok(d2.getAttribute(&quot;id&quot;) == null, &quot;no id on d2&quot;);
        _jsPlumb.draggable(d);
        _jsPlumb.addEndpoint(d3);
        ok(d2.getAttribute(&quot;id&quot;) == null, &quot;no id on d2&quot;);
        ok(d3.getAttribute(&quot;id&quot;) != null, &quot;id on d3&quot;);
    });

    test(&quot; : draggable, reference elements returned correctly&quot;, function () {
        var d = _addDiv(&quot;d1&quot;);
        var d2 = document.createElement(&quot;div&quot;);
        d2.setAttribute(&quot;foo&quot;, &quot;ff&quot;);
        d.appendChild(d2);
        var d3 = document.createElement(&quot;div&quot;);
        d3.setAttribute(&quot;id&quot;, &quot;d3&quot;);
        d2.appendChild(d3);
        _jsPlumb.draggable(d);
        _jsPlumb.addEndpoint(d3);
        _jsPlumb.draggable(d3);
        // now check ref ids for element d1
        var els = _jsPlumb.dragManager.getElementsForDraggable(&quot;d1&quot;);
        ok(!jsPlumbUtil.isEmpty(els), &quot;there is one sub-element for d1&quot;);
        ok(els[&quot;d3&quot;] != null, &quot;d3 registered&quot;);
    });


    test(&quot; : draggable + setParent, reference elements returned correctly&quot;, function () {
        var d = _addDiv(&quot;d1&quot;);
        var d2 = document.createElement(&quot;div&quot;);
        d2.setAttribute(&quot;foo&quot;, &quot;ff&quot;);
        d.appendChild(d2);
        var d3 = document.createElement(&quot;div&quot;);
        d3.setAttribute(&quot;id&quot;, &quot;d3&quot;);
        d2.appendChild(d3);
        _jsPlumb.draggable(d);
        _jsPlumb.addEndpoint(d3);
        _jsPlumb.draggable(d3);
        // create some other new parent
        var d12 = _addDiv(&quot;d12&quot;);
        // and move d3
        _jsPlumb.setParent(d3, d12);

        // now check ref ids for element d1
        var els = _jsPlumb.dragManager.getElementsForDraggable(&quot;d1&quot;);
        ok(jsPlumbUtil.isEmpty(els), &quot;there are no sub-elements for d1&quot;);
        var els12 = _jsPlumb.dragManager.getElementsForDraggable(&quot;d12&quot;);
        ok(!jsPlumbUtil.isEmpty(els12), &quot;there is one sub-element for d12&quot;);
        ok(els12[&quot;d3&quot;] != null, &quot;d3 registered&quot;);
    });

test(&quot;drag multiple elements and ensure their connections are painted correctly at the end&quot;, function() {

        var d1 = _addDraggableDiv (_jsPlumb, &#x27;d1&#x27;, null, null,50, 50, 100, 100);
        var d2 = _addDraggableDiv (_jsPlumb, &#x27;d2&#x27;, null, null,250, 250, 100, 100);
        var d3 = _addDraggableDiv (_jsPlumb, &#x27;d3&#x27;, null, null,500, 500, 100, 100);

        var e1 = _jsPlumb.addEndpoint(d1, {
            anchor:&quot;TopLeft&quot;
        });
        var e2 = _jsPlumb.addEndpoint(d2, {
            anchor:&quot;TopLeft&quot;,
            maxConnections:-1
        });
        var e3 = _jsPlumb.addEndpoint(d3, {
            anchor:&quot;TopLeft&quot;
        });

        _jsPlumb.connect({source:e1, target:e2});
        _jsPlumb.connect({source:e2, target:e3});

        equal(e1.canvas.offsetLeft, 50 - (e1.canvas.offsetWidth/2), &quot;endpoint 1 is at the right place&quot;);
        equal(e1.canvas.offsetTop, 50 - (e1.canvas.offsetHeight/2), &quot;endpoint 1 is at the right place&quot;);
        equal(e2.canvas.offsetLeft, 250 - (e2.canvas.offsetWidth/2), &quot;endpoint 2 is at the right place&quot;);
        equal(e2.canvas.offsetTop, 250 - (e2.canvas.offsetHeight/2), &quot;endpoint 2 is at the right place&quot;);
        equal(e3.canvas.offsetLeft, 500 - (e3.canvas.offsetWidth/2), &quot;endpoint 3 is at the right place&quot;);
        equal(e3.canvas.offsetTop, 500 - (e3.canvas.offsetHeight/2), &quot;endpoint 3 is at the right place&quot;);

        _jsPlumb.addToDragSelection(&quot;d1&quot;);
        _jsPlumb.addToDragSelection(&quot;d3&quot;);

        // drag node 2 by 750,750. we expect its endpoint to have moved too

        support.dragNodeTo(d2, 1000, 1000);

        equal(d2.offsetLeft, 950, &quot;div 2 is at the right left position&quot;);
        equal(d2.offsetTop, 950, &quot;div 2 is at the right top position&quot;);

        // divs 1 and 3 have moved too, make sure they are in the right place
        equal(d1.offsetLeft, 750, &quot;div 1 is at the right left position&quot;);
        equal(d1.offsetTop, 750, &quot;div 1 is at the right top position&quot;);
        equal(d3.offsetLeft, 1200, &quot;div 3 is at the right left position&quot;);
        equal(d3.offsetTop, 1200, &quot;div 3 is at the right top position&quot;);

        // check the endpoints
        equal(e2.canvas.offsetLeft, 950 - (e2.canvas.offsetWidth/2), &quot;endpoint 2 is at the right place&quot;);
        equal(e2.canvas.offsetTop, 950 - (e2.canvas.offsetHeight/2), &quot;endpoint 2 is at the right place&quot;);

        equal(e1.canvas.offsetLeft, 750 - (e1.canvas.offsetWidth/2), &quot;endpoint 1 is at the right place&quot;);
        equal(e1.canvas.offsetTop, 750 - (e1.canvas.offsetHeight/2), &quot;endpoint 1 is at the right place&quot;);

        equal(e3.canvas.offsetLeft, 1200 - (e3.canvas.offsetWidth/2), &quot;endpoint 3 is at the right place&quot;);
        equal(e3.canvas.offsetTop, 1200 - (e3.canvas.offsetHeight/2), &quot;endpoint 3 is at the right place&quot;);

    });

    test(&quot;: lineWidth specified as string (eew)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({
            source: &quot;d1&quot;,
            target: &quot;d2&quot;,
            paintStyle: {
                stroke: &quot;red&quot;,
                strokeWidth: &quot;3&quot;
            }
        });
        equal(c._jsPlumb.paintStyleInUse.strokeWidth, 3, &quot;line width converted to integer&quot;);
    });

    test(&quot;: outlineWidth specified as string (eew)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({
            source: &quot;d1&quot;,
            target: &quot;d2&quot;,
            paintStyle: {
                stroke: &quot;red&quot;,
                strokeWidth: 3,
                outlineWidth: &quot;5&quot;
            }
        });
        c.repaint();
        equal(c._jsPlumb.paintStyleInUse.outlineWidth, 5, &quot;outline width converted to integer&quot;);
    });




    test(&quot;: strokeWidth and outlineWidth specified as strings (eew)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({
            source: &quot;d1&quot;,
            target: &quot;d2&quot;,
            paintStyle: {
                stroke: &quot;red&quot;,
                strokeWidth: &quot;3&quot;,
                outlineWidth: &quot;5&quot;
            }
        });
        c.repaint();
        equal(c._jsPlumb.paintStyleInUse.outlineWidth, 5, &quot;outline width converted to integer&quot;);
        equal(c._jsPlumb.paintStyleInUse.strokeWidth, 3, &quot;line width converted to integer&quot;);
    });

    test(&#x27;: defaultEndpointMaxConnections&#x27;, function () {
        var d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        var e3 = _jsPlumb.addEndpoint(d3, {isSource: true});
        ok(e3.anchor, &#x27;endpoint 3 has an anchor&#x27;);
        var e4 = _jsPlumb.addEndpoint(d4, {isSource: true});
        assertEndpointCount(&quot;d3&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d4&quot;, 1, _jsPlumb);
        ok(!e3.isFull(), &quot;endpoint 3 is not full.&quot;);
        _jsPlumb.connect({source: d3, target: &#x27;d4&#x27;, sourceEndpoint: e3, targetEndpoint: e4});
        assertConnectionCount(e3, 1);   // we have one connection
        _jsPlumb.connect({source: d3, target: &#x27;d4&#x27;, sourceEndpoint: e3, targetEndpoint: e4});
        assertConnectionCount(e3, 1);  // should have refused the connection; default max is 1.
    });

    test(&#x27;: specifiedEndpointMaxConnections&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;);
        var e5 = _jsPlumb.addEndpoint(d5, {isSource: true, maxConnections: 3});
        ok(e5.anchor, &#x27;endpoint 5 has an anchor&#x27;);
        var e6 = _jsPlumb.addEndpoint(d6, {isSource: true, maxConnections: 2});  // this one has max TWO
        assertEndpointCount(&quot;d5&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d6&quot;, 1, _jsPlumb);
        ok(!e5.isFull(), &quot;endpoint 5 is not full.&quot;);
        _jsPlumb.connect({sourceEndpoint: e5, targetEndpoint: e6});
        assertConnectionCount(e5, 1);   // we have one connection
        _jsPlumb.connect({sourceEndpoint: e5, targetEndpoint: e6});
        assertConnectionCount(e5, 2);  // two connections
        _jsPlumb.connect({sourceEndpoint: e5, targetEndpoint: e6});
        assertConnectionCount(e5, 2);  // should have refused; max is 2, for d4.
    });

    test(&#x27;: noEndpointMaxConnections&#x27;, function () {
        var d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        var e3 = _jsPlumb.addEndpoint(d3, {isSource: true, maxConnections: -1});
        var e4 = _jsPlumb.addEndpoint(d4, {isSource: true, maxConnections: -1});
        _jsPlumb.connect({sourceEndpoint: e3, targetEndpoint: e4});
        assertConnectionCount(e3, 1);   // we have one connection
        _jsPlumb.connect({sourceEndpoint: e3, targetEndpoint: e4});
        assertConnectionCount(e3, 2);  // we have two.  etc (default was one. this proves max is working).
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;);
        var e5 = _jsPlumb.addEndpoint(d3, {isSource: true, maxConnections: -1});
        _jsPlumb.connect({sourceEndpoint: e5, targetEndpoint: e4});
        assertConnectionCount(e4, 3);
    });


    test(&#x27;: endpoint.isConnectdTo&#x27;, function () {
        var d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        var e3 = _jsPlumb.addEndpoint(d3, {isSource: true, maxConnections: -1});
        var e4 = _jsPlumb.addEndpoint(d4, {isSource: true, maxConnections: -1});
        _jsPlumb.connect({sourceEndpoint: e3, targetEndpoint: e4});
        ok(e3.isConnectedTo(e4), &quot;e3 is connected to e4&quot;);
        ok(e4.isConnectedTo(e3), &quot;e4 is connected to e3&quot;);
    });

// ************** ANCHORS ********************************************	

    test(&#x27;: anchors equal&#x27;, function () {
        var a1 = _jsPlumb.makeAnchor([0, 1, 1, 1], null, _jsPlumb);
        var a2 = _jsPlumb.makeAnchor([0, 1, 1, 1], null, _jsPlumb);
        ok(a1.equals(a2), &quot;anchors are the same&quot;);
    });

    test(&#x27;: anchors equal with offsets&#x27;, function () {
        var a1 = _jsPlumb.makeAnchor([0, 1, 1, 1, 10, 13], null, _jsPlumb);
        var a2 = _jsPlumb.makeAnchor([0, 1, 1, 1, 10, 13], null, _jsPlumb);
        ok(a1.equals(a2), &quot;anchors are the same&quot;);
    });

    test(&#x27;: anchors not equal&#x27;, function () {
        var a1 = _jsPlumb.makeAnchor([0, 1, 0, 1], null, _jsPlumb);
        var a2 = _jsPlumb.makeAnchor([0, 1, 1, 1], null, _jsPlumb);
        ok(!a1.equals(a2), &quot;anchors are different&quot;);
    });

    test(&#x27;: anchor not equal with offsets&#x27;, function () {
        var a1 = _jsPlumb.makeAnchor([0, 1, 1, 1, 10, 13], null, _jsPlumb);
        var a2 = _jsPlumb.makeAnchor([0, 1, 1, 1], null, _jsPlumb);
        ok(!a1.equals(a2), &quot;anchors are different&quot;);
    });

    test(&#x27;simple makeAnchor, dynamicAnchors&#x27;, function () {
        expect(0);
        var spec = [
            [0.2, 0, 0, -1],
            [1, 0.2, 1, 0],
            [0.8, 1, 0, 1],
            [0, 0.8, -1, 0]
        ];
        _jsPlumb.makeAnchor(spec);
    });

    test(&quot;: unknown anchor type should throw Error&quot;, function () {
        try {
            _addDiv(&quot;d1&quot;);
            _addDiv(&quot;d2&quot;);
            _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, anchor: &quot;FOO&quot;});
        }
        catch (e) {
            // ok	
            ok(e.msg == &quot;jsPlumb: unknown anchor type &#x27;FOO&#x27;&quot;, &quot;useful error message&quot;);
        }
    });

    test(&quot;: unknown anchor type should not throw Error because it is suppressed in Defaults&quot;, function () {
        try {
            _addDiv(&quot;d1&quot;);
            _addDiv(&quot;d2&quot;);
            _jsPlumb.Defaults.DoNotThrowErrors = true;
            _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, anchor: &quot;FOO&quot;});
        }
        catch (e) {
            // ok	
            ok(e.msg != &quot;jsPlumb: unknown anchor type &#x27;FOO&#x27;&quot;, &quot;no error message&quot;);
        }
    });

    test(&quot;: unknown endpoint type should throw Error&quot;, function () {
        try {
            _addDiv(&quot;d1&quot;);
            _addDiv(&quot;d2&quot;);
            _jsPlumb.Defaults.DoNotThrowErrors = false;
            _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, endpoint: &quot;FOO&quot;});
        }
        catch (e) {
            // ok	
            ok(e.msg == &quot;jsPlumb: unknown endpoint type &#x27;FOO&#x27;&quot;, &quot;useful error message&quot;);
        }
    });

    test(&quot;: unknown endpoint type should not throw Error because it is suppressed in Defaults&quot;, function () {
        try {
            _addDiv(&quot;d1&quot;);
            _addDiv(&quot;d2&quot;);
            _jsPlumb.Defaults.DoNotThrowErrors = true;
            _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, endpoint: &quot;FOO&quot;});
        }
        catch (e) {
            // ok	
            ok(e.msg != &quot;jsPlumb: unknown endpoint type &#x27;FOO&#x27;&quot;, &quot;no error message&quot;);
        }
    });

    test(&quot;: unknown connector type should throw Error&quot;, function () {
        try {
            _addDiv(&quot;d1&quot;);
            _addDiv(&quot;d2&quot;);
            _jsPlumb.Defaults.DoNotThrowErrors = false;
            _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, connector: &quot;FOO&quot;});
        }
        catch (e) {
            // ok	
            ok(e.msg == &quot;jsPlumb: unknown connector type &#x27;FOO&#x27;&quot;, &quot;useful error message&quot;);
        }
    });

    test(&quot;: unknown connector type should not throw Error because it is suppressed in Defaults&quot;, function () {
        try {
            _addDiv(&quot;d1&quot;);
            _addDiv(&quot;d2&quot;);
            _jsPlumb.Defaults.DoNotThrowErrors = true;
            _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, connector: &quot;FOO&quot;});
        }
        catch (e) {
            // ok	
            ok(e.msg != &quot;jsPlumb: unknown connector type &#x27;FOO&#x27;&quot;, &quot;no error message&quot;);
        }
    });

// ************** / ANCHORS ********************************************


// **************************** DETACHING CONNECTIONS ****************************************************


    test(&#x27;: detach does not fail when no arguments are provided&#x27;, function () {
        var d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        _jsPlumb.connect({source: d3, target: d4});
        _jsPlumb.detach();
        expect(0);
    });

    // test that detach does not fire an event by default
    test(&#x27;: _jsPlumb.detach should fire detach event by default&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;);
        var conn = _jsPlumb.connect({source: d5, target: d6});
        var eventCount = 0;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (c) {
            eventCount++;
        });
        _jsPlumb.detach(conn);
        equal(eventCount, 1);
    });

    // test that detach does not fire an event by default
    test(&#x27;: _jsPlumb.detach should fire detach event by default, using params object&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;);
        var conn = _jsPlumb.connect({source: d5, target: d6});
        var eventCount = 0;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (c) {
            eventCount++;
        });
        _jsPlumb.detach({connection: conn});
        equal(eventCount, 1);
    });

    // test that detach fires an event when instructed to do so
    test(&#x27;: _jsPlumb.detach should not fire detach event when instructed to not do so&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;);
        var conn = _jsPlumb.connect({source: d5, target: d6});
        var eventCount = 0;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (c) {
            eventCount++;
        });
        _jsPlumb.detach(conn, {fireEvent: false});
        equal(eventCount, 0);
    });

    // issue 81
    test(&#x27;: _jsPlumb.detach should fire only one detach event (pass Connection as argument)&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;);
        var conn = _jsPlumb.connect({source: d5, target: d6});
        var eventCount = 0;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (c) {
            eventCount++;
        });
        _jsPlumb.detach(conn);
        equal(eventCount, 1);
    });

    // issue 81
    test(&#x27;: _jsPlumb.detach should fire only one detach event (pass Connection as param in argument)&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;);
        var conn = _jsPlumb.connect({source: d5, target: d6});
        var eventCount = 0;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (c) {
            eventCount++;
        });
        _jsPlumb.detach({connection: conn});
        equal(eventCount, 1);
    });

    // issue 81
    test(&#x27;: detach should fire only one detach event (pass source and targets as strings as arguments in params object)&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;);
        var conn = _jsPlumb.connect({source: d5, target: d6});
        var eventCount = 0;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (c) {
            eventCount++;
        });
        _jsPlumb.detach({source: &quot;d5&quot;, target: &quot;d6&quot;});
        equal(eventCount, 1);
    });

    // issue 81
    test(&#x27;: detach should fire only one detach event (pass source and targets as divs as arguments in params object)&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;);
        var conn = _jsPlumb.connect({source: d5, target: d6});
        var eventCount = 0;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (c) {
            eventCount++;
        });
        _jsPlumb.detach({source: d5, target: d6, fireEvent: true});
        equal(eventCount, 1);
    });

    //TODO make sure you run this test with a single detach call, to ensure that
    // single detach calls result in the connection being removed. detachEveryConnection can
    // just blow away the connectionsByScope array and recreate it.
    test(&#x27;: getConnections (simple case, default scope)&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;);
        _jsPlumb.connect({source: d5, target: d6});
        var c = _jsPlumb.getConnections();  // will get all connections in the default scope.
        equal(c.length, 1, &quot;there is one connection&quot;);
    });

    test(&#x27;getConnections (uuids)&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;),
            d6 = _addDiv(&quot;d6&quot;),
            e5 = _jsPlumb.addEndpoint(d5, {uuid:&quot;foo&quot;}),
            e6 = _jsPlumb.addEndpoint(d6, {uuid:&quot;bar&quot;});
        _jsPlumb.connect({uuids:[&quot;foo&quot;, &quot;bar&quot;]});
        var c = _jsPlumb.getConnections();  // will get all connections in the default scope.
        equal(c.length, 1, &quot;there is one connection&quot;);
        equal(c[0].getUuids()[0], &quot;foo&quot;);
        equal(c[0].getUuids()[1], &quot;bar&quot;);
    });

    test(&#x27;getConnections (simple case, default scope; detach by element id using params object)&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;), d7 = _addDiv(&quot;d7&quot;);
        _jsPlumb.connect({source: d5, target: d6});
        _jsPlumb.connect({source: d6, target: d7});
        var c = _jsPlumb.getConnections();  // will get all connections
        equal(c.length, 2, &quot;there are two connections initially&quot;);
        _jsPlumb.detach({source: &#x27;d5&#x27;, target: &#x27;d6&#x27;});
        c = _jsPlumb.getConnections();  // will get all connections
        equal(c.length, 1, &quot;after detaching one, there is now one connection.&quot;);
    });

    test(&#x27;: getConnections (simple case, default scope; detach by id using params object)&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;), d7 = _addDiv(&quot;d7&quot;);
        _jsPlumb.connect({source: d5, target: d6});
        _jsPlumb.connect({source: d6, target: d7});
        var c = _jsPlumb.getConnections();  // will get all connections
        equal(c.length, 2, &quot;there are two connections initially&quot;);
        _jsPlumb.detach({source: &quot;d5&quot;, target: &quot;d6&quot;});
        c = _jsPlumb.getConnections();  // will get all connections
        equal(c.length, 1, &quot;after detaching one, there is now one connection.&quot;);
    });

    test(&#x27;: getConnections (simple case, default scope; detach by element object using params object)&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;), d7 = _addDiv(&quot;d7&quot;);
        _jsPlumb.connect({source: d5, target: d6});
        _jsPlumb.connect({source: d6, target: d7});
        var c = _jsPlumb.getConnections();  // will get all connections
        equal(c.length, 2, &quot;there are two connections initially&quot;);
        _jsPlumb.detach({source: d5, target: d6});
        c = _jsPlumb.getConnections();  // will get all connections
        equal(c.length, 1, &quot;after detaching one, there is now one connection.&quot;);
    });

    test(&#x27;: getConnections (simple case, default scope; detach by Connection)&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;), d7 = _addDiv(&quot;d7&quot;);
        var c56 = _jsPlumb.connect({source: d5, target: d6});
        var c67 = _jsPlumb.connect({source: d6, target: d7});
        var c = _jsPlumb.getConnections();  // will get all connections
        equal(c.length, 2, &quot;there are two connections initially&quot;);
        _jsPlumb.detach(c56);
        c = _jsPlumb.getConnections();  // will get all connections
        equal(c.length, 1, &quot;after detaching one, there is now one connection.&quot;);
    });

// beforeDetach functionality

    test(&quot;: detach; beforeDetach on connect call returns false&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, beforeDetach: function (conn) {
            return false;
        }});
        var beforeDetachCount = 0;
        _jsPlumb.bind(&quot;beforeDetach&quot;, function (connection) {
            beforeDetachCount++;
        });
        equal(c.endpoints[0].connections.length, 1, &quot;source endpoint has a connection initially&quot;);
        _jsPlumb.detach(c);
        equal(c.endpoints[0].connections.length, 1, &quot;source endpoint has a connection after detach call was denied&quot;);
        equal(beforeDetachCount, 0, &quot;jsplumb before detach was not called&quot;);
    });

    test(&quot;: detach; beforeDetach on connect call returns undefined&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, beforeDetach: function (conn) { }});
        var beforeDetachCount = 0;
        _jsPlumb.bind(&quot;beforeDetach&quot;, function (connection) {
            beforeDetachCount++;
        });
        equal(c.endpoints[0].connections.length, 1, &quot;source endpoint has a connection initially&quot;);
        _jsPlumb.detach(c);
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
    });

    test(&quot;: detach; beforeDetach on connect call returns true&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, beforeDetach: function (conn) {
            return true;
        }});
        equal(c.endpoints[0].connections.length, 1, &quot;source endpoint has a connection initially&quot;);
        _jsPlumb.detach(c);
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
    });

    test(&quot;: detach; beforeDetach on connect call throws an exception; we treat it with the contempt it deserves and pretend it said the detach was ok.&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, beforeDetach: function (conn) {
            throw &quot;i am an example of badly coded beforeDetach, but i don&#x27;t break jsPlumb &quot;;
        }});
        equal(c.endpoints[0].connections.length, 1, &quot;source endpoint has a connection initially&quot;);
        _jsPlumb.detach(c);
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
    });

    test(&quot;: detach; beforeDetach on addEndpoint call to source Endpoint returns false&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true, beforeDetach: function (conn) {
                return false;
            } }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true });
        var c = _jsPlumb.connect({source: e1, target: e2});
        var beforeDetachCount = 0;
        _jsPlumb.bind(&quot;beforeDetach&quot;, function (connection) {
            beforeDetachCount++;
        });
        equal(c.endpoints[0].connections.length, 1, &quot;source endpoint has a connection initially&quot;);
        _jsPlumb.detach(c);
        equal(c.endpoints[0].connections.length, 1, &quot;source endpoint has a connection after detach call was denied&quot;);
        equal(beforeDetachCount, 0, &quot;jsplumb before detach was not called&quot;);
    });

    test(&quot;: detach; beforeDetach on addEndpoint call to source Endpoint returns true&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true, beforeDetach: function (conn) {
                return true;
            } }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[0].connections.length, 1, &quot;source endpoint has a connection initially&quot;);
        _jsPlumb.detach(c);
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
    });


    test(&quot;: Endpoint.detach; beforeDetach on addEndpoint call to source Endpoint returns false; Endpoint.detach returns false too (the UI needs it to)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true, beforeDetach: function (conn) {
                return false;
            } }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[0].connections.length, 1, &quot;source endpoint has a connection initially&quot;);
        var success = e1.detach(c);
        equal(c.endpoints[0].connections.length, 1, &quot;source endpoint has a connection after detach call was denied&quot;);
        ok(!success, &quot;Endpoint reported detach did not execute&quot;);
    });

    test(&quot;: _jsPlumb.detach; beforeDetach on addEndpoint call to target Endpoint returns false&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true, beforeDetach: function (conn) {
                return false;
            } });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.detach(c);
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection after detach call was denied&quot;);
    });

    test(&quot;: _jsPlumb.detach; beforeDetach on addEndpoint call to target Endpoint returns false but detach is forced&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true, beforeDetach: function (conn) {
                return false;
            } });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.detach(c, {forceDetach: true});
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
    });

    test(&quot;: _jsPlumb.detach; beforeDetach on addEndpoint call to target Endpoint returns true&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true, beforeDetach: function (conn) {
                return true;
            } });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.detach(c);
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
        equal(e1.connections.length, 0, &quot;source endpoint has no connections&quot;);
        equal(e2.connections.length, 0, &quot;target endpoint has no connections&quot;);
    });

    test(&quot;: _jsPlumb.detach; beforeDetach bound to _jsPlumb returns false&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true });
        var c = _jsPlumb.connect({source: e1, target: e2});
        var beforeDetachCount = 0;
        _jsPlumb.bind(&quot;beforeDetach&quot;, function (connection) {
            ok(connection.sourceId === &quot;d1&quot;, &quot;connection is provided and configured with correct source&quot;);
            ok(connection.targetId === &quot;d2&quot;, &quot;connection is provided and configured with correct target&quot;);
            beforeDetachCount++;
            return false;
        });
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.detach(c);
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection after detach call was denied&quot;);
        equal(beforeDetachCount, 1, &quot;beforeDetach was called only one time&quot;);
    });

    test(&quot;: _jsPlumb.detach; beforeDetach bound to _jsPlumb returns true&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true });
        var c = _jsPlumb.connect({source: e1, target: e2});
        _jsPlumb.bind(&quot;beforeDetach&quot;, function (connection) {
            ok(connection.sourceId === &quot;d1&quot;, &quot;connection is provided and configured with correct source&quot;);
            ok(connection.targetId === &quot;d2&quot;, &quot;connection is provided and configured with correct target&quot;);
            return true;
        });
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.detach(c);
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
        equal(e1.connections.length, 0, &quot;source endpoint has no connections&quot;);
        equal(e2.connections.length, 0, &quot;target endpoint has no connections&quot;);
    });

    test(&quot;: _jsPlumb.detach; beforeDetach bound to _jsPlumb returns false&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true });
        var c = _jsPlumb.connect({source: e1, target: e2});
        _jsPlumb.bind(&quot;beforeDetach&quot;, function (connection) {
            return false;
        });
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.detach(c);
        equal(e1.connections.length, 1, &quot;source endpoint&#x27;s connection was not removed&quot;);
    });

    test(&quot;: _jsPlumb.detachAllConnections ; beforeDetach on addEndpoint call to target Endpoint returns false but we should detach anyway&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true, beforeDetach: function (conn) {
                return false;
            } });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.detachAllConnections(d1);
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
        equal(e1.connections.length, 0, &quot;source endpoint has no connections&quot;);
        equal(e2.connections.length, 0, &quot;target endpoint has no connections&quot;);
    });

    test(&quot;: _jsPlumb.detachAllConnections ; beforeDetach on jsPlumb returns false and we dont detach&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.bind(&quot;beforeDetach&quot;, function (conn) {
            return false;
        });
        _jsPlumb.detachAllConnections(d1);
        equal(c.endpoints.length, 2, &quot;connection&#x27;s endpoints were not removed&quot;);
        equal(e1.connections.length, 1, &quot;source endpoint has a connection&quot;);
        equal(e2.connections.length, 1, &quot;target endpoint has a connection&quot;);
    });

    test(&quot;: _jsPlumb.detachAllConnections ; beforeDetach on jsPlumb returns true and we do detach&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.bind(&quot;beforeDetach&quot;, function (conn) {
            return true;
        });
        _jsPlumb.detachAllConnections(d1);
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
        equal(e1.connections.length, 0, &quot;source endpoint has no connections&quot;);
        equal(e2.connections.length, 0, &quot;target endpoint has no connections&quot;);
    });

    test(&quot;: _jsPlumb.detachEveryConnection ; beforeDetach on jsPlumb returns false and we dont detach&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.bind(&quot;beforeDetach&quot;, function (conn) {
            return false;
        });
        _jsPlumb.detachEveryConnection();
        equal(c.endpoints.length, 2, &quot;connection&#x27;s endpoints were not removed&quot;);
        equal(e1.connections.length, 1, &quot;source endpoint has a connection&quot;);
        equal(e2.connections.length, 1, &quot;target endpoint has a connection&quot;);
    });

    test(&quot;: _jsPlumb.detachEveryConnection ; beforeDetach on jsPlumb returns true and we do detach&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.bind(&quot;beforeDetach&quot;, function (conn) {
            return true;
        });
        _jsPlumb.detachEveryConnection();
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
        equal(e1.connections.length, 0, &quot;source endpoint has no connections&quot;);
        equal(e2.connections.length, 0, &quot;target endpoint has no connections&quot;);
    });

    test(&quot;: _jsPlumb.detachEveryConnection ; beforeDetach on jsPlumb returns true but we have forced detach&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.bind(&quot;beforeDetach&quot;, function (conn) {
            return false;
        });
        _jsPlumb.detachEveryConnection({forceDetach: true});
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
        equal(e1.connections.length, 0, &quot;source endpoint has no connections&quot;);
        equal(e2.connections.length, 0, &quot;target endpoint has no connections&quot;);
    });

    test(&quot;: _jsPlumb.detachEveryConnection ; beforeDetach on addEndpoint call to target Endpoint returns false but we should detach anyway&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true, beforeDetach: function (conn) {
                return false;
            } });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        _jsPlumb.detachEveryConnection();
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
        equal(e1.connections.length, 0, &quot;source endpoint has no connections&quot;);
        equal(e2.connections.length, 0, &quot;target endpoint has no connections&quot;);
    });

    test(&quot;: Endpoint.detachAll ; beforeDetach on addEndpoint call to target Endpoint returns false but we should detach anyway&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource: true }),
            e2 = _jsPlumb.addEndpoint(d2, { isTarget: true, beforeDetach: function (conn) {
                return false;
            } });
        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.endpoints[1].connections.length, 1, &quot;target endpoint has a connection initially&quot;);
        e1.detachAll();
        equal(c.endpoints, null, &quot;connection&#x27;s endpoints were removed&quot;);
        equal(e1.connections.length, 0, &quot;source endpoint has no connections&quot;);
        equal(e2.connections.length, 0, &quot;target endpoint has no connections&quot;);
    });

// ******** end of beforeDetach tests **************

// detachEveryConnection/detachAllConnections fireEvent overrides tests

    test(&quot;: _jsPlumb.detachEveryConnection fires events&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), connCount = 0;
        _jsPlumb.bind(&quot;connection&quot;, function () {
            connCount++;
        });
        _jsPlumb.bind(&quot;connectionDetached&quot;, function () {
            connCount--;
        });
        _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.connect({source: d1, target: d2});
        equal(connCount, 2, &quot;two connections registered&quot;);
        _jsPlumb.detachEveryConnection();
        equal(connCount, 0, &quot;no connections registered&quot;);
    });


    test(&quot;: _jsPlumb.detachEveryConnection doesn&#x27;t fire events when instructed not to&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), connCount = 0;
        _jsPlumb.bind(&quot;connection&quot;, function () {
            connCount++;
        });
        _jsPlumb.bind(&quot;connectionDetached&quot;, function () {
            connCount--;
        });
        _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.connect({source: d1, target: d2});
        equal(connCount, 2, &quot;two connections registered&quot;);
        _jsPlumb.detachEveryConnection({fireEvent: false});
        equal(connCount, 2, &quot;two connections registered&quot;);
    });

    test(&quot;: _jsPlumb.detachAllConnections fires events&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), connCount = 0,
            e1 = _jsPlumb.addEndpoint(d1), e2 = _jsPlumb.addEndpoint(d2);
        _jsPlumb.bind(&quot;connection&quot;, function () {
            connCount++;
        });
        _jsPlumb.bind(&quot;connectionDetached&quot;, function () {
            connCount--;
        });
        _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.connect({source: d1, target: d2});
        equal(connCount, 2, &quot;two connections registered&quot;);
        _jsPlumb.detachAllConnections(&quot;d1&quot;);
        equal(connCount, 0, &quot;no connections registered&quot;);
    });

    test(&quot;: _jsPlumb.detachAllConnections doesn&#x27;t fire events when instructed not to&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), connCount = 0,
            e1 = _jsPlumb.addEndpoint(d1), e2 = _jsPlumb.addEndpoint(d2);
        _jsPlumb.bind(&quot;connection&quot;, function () {
            connCount++;
        });
        _jsPlumb.bind(&quot;connectionDetached&quot;, function () {
            connCount--;
        });
        _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.connect({source: d1, target: d2});
        equal(connCount, 2, &quot;two connections registered&quot;);
        _jsPlumb.detachAllConnections(&quot;d1&quot;, {fireEvent: false});
        equal(connCount, 2, &quot;two connections registered&quot;);
    });

// **************************** / DETACHING CONNECTIONS ****************************************************    

    test(&quot; : deletions, simple endpoint case&quot;, function () {

        // 1. simplest case - an endpoint that exists on some element.		
        var d1 = _addDiv(&quot;d1&quot;),
            e = _jsPlumb.addEndpoint(d1),
            dt = _jsPlumb.deleteObject({endpoint: e});

        equal(jsPlumbUtil.isEmpty(dt.endpoints), false, &quot;one endpoint to delete&quot;);
        equal(dt.endpointCount, 1, &quot;one endpoint to delete&quot;);
        equal(jsPlumbUtil.isEmpty(dt.connections), true, &quot;zero connections to delete&quot;);
        equal(dt.connectionCount, 0, &quot;zero connections to delete&quot;);

        // 2. create two endpoints and connect them, then delete one. the other endpoint should
        // still exist.
        var d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            e2 = _jsPlumb.addEndpoint(d2),
            e3 = _jsPlumb.addEndpoint(d3);

        _jsPlumb.connect({source: e2, target: e3});
        equal(_jsPlumb.select({source: d2}).length, 1, &quot;one connection exists&quot;);

        var dt2 = _jsPlumb.deleteObject({endpoint: e2});
        equal(jsPlumbUtil.isEmpty(dt2.endpoints), false, &quot;one endpoint to delete&quot;);
        equal(jsPlumbUtil.isEmpty(dt2.connections), false, &quot;one connection to delete&quot;);
        equal(_jsPlumb.select({source: d2}).length, 0, &quot;zero connections exist&quot;);
        equal(_jsPlumb.getEndpoints(d2), null, &quot;zero endpoints on d2&quot;);
        equal(_jsPlumb.getEndpoints(d3).length, 1, &quot;one endpoint on d3&quot;);

        // 3. create two endpoints and connect them, then detach the connection. the two endpoints
        // should still exist.
        var d4 = _addDiv(&quot;d4&quot;), d5 = _addDiv(&quot;d5&quot;),
            e4 = _jsPlumb.addEndpoint(d4),
            e5 = _jsPlumb.addEndpoint(d5);

        var c = _jsPlumb.connect({source: e4, target: e5});
        equal(_jsPlumb.select({source: d4}).length, 1, &quot;one connection exists&quot;);

        var dt3 = _jsPlumb.deleteObject({connection: c});
        equal(jsPlumbUtil.isEmpty(dt3.endpoints), true, &quot;zero endpoints to delete&quot;);
        equal(jsPlumbUtil.isEmpty(dt3.connections), false, &quot;connections to delete&quot;);
        equal(_jsPlumb.select({source: d4}).length, 0, &quot;zero connections exist&quot;);
        equal(_jsPlumb.getEndpoints(d4).length, 1, &quot;one endpoint on d4&quot;);
        equal(_jsPlumb.getEndpoints(d5).length, 1, &quot;one endpoint on d5&quot;);

        // 4. same as (3), except set deleteEndpointsOnDetach on the connect call.
        var d6 = _addDiv(&quot;d6&quot;), d7 = _addDiv(&quot;d7&quot;);

        var c2 = _jsPlumb.connect({source: d6, target: d7, deleteEndpointsOnDetach: true});
        equal(_jsPlumb.select({source: d6}).length, 1, &quot;one connection exists&quot;);

        var dt4 = _jsPlumb.deleteObject({connection: c2});
        equal(jsPlumbUtil.isEmpty(dt4.endpoints), false, &quot;endpoints to delete&quot;);
        equal(dt4.endpointCount, 2, &quot;2 endpoints to delete&quot;);
        equal(jsPlumbUtil.isEmpty(dt4.connections), false, &quot;zero connections to delete&quot;);
        equal(_jsPlumb.select({source: d6}).length, 0, &quot;zero connections exist&quot;);
        equal(_jsPlumb.getEndpoints(d6), null, &quot;no endpoints on d4&quot;);
        equal(_jsPlumb.getEndpoints(d7), null, &quot;no endpoints on d5&quot;);

    });


    test(&#x27;: getConnections (scope testScope)&#x27;, function () {
        var d5 = _addDiv(&quot;d5&quot;), d6 = _addDiv(&quot;d6&quot;);
        _jsPlumb.connect({source: d5, target: d6, scope: &#x27;testScope&#x27;});
        var c = _jsPlumb.getConnections(&quot;testScope&quot;);  // will get all connections in testScope	
        equal(c.length, 1, &quot;there is one connection&quot;);
        equal(c[0].sourceId, &#x27;d5&#x27;, &quot;the connection&#x27;s source is d5&quot;);
        equal(c[0].targetId, &#x27;d6&#x27;, &quot;the connection&#x27;s source is d6&quot;);
        c = _jsPlumb.getConnections();  // will get all connections in default scope; should be none.
        equal(c.length, 0, &quot;there are no connections in the default scope&quot;);
    });

    test(&#x27;: _jsPlumb.getAllConnections (filtered by scope)&#x27;, function () {
        var d8 = _addDiv(&quot;d8&quot;), d9 = _addDiv(&quot;d9&quot;), d10 = _addDiv(&#x27;d10&#x27;);
        _jsPlumb.connect({source: d8, target: d9, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d9, target: d10}); // default scope
        var c = _jsPlumb.getAllConnections();  // will get all connections	
        equal(c.length, 2, &quot;all connections has two entries&quot;);
        // now supply a list of scopes
        c = _jsPlumb.getConnections();
        equal(c.length, 1, &quot;1 connection in default scope&quot;);
        c = _jsPlumb.getConnections(&quot;testScope&quot;);
        equal(c.length, 1, &quot;there is one connection in &#x27;testScope&#x27;&quot;);
    });

    test(&#x27;: _jsPlumb.getConnections (filtered by scope and sourceId)&#x27;, function () {
        var d8 = _addDiv(&quot;d8&quot;), d9 = _addDiv(&quot;d9&quot;), d10 = _addDiv(&#x27;d10&#x27;);
        _jsPlumb.connect({source: d8, target: d9, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d9, target: d8, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d9, target: d10}); // default scope
        var c = _jsPlumb.getConnections({scope: &#x27;testScope&#x27;, source: &#x27;d8&#x27;});  // will get all connections with sourceId &#x27;d8&#x27;	
        equal(c.length, 1, &quot;there is one connection in &#x27;testScope&#x27; from d8&quot;);
    });

    test(&#x27;: _jsPlumb.getConnections (filtered by scope, source id and target id)&#x27;, function () {
        var d11 = _addDiv(&quot;d11&quot;), d12 = _addDiv(&quot;d12&quot;), d13 = _addDiv(&#x27;d13&#x27;);
        _jsPlumb.connect({source: d11, target: d12, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d12, target: d13, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d11, target: d13, scope: &#x27;testScope&#x27;});
        var c = _jsPlumb.getConnections({scope: &#x27;testScope&#x27;, source: &#x27;d11&#x27;, target: &#x27;d13&#x27;});
        equal(c.length, 1, &quot;there is one connection from d11 to d13&quot;);
    });

    test(&#x27;: _jsPlumb.getConnections (filtered by a list of scopes)&#x27;, function () {
        var d11 = _addDiv(&quot;d11&quot;), d12 = _addDiv(&quot;d12&quot;), d13 = _addDiv(&#x27;d13&#x27;);
        _jsPlumb.connect({source: d11, target: d12, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d12, target: d13, scope: &#x27;testScope2&#x27;});
        _jsPlumb.connect({source: d11, target: d13, scope: &#x27;testScope3&#x27;});
        var c = _jsPlumb.getConnections({scope: [&#x27;testScope&#x27;, &#x27;testScope3&#x27;]});
        equal(c[&#x27;testScope&#x27;].length, 1, &#x27;there is one connection in testScope&#x27;);
        equal(c[&#x27;testScope3&#x27;].length, 1, &#x27;there is one connection in testScope3&#x27;);
        equal(c[&#x27;testScope2&#x27;], null, &#x27;there are no connections in testScope2&#x27;);
    });

    test(&#x27;: _jsPlumb.getConnections (filtered by a list of scopes and source ids)&#x27;, function () {
        var d11 = _addDiv(&quot;d11&quot;), d12 = _addDiv(&quot;d12&quot;), d13 = _addDiv(&#x27;d13&#x27;);
        _jsPlumb.connect({source: d11, target: d12, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d13, target: d12, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d12, target: d13, scope: &#x27;testScope2&#x27;});
        _jsPlumb.connect({source: d11, target: d13, scope: &#x27;testScope3&#x27;});
        var c = _jsPlumb.getConnections({scope: [&#x27;testScope&#x27;, &#x27;testScope3&#x27;], source: [&#x27;d11&#x27;]});
        equal(c[&#x27;testScope&#x27;].length, 1, &#x27;there is one connection in testScope&#x27;);
        equal(c[&#x27;testScope3&#x27;].length, 1, &#x27;there is one connection in testScope3&#x27;);
        equal(c[&#x27;testScope2&#x27;], null, &#x27;there are no connections in testScope2&#x27;);
    });

    test(&#x27;: _jsPlumb.getConnections (filtered by a list of scopes, source ids and target ids)&#x27;, function () {
        _jsPlumb.detachEveryConnection();
        var d11 = _addDiv(&quot;d11&quot;), d12 = _addDiv(&quot;d12&quot;), d13 = _addDiv(&#x27;d13&#x27;), d14 = _addDiv(&quot;d14&quot;), d15 = _addDiv(&quot;d15&quot;);
        _jsPlumb.connect({source: d11, target: d12, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d13, target: d12, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d11, target: d14, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d11, target: d15, scope: &#x27;testScope&#x27;});
        _jsPlumb.connect({source: d12, target: d13, scope: &#x27;testScope2&#x27;});
        _jsPlumb.connect({source: d11, target: d13, scope: &#x27;testScope3&#x27;});
        var c = _jsPlumb.getConnections({scope: [&#x27;testScope&#x27;, &#x27;testScope3&#x27;], source: [&#x27;d11&#x27;], target: [&#x27;d14&#x27;, &#x27;d15&#x27;]});
        equal(c[&#x27;testScope&#x27;].length, 2, &#x27;there are two connections in testScope&#x27;);
        equal(c[&#x27;testScope3&#x27;], null, &#x27;there are no connections in testScope3&#x27;);
        equal(c[&#x27;testScope2&#x27;], null, &#x27;there are no connections in testScope2&#x27;);
        var anEntry = c[&#x27;testScope&#x27;][0];
        ok(anEntry.endpoints[0] != null, &quot;Source endpoint is set&quot;);
        ok(anEntry.endpoints[1] != null, &quot;Target endpoint is set&quot;);
        equal(anEntry.source.getAttribute(&quot;id&quot;), &quot;d11&quot;, &quot;Source is div d11&quot;);
        equal(anEntry.target.getAttribute(&quot;id&quot;), &quot;d14&quot;, &quot;Target is div d14&quot;);
    });

    test(&#x27;: getEndpoints, one Endpoint added by addEndpoint, get Endpoints by selector&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        _jsPlumb.addEndpoint(d1);
        var e = _jsPlumb.getEndpoints(d1);
        equal(e.length, 1, &quot;there is one endpoint for element d1&quot;);
    });

    test(&#x27;: getEndpoints, one Endpoint added by addEndpoint, get Endpoints by id&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        _jsPlumb.addEndpoint(d1);
        var e = _jsPlumb.getEndpoints(&quot;d1&quot;);
        equal(e.length, 1, &quot;there is one endpoint for element d1&quot;);
    });

    test(&#x27;: addEndpoint, css class on anchor added to endpoint artefact and element&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var ep = _jsPlumb.addEndpoint(d1, { anchor: [0, 0, 1, 1, 0, 0, &quot;foo&quot; ]});
        ok(jsPlumb.hasClass(ep.canvas, &quot;jtk-endpoint-anchor-foo&quot;), &quot;class set on endpoint&quot;);
        ok(jsPlumb.hasClass(d1, &quot;jtk-endpoint-anchor-foo&quot;), &quot;class set on element&quot;);
        _jsPlumb.deleteEndpoint(ep);
        ok(!jsPlumb.hasClass(d1, &quot;jtk-endpoint-anchor-foo&quot;), &quot;class removed from element&quot;);
    });

    test(&#x27;: addEndpoint, blank css class on anchor does not add extra prefix &#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var ep = _jsPlumb.addEndpoint(d1, { anchor: [0, 0, 1, 1, 0, 0  ]});
        ok(jsPlumb.hasClass(ep.canvas, &quot;jtk-endpoint-anchor&quot;), &quot;class set on endpoint&quot;);
        ok(jsPlumb.hasClass(d1, &quot;jtk-endpoint-anchor&quot;), &quot;class set on element&quot;);
        _jsPlumb.deleteEndpoint(ep);
        ok(!jsPlumb.hasClass(d1, &quot;jtk-endpoint-anchor&quot;), &quot;class removed from element&quot;);
    });

    test(&#x27;: connect, jsplumb connected class added to elements&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        // connect two elements and check they both get the class.
        var c = _jsPlumb.connect({source:d1, target:d2});
        ok(jsPlumb.hasClass(d1, &quot;jtk-connected&quot;), &quot;class set on element d1&quot;);
        ok(jsPlumb.hasClass(d2, &quot;jtk-connected&quot;), &quot;class set on element d2&quot;);
        // connect d1 to another element and check d3 gets the class
        var c2 = _jsPlumb.connect({source:d1, target:d3});
        ok(jsPlumb.hasClass(d3, &quot;jtk-connected&quot;), &quot;class set on element d3&quot;);
        // now disconnect original connection. d2 should no longer have the class, but d1 should, since it has
        // still one connection.
        _jsPlumb.detach(c);
        ok(jsPlumb.hasClass(d1, &quot;jtk-connected&quot;), &quot;class still on element d1&quot;);
        ok(!jsPlumb.hasClass(d2, &quot;jtk-connected&quot;), &quot;class removed from element d2&quot;);
        _jsPlumb.detach(c2);
        ok(!jsPlumb.hasClass(d1, &quot;jtk-connected&quot;), &quot;class removed from element d1&quot;);
        ok(!jsPlumb.hasClass(d3, &quot;jtk-connected&quot;), &quot;class removed from element d3&quot;);
    });

    test(&#x27;: connection event listeners&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var returnedParams = null;
        _jsPlumb.bind(&quot;connection&quot;, function (params) {
            returnedParams = jsPlumb.extend({}, params);
        });
        var c = _jsPlumb.connect({source: d1, target: d2});
        ok(returnedParams != null, &quot;new connection listener event was fired&quot;);
        ok(returnedParams.connection != null, &#x27;connection is set&#x27;);
        equal(returnedParams.sourceId, &quot;d1&quot;, &#x27;sourceid is set&#x27;);
        equal(returnedParams.targetId, &quot;d2&quot;, &#x27;targetid is set&#x27;);
        equal(returnedParams.source.getAttribute(&quot;id&quot;), &quot;d1&quot;, &#x27;source is set&#x27;);
        equal(returnedParams.target.getAttribute(&quot;id&quot;), &quot;d2&quot;, &#x27;target is set&#x27;);
        ok(returnedParams.sourceEndpoint != null, &quot;source endpoint is not null&quot;);
        ok(returnedParams.targetEndpoint != null, &quot;target endpoint is not null&quot;);
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            returnedParams = jsPlumb.extend({}, params);
        });
        _jsPlumb.detach(c);
        ok(returnedParams.connection != null, &#x27;connection is set&#x27;);
    });

    test(&#x27;: detach event listeners (detach by connection)&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var returnedParams = null;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            returnedParams = jsPlumb.extend({}, params);
        });
        var conn = _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.detach(conn);
        ok(returnedParams != null, &quot;removed connection listener event was fired&quot;);
        ok(returnedParams.connection != null, &quot;removed connection listener event passed in connection&quot;);
    });

    test(&#x27;: detach event listeners (detach by element ids)&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var returnedParams = null;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            returnedParams = jsPlumb.extend({}, params);
        });
        var conn = _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.detach({source: &quot;d1&quot;, target: &quot;d2&quot;});
        ok(returnedParams != null, &quot;removed connection listener event was fired&quot;);
    });

    test(&#x27;: detach event listeners (detach by elements)&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var returnedParams = null;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            returnedParams = jsPlumb.extend({}, params);
        });
        var conn = _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.detach({source: d1, target: d2});
        ok(returnedParams != null, &quot;removed connection listener event was fired&quot;);
    });

    test(&#x27;: detach event listeners (via Endpoint.detach method)&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, {});
        var e2 = _jsPlumb.addEndpoint(d2, {});
        var returnedParams = null;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            returnedParams = jsPlumb.extend({}, params);
        });
        var conn = _jsPlumb.connect({sourceEndpoint: e1, targetEndpoint: e2});
        e1.detach({connection:conn});
        ok(returnedParams != null, &quot;removed connection listener event was fired&quot;);
    });

    test(&#x27;: detach event listeners (via Endpoint.detachFrom method)&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, {});
        var e2 = _jsPlumb.addEndpoint(d2, {});
        var returnedParams = null;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            returnedParams = jsPlumb.extend({}, params);
        });
        _jsPlumb.connect({sourceEndpoint: e1, targetEndpoint: e2});
        e1.detachFrom(e2);
        ok(returnedParams != null, &quot;removed connection listener event was fired&quot;);
    });

    test(&#x27;: detach event listeners (via Endpoint.detachAll method)&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, {});
        var e2 = _jsPlumb.addEndpoint(d2, {});
        var returnedParams = null;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            returnedParams = jsPlumb.extend({}, params);
        });
        _jsPlumb.connect({sourceEndpoint: e1, targetEndpoint: e2});
        e1.detachAll();
        ok(returnedParams != null, &quot;removed connection listener event was fired&quot;);
    });

    test(&#x27;: detach event listeners (via _jsPlumb.deleteEndpoint method)&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, {});
        var e2 = _jsPlumb.addEndpoint(d2, {});
        var returnedParams = null;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            returnedParams = jsPlumb.extend({}, params);
        });
        _jsPlumb.connect({sourceEndpoint: e1, targetEndpoint: e2});
        _jsPlumb.deleteEndpoint(e1);
        ok(returnedParams != null, &quot;removed connection listener event was fired&quot;);
    });

    test(&#x27;: detach event listeners (ensure cleared by _jsPlumb.reset)&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var returnedParams = null;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            returnedParams = jsPlumb.extend({}, params);
        });
        var conn = _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.detach({source: d1, target: d2, fireEvent: true});
        ok(returnedParams != null, &quot;removed connection listener event was fired&quot;);
        returnedParams = null;

        _jsPlumb.reset();
        var conn = _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.detach({source: d1, target: d2, fireEvent: true});
        ok(returnedParams == null, &quot;connection listener was cleared by _jsPlumb.reset()&quot;);
        equal(_jsPlumb.select({source: d1}).length, 0, &quot;no connections from d1 after detach with two connections as arguments&quot;);
    });

    test(&#x27;: connection events that throw errors&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var returnedParams = null, returnedParams2 = null;
        _jsPlumb.bind(&quot;connection&quot;, function (params) {
            returnedParams = jsPlumb.extend({}, params);
            throw &quot;oh no!&quot;;
        });
        _jsPlumb.connect({source: d1, target: d2});
        var d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        _jsPlumb.connect({source: d3, target: d4});
        ok(returnedParams != null, &quot;new connection listener event was fired; we threw an error, _jsPlumb survived.&quot;);
    });

    test(&#x27;: unbinding connection event listeners, connection&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var count = 0;
        _jsPlumb.bind(&quot;connection&quot;, function (params) {
            count++;
        });
        var c = _jsPlumb.connect({source: d1, target: d2});
        ok(count == 1, &quot;received one event&quot;);
        _jsPlumb.unbind(&quot;connection&quot;);
        var c2 = _jsPlumb.connect({source: d1, target: d2});
        ok(count == 1, &quot;still received only one event&quot;);

        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            count--;
        });
        _jsPlumb.detach(c);
        ok(count == 0, &quot;count of events is now zero&quot;);
    });

    test(&#x27;: unbinding connection event listeners, detach&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var count = 0;
        _jsPlumb.bind(&quot;connection&quot;, function (params) {
            count++;
        });
        var c = _jsPlumb.connect({source: d1, target: d2});
        ok(count == 1, &quot;received one event&quot;);
        var c2 = _jsPlumb.connect({source: d1, target: d2});
        ok(count == 2, &quot;received two events&quot;);

        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            count--;
        });
        _jsPlumb.detach(c);
        ok(count == 1, &quot;count of events is now one&quot;);
        _jsPlumb.unbind(&quot;connectionDetached&quot;);
        _jsPlumb.detach(c2);
        ok(count == 1, &quot;count of events is still one&quot;);
    });

    test(&#x27;: unbinding connection event listeners, all listeners&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var count = 0;
        _jsPlumb.bind(&quot;connection&quot;, function (params) {
            count++;
        });
        var c = _jsPlumb.connect({source: d1, target: d2}),
            c2 = _jsPlumb.connect({source: d1, target: d2}),
            c3 = _jsPlumb.connect({source: d1, target: d2});

        ok(count == 3, &quot;received three events&quot;);

        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            count--;
        });
        _jsPlumb.detach(c);
        ok(count == 2, &quot;count of events is now two&quot;);

        _jsPlumb.unbind();  // unbind everything

        _jsPlumb.detach(c2);
        _jsPlumb.detach(c3);
        _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.connect({source: d1, target: d2});

        ok(count == 2, &quot;count of events is still two&quot;);
    });

    test(&quot;: Endpoint.detachFrom&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true});
        ok(e16.anchor, &#x27;endpoint 16 has an anchor&#x27;);
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true});
        var conn = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        assertConnectionCount(e16, 1);
        assertConnectionCount(e17, 1);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        e16.detachFrom(e17);
        // but the connection should be gone, meaning not registered by _jsPlumb and not registered on either Endpoint:
        assertConnectionCount(e16, 0);
        assertConnectionCount(e17, 0);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 0, _jsPlumb);
    });

    test(&quot;: Endpoint.detachFromConnection&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true});
        ok(e16.anchor, &#x27;endpoint 16 has an anchor&#x27;);
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true});
        var conn = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        assertConnectionCount(e16, 1);
        assertConnectionCount(e17, 1);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        e16.detachFromConnection(conn);
        // but endpoint e16 should have no connections now.
        assertConnectionCount(e16, 0);
        assertConnectionCount(e17, 1);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
    });

    test(&quot;: Endpoint.detachAll&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);
        var e16 = _jsPlumb.addEndpoint(&quot;d16&quot;, {isSource: true, maxConnections: -1});
        ok(e16.anchor, &#x27;endpoint 16 has an anchor&#x27;);
        var e17 = _jsPlumb.addEndpoint(&quot;d17&quot;, {isSource: true});
        var e18 = _jsPlumb.addEndpoint(&quot;d18&quot;, {isSource: true});
        _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e18});
        assertConnectionCount(e16, 2);
        assertConnectionCount(e17, 1);
        assertConnectionCount(e18, 1);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 2, _jsPlumb);
        e16.detachAll();
        assertConnectionCount(e16, 0);
        assertConnectionCount(e17, 0);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 0, _jsPlumb);
    });

    test(&quot;: Endpoint.detach&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true});
        ok(e16.anchor, &#x27;endpoint 16 has an anchor&#x27;);
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true});
        var conn = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        assertConnectionCount(e16, 1);
        assertConnectionCount(e17, 1);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        e16.detach({connection:conn});
        // but the connection should be gone, meaning not registered by _jsPlumb and not registered on either Endpoint:
        assertConnectionCount(e16, 0);
        assertConnectionCount(e17, 0);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 0, _jsPlumb);
    });

    test(&quot;Image Endpoint remove&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        _jsPlumb.makeSource(d1, {
            endpoint:[ &quot;Image&quot;, { src:&quot;atom.png&quot; }]
        });

        _jsPlumb.makeTarget(d2, {
            endpoint:[ &quot;Image&quot;, { src:&quot;atom.png&quot; }]
        });

        var c = _jsPlumb.connect({source:d1, target:d2});
        var ep = c.endpoints[0];

        ok(ep.canvas.parentNode != null, &quot;endpoint 1 is in the DOM&quot;);

        _jsPlumb.detach(c);
        ok(ep.canvas.parentNode == null, &quot;endpoint 1 is no longer in the DOM&quot;);
    });

    // Some race condition causes this to fail randomly.
    // asyncTest(&quot; jsPlumbUtil.setImage on Endpoint, with supplied onload&quot;, function() {
    // var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
    // e = {
    // endpoint:[ &quot;Image&quot;, {
    // src:&quot;../demo/home/endpointTest1.png&quot;,
    // onload:function(imgEp) {
    // _jsPlumb.repaint(&quot;d1&quot;);
    // ok(imgEp._jsPlumb.img.src.indexOf(&quot;endpointTest1.png&quot;) != -1, &quot;image source is correct&quot;);
    // ok(imgEp._jsPlumb.img.src.indexOf(&quot;endpointTest1.png&quot;) != -1, &quot;image elementsource is correct&quot;);

    // imgEp.canvas.setAttribute(&quot;id&quot;, &quot;iwilllookforthis&quot;);

     //_jsPlumb.removeAllEndpoints(&quot;d1&quot;);
    // ok(document.getElementById(&quot;iwilllookforthis&quot;) == null, &quot;image element was removed after remove endpoint&quot;);
    // }
    // } ]
    // };
    // start();
    // _jsPlumb.addEndpoint(d1, e);
    // expect(3);
    // });

    test(&quot;: setting endpoint uuid&quot;, function () {
        var uuid = &quot;14785937583175927504313&quot;;
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, maxConnections: -1, uuid: uuid});
        equal(e16.getUuid(), uuid, &quot;endpoint&#x27;s uuid was set correctly&quot;);
    });

    test(&quot;: _jsPlumb.getEndpoint (by uuid)&quot;, function () {
        var uuid = &quot;14785937583175927504313&quot;;
        var d16 = _addDiv(&quot;d16&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, maxConnections: -1, uuid: uuid});
        var e = _jsPlumb.getEndpoint(uuid);
        equal(e.getUuid(), uuid, &quot;retrieved endpoint by uuid&quot;);
    });

    test(&quot;: _jsPlumb.deleteEndpoint (by uuid, simple case)&quot;, function () {
        var uuid = &quot;14785937583175927504313&quot;;
        var d16 = _addDiv(&quot;d16&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, maxConnections: -1, uuid: uuid});
        var e = _jsPlumb.getEndpoint(uuid);
        equal(e.getUuid(), uuid, &quot;retrieved endpoint by uuid&quot;);
        _jsPlumb.deleteEndpoint(uuid);
        var f = _jsPlumb.getEndpoint(uuid);
        equal(f, null, &quot;endpoint has been deleted&quot;);
        var ebe = _jsPlumb.getEndpoints(&quot;d16&quot;);
        ok(ebe == null, &quot;no endpoints registered for element d16 anymore&quot;);
    });


    test(&quot;: deleteEndpoint (by uuid, connections too)&quot;, function () {
        // create two endpoints (one with a uuid), add them to two divs and then connect them.
        var uuid = &quot;14785937583175927504313&quot;;
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, maxConnections: -1, uuid: uuid});
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true, maxConnections: -1});
        _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        // check that the connection was ok.
        equal(e16.connections.length, 1, &quot;e16 has one connection&quot;);
        equal(e17.connections.length, 1, &quot;e17 has one connection&quot;);

        // delete the endpoint that has a uuid.  verify that the endpoint cannot be retrieved and that the connection has been removed, but that
        // element d17 still has its Endpoint.
        _jsPlumb.deleteEndpoint(uuid);
        var f = _jsPlumb.getEndpoint(uuid);
        equal(f, null, &quot;endpoint has been deleted&quot;);
        equal(e16.connections.length, 0, &quot;e16 has no connections&quot;);
        equal(e17.connections.length, 0, &quot;e17 has no connections&quot;);
        var ebe = _jsPlumb.getEndpoints(&quot;d16&quot;);
        ok(ebe == null, &quot;no endpoints registered for element d16 anymore&quot;);
        ebe = _jsPlumb.getEndpoints(&quot;d17&quot;);
        equal(ebe.length, 1, &quot;element d17 still has its Endpoint&quot;);

        // now delete d17&#x27;s endpoint and check that it has gone.
        _jsPlumb.deleteEndpoint(e17);
        f = _jsPlumb.getEndpoint(e17);
        equal(f, null, &quot;endpoint has been deleted&quot;);
        ebe = _jsPlumb.getEndpoints(&quot;d17&quot;);
        ok(ebe == null, &quot;element d17 no longer has any Endpoints&quot;);
    });

    test(&quot;: deleteEndpoint (by reference, simple case)&quot;, function () {
        var uuid = &quot;14785937583175927504313&quot;;
        var d16 = _addDiv(&quot;d16&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, maxConnections: -1, uuid: uuid});
        var e = _jsPlumb.getEndpoint(uuid);
        equal(e.getUuid(), uuid, &quot;retrieved endpoint by uuid&quot;);
        _jsPlumb.deleteEndpoint(e16);
        var f = _jsPlumb.getEndpoint(uuid);
        equal(f, null, &quot;endpoint has been deleted&quot;);
    });

    test(&quot;: _jsPlumb.deleteEndpoint (by reference, connections too)&quot;, function () {
        var uuid = &quot;14785937583175927504313&quot;;
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, maxConnections: -1, uuid: uuid});
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true, maxConnections: -1});
        _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        equal(e16.connections.length, 1, &quot;e16 has one connection&quot;);
        equal(e17.connections.length, 1, &quot;e17 has one connection&quot;);

        _jsPlumb.deleteEndpoint(e16);
        var f = _jsPlumb.getEndpoint(uuid);
        equal(f, null, &quot;endpoint has been deleted&quot;);
        equal(e16.connections.length, 0, &quot;e16 has no connections&quot;);
        equal(e17.connections.length, 0, &quot;e17 has no connections&quot;);
    });

    test(&quot;: _jsPlumb.deleteEveryEndpoint&quot;, function () {
        var uuid = &quot;14785937583175927504313&quot;;
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, maxConnections: -1, uuid: uuid});
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true, maxConnections: -1});
        var e = _jsPlumb.getEndpoint(uuid);
        equal(e.getUuid(), uuid, &quot;retrieved endpoint by uuid&quot;);

        _jsPlumb.deleteEveryEndpoint();

        var f = _jsPlumb.getEndpoint(uuid);
        equal(f, null, &quot;endpoint e16 has been deleted&quot;);
        var g = _jsPlumb.getEndpoint(e17);
        equal(g, null, &quot;endpoint e17 has been deleted&quot;);
    });

    test(&quot;: _jsPlumb.deleteEveryEndpoint (connections too)&quot;, function () {
        var uuid = &quot;14785937583175927504313&quot;;
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, maxConnections: -1, uuid: uuid});
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true, maxConnections: -1});
        _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        var e = _jsPlumb.getEndpoint(uuid);
        equal(e.getUuid(), uuid, &quot;retrieved endpoint by uuid&quot;);

        _jsPlumb.deleteEveryEndpoint();

        var f = _jsPlumb.getEndpoint(uuid);
        equal(f, null, &quot;endpoint e16 has been deleted&quot;);
        var g = _jsPlumb.getEndpoint(e17);
        equal(g, null, &quot;endpoint e17 has been deleted&quot;);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 0, _jsPlumb);
    });

    test(&quot;: removeAllEndpoints, referenced as string&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;);
        _jsPlumb.addEndpoint(d1);
        _jsPlumb.addEndpoint(d1);
        _jsPlumb.addEndpoint(d1);

        _jsPlumb.removeAllEndpoints(&quot;d1&quot;);
        _jsPlumb.repaintEverything();

        _jsPlumb.addEndpoint(d1);
        equal(_jsPlumb.getEndpoints(&quot;d1&quot;).length, 1, &quot;one endpoint for the given element&quot;);

        expect(1);
    });

    test(&quot;: removeAllEndpoints, referenced as selector&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;);
        _jsPlumb.addEndpoint(d1);
        _jsPlumb.addEndpoint(d1);
        _jsPlumb.addEndpoint(d1);

        _jsPlumb.removeAllEndpoints(d1);

        _jsPlumb.repaintEverything();

        _jsPlumb.addEndpoint(d1);
        equal(_jsPlumb.getEndpoints(&quot;d1&quot;).length, 1, &quot;one endpoint for the given element&quot;);

        expect(1);
    });

    //
    //test(&quot;: removeAllEndpoints - element already deleted&quot;, function() {
    //var d1 = _addDiv(&quot;d1&quot;);
    // _jsPlumb.addEndpoint(d1);
    // _jsPlumb.addEndpoint(d1);
    // _jsPlumb.addEndpoint(d1);

    // d1.remove();
    // _jsPlumb.removeAllEndpoints(&quot;d1&quot;);
    // _jsPlumb.repaintEverything();

     //expect(0);
    // });

    test(&quot;: jsPlumb.remove, element identified by string&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;);
        var e1 = _jsPlumb.addEndpoint(d1);

        _jsPlumb.remove(&quot;d1&quot;);

        _jsPlumb.repaintEverything(); // shouldn&#x27;t complain

        ok(_jsPlumb.getEndpoints(&quot;d1&quot;) == null, &quot;no endpoints for the given element&quot;);
        ok(e1.canvas.parentNode == null, &quot;e1 cleaned up&quot;);
    });

    test(&quot;: jsPlumb.remove, element identified by selector&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;);
        var e1 = _jsPlumb.addEndpoint(d1);
        _jsPlumb.addEndpoint(d1);
        _jsPlumb.addEndpoint(d1);

        _jsPlumb.remove(d1);

        _jsPlumb.repaintEverything(); // shouldn&#x27;t complain

        ok(_jsPlumb.getEndpoints(&quot;d1&quot;) == null, &quot;no endpoints for the given element&quot;);
        ok(e1.canvas.parentNode == null, &quot;e1 cleaned up&quot;);
    });

    test(&quot;: jsPlumb.remove, element identified by string, nested endpoints&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        d1.appendChild(d2);
        d1.appendChild(d3);
        _jsPlumb.addEndpoint(d1);
        _jsPlumb.addEndpoint(d2);
        _jsPlumb.addEndpoint(d2);
        _jsPlumb.addEndpoint(d3);

        ok(_jsPlumb.getEndpoints(&quot;d1&quot;).length == 1, &quot; 1 endpoint exists for the parent div&quot;);
        ok(_jsPlumb.getEndpoints(&quot;d2&quot;).length == 2, &quot; 2 endpoints exist for the first nested div&quot;);
        ok(_jsPlumb.getEndpoints(&quot;d3&quot;).length == 1, &quot; 1 endpoint exists for the first nested div&quot;);

        _jsPlumb.remove(&quot;d1&quot;);

        _jsPlumb.repaintEverything(); // shouldn&#x27;t complain

        ok(_jsPlumb.getEndpoints(&quot;d1&quot;) == null, &quot;no endpoints for the main div&quot;);
        ok(_jsPlumb.getEndpoints(&quot;d2&quot;) == null, &quot;no endpoints for the nested div&quot;);
        ok(_jsPlumb.getEndpoints(&quot;d3&quot;) == null, &quot;no endpoints for the nested div&quot;);

    });

    test(&quot;: jsPlumb.remove, nested element, element identified by string, nested endpoints&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        d1.appendChild(d2);
        _jsPlumb.addEndpoint(d2);
        _jsPlumb.addEndpoint(d2);
        _jsPlumb.addEndpoint(d2);

        _jsPlumb.remove(&quot;d2&quot;);

        _jsPlumb.repaint(&quot;d1&quot;); // shouldn&#x27;t complain
        _jsPlumb.recalculateOffsets(&quot;d1&quot;);

        ok(_jsPlumb.getEndpoints(&quot;d1&quot;) == null, &quot;no endpoints for the main div&quot;);
        ok(_jsPlumb.getEndpoints(&quot;d2&quot;) == null, &quot;no endpoints for the nested div&quot;);

        expect(2);
    });

    test(&quot;jsPlumb.remove fires connectionDetached events&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);

        _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.connect({source: d1, target: d3});

        var o = 0;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function () {
            o++;
        });

        _jsPlumb.remove(d1);
        equal(o, 2, &quot;connectionDetached event was fired twice.&quot;);

    });

    test(&quot;jsPlumb.removeAllEndpoints fires connectionDetached events&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);

        _jsPlumb.connect({source: d1, target: d2});
        _jsPlumb.connect({source: d1, target: d3});

        var o = 0;
        _jsPlumb.bind(&quot;connectionDetached&quot;, function () {
            o++;
        });

        _jsPlumb.removeAllEndpoints(d1);
        equal(o, 2, &quot;connectionDetached event was fired twice.&quot;);

    });

    test(&quot;: jsPlumb.empty, element identified by string&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        d1.appendChild(d2);
        d1.appendChild(d3);
        _jsPlumb.addEndpoint(d1);
        _jsPlumb.addEndpoint(d2);
        _jsPlumb.addEndpoint(d2);
        _jsPlumb.addEndpoint(d3);

        ok(_jsPlumb.getEndpoints(&quot;d1&quot;).length == 1, &quot; 1 endpoint exists for the parent div&quot;);
        ok(_jsPlumb.getEndpoints(&quot;d2&quot;).length == 2, &quot; 2 endpoints exist for the first nested div&quot;);
        ok(_jsPlumb.getEndpoints(&quot;d3&quot;).length == 1, &quot; 1 endpoint exists for the first nested div&quot;);

        _jsPlumb.empty(&quot;d1&quot;);

        _jsPlumb.repaintEverything(); // shouldn&#x27;t complain

        ok(_jsPlumb.getEndpoints(&quot;d1&quot;).length == 1, &quot; 1 endpoint exists for the parent div&quot;);
        ok(_jsPlumb.getEndpoints(&quot;d2&quot;) == null, &quot;no endpoints for the first nested div&quot;);
        ok(_jsPlumb.getEndpoints(&quot;d3&quot;) == null, &quot;no endpoints for the second nested div&quot;);

    });

    //
     //I&#x27;m on the fence about this one.  There is a method you can call to tell jsPlumb that an element
     //has been deleted, so in theory you should not get into a situation where you are doing what this
     //test does.  But you can of course get there accidentally, which is one reason why it would be good
     //for this test to exist.
     //test(&quot;: deleting endpoints of deleted element should not fail&quot;, function() {
     //var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
     //var ep1 = _jsPlumb.addEndpoint(d1);
     //_jsPlumb.addEndpoint(d1);
     //_jsPlumb.addEndpoint(d1);
     //_jsPlumb.connect({source:ep1, target:&quot;d2&quot;});
     //d1.remove();
     //var eps = _jsPlumb.getEndpoints(d1);
     //equal(eps.length, 3, &quot;there are three endpoints for d1&quot;);
     //for (var i = 0; i &lt; eps.length; i++) {
     //_jsPlumb.deleteEndpoint(eps[i]);
     //}
     //eps = _jsPlumb.getEndpoints(&quot;d1&quot;);
     //equal(eps, null, &quot;there are zero endpoints for d1&quot;);
     //equal(_jsPlumb.getEndpoints(&quot;d1&quot;).length, 0, &quot;no endpoints for the given element&quot;);
     //});



    test(&quot;: _jsPlumb.addEndpoint (simple case)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {anchor: [0, 0.5, 0, -1]});
        var e17 = _jsPlumb.addEndpoint(d17, {anchor: &quot;TopCenter&quot;});
        equal(e16.anchor.x, 0);
        equal(e16.anchor.y, 0.5);
        equal(e17.anchor.x, 0.5);
        equal(e17.anchor.y, 0);
    });


    test(&quot;: _jsPlumb.addEndpoint (simple case, dynamic anchors)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {anchor: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        var e17 = _jsPlumb.addEndpoint(d17, {anchor: [&quot;TopCenter&quot;, &quot;BottomCenter&quot;]});
        equal(e16.anchor.isDynamic, true, &quot;Endpoint 16 has a dynamic anchor&quot;);
        equal(e17.anchor.isDynamic, true, &quot;Endpoint 17 has a dynamic anchor&quot;);
    });

    test(&quot;: _jsPlumb.addEndpoint (simple case, two arg method)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false}, {anchor: [0, 0.5, 0, -1]});
        var e17 = _jsPlumb.addEndpoint(d17, {isTarget: true, isSource: false}, {anchor: &quot;TopCenter&quot;});
        equal(e16.anchor.x, 0);
        equal(e16.anchor.y, 0.5);
        equal(false, e16.isTarget);
        equal(true, e16.isSource);
        equal(e17.anchor.x, 0.5);
        equal(e17.anchor.y, 0);
        equal(true, e17.isTarget);
        equal(false, e17.isSource);
    });


    test(&quot;: _jsPlumb.addEndpoints (simple case)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoints(d16, [
            {isSource: true, isTarget: false, anchor: [0, 0.5, 0, -1] },
            { isTarget: true, isSource: false, anchor: &quot;TopCenter&quot; }
        ]);
        equal(e16[0].anchor.x, 0);
        equal(e16[0].anchor.y, 0.5);
        equal(false, e16[0].isTarget);
        equal(true, e16[0].isSource);
        equal(e16[1].anchor.x, 0.5);
        equal(e16[1].anchor.y, 0);
        equal(true, e16[1].isTarget);
        equal(false, e16[1].isSource);
    });


    test(&quot;: _jsPlumb.addEndpoint (empty array)&quot;, function () {
        _jsPlumb.addEndpoint([], {isSource: true});
        _jsPlumb.repaintEverything();
        expect(0);
    });

    test(&quot;: _jsPlumb.addEndpoints (with reference params)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var refParams = {anchor: &quot;RightMiddle&quot;};
        var e16 = _jsPlumb.addEndpoints(d16, [
            {isSource: true, isTarget: false},
            { isTarget: true, isSource: false }
        ], refParams);
        equal(e16[0].anchor.x, 1);
        equal(e16[0].anchor.y, 0.5);
        equal(false, e16[0].isTarget);
        equal(true, e16[0].isSource);
        equal(e16[1].anchor.x, 1);
        equal(e16[1].anchor.y, 0.5);
        equal(true, e16[1].isTarget);
        equal(false, e16[1].isSource);
    });

    test(&quot;: _jsPlumb.addEndpoint (simple case, dynamic anchors, two arg method)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false}, {anchor: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        var e17 = _jsPlumb.addEndpoint(d17, {isTarget: true, isSource: false}, {anchor: [&quot;TopCenter&quot;, &quot;BottomCenter&quot;]});
        equal(e16.anchor.isDynamic, true, &quot;Endpoint 16 has a dynamic anchor&quot;);
        equal(e17.anchor.isDynamic, true, &quot;Endpoint 17 has a dynamic anchor&quot;);
    });

    test(&quot;: _jsPlumb.addEndpoints (default overlays)&quot;, function () {
        _jsPlumb.Defaults.Overlays = [
            [ &quot;Label&quot;, { id: &quot;label&quot; } ]
        ];
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;),
            e1 = _jsPlumb.addEndpoint(d16),
            e2 = _jsPlumb.addEndpoint(d17);

        ok(e1.getOverlay(&quot;label&quot;) != null, &quot;endpoint 1 has overlay from defaults&quot;);
    });



    test(&quot;: _jsPlumb.addEndpoints (default overlays)&quot;, function () {
        _jsPlumb.Defaults.Overlays = [
            [ &quot;Label&quot;, { id: &quot;label&quot; } ]
        ];
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;),
            e1 = _jsPlumb.addEndpoint(d16, {
                overlays: [
                    [&quot;Label&quot;, { id: &quot;label2&quot;, location: [ 0.5, 1 ] } ]
                ]
            }),
            e2 = _jsPlumb.addEndpoint(d17);

        ok(e1.getOverlay(&quot;label&quot;) != null, &quot;endpoint 1 has overlay from defaults&quot;);
        ok(e1.getOverlay(&quot;label2&quot;) != null, &quot;endpoint 1 has overlay from addEndpoint call&quot;);
    });

    test(&quot;: _jsPlumb.addEndpoints (end point set label)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;),
            e1 = _jsPlumb.addEndpoint(d16),
            e2 = _jsPlumb.addEndpoint(d17);

        e1.setLabel(&quot;FOO&quot;);
        equal(e1.getLabel(), &quot;FOO&quot;, &quot;endpoint&#x27;s label is correct&quot;);
    });

    test(&quot;: _jsPlumb.addEndpoints (end point set label in constructor, as string)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;),
            e1 = _jsPlumb.addEndpoint(d16, {label: &quot;FOO&quot;}),
            e2 = _jsPlumb.addEndpoint(d17);

        equal(e1.getLabel(), &quot;FOO&quot;, &quot;endpoint&#x27;s label is correct&quot;);
    });



    test(&quot;: _jsPlumb.addEndpoints (end point set label in constructor, as function)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;),
            e1 = _jsPlumb.addEndpoint(d16, {label: function () {
                return &quot;BAZ&quot;;
            }, labelLocation: 0.1}),
            e2 = _jsPlumb.addEndpoint(d17);

        equal(e1.getLabel()(), &quot;BAZ&quot;, &quot;endpoint&#x27;s label is correct&quot;);
        equal(e1.getLabelOverlay().getLocation(), 0.1, &quot;endpoint&#x27;s label&#x27;s location is correct&quot;);
    });

    test(&quot;: jsPlumb.addEndpoint (events)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;),
            click = 0,
            e16 = _jsPlumb.addEndpoint(d16, {
                isSource: true,
                isTarget: false,
                anchor: [0, 0.5, 0, -1],
                events: {
                    click: function (ep) {
                        click++;
                    }
                }
            });
        e16.fire(&quot;click&quot;, function () {
            click++;
        });
        equal(click, 1, &quot;click event was fired once&quot;);
    });


// ***************** setConnector ************************************************************



    test(&quot;: setConnector, check the connector is set&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var def = {
            Connector: [ &quot;Bezier&quot;, { curviness: 45 } ]
        };
        var j = jsPlumb.getInstance(def);
        var c = j.connect({source: &quot;d1&quot;, target: &quot;d2&quot;});
        equal(c.getConnector().type, &quot;Bezier&quot;, &quot;connector is the default&quot;);
        c.setConnector([&quot;Bezier&quot;, { curviness: 789 }]);
        equal(def.Connector[1].curviness, 45, &quot;curviness unchanged by setConnector call&quot;);
        j.unbindContainer();
    });

    test(&quot;: setConnector, overlays are retained&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var def = {
            Connector: [ &quot;Bezier&quot;, { curviness: 45 } ]
        };
        var j = jsPlumb.getInstance(def);
        var c = j.connect({
            source: &quot;d1&quot;, target: &quot;d2&quot;,
            overlays:[
                [ &quot;Label&quot;, { label:&quot;foo&quot; } ]
            ]
        });
        equal(c.getConnector().type, &quot;Bezier&quot;, &quot;connector is the default&quot;);
        equal(_length(c.getOverlays()), 1, &quot;one overlay on the connector&quot;);

        c.setConnector([&quot;StateMachine&quot;, { curviness: 789 }]);
        equal(def.Connector[1].curviness, 45, &quot;curviness unchanged by setConnector call&quot;);
        equal(_length(c.getOverlays()), 1, &quot;one overlay on the connector&quot;);
        j.unbindContainer();
    });




// ******************  makeTarget (and associated methods) tests ********************************************	

    test(&quot;: _jsPlumb.makeTarget (simple case)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeTarget(d17, { isTarget: true, anchor: &quot;TopCenter&quot;  });
        equal(true, jsPlumb.hasClass(d17, support.droppableClass));
    });

    test(&quot;: _jsPlumb.makeTarget (specify two divs in an array)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        _jsPlumb.makeTarget([d16, d17], { isTarget: true, anchor: &quot;TopCenter&quot;  });
        equal(true, jsPlumb.hasClass(d16, support.droppableClass));
        equal(true, jsPlumb.hasClass(d17, support.droppableClass));
    });

    test(&quot;: _jsPlumb.makeTarget (specify two divs by id in an array)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        _jsPlumb.makeTarget([&quot;d16&quot;, &quot;d17&quot;], { isTarget: true, anchor: &quot;TopCenter&quot;  });
        equal(true, jsPlumb.hasClass(d16, support.droppableClass));
        equal(true, jsPlumb.hasClass(d17, support.droppableClass));
    });

    test(&quot;: _jsPlumb.makeTarget (specify divs by selector)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        jsPlumb.addClass(d16, &quot;FOO&quot;);
        jsPlumb.addClass(d17, &quot;FOO&quot;);
        _jsPlumb.makeTarget(jsPlumb.getSelector(&quot;.FOO&quot;), { isTarget: true, anchor: &quot;TopCenter&quot;  });
        equal(true, jsPlumb.hasClass(d16, support.droppableClass));
        equal(true, jsPlumb.hasClass(d17, support.droppableClass));
    });

    test(&quot;: _jsPlumb.connect after makeTarget (simple case)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeTarget(d17, { isTarget: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        equal(true, jsPlumb.hasClass(d17, support.droppableClass));
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
        var e = _jsPlumb.getEndpoints(&quot;d17&quot;);
        equal(e.length, 1, &quot;d17 has one endpoint&quot;);
        equal(e[0].anchor.x, 0, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
        equal(e[0].anchor.y, 0.5, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
    });

    test(&quot;: _jsPlumb.connect after makeTarget (simple case, two connect calls)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false, maxConnections: -1}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeTarget(d17, { isTarget: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        equal(true, jsPlumb.hasClass(d17, support.droppableClass));
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 2, _jsPlumb);
        var e = _jsPlumb.getEndpoints(&quot;d17&quot;);
        equal(e[0].anchor.x, 0, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
        equal(e[0].anchor.y, 0.5, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
    });

    test(&quot;: _jsPlumb.connect after makeTarget (simple case, two connect calls, uniqueEndpoint set)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false, maxConnections: -1}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeTarget(d17, { isTarget: true, anchor: &quot;LeftMiddle&quot;, uniqueEndpoint: true, maxConnections: -1  }); // give it a non-default anchor, we will check this below.
        equal(true, jsPlumb.hasClass(d17, support.droppableClass));
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
        var e = _jsPlumb.getEndpoints(&quot;d17&quot;);
        equal(e[0].anchor.x, 0, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
        equal(e[0].anchor.y, 0.5, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
        equal(e[0].connections.length, 2, &quot;endpoint on d17 has two connections&quot;);
    });

    test(&quot;: _jsPlumb.connect after makeTarget (newConnection:true specified)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeTarget(d17, { isTarget: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        equal(true, jsPlumb.hasClass(d17, support.droppableClass));
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;, newConnection: true});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
        var e = _jsPlumb.getEndpoints(&quot;d17&quot;);
        equal(e[0].anchor.x, 0.5, &quot;anchor is BottomCenter&quot;); //here we should be seeing the default anchor
        equal(e[0].anchor.y, 1, &quot;anchor is BottomCenter&quot;); //here we should be seeing the default anchor
    });

// jsPlumb.connect, after makeSource has been called on some element
    test(&quot;: _jsPlumb.connect after makeSource (simple case)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: false, isTarget: true}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeSource(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
        var e = _jsPlumb.getEndpoints(&quot;d17&quot;);
        equal(e[0].anchor.x, 0, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
        equal(e[0].anchor.y, 0.5, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
    });


    test(&quot;: _jsPlumb.connect after makeSource (simple case, two connect calls)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: false, isTarget: true, maxConnections: -1}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeSource(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.		
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 2, _jsPlumb);
        var e = _jsPlumb.getEndpoints(&quot;d17&quot;);
        equal(e[0].anchor.x, 0, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
        equal(e[0].anchor.y, 0.5, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
    });

    test(&quot;: endpoint source and target scope&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {scope: &quot;foo&quot;});
        var e18 = _jsPlumb.addEndpoint(d18, {scope: &quot;bar&quot;});
        var e17 = _jsPlumb.addEndpoint(d17, { scope: &quot;foo&quot; }); // give it a non-default anchor, we will check this below.

        var c = _jsPlumb.connect({source: e17, target: e16});
        ok(c != null, &quot;connection with matching scope established&quot;);

        c = _jsPlumb.connect({source: e17, target: e18});
        ok(c == null, &quot;connection with non-matching scope not established&quot;);
    });

    test(&quot;: endpoint source and target scope, multiple scope&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;), d19 = _addDiv(&quot;d19&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {scope: &quot;foo baz&quot;, maxConnections: -1});
        var e18 = _jsPlumb.addEndpoint(d18, {scope: &quot;bar&quot;});
        var e17 = _jsPlumb.addEndpoint(d17, { scope: &quot;baz&quot;, maxConnections: -1 }); // give it a non-default anchor, we will check this below.
        var e19 = _jsPlumb.addEndpoint(d17, { scope: &quot;foo&quot; }); // give it a non-default anchor, we will check this below.

        var c = _jsPlumb.connect({source: e17, target: e16});
        ok(c != null, &quot;connection with matching scope established&quot;);

        c = _jsPlumb.connect({source: e17, target: e18});
        ok(c == null, &quot;connection with non-matching scope not established&quot;);

        c = _jsPlumb.connect({source: e19, target: e16});
        ok(c != null, &quot;connection with second matching scope established&quot;);
    });

    test(&quot;: makeSource/makeTarget scope&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);
        _jsPlumb.makeTarget(d16, {scope: &quot;foo&quot;});
        _jsPlumb.makeTarget(d18, {scope: &quot;bar&quot;});
        _jsPlumb.makeSource(d17, { scope: &quot;foo&quot; }); // give it a non-default anchor, we will check this below.
        var c = _jsPlumb.connect({source: d17, target: d16});
        ok(c != null, &quot;connection with matching scope established&quot;);
        c = _jsPlumb.connect({source: d17, target: d18});
        ok(c == null, &quot;connection with non-matching scope not established&quot;);
    });

    test(&quot;: makeSource, manipulate scope programmatically&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);
        _jsPlumb.makeSource(d16, {scope: &quot;foo&quot;, isSource: true, maxConnections: -1});
        _jsPlumb.makeTarget(d17, {scope: &quot;bar&quot;, maxConnections: -1});
        _jsPlumb.makeTarget(d18, {scope: &quot;qux&quot;, maxConnections: -1});

        equal(_jsPlumb.getSourceScope(d16), &quot;foo&quot;, &quot;scope of makeSource element retrieved&quot;);
        equal(_jsPlumb.getTargetScope(d17), &quot;bar&quot;, &quot;scope of makeTarget element retrieved&quot;);

        var c = _jsPlumb.connect({source: d16, target: d17});
        ok(c == null, &quot;connection was established&quot;);

        // change scope of source, then try to connect, and it should fail.
        _jsPlumb.setSourceScope(d16, &quot;qux&quot;);
        c = _jsPlumb.connect({source: d16, target: d17});
        ok(c == null, &quot;connection was not established due to unmatched scopes&quot;);

        _jsPlumb.setTargetScope(d17, &quot;foo qux&quot;);
        equal(_jsPlumb.getTargetScope(d17), &quot;foo qux&quot;, &quot;scope of makeTarget element retrieved&quot;);
        c = _jsPlumb.connect({source: d16, target: d17});
        ok(c != null, &quot;connection was established now that scopes match&quot;);

        _jsPlumb.makeSource(d17);
        _jsPlumb.setScope(d17, &quot;BAZ&quot;);
        // use setScope method to set source _and_ target scope
        equal(_jsPlumb.getTargetScope(d17), &quot;BAZ&quot;, &quot;scope of target element retrieved&quot;);
        equal(_jsPlumb.getSourceScope(d17), &quot;BAZ&quot;, &quot;scope of source element retrieved&quot;);

        // getScope will give us what it can, defaulting to source scope.
        equal(_jsPlumb.getScope(d16), &quot;qux&quot;, &quot;source scope retrieved for d16&quot;);
        equal(_jsPlumb.getScope(d18), &quot;qux&quot;, &quot;target scope retrieved for d18&quot;);
        equal(_jsPlumb.getScope(d17), &quot;BAZ&quot;, &quot;source scope retrieved for d17, although target scope is set too&quot;);

    });


    test(&quot;: _jsPlumb.connect after makeSource (parameters)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: false, isTarget: true}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeSource(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;, parameters: { foo: &quot;bar&quot;}  }); // give it a non-default anchor, we will check this below.
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
        var e = _jsPlumb.getEndpoints(&quot;d17&quot;);
        equal(e[0].getParameter(&quot;foo&quot;), &quot;bar&quot;, &quot;parameter was set on endpoint made from makeSource call&quot;);
    });

    test(&quot;: _jsPlumb.connect after makeTarget (simple case, two connect calls, uniqueEndpoint set)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: false, isTarget: true, maxConnections: -1}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeSource(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;, uniqueEndpoint: true, maxConnections: -1  }); // give it a non-default anchor, we will check this below.		
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
        var e = _jsPlumb.getEndpoints(&quot;d17&quot;);
        equal(e[0].anchor.x, 0, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
        equal(e[0].anchor.y, 0.5, &quot;anchor is LeftMiddle&quot;); //here we should be seeing the anchor we setup via makeTarget
        equal(e[0].connections.length, 2, &quot;endpoint on d17 has two connections&quot;);
    });

    test(&quot;: _jsPlumb.connect after makeTarget (newConnection:true specified)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: false, isTarget: true}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeSource(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.		
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16, newConnection: true});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
        var e = _jsPlumb.getEndpoints(&quot;d17&quot;);
        equal(e[0].anchor.x, 0.5, &quot;anchor is BottomCenter&quot;); //here we should be seeing the default anchor
        equal(e[0].anchor.y, 1, &quot;anchor is BottomCenter&quot;); //here we should be seeing the default anchor
    });

    // makeSource, then disable it. should not be able to make a connection from it.
    test(&quot;: _jsPlumb.connect after makeSource and setSourceEnabled(false) (string id as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: false, isTarget: true}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeSource(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        _jsPlumb.setSourceEnabled(d17, false);
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 0, _jsPlumb);
    });

    // makeSource, then disable it. should not be able to make a connection from it.
    test(&quot;: _jsPlumb.connect after makeSource and setSourceEnabled(false) (selector as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: false, isTarget: true}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeSource(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        _jsPlumb.setSourceEnabled(jsPlumb.getSelector(&quot;div&quot;), false);
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 0, _jsPlumb);
    });

    // makeSource, then toggle its enabled state. should not be able to make a connection from it.
    test(&quot;: _jsPlumb.connect after makeSource and toggleSourceEnabled() (string id as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: false, isTarget: true}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeSource(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        _jsPlumb.toggleSourceEnabled(d17);
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 0, _jsPlumb);

        _jsPlumb.toggleSourceEnabled(d17);
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
    });

    // makeSource, then disable it. should not be able to make a connection from it.
    test(&quot;: _jsPlumb.connect after makeSource and toggleSourceEnabled() (selector as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: false, isTarget: true}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeSource(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        _jsPlumb.toggleSourceEnabled(jsPlumb.getSelector(&quot;#d17&quot;));
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 0, _jsPlumb);
        _jsPlumb.toggleSourceEnabled(jsPlumb.getSelector(&quot;#d17&quot;));
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
    });

    test(&quot;: jsPlumb.isSource and jsPlumb.isSourceEnabled&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: false, isTarget: true}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeSource(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        ok(_jsPlumb.isSource(d17) == true, &quot;d17 is recognised as connection source&quot;);
        ok(_jsPlumb.isSourceEnabled(d17) == true, &quot;d17 is recognised as enabled&quot;);
        _jsPlumb.setSourceEnabled(d17, false);
        ok(_jsPlumb.isSourceEnabled(d17) == false, &quot;d17 is recognised as disabled&quot;);
    });

    // makeSource, then disable it. should not be able to make a connection to it.
    test(&quot;: _jsPlumb.connect after makeTarget and setTargetEnabled(false) (string id as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeTarget(d17, { anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        var originallyEnabled = _jsPlumb.setTargetEnabled(&quot;d17&quot;, false);
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 0, _jsPlumb);


        // tests for css class for disabled target
        ok(_jsPlumb.hasClass(d17, &quot;jtk-target-disabled&quot;), &quot;disabled class added&quot;);

        ok(originallyEnabled, &quot;setTargetEnabled returned the original enabled value of true when setting to false&quot;);
        originallyEnabled = _jsPlumb.setTargetEnabled(&quot;d17&quot;, true);
        ok(!originallyEnabled, &quot;setTargetEnabled returned the previous enabled value of false when setting to true&quot;);

        ok(!_jsPlumb.hasClass(d17, &quot;jtk-target-disabled&quot;), &quot;disabled class removed&quot;);
    });

    // makeSource, then disable it. should not be able to make a connection to it.
    test(&quot;: _jsPlumb.connect after makeTarget and setTargetEnabled(false) (DOM element as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeTarget(d17, { anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        var originallyEnabled = _jsPlumb.setTargetEnabled(d17, false);
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 0, _jsPlumb);


        // tests for css class for disabled target
        ok(_jsPlumb.hasClass(d17, &quot;jtk-target-disabled&quot;), &quot;disabled class added&quot;);

        ok(originallyEnabled, &quot;setTargetEnabled returned the original enabled value of true when setting to false&quot;);
        originallyEnabled = _jsPlumb.setTargetEnabled(d17, true);
        ok(!originallyEnabled, &quot;setTargetEnabled returned the previous enabled value of false when setting to true&quot;);

        ok(!_jsPlumb.hasClass(d17, &quot;jtk-target-disabled&quot;), &quot;disabled class removed&quot;);
    });

    // makeTarget, then disable it. should not be able to make a connection to it.
    test(&quot;: _jsPlumb.connect after makeTarget and setTargetEnabled(false) (selector as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeTarget(d17, { anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        _jsPlumb.setTargetEnabled(jsPlumb.getSelector(&quot;div&quot;), false);
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 0, _jsPlumb);
    });

    // makeTarget, then toggle its enabled state. should not be able to make a connection to it.
    test(&quot;: _jsPlumb.connect after makeTarget and toggleTargetEnabled() (string id as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeTarget(d17, { anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        _jsPlumb.toggleTargetEnabled(d17);
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 0, _jsPlumb);

        _jsPlumb.toggleTargetEnabled(d17);
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
    });

    // makeTarget, then disable it. should not be able to make a connection to it.
    test(&quot;: _jsPlumb.connect after makeTarget and toggleTargetEnabled() (selector as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeTarget(d17, { anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        _jsPlumb.toggleTargetEnabled(jsPlumb.getSelector(&quot;div&quot;));
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 0, _jsPlumb);
        _jsPlumb.toggleTargetEnabled(jsPlumb.getSelector(&quot;div&quot;));
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
    });

    test(&quot;: jsPlumb.isTarget and jsPlumb.isTargetEnabled&quot;, function () {
        var d17 = _addDiv(&quot;d17&quot;);
        _jsPlumb.makeTarget(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        ok(_jsPlumb.isTarget(d17) == true, &quot;d17 is recognised as connection target&quot;);
        ok(_jsPlumb.isTargetEnabled(d17) == true, &quot;d17 is recognised as enabled&quot;);
        _jsPlumb.setTargetEnabled(d17, false);
        ok(_jsPlumb.isTargetEnabled(d17) == false, &quot;d17 is recognised as disabled&quot;);
    });

    test(&quot;: _jsPlumb.makeTarget - endpoints deleted by default.&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        _jsPlumb.makeSource(d16);
        _jsPlumb.makeTarget(d17);

        var c = _jsPlumb.connect({source: &quot;d16&quot;, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
        _jsPlumb.detach(c);
        assertEndpointCount(&quot;d16&quot;, 0, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 0, _jsPlumb);
    });

// setSource/setTarget methods.


    test(&quot;: _jsPlumb.setSource (element)&quot;, function () {

        var sc = false;
        _jsPlumb.bind(&quot;connectionMoved&quot;, function () {
            sc = true;
        });

        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);

        var c = _jsPlumb.connect({source: &quot;d16&quot;, target: d17, endpoint: &quot;Rectangle&quot;});
        equal(c.sourceId, &quot;d16&quot;);
        equal(c.targetId, &quot;d17&quot;);

        equal(c.endpoints[0].type, &quot;Rectangle&quot;, &quot;endpoint is type Rectangle&quot;);
        equal(c.endpoints[0].connections.length, 1, &quot;endpoint has one connection&quot;);

        _jsPlumb.setSource(c, d18);
        equal(c.sourceId, &quot;d18&quot;, &quot;source is now d18&quot;);
        equal(c.endpoints[0].type, &quot;Rectangle&quot;, &quot;endpoint is still type Rectangle&quot;);
        equal(c.endpoints[0].connections.length, 1, &quot;endpoint has one connection&quot;);

        equal(sc, true, &quot;connectionMoved event fired&quot;);

        // test we dont overwrite if the source is already the element
        c.endpoints[0].original = true;
        _jsPlumb.setSource(c, d18);
        equal(c.endpoints[0].original, true, &quot;redundant setSource call ignored&quot;);
    });

    test(&quot;: _jsPlumb.setSource (endpoint)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);
        var ep = _jsPlumb.addEndpoint(d18), ep2 = _jsPlumb.addEndpoint(d18);

        var c = _jsPlumb.connect({source: &quot;d16&quot;, target: d17});
        equal(c.sourceId, &quot;d16&quot;);
        equal(c.targetId, &quot;d17&quot;);

        _jsPlumb.setSource(c, ep);
        equal(c.sourceId, &quot;d18&quot;, &quot;source is now d18&quot;);

        // test that new endpoint is set (different from the case that an element or element id was given)
        c.endpoints[0].original = true;
        _jsPlumb.setSource(c, ep2);
        equal(c.endpoints[0].original, undefined, &quot;setSource with new endpoint honoured&quot;);

    });

    test(&quot;: _jsPlumb.setSource (element, with makeSource)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);
        _jsPlumb.makeSource(d18, {
            endpoint: &quot;Rectangle&quot;
        });

        var c = _jsPlumb.connect({source: &quot;d16&quot;, target: d17});
        equal(c.sourceId, &quot;d16&quot;);
        equal(c.targetId, &quot;d17&quot;);

        _jsPlumb.setSource(c, d18);
        equal(c.sourceId, &quot;d18&quot;, &quot;source is now d18&quot;);
        equal(c.endpoints[0].type, &quot;Rectangle&quot;, &quot;endpoint is type Rectangle&quot;);

        // test we dont overwrite if the source is already the element
        c.endpoints[0].original = true;
        _jsPlumb.setSource(c, d18);
        equal(c.endpoints[0].original, true, &quot;redundant setSource call ignored&quot;);
    });


    test(&quot;: _jsPlumb.setTarget (element)&quot;, function () {

        var sc = false;
        _jsPlumb.bind(&quot;connectionMoved&quot;, function () {
            sc = true;
        });

        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);

        var c = _jsPlumb.connect({source: &quot;d16&quot;, target: d17, endpoint: &quot;Rectangle&quot;});
        equal(c.sourceId, &quot;d16&quot;);
        equal(c.targetId, &quot;d17&quot;);

        equal(c.endpoints[1].type, &quot;Rectangle&quot;, &quot;endpoint is type Rectangle&quot;);

        _jsPlumb.setTarget(c, d18);
        equal(c.targetId, &quot;d18&quot;, &quot;source is now d18&quot;);
        equal(c.endpoints[1].type, &quot;Rectangle&quot;, &quot;endpoint is still type Rectangle&quot;);

        equal(sc, true, &quot;connectionMoved event fired&quot;);

        // test we dont overwrite if the target is already the element
        c.endpoints[1].original = true;
        _jsPlumb.setTarget(c, d18);
        equal(c.endpoints[1].original, true, &quot;redundant setTarget call ignored&quot;);
    });

    test(&quot;: _jsPlumb.setTarget (endpoint)&quot;, function () {
        var sc = false;
        _jsPlumb.bind(&quot;connectionMoved&quot;, function () {
            sc = true;
        });

        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);
        var ep = _jsPlumb.addEndpoint(d18), ep2 = _jsPlumb.addEndpoint(d18);

        var c = _jsPlumb.connect({source: &quot;d16&quot;, target: d17});
        equal(c.sourceId, &quot;d16&quot;);
        equal(c.targetId, &quot;d17&quot;);

        _jsPlumb.setTarget(c, ep);
        equal(c.targetId, &quot;d18&quot;, &quot;source is now d18&quot;);

        equal(sc, true, &quot;connectionMoved event fired&quot;);

        // test that new endpoint is set (different from the case that an element or element id was given)
        c.endpoints[1].original = true;
        _jsPlumb.setTarget(c, ep2);
        equal(c.endpoints[1].original, undefined, &quot;setTarget with new endpoint honoured&quot;);
    });

    test(&quot;: _jsPlumb.setTarget (element, with makeSource)&quot;, function () {
        var sc = false;
        _jsPlumb.bind(&quot;connectionMoved&quot;, function () {
            sc = true;
        });

        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);
        _jsPlumb.makeTarget(d18, {
            endpoint: &quot;Rectangle&quot;
        });

        var c = _jsPlumb.connect({source: &quot;d16&quot;, target: d17});
        equal(c.sourceId, &quot;d16&quot;);
        equal(c.targetId, &quot;d17&quot;);

        _jsPlumb.setTarget(c, d18);
        equal(c.targetId, &quot;d18&quot;, &quot;source is now d18&quot;);
        equal(c.endpoints[1].type, &quot;Rectangle&quot;, &quot;endpoint is type Rectangle&quot;);

        equal(sc, true, &quot;connectionMoved event fired&quot;);

        // test we dont overwrite if the target is already the element
        c.endpoints[1].original = true;
        _jsPlumb.setTarget(c, d18);
        equal(c.endpoints[1].original, true, &quot;redundant setTarget call ignored&quot;);
    });


// end setSource/setTarget methods.

    test(&quot;: _jsPlumb.makeSource (parameters)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;),
            params = { &quot;foo&quot;: &quot;foo&quot; },
            e16 = _jsPlumb.addEndpoint(&quot;d16&quot;, { parameters: params });

        _jsPlumb.makeSource(d17, {
            isSource: true,
            parameters: params
        });

        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
        var e = _jsPlumb.getEndpoints(&quot;d17&quot;);
        equal(e[0].getParameter(&quot;foo&quot;), &quot;foo&quot;, &quot;makeSource created endpoint has parameters&quot;);
        equal(e16.getParameter(&quot;foo&quot;), &quot;foo&quot;, &quot;normally created endpoint has parameters&quot;);
    });

    // makeSource, then unmake it. should not be able to make a connection from it. then connect to it, which should succeed,
    // because jsPlumb will just add a new endpoint.
    test(&quot;: jsPlumb.unmakeSource (string id as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: false, isTarget: true}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeSource(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        ok(_jsPlumb.isSource(d17) == true, &quot;d17 is currently a source&quot;);
        // unmake source
        _jsPlumb.unmakeSource(d17);
        ok(_jsPlumb.isSource(d17) == false, &quot;d17 is no longer a source&quot;);

        // this should succeed, because d17 is no longer a source and so jsPlumb will just create and add a new endpoint to d17.
        _jsPlumb.connect({source: &quot;d17&quot;, target: e16});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
    });

    // maketarget, then unmake it. should not be able to make a connection to it. 
    test(&quot;: jsPlumb.unmakeTarget (string id as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, isTarget: false}, {anchors: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        _jsPlumb.makeTarget(d17, { isSource: true, anchor: &quot;LeftMiddle&quot;  }); // give it a non-default anchor, we will check this below.
        ok(_jsPlumb.isTarget(d17) == true, &quot;d17 is currently a target&quot;);
        // unmake target
        _jsPlumb.unmakeTarget(d17);
        ok(_jsPlumb.isTarget(d17) == false, &quot;d17 is no longer a target&quot;);

        // this should succeed, because d17 is no longer a target and so jsPlumb will just create and add a new endpoint to d17.
        _jsPlumb.connect({source: e16, target: &quot;d17&quot;});
        assertEndpointCount(&quot;d16&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d17&quot;, 1, _jsPlumb);
    });


    test(&quot;: jsPlumb.removeEverySource and removeEveryTarget (string id as argument)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;);
        _jsPlumb.makeSource(d16).makeTarget(d17).makeSource(d18);
        ok(_jsPlumb.isSource(d16) == true, &quot;d16 is a source&quot;);
        ok(_jsPlumb.isTarget(d17) == true, &quot;d17 is a target&quot;);
        ok(_jsPlumb.isSource(d18) == true, &quot;d18 is a source&quot;);

        _jsPlumb.unmakeEverySource();
        _jsPlumb.unmakeEveryTarget();

        ok(_jsPlumb.isSource(d16) == false, &quot;d16 is no longer a source&quot;);
        ok(_jsPlumb.isTarget(d17) == false, &quot;d17 is no longer a target&quot;);
        ok(_jsPlumb.isSource(d18) == false, &quot;d18 is no longer a source&quot;);
    });

// *********************** end of makeTarget (and associated methods) tests ************************ 

    test(&#x27;: _jsPlumb.connect (between two Endpoints)&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e = _jsPlumb.addEndpoint(d1, {});
        var e2 = _jsPlumb.addEndpoint(d2, {});
        ok(e, &#x27;endpoint e exists&#x27;);
        ok(e2, &#x27;endpoint e2 exists&#x27;);
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
        var c = _jsPlumb.connect({target: &#x27;d2&#x27;, sourceEndpoint: e, targetEndpoint: e2});
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);		// no new endpoint should have been added
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb); 		// no new endpoint should have been added
        ok(c.id != null, &quot;connection has had an id assigned&quot;);
    });


    test(&#x27;: _jsPlumb.connect (between two Endpoints, and dont supply any parameters to the Endpoints.)&#x27;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e = _jsPlumb.addEndpoint(d1);
        var e2 = _jsPlumb.addEndpoint(d2);
        ok(e, &#x27;endpoint e exists&#x27;);
        ok(e2, &#x27;endpoint e2 exists&#x27;);
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
        _jsPlumb.connect({target: &#x27;d2&#x27;, sourceEndpoint: e, targetEndpoint: e2});
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);		// no new endpoint should have been added
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb); 		// no new endpoint should have been added
    });

    test(&quot; : _jsPlumb.connect, passing &#x27;anchors&#x27; array&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2, anchors: [&quot;LeftMiddle&quot;, &quot;RightMiddle&quot;]});

        equal(c.endpoints[0].anchor.x, 0, &quot;source anchor is at x=0&quot;);
        equal(c.endpoints[0].anchor.y, 0.5, &quot;source anchor is at y=0.5&quot;);
        equal(c.endpoints[1].anchor.x, 1, &quot;target anchor is at x=1&quot;);
        equal(c.endpoints[1].anchor.y, 0.5, &quot;target anchor is at y=0.5&quot;);
    });

    test(&#x27;: _jsPlumb.connect (by endpoint)&#x27;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true});
        ok(e16.anchor, &#x27;endpoint 16 has an anchor&#x27;);
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true});
        _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
    });

    test(&#x27;: _jsPlumb.connect (cost)&#x27;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true});
        ok(e16.anchor, &#x27;endpoint 16 has an anchor&#x27;);
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true});
        var c = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17, cost: 567});
        equal(c.getCost(), 567, &quot;connection cost is 567&quot;);
    });

    test(&#x27;: _jsPlumb.connect (default cost)&#x27;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true});
        ok(e16.anchor, &#x27;endpoint 16 has an anchor&#x27;);
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true});
        var c = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        equal(c.getCost(), undefined, &quot;default connection cost is 1&quot;);
    });

    test(&#x27;: _jsPlumb.connect (set cost)&#x27;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true});
        ok(e16.anchor, &#x27;endpoint 16 has an anchor&#x27;);
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true});
        var c = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        equal(c.getCost(), undefined, &quot;default connection cost is 1&quot;);
        c.setCost(8989);
        equal(c.getCost(), 8989, &quot;connection cost is 8989&quot;);
    });

    test(&#x27;: _jsPlumb.connect two endpoints (connectionCost)&#x27;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, connectionCost: 567});
        ok(e16.anchor, &#x27;endpoint 16 has an anchor&#x27;);
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true});
        var c = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        equal(c.getCost(), 567, &quot;connection cost is 567&quot;);
    });

    test(&#x27;: _jsPlumb.connect two endpoints (change connectionCost)&#x27;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;),
            e16 = _jsPlumb.addEndpoint(d16, {isSource: true, connectionCost: 567, maxConnections: -1}),
            e17 = _jsPlumb.addEndpoint(d17, {isSource: true, maxConnections: -1});
        c = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        equal(c.getCost(), 567, &quot;connection cost is 567&quot;);
        e16.setConnectionCost(23);
        var c2 = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        equal(c2.getCost(), 23, &quot;connection cost is 23 after change on endpoint&quot;);
    });

    test(&#x27;: _jsPlumb.connect (directed is false by default)&#x27;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;),
            e16 = _jsPlumb.addEndpoint(d16, {isSource: true}),
            e17 = _jsPlumb.addEndpoint(d17, {isSource: true}),
            c = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        equal(c.isDirected(), false, &quot;default connection is not directed&quot;);
    });

    test(&#x27;: _jsPlumb.connect (directed true)&#x27;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;),
            e16 = _jsPlumb.addEndpoint(d16, {isSource: true}),
            e17 = _jsPlumb.addEndpoint(d17, {isSource: true}),
            c = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17, directed: true});
        equal(c.isDirected(), true, &quot;connection is directed&quot;);
    });

    test(&#x27;: _jsPlumb.connect two endpoints (connectionsDirected)&#x27;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {isSource: true, connectionsDirected: true, maxConnections: -1});
        ok(e16.anchor, &#x27;endpoint 16 has an anchor&#x27;);
        var e17 = _jsPlumb.addEndpoint(d17, {isSource: true, maxConnections: -1});
        var c = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        equal(c.isDirected(), true, &quot;connection is directed&quot;);
    });

    test(&#x27;: _jsPlumb.connect two endpoints (change connectionsDirected)&#x27;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;),
            e16 = _jsPlumb.addEndpoint(d16, {isSource: true, connectionsDirected: true, maxConnections: -1}),
            e17 = _jsPlumb.addEndpoint(d17, {isSource: true, maxConnections: -1});
        c = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        equal(c.isDirected(), true, &quot;connection is directed&quot;);
        e16.setConnectionsDirected(false);
        var c2 = _jsPlumb.connect({sourceEndpoint: e16, targetEndpoint: e17});
        equal(c2.isDirected(), false, &quot;connection is not directed&quot;);
    });

    test(&quot;: _jsPlumb.connect (two Endpoints - that have been already added - by UUID)&quot;, function () {
        var srcEndpointUuid = &quot;14785937583175927504313&quot;, dstEndpointUuid = &quot;14785937583175927534325&quot;;
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e1 = _jsPlumb.addEndpoint(&quot;d16&quot;, {isSource: true, maxConnections: -1, uuid: srcEndpointUuid});
        var e2 = _jsPlumb.addEndpoint(&quot;d17&quot;, {isSource: true, maxConnections: -1, uuid: dstEndpointUuid});
        _jsPlumb.connect({ uuids: [ srcEndpointUuid, dstEndpointUuid  ] });
        assertConnectionCount(e1, 1);
        assertConnectionCount(e2, 1);
    });

    test(&quot;: _jsPlumb.connect (two Endpoints - that have not been already added - by UUID)&quot;, function () {
        var srcEndpointUuid = &quot;14785937583175927504313&quot;, dstEndpointUuid = &quot;14785937583175927534325&quot;;
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        _jsPlumb.connect({ uuids: [ srcEndpointUuid, dstEndpointUuid  ], source: d16, target: d17 });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        var e1 = _jsPlumb.getEndpoint(srcEndpointUuid);
        ok(e1 != null, &quot;endpoint with src uuid added&quot;);
        ok(e1.canvas != null);
        var e2 = _jsPlumb.getEndpoint(dstEndpointUuid);
        ok(e2 != null, &quot;endpoint with target uuid added&quot;);
        assertConnectionCount(e1, 1);
        assertConnectionCount(e2, 1);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
    });

    test(&quot;: _jsPlumb.connect (two Endpoints - that have been already added - by endpoint reference)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e1 = _jsPlumb.addEndpoint(&quot;d16&quot;, {isSource: true, maxConnections: -1});
        var e2 = _jsPlumb.addEndpoint(&quot;d17&quot;, {isSource: true, maxConnections: -1});
        _jsPlumb.connect({ sourceEndpoint: e1, targetEndpoint: e2 });
        assertConnectionCount(e1, 1);
        assertConnectionCount(e2, 1);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
    });

    test(&quot;: _jsPlumb.connect (two elements)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        _jsPlumb.connect({ source: d16, target: d17 });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
    });

    test(&quot;: _jsPlumb.connect (Connector test, straight)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, connector: &quot;Straight&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
    });

    test(&quot;: _jsPlumb.connect (Connector test, bezier, no params)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, connector: &quot;Bezier&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.getConnector().type, &quot;Bezier&quot;, &quot;Bezier connector chosen for connection&quot;);
        equal(conn.getConnector().getCurviness(), 150, &quot;Bezier connector chose 150 curviness&quot;);
    });

    test(&quot;: _jsPlumb.connect (Connector test, bezier, curviness as int)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, connector: [&quot;Bezier&quot;, { curviness: 200 }] });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.getConnector().type, &quot;Bezier&quot;, &quot;Canvas Bezier connector chosen for connection&quot;);
        equal(conn.getConnector().getCurviness(), 200, &quot;Bezier connector chose 200 curviness&quot;);
    });

    test(&quot;: _jsPlumb.connect (Connector test, bezier, curviness as named option)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, connector: [&quot;Bezier&quot;, {curviness: 300}] });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.getConnector().type, &quot;Bezier&quot;, &quot;Bezier connector chosen for connection&quot;);
        equal(conn.getConnector().getCurviness(), 300, &quot;Bezier connector chose 300 curviness&quot;);
    });

    test(&quot;: _jsPlumb.connect (anchors registered correctly; source and target anchors given, as arrays)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, connector: &quot;Straight&quot;, anchors: [
            [0.3, 0.3, 1, 0],
            [0.7, 0.7, 0, 1]
        ] });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.getConnector().type, &quot;Straight&quot;, &quot;Canvas Straight connector chosen for connection&quot;);
        equal(0.3, conn.endpoints[0].anchor.x, &quot;source anchor x&quot;);
        equal(0.3, conn.endpoints[0].anchor.y, &quot;source anchor y&quot;);
        equal(0.7, conn.endpoints[1].anchor.x, &quot;target anchor x&quot;);
        equal(0.7, conn.endpoints[1].anchor.y, &quot;target anchor y&quot;);
    });

    test(&quot;: _jsPlumb.connect (anchors registered correctly; source and target anchors given, as strings)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, connector: &quot;Straight&quot;, anchors: [&quot;LeftMiddle&quot;, &quot;RightMiddle&quot;] });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
        equal(0, conn.endpoints[0].anchor.x, &quot;source anchor x&quot;);
        equal(0.5, conn.endpoints[0].anchor.y, &quot;source anchor y&quot;);
        equal(1, conn.endpoints[1].anchor.x, &quot;target anchor x&quot;);
        equal(0.5, conn.endpoints[1].anchor.y, &quot;target anchor y&quot;);
    });

    test(&quot;: _jsPlumb.connect (anchors registered correctly; source and target anchors given, as arrays)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, connector: &quot;Straight&quot;, anchors: [
            [0.3, 0.3, 1, 0],
            [0.7, 0.7, 0, 1]
        ] });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
        equal(0.3, conn.endpoints[0].anchor.x, &quot;source anchor x&quot;);
        equal(0.3, conn.endpoints[0].anchor.y, &quot;source anchor y&quot;);
        equal(0.7, conn.endpoints[1].anchor.x, &quot;target anchor x&quot;);
        equal(0.7, conn.endpoints[1].anchor.y, &quot;target anchor y&quot;);
    });


    test(&quot;: _jsPlumb.connect (two argument method in which some data is reused across connections)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;), d18 = _addDiv(&quot;d18&quot;), d19 = _addDiv(&quot;d19&quot;);
        var sharedData = { connector: &quot;Straight&quot;, anchors: [
            [0.3, 0.3, 1, 0],
            [0.7, 0.7, 0, 1]
        ] };
        var conn = _jsPlumb.connect({ source: d16, target: d17}, sharedData);
        var conn2 = _jsPlumb.connect({ source: d18, target: d19}, sharedData);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 2, _jsPlumb);
        equal(conn.getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
        equal(conn2.getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
        equal(0.3, conn.endpoints[0].anchor.x, &quot;source anchor x&quot;);
        equal(0.3, conn.endpoints[0].anchor.y, &quot;source anchor y&quot;);
        equal(0.7, conn.endpoints[1].anchor.x, &quot;target anchor x&quot;);
        equal(0.7, conn.endpoints[1].anchor.y, &quot;target anchor y&quot;);
        equal(0.3, conn2.endpoints[0].anchor.x, &quot;source anchor x&quot;);
        equal(0.3, conn2.endpoints[0].anchor.y, &quot;source anchor y&quot;);
        equal(0.7, conn2.endpoints[1].anchor.x, &quot;target anchor x&quot;);
        equal(0.7, conn2.endpoints[1].anchor.y, &quot;target anchor y&quot;);
    });

    test(&quot;: _jsPlumb.connect (Connector as string test)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, connector: &quot;Straight&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
    });

    test(&quot;: _jsPlumb.connect (Endpoint test)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, endpoint: &quot;Rectangle&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.endpoints[0].endpoint.constructor, jsPlumb.Endpoints[renderMode].Rectangle, &quot;Rectangle endpoint chosen for connection source&quot;);
        equal(conn.endpoints[1].endpoint.constructor, jsPlumb.Endpoints[renderMode].Rectangle, &quot;Rectangle endpoint chosen for connection target&quot;);
    });

    test(&quot;: _jsPlumb.connect (Endpoint as string test)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, endpoint: &quot;Rectangle&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.endpoints[0].endpoint.constructor, jsPlumb.Endpoints[renderMode].Rectangle, &quot;Rectangle endpoint chosen for connection source&quot;);
        equal(conn.endpoints[1].endpoint.constructor, jsPlumb.Endpoints[renderMode].Rectangle, &quot;Rectangle endpoint chosen for connection target&quot;);
    });

    test(&quot;: _jsPlumb.connect (Endpoints test)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, endpoints: [&quot;Rectangle&quot;, &quot;Dot&quot; ] });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.endpoints[0].endpoint.constructor, jsPlumb.Endpoints[renderMode].Rectangle, &quot;Rectangle endpoint chosen for connection source&quot;);
        equal(conn.endpoints[1].endpoint.constructor, jsPlumb.Endpoints[renderMode].Dot, &quot;Dot endpoint chosen for connection target&quot;);
    });

    test(&quot;: _jsPlumb.connect (Blank Endpoint specified via &#x27;endpoint&#x27; param)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, endpoint: &quot;Blank&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.endpoints[0].endpoint.constructor, jsPlumb.Endpoints[renderMode].Blank, &quot;Blank endpoint chosen for connection source&quot;);
        equal(conn.endpoints[1].endpoint.constructor, jsPlumb.Endpoints[renderMode].Blank, &quot;Blank endpoint chosen for connection target&quot;);
    });

    test(&quot;: _jsPlumb.connect (Blank Endpoint specified via &#x27;endpoints&#x27; param)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, endpoints: [&quot;Blank&quot;, &quot;Blank&quot; ] });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.endpoints[0].endpoint.constructor, jsPlumb.Endpoints[renderMode].Blank, &quot;Blank endpoint chosen for connection source&quot;);
        equal(conn.endpoints[1].endpoint.constructor, jsPlumb.Endpoints[renderMode].Blank, &quot;Blank endpoint chosen for connection target&quot;);
    });

    test(&quot;: _jsPlumb.connect (Endpoint as string test)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var conn = _jsPlumb.connect({ source: d16, target: d17, endpoints: [&quot;Rectangle&quot;, &quot;Dot&quot; ] });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(conn.endpoints[0].endpoint.constructor, jsPlumb.Endpoints[renderMode].Rectangle, &quot;Rectangle endpoint chosen for connection source&quot;);
        equal(conn.endpoints[1].endpoint.constructor, jsPlumb.Endpoints[renderMode].Dot, &quot;Dot endpoint chosen for connection target&quot;);
    });

    test(&quot;: _jsPlumb.connect (by Endpoints, connector test)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {});
        var e17 = _jsPlumb.addEndpoint(d17, {});
        window.FOO = &quot;BAR&quot;
        var conn = _jsPlumb.connect({ sourceEndpoint: e16, targetEndpoint: e17, connector: &quot;Straight&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(e16.connections[0].getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
        window.FOO = null;
    });

    test(&quot;: _jsPlumb.connect (by Endpoints, connector as string test)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {});
        var e17 = _jsPlumb.addEndpoint(d17, {});
        var conn = _jsPlumb.connect({ sourceEndpoint: e16, targetEndpoint: e17, connector: &quot;Straight&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(e16.connections[0].getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
    });

    test(&quot;: _jsPlumb.connect (by Endpoints, anchors as string test)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var a16 = &quot;TopCenter&quot;, a17 = &quot;BottomCenter&quot;;
        var e16 = _jsPlumb.addEndpoint(d16, {anchor: a16});
        var e17 = _jsPlumb.addEndpoint(d17, {anchor: a17});
        var conn = _jsPlumb.connect({ sourceEndpoint: e16, targetEndpoint: e17, connector: &quot;Straight&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(e16.connections[0].getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
        equal(e16.anchor.x, 0.5, &quot;endpoint 16 is at top center&quot;);
        equal(e16.anchor.y, 0, &quot;endpoint 16 is at top center&quot;);
        equal(e17.anchor.x, 0.5, &quot;endpoint 17 is at bottom center&quot;);
        equal(e17.anchor.y, 1, &quot;endpoint 17 is at bottom center&quot;);
    });

    test(&quot;: _jsPlumb.connect (by Endpoints, endpoints create anchors)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var a16 = [0, 0.5, 0, -1], a17 = [1, 0.0, -1, -1];
        var e16 = _jsPlumb.addEndpoint(d16, {anchor: a16});
        var e17 = _jsPlumb.addEndpoint(d17, {anchor: a17});
        var conn = _jsPlumb.connect({ sourceEndpoint: e16, targetEndpoint: e17, connector: &quot;Straight&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(e16.connections[0].getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
        equal(e16.anchor.x, a16[0]);
        equal(e16.anchor.y, a16[1]);
        equal(e17.anchor.x, a17[0]);
        equal(e17.anchor.y, a17[1]);
        equal(e16.anchor.getOrientation()[0], a16[2]);
        equal(e16.anchor.getOrientation()[1], a16[3]);
        equal(e17.anchor.getOrientation()[0], a17[2]);
        equal(e17.anchor.getOrientation()[1], a17[3]);
    });

    test(&quot;: _jsPlumb.connect (by Endpoints, endpoints create dynamic anchors; anchors specified by &#x27;anchor&#x27;)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {anchor: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        var e17 = _jsPlumb.addEndpoint(d17, {anchor: [&quot;TopCenter&quot;, &quot;BottomCenter&quot;]});
        var conn = _jsPlumb.connect({ sourceEndpoint: e16, targetEndpoint: e17, connector: &quot;Straight&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(e16.connections[0].getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
        equal(e16.anchor.isDynamic, true, &quot;Endpoint 16 has a dynamic anchor&quot;);
        equal(e17.anchor.isDynamic, true, &quot;Endpoint 17 has a dynamic anchor&quot;);
    });

    test(&quot;: _jsPlumb.connect (by Endpoints, endpoints create dynamic anchors; anchors specified by &#x27;anchors&#x27;)&quot;, function () {
        var d16 = _addDiv(&quot;d16&quot;), d17 = _addDiv(&quot;d17&quot;);
        var e16 = _jsPlumb.addEndpoint(d16, {anchor: [
            [0, 0.5, 0, -1],
            [1, 0.5, 0, 1]
        ]});
        var e17 = _jsPlumb.addEndpoint(d17, {anchor: [&quot;TopCenter&quot;, &quot;BottomCenter&quot;]});
        var conn = _jsPlumb.connect({ sourceEndpoint: e16, targetEndpoint: e17, connector: &quot;Straight&quot; });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        equal(e16.connections[0].getConnector().type, &quot;Straight&quot;, &quot;Straight connector chosen for connection&quot;);
        equal(e16.anchor.isDynamic, true, &quot;Endpoint 16 has a dynamic anchor&quot;);
        equal(e17.anchor.isDynamic, true, &quot;Endpoint 17 has a dynamic anchor&quot;);
    });

    test(&quot;: _jsPlumb.connect (connect by element, default endpoint, supplied dynamic anchors)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var anchors = [
            [0.25, 0, 0, -1],
            [1, 0.25, 1, 0],
            [0.75, 1, 0, 1],
            [0, 0.75, -1, 0]
        ];
        _jsPlumb.connect({source: d1, target: d2, dynamicAnchors: anchors});                // auto connect with default endpoint and provided anchors
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
        _jsPlumb.detach({source: d1, target: d2});
        // this changed in 1.3.5, because auto generated endpoints are now removed by detach.  so i added the test below this one
        // to check that the deleteEndpointsOnDetach flag is honoured.
        assertEndpointCount(&quot;d1&quot;, 0, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 0, _jsPlumb);
    });

    test(&quot;: _jsPlumb.connect (connect by element, default endpoint, supplied dynamic anchors, delete on detach false)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var anchors = [
            [0.25, 0, 0, -1],
            [1, 0.25, 1, 0],
            [0.75, 1, 0, 1],
            [0, 0.75, -1, 0]
        ];
        _jsPlumb.connect({
            source: d1,
            target: d2,
            dynamicAnchors: anchors,
            deleteEndpointsOnDetach: false
        });                // auto connect with default endpoint and provided anchors
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
        _jsPlumb.detach({source: d1, target: d2});
        // this changed in 1.3.5, because auto generated endpoints are now removed by detach.  so i added this test
        // to check that the deleteEndpointsOnDetach flag is honoured.
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
    });

    test(&quot;: delete endpoints on detach, makeSource and makeTarget)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        _jsPlumb.makeSource(d1);
        _jsPlumb.makeTarget(d2);
        var c = _jsPlumb.connect({
            source: d1,
            target: d2
        });
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
        _jsPlumb.detach(c);
        // both endpoints should have been deleted, as they were both created automatically
        assertEndpointCount(&quot;d1&quot;, 0, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 0, _jsPlumb);
    });

    test(&quot;: delete endpoints on detach, addEndpoint and makeTarget)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e = _jsPlumb.addEndpoint(d1);
        _jsPlumb.makeTarget(d2);
        var c = _jsPlumb.connect({
            source: e,
            target: d2
        });
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
        _jsPlumb.detach(c);
        // only target endpoint should have been deleted, as the other was not added automatically
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 0, _jsPlumb);
    });

    test(&quot;: delete endpoints on detach, makeSource and addEndpoint)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        _jsPlumb.makeSource(d1);
        var e = _jsPlumb.addEndpoint(d2);
        var c = _jsPlumb.connect({
            source: d1,
            target: e
        });
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
        _jsPlumb.detach(c);
        // only source endpoint should have been deleted, as the other was not added automatically
        assertEndpointCount(&quot;d1&quot;, 0, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
    });

    test(&quot;: _jsPlumb.connect (connect by element, supplied endpoint and dynamic anchors)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var endpoint = { isSource: true };
        var e1 = _jsPlumb.addEndpoint(d1, endpoint);
        var e2 = _jsPlumb.addEndpoint(d2, endpoint);
        var anchors = [ &quot;TopCenter&quot;, &quot;BottomCenter&quot; ];
        _jsPlumb.connect({sourceEndpoint: e1, targetEndpoint: e2, dynamicAnchors: anchors});
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
        _jsPlumb.detach({source: d1, target: d2});
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
    });

    test(&quot;: _jsPlumb.connect (connect by element, supplied endpoints using &#x27;source&#x27; and &#x27;target&#x27; (this test is identical to the one above apart from the param names), and dynamic anchors)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var endpoint = { isSource: true };
        var e1 = _jsPlumb.addEndpoint(d1, endpoint);
        var e2 = _jsPlumb.addEndpoint(d2, endpoint);
        var anchors = [ &quot;TopCenter&quot;, &quot;BottomCenter&quot; ];
        _jsPlumb.connect({source: e1, target: e2, dynamicAnchors: anchors});
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
        _jsPlumb.detach({source: d1, target: d2});
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
    });

    test(&quot;: jsPlumb.connect, events specified&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            clicked = 0,
            c = _jsPlumb.connect({
                source: d1,
                target: d2,
                events: {
                    click: function (conn) {
                        clicked++;
                    }
                }
            });

        c.fire(&quot;click&quot;, c);
        equal(1, clicked, &quot;connection was clicked once&quot;);
    });

    test(&quot; detachable parameter defaults to true on _jsPlumb.connect&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});
        equal(c.isDetachable(), true, &quot;connections detachable by default&quot;);
    });

    test(&quot; detachable parameter set to false on _jsPlumb.connect&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2, detachable: false});
        equal(c.isDetachable(), false, &quot;connection detachable&quot;);
    });

    test(&quot; setDetachable on initially detachable connection&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});
        equal(c.isDetachable(), true, &quot;connection initially detachable&quot;);
        c.setDetachable(false);
        equal(c.isDetachable(), false, &quot;connection not detachable&quot;);
    });

    test(&quot; setDetachable on initially not detachable connection&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2, detachable: false });
        equal(c.isDetachable(), false, &quot;connection not initially detachable&quot;);
        c.setDetachable(true);
        equal(c.isDetachable(), true, &quot;connection now detachable&quot;);
    });

    test(&quot; _jsPlumb.Defaults.ConnectionsDetachable&quot;, function () {
        _jsPlumb.Defaults.ConnectionsDetachable = false;
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});
        equal(c.isDetachable(), false, &quot;connections not detachable by default (overrode the defaults)&quot;);
        _jsPlumb.Defaults.ConnectionsDetachable = true;
    });


    test(&quot;: _jsPlumb.connect (testing for connection event callback)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var connectCallback = null, detachCallback = null;
        _jsPlumb.bind(&quot;connection&quot;, function (params) {
            connectCallback = jsPlumb.extend({}, params);
        });
        _jsPlumb.bind(&quot;connectionDetached&quot;, function (params) {
            detachCallback = jsPlumb.extend({}, params);
        });
        _jsPlumb.connect({source: d1, target: d2});                // auto connect with default endpoint and anchor set
        ok(connectCallback != null, &quot;connect callback was made&quot;);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        assertEndpointCount(&quot;d1&quot;, 1, _jsPlumb);
        assertEndpointCount(&quot;d2&quot;, 1, _jsPlumb);
        _jsPlumb.detach({source: d1, target: d2});
        ok(detachCallback != null, &quot;detach callback was made&quot;);
    });

    test(&quot;: _jsPlumb.connect (setting outline class on Connector)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, paintStyle:{outlineStroke:&quot;green&quot;, outlineWidth:6, strokeWidth:4, stroke:&quot;red&quot;}});
        var has = function (clazz, elName) {
            var cn = c.getConnector()[elName].className,
                cns = cn.constructor == String ? cn : cn.baseVal;

            return cns.indexOf(clazz) != -1;
        };
        ok(has(_jsPlumb.connectorClass, &quot;canvas&quot;), &quot;basic connector class set correctly&quot;);

        ok(has(&quot;jtk-connector-outline&quot;, &quot;bgPath&quot;), &quot;outline canvas set correctly&quot;);
        ok(has(_jsPlumb.connectorOutlineClass, &quot;bgPath&quot;), &quot;outline canvas set correctly&quot;);
    });

    test(&quot;: _jsPlumb.connect (setting cssClass on Connector)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, cssClass: &quot;CSS&quot;});
        var has = function (clazz) {
            var cn = c.getConnector().canvas.className,
                cns = cn.constructor == String ? cn : cn.baseVal;

            return cns.indexOf(clazz) != -1;
        };
        ok(has(&quot;CSS&quot;), &quot;custom cssClass set correctly&quot;);
        ok(has(_jsPlumb.connectorClass), &quot;basic connector class set correctly&quot;);
    });

    test(&quot;: _jsPlumb.addEndpoint (setting cssClass on Endpoint)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e = _jsPlumb.addEndpoint(d1, {cssClass: &quot;CSS&quot;});
        var has = function (clazz) {
            var cn = e.endpoint.canvas.className,
                cns = cn.constructor == String ? cn : cn.baseVal;

            return cns.indexOf(clazz) != -1;
        };
        ok(has(&quot;CSS&quot;), &quot;custom cssClass set correctly&quot;);
        ok(has(_jsPlumb.endpointClass), &quot;basic endpoint class set correctly&quot;);
    });

    test(&quot;: _jsPlumb.addEndpoint (setting cssClass on blank Endpoint)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e = _jsPlumb.addEndpoint(d1, {endpoint: &quot;Blank&quot;, cssClass: &quot;CSS&quot;});
        var has = function (clazz) {
            var cn = e.endpoint.canvas.className,
                cns = cn.constructor == String ? cn : cn.baseVal;

            return cns.indexOf(clazz) != -1;
        };
        ok(has(&quot;CSS&quot;), &quot;custom cssClass set correctly&quot;);
        ok(has(_jsPlumb.endpointClass), &quot;basic endpoint class set correctly&quot;);
    });

    test(&quot;: _jsPlumb.connect (overlays, long-hand version)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var imageEventListener = function () {
        };
        var arrowSpec = {width: 40, length: 40, location: 0.7, foldback: 0, paintStyle: {strokeWidth: 1, stroke: &quot;#000000&quot;}, id:&quot;a&quot;};
        var connection1 = _jsPlumb.connect({
            source: d1,
            target: d2,
            anchors: [&quot;BottomCenter&quot;, [ 0.75, 0, 0, -1 ]],
            overlays: [
                [&quot;Label&quot;, {label: &quot;CONNECTION 1&quot;, location: 0.3, id:&quot;l&quot;}],
                [&quot;Arrow&quot;, arrowSpec ]
            ]
        });
        equal(_length(connection1._jsPlumb.overlays), 2);
        equal(jsPlumb.Overlays[renderMode].Label, connection1._jsPlumb.overlays[&quot;l&quot;].constructor);

        equal(jsPlumb.Overlays[renderMode].Arrow, connection1._jsPlumb.overlays[&quot;a&quot;].constructor);
        equal(0.7, connection1._jsPlumb.overlays[&quot;a&quot;].loc);
        equal(40, connection1._jsPlumb.overlays[&quot;a&quot;].width);
        equal(40, connection1._jsPlumb.overlays[&quot;a&quot;].length);
    });

    test(&quot;: _jsPlumb.connect (overlays, long-hand version, IDs specified)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var imageEventListener = function () {
        };
        var arrowSpec = {
            width: 40,
            length: 40,
            location: 0.7,
            foldback: 0,
            paintStyle: {strokeWidth: 1, stroke: &quot;#000000&quot;},
            id: &quot;anArrow&quot;
        };
        var connection1 = _jsPlumb.connect({
            source: d1,
            target: d2,
            anchors: [&quot;BottomCenter&quot;, [ 0.75, 0, 0, -1 ]],
            overlays: [
                [&quot;Label&quot;, {label: &quot;CONNECTION 1&quot;, location: 0.3, id: &quot;aLabel&quot;}],
                [&quot;Arrow&quot;, arrowSpec ]
            ]
        });
        equal(2, _length(connection1._jsPlumb.overlays));
        equal(jsPlumb.Overlays[renderMode].Label, connection1._jsPlumb.overlays[&quot;aLabel&quot;].constructor);
        equal(&quot;aLabel&quot;, connection1._jsPlumb.overlays[&quot;aLabel&quot;].id);

        equal(jsPlumb.Overlays[renderMode].Arrow, connection1._jsPlumb.overlays[&quot;anArrow&quot;].constructor);
        equal(0.7, connection1._jsPlumb.overlays[&quot;anArrow&quot;].loc);
        equal(40, connection1._jsPlumb.overlays[&quot;anArrow&quot;].width);
        equal(40, connection1._jsPlumb.overlays[&quot;anArrow&quot;].length);
        equal(&quot;anArrow&quot;, connection1._jsPlumb.overlays[&quot;anArrow&quot;].id);
    });

    test(&quot;: _jsPlumb.connect (default overlays)&quot;, function () {
        _jsPlumb.Defaults.Overlays = [
            [&quot;Arrow&quot;, { location: 0.1, id: &quot;arrow&quot; }]
        ];
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        ok(c.getOverlay(&quot;arrow&quot;) != null, &quot;Arrow overlay created from defaults&quot;);
    });

    test(&quot;: _jsPlumb.connect (default overlays + overlays specified in connect call)&quot;, function () {
        _jsPlumb.Defaults.Overlays = [
            [&quot;Arrow&quot;, { location: 0.1, id: &quot;arrow&quot; }]
        ];
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2, overlays: [
                [&quot;Label&quot;, {id: &quot;label&quot;}]
            ]});

        ok(c.getOverlay(&quot;arrow&quot;) != null, &quot;Arrow overlay created from defaults&quot;);
        ok(c.getOverlay(&quot;label&quot;) != null, &quot;Label overlay created from connect call&quot;);
    });

    test(&quot;: _jsPlumb.connect (default connection overlays)&quot;, function () {
        _jsPlumb.Defaults.ConnectionOverlays = [
            [&quot;Arrow&quot;, { location: 0.1, id: &quot;arrow&quot; }]
        ];
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        ok(c.getOverlay(&quot;arrow&quot;) != null, &quot;Arrow overlay created from defaults&quot;);
    });

    test(&quot;: _jsPlumb.connect (default connection overlays + overlays specified in connect call)&quot;, function () {
        _jsPlumb.Defaults.ConnectionOverlays = [
            [&quot;Arrow&quot;, { location: 0.1, id: &quot;arrow&quot; }]
        ];
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2, overlays: [
                [&quot;Label&quot;, {id: &quot;label&quot;}]
            ]});

        ok(c.getOverlay(&quot;arrow&quot;) != null, &quot;Arrow overlay created from defaults&quot;);
        ok(c.getOverlay(&quot;label&quot;) != null, &quot;Label overlay created from connect call&quot;);
    });

    test(&quot;: _jsPlumb.connect (default overlays + default connection overlays)&quot;, function () {
        _jsPlumb.Defaults.ConnectionOverlays = [
            [&quot;Arrow&quot;, { location: 0.1, id: &quot;arrow&quot; }]
        ];
        _jsPlumb.Defaults.Overlays = [
            [&quot;Arrow&quot;, { location: 0.1, id: &quot;arrow2&quot; }]
        ];
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        ok(c.getOverlay(&quot;arrow&quot;) != null, &quot;Arrow overlay created from defaults&quot;);
        ok(c.getOverlay(&quot;arrow2&quot;) != null, &quot;Arrow overlay created from connection defaults&quot;);
    });


    test(&quot;: _jsPlumb.connect (default overlays + default connection overlays)&quot;, function () {
        _jsPlumb.Defaults.ConnectionOverlays = [
            [&quot;Arrow&quot;, { location: 0.1, id: &quot;arrow&quot; }]
        ];
        _jsPlumb.Defaults.Overlays = [
            [&quot;Arrow&quot;, { location: 0.1, id: &quot;arrow2&quot; }]
        ];
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2, overlays: [
                [&quot;Label&quot;, {id: &quot;label&quot;}]
            ]});

        ok(c.getOverlay(&quot;arrow&quot;) != null, &quot;Arrow overlay created from defaults&quot;);
        ok(c.getOverlay(&quot;arrow2&quot;) != null, &quot;Arrow overlay created from connection defaults&quot;);
        ok(c.getOverlay(&quot;label&quot;) != null, &quot;Label overlay created from connect call&quot;);
    });

    test(&quot;: _jsPlumb.connect (label overlay set using &#x27;label&#x27;)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({
                source: d1,
                target: d2,
                label: &quot;FOO&quot;
            });

        equal(_length(c.getOverlays()), 1, &quot;one overlay set&quot;);
        equal(c.getLabel(), &quot;FOO&quot;, &quot;label is set correctly&quot;);
    });

    test(&quot;: _jsPlumb.connect (set label after construction, with string)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({
                source: d1,
                target: d2});

        c.setLabel(&quot;FOO&quot;);
        equal(c.getLabel(), &quot;FOO&quot;, &quot;label is set correctly&quot;);
    });

    test(&quot;: _jsPlumb.connect (set label after construction, with function)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({
                source: d1,
                target: d2});

        c.setLabel(function () {
            return &quot;BAR&quot;;
        });
        equal(c.getLabel()(), &quot;BAR&quot;, &quot;label is set correctly&quot;);
    });

    test(&quot;: _jsPlumb.connect (set label after construction, with params object)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({
                source: d1,
                target: d2});

        c.setLabel({
            label: &quot;BAZ&quot;,
            cssClass: &quot;CLASSY&quot;,
            location: 0.9
        });
        var lo = c.getLabelOverlay();
        ok(lo != null, &quot;label overlay exists&quot;);
        equal(lo.getLabel(), &quot;BAZ&quot;, &quot;label overlay has correct value&quot;);
        equal(lo.getLocation(), 0.9, &quot;label overlay has correct location&quot;);
    });

    test(&quot;: _jsPlumb.connect (set label after construction with existing label set, with params object)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({
                source: d1,
                target: d2,
                label: &quot;FOO&quot;,
                labelLocation: 0.2
            });

        var lo = c.getLabelOverlay();
        equal(lo.getLocation(), 0.2, &quot;label overlay has correct location&quot;);

        c.setLabel({
            label: &quot;BAZ&quot;,
            cssClass: &quot;CLASSY&quot;,
            location: 0.9
        });

        ok(lo != null, &quot;label overlay exists&quot;);
        equal(lo.getLabel(), &quot;BAZ&quot;, &quot;label overlay has correct value&quot;);
        equal(lo.getLocation(), 0.9, &quot;label overlay has correct location&quot;);
    });

    test(&quot;: _jsPlumb.connect (getLabelOverlay, label on connect call)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({
                source: d1,
                target: d2,
                label: &quot;FOO&quot;
            }),
            lo = c.getLabelOverlay();

        ok(lo != null, &quot;label overlay exists&quot;);
        equal(lo.getLabel(), &quot;FOO&quot;, &quot;label overlay has correct value&quot;);
        equal(lo.getLocation(), 0.5, &quot;label overlay has correct location&quot;);
    });

    test(&quot;: _jsPlumb.connect (getLabelOverlay, label on connect call, location set)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({
                source: d1,
                target: d2,
                label: &quot;FOO&quot;,
                labelLocation: 0.2
            }),
            lo = c.getLabelOverlay();

        ok(lo != null, &quot;label overlay exists&quot;);
        equal(lo.getLabel(), &quot;FOO&quot;, &quot;label overlay has correct value&quot;);
        equal(lo.getLocation(), 0.2, &quot;label overlay has correct location&quot;);
    });

    test(&quot;: _jsPlumb.connect (remove single overlay by id)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var arrowSpec = {
            width: 40,
            length: 40,
            location: 0.7,
            foldback: 0,
            paintStyle: {strokeWidth: 1, stroke: &quot;#000000&quot;},
            id: &quot;anArrow&quot;
        };
        var connection1 = _jsPlumb.connect({
            source: d1,
            target: d2,
            anchors: [&quot;BottomCenter&quot;, [ 0.75, 0, 0, -1 ]],
            overlays: [
                [&quot;Label&quot;, {label: &quot;CONNECTION 1&quot;, location: 0.3, id: &quot;aLabel&quot;}],
                [&quot;Arrow&quot;, arrowSpec ]
            ]
        });
        equal(2, _length(connection1._jsPlumb.overlays));
        connection1.removeOverlay(&quot;aLabel&quot;);
        equal(1, _length(connection1._jsPlumb.overlays));
        equal(&quot;anArrow&quot;, connection1._jsPlumb.overlays[&quot;anArrow&quot;].id);
    });

    test(&quot;: _jsPlumb.connect (remove multiple overlays by id)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var arrowSpec = {
            width: 40,
            length: 40,
            location: 0.7,
            foldback: 0,
            paintStyle: {strokeWidth: 1, stroke: &quot;#000000&quot;},
            id: &quot;anArrow&quot;
        };
        var connection1 = _jsPlumb.connect({
            source: d1,
            target: d2,
            anchors: [&quot;BottomCenter&quot;, [ 0.75, 0, 0, -1 ]],
            overlays: [
                [&quot;Label&quot;, {label: &quot;CONNECTION 1&quot;, location: 0.3, id: &quot;aLabel&quot;}],
                [&quot;Arrow&quot;, arrowSpec ]
            ]
        });
        equal(2, _length(connection1._jsPlumb.overlays));
        connection1.removeOverlays(&quot;aLabel&quot;, &quot;anArrow&quot;);
        equal(0, _length(connection1._jsPlumb.overlays));
    });

    test(&quot;: _jsPlumb.connect (overlays, short-hand version)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var imageEventListener = function () {
        };
        var loc = { location: 0.7 };
        var arrowSpec = { width: 40, length: 40, foldback: 0, paintStyle: {strokeWidth: 1, stroke: &quot;#000000&quot;}, id:&quot;a&quot; };
        var connection1 = _jsPlumb.connect({
            source: d1,
            target: d2,
            anchors: [&quot;BottomCenter&quot;, [ 0.75, 0, 0, -1 ]],
            overlays: [
                [&quot;Label&quot;, {label: &quot;CONNECTION 1&quot;, location: 0.3, id:&quot;l&quot;}],
                [&quot;Arrow&quot;, arrowSpec, loc]
            ]
        });
        equal(2, _length(connection1._jsPlumb.overlays));
        equal(jsPlumb.Overlays[renderMode].Label, connection1._jsPlumb.overlays[&quot;l&quot;].constructor);

        equal(jsPlumb.Overlays[renderMode].Arrow, connection1._jsPlumb.overlays[&quot;a&quot;].constructor);
        equal(0.7, connection1._jsPlumb.overlays[&quot;a&quot;].loc);
        equal(40, connection1._jsPlumb.overlays[&quot;a&quot;].width);
        equal(40, connection1._jsPlumb.overlays[&quot;a&quot;].length);
    });

    test(&quot;: _jsPlumb.connect (removeAllOverlays)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var imageEventListener = function () {
        };
        var loc = { location: 0.7 };
        var arrowSpec = { width: 40, length: 40, foldback: 0, paintStyle: {strokeWidth: 1, stroke: &quot;#000000&quot;}, id:&quot;a&quot; };
        var connection1 = _jsPlumb.connect({
            source: d1,
            target: d2,
            anchors: [&quot;BottomCenter&quot;, [ 0.75, 0, 0, -1 ]],
            overlays: [
                [&quot;Label&quot;, {label: &quot;CONNECTION 1&quot;, location: 0.3, cssClass: &quot;PPPP&quot;, id:&quot;l&quot;}],
                [&quot;Arrow&quot;, arrowSpec, loc]
            ]
        });
        equal(2, _length(connection1._jsPlumb.overlays));
        equal(jsPlumb.Overlays[renderMode].Label, connection1._jsPlumb.overlays[&quot;l&quot;].constructor);

        equal(jsPlumb.Overlays[renderMode].Arrow, connection1._jsPlumb.overlays[&quot;a&quot;].constructor);
        equal(0.7, connection1._jsPlumb.overlays[&quot;a&quot;].loc);
        equal(40, connection1._jsPlumb.overlays[&quot;a&quot;].width);
        equal(40, connection1._jsPlumb.overlays[&quot;a&quot;].length);

        // not valid anymore, as we dont nuke overlays until the component is deleted.
        /*connection1.removeAllOverlays();
        equal(0, connection1._jsPlumb.overlays.length);
        equal(0, jsPlumb.getSelector(&quot;.PPPP&quot;).length);*/
        _jsPlumb.detach(connection1);
        equal(0, jsPlumb.getSelector(&quot;.PPPP&quot;).length, &quot;overlay has been fully cleaned up&quot;);
    });

    test(&quot;: _jsPlumb.connect, specify arrow overlay using string identifier only&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var conn = _jsPlumb.connect({source: d1, target: d2, overlays: [&quot;Arrow&quot;]});
        equal(jsPlumb.Overlays[renderMode].Arrow, _head(conn._jsPlumb.overlays).constructor);
    });

    test(&quot;: Connection.getOverlay method, existing overlay&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var conn = _jsPlumb.connect({source: d1, target: d2, overlays: [
            [ &quot;Arrow&quot;, { id: &quot;arrowOverlay&quot; } ]
        ] });
        var overlay = conn.getOverlay(&quot;arrowOverlay&quot;);
        ok(overlay != null);
    });

    test(&quot;: Connection.getOverlay method, non-existent overlay&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var conn = _jsPlumb.connect({source: d1, target: d2, overlays: [
            [ &quot;Arrow&quot;, { id: &quot;arrowOverlay&quot; } ]
        ] });
        var overlay = conn.getOverlay(&quot;IDONTEXIST&quot;);
        ok(overlay == null);
    });

    test(&quot;: Overlay.setVisible method&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var conn = _jsPlumb.connect({source: d1, target: d2, overlays: [
            [ &quot;Arrow&quot;, { id: &quot;arrowOverlay&quot; } ]
        ] });
        var overlay = conn.getOverlay(&quot;arrowOverlay&quot;);
        ok(overlay.isVisible());
        overlay.setVisible(false);
        ok(!overlay.isVisible());
        overlay.setVisible(true);
        ok(overlay.isVisible());
    });

    test(&quot;: _jsPlumb.connect (custom label overlay, set on Defaults, return plain DOM element)&quot;, function () {
        _jsPlumb.Defaults.ConnectionOverlays = [
            [&quot;Custom&quot;, { id: &quot;custom&quot;, create: function (connection) {
                ok(connection != null, &quot;we were passed in a connection&quot;);
                var d = document.createElement(&quot;div&quot;);
                d.setAttribute(&quot;custom&quot;, &quot;true&quot;);
                d.innerHTML = connection.id;
                return d;
            }}]
        ];
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        var o = c.getOverlay(&quot;custom&quot;);
        equal(o.getElement().getAttribute(&quot;custom&quot;), &quot;true&quot;, &quot;custom overlay created correctly&quot;);
        equal(o.getElement().innerHTML, c.id, &quot;custom overlay has correct value&quot;);
    });

    test(&quot;: _jsPlumb.connect (custom label overlay, set on Defaults, return selector)&quot;, function () {
        _jsPlumb.Defaults.ConnectionOverlays = [
            [&quot;Custom&quot;, { id: &quot;custom&quot;, create: function (connection) {
                ok(connection != null, &quot;we were passed in a connection&quot;);
                return makeContent(&quot;&lt;div custom=&#x27;true&#x27;&gt;&quot; + connection.id + &quot;&lt;/div&gt;&quot;);
            }}]
        ];
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        var o = c.getOverlay(&quot;custom&quot;);
        equal(o.getElement().getAttribute(&quot;custom&quot;), &quot;true&quot;, &quot;custom overlay created correctly&quot;);
        equal(o.getElement().innerHTML, c.id, &quot;custom overlay has correct value&quot;);
    });

    test(&quot;: overlay events&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var clicked = 0;
        var connection1 = _jsPlumb.connect({
            source: d1,
            target: d2,
            overlays: [
                [&quot;Label&quot;, {
                    label: &quot;CONNECTION 1&quot;,
                    location: 0.3,
                    id: &quot;label&quot;,
                    events: {
                        click: function (label, e) {
                            clicked++;
                        }
                    }
                }]
            ]
        });
        var l = connection1.getOverlay(&quot;label&quot;);
        l.fire(&quot;click&quot;, l);
        equal(clicked, 1, &quot;click event was fired once&quot;);
    });


    // this test is for the original detach function; it should stay working after i mess with it
    // a little.
    test(&quot;: _jsPlumb.detach (by element ids)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1);
        var e2 = _jsPlumb.addEndpoint(d2);
        var e3 = _jsPlumb.addEndpoint(d1);
        var e4 = _jsPlumb.addEndpoint(d2);
        _jsPlumb.connect({ sourceEndpoint: e1, targetEndpoint: e2 });
        _jsPlumb.connect({ sourceEndpoint: e3, targetEndpoint: e4 });  // make two connections to be sure this works ;)
        assertConnectionCount(e1, 1);
        assertConnectionCount(e2, 1);
        assertConnectionCount(e3, 1);
        assertConnectionCount(e4, 1);

        _jsPlumb.detach({source: &quot;d1&quot;, target: &quot;d2&quot;});

        assertConnectionCount(e1, 0);
        assertConnectionCount(e2, 0);
        assertConnectionCount(e3, 0);
        assertConnectionCount(e4, 0);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 0, _jsPlumb);
    });

    // detach is being made to operate more like connect - by taking one argument with a whole 
    // bunch of possible params in it.  if two args are passed in it will continue working
    // in the old way.
    test(&quot;: _jsPlumb.detach (params object, using element ids)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1);
        var e2 = _jsPlumb.addEndpoint(d2);
        _jsPlumb.connect({ sourceEndpoint: e1, targetEndpoint: e2 });
        assertConnectionCount(e1, 1);
        assertConnectionCount(e2, 1);
        _jsPlumb.detach({source: &quot;d1&quot;, target: &quot;d2&quot;});
        assertConnectionCount(e1, 0);
        assertConnectionCount(e2, 0);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 0, _jsPlumb);
    });
    //
    //test(&quot;: _jsPlumb.detach (params object, using target only)&quot;, function() {
     //var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
     //e1 = _jsPlumb.addEndpoint(d1, {maxConnections:2}),
     //e2 = _jsPlumb.addEndpoint(d2),
     //e3 = _jsPlumb.addEndpoint(d3);
     //_jsPlumb.connect({ sourceEndpoint:e1, targetEndpoint:e2 });
     //_jsPlumb.connect({ sourceEndpoint:e1, targetEndpoint:e3 });
     //assertConnectionCount(e1, 2);
     //assertConnectionCount(e2, 1);
     //assertConnectionCount(e3, 1);
     //_jsPlumb.detach({target:&quot;d2&quot;});
     //assertConnectionCount(e1, 1);
     //assertConnectionCount(e2, 0);
     //assertConnectionCount(e3, 1);
     //assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1);
     //});

    test(&quot;: _jsPlumb.detach (params object, using element objects)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1);
        var e2 = _jsPlumb.addEndpoint(d2);
        _jsPlumb.connect({ sourceEndpoint: e1, targetEndpoint: e2 });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        assertConnectionCount(e1, 1);
        assertConnectionCount(e2, 1);
        _jsPlumb.detach({source: d1, target: d2});
        assertConnectionCount(e1, 0);
        assertConnectionCount(e2, 0);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 0, _jsPlumb);
    });

    test(&quot;: _jsPlumb.detach (source and target as endpoint UUIDs)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, {uuid: &quot;abcdefg&quot;});
        ok(_jsPlumb.getEndpoint(&quot;abcdefg&quot;) != null, &quot;e1 exists&quot;);
        var e2 = _jsPlumb.addEndpoint(d2, {uuid: &quot;hijklmn&quot;});
        ok(_jsPlumb.getEndpoint(&quot;hijklmn&quot;) != null, &quot;e2 exists&quot;);
        _jsPlumb.connect({ sourceEndpoint: e1, targetEndpoint: e2 });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        assertConnectionCount(e1, 1);
        assertConnectionCount(e2, 1);
        _jsPlumb.detach({uuids: [&quot;abcdefg&quot;, &quot;hijklmn&quot;]});
        assertConnectionCount(e1, 0);
        assertConnectionCount(e2, 0);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 0, _jsPlumb);
    });

    test(&quot;: _jsPlumb.detach (sourceEndpoint and targetEndpoint supplied)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1);
        var e2 = _jsPlumb.addEndpoint(d2);
        _jsPlumb.connect({ sourceEndpoint: e1, targetEndpoint: e2 });
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 1, _jsPlumb);
        assertConnectionCount(e1, 1);
        assertConnectionCount(e2, 1);
        _jsPlumb.detach({ sourceEndpoint: e1, targetEndpoint: e2 });
        assertConnectionCount(e1, 0);
        assertConnectionCount(e2, 0);
        assertConnectionByScopeCount(_jsPlumb.getDefaultScope(), 0, _jsPlumb);
    });

    test(&quot;: _jsPlumb.makeDynamicAnchors (longhand)&quot;, function () {
        var anchors = [_jsPlumb.makeAnchor([0.2, 0, 0, -1], null, _jsPlumb), _jsPlumb.makeAnchor([1, 0.2, 1, 0], null, _jsPlumb),
            _jsPlumb.makeAnchor([0.8, 1, 0, 1], null, _jsPlumb), _jsPlumb.makeAnchor([0, 0.8, -1, 0], null, _jsPlumb) ];
        var dynamicAnchor = _jsPlumb.makeDynamicAnchor(anchors);
        var a = dynamicAnchor.getAnchors();
        equal(a.length, 4, &quot;Dynamic Anchors has four anchors&quot;);
        for (var i = 0; i &lt; a.length; i++)
            ok(a[i].compute.constructor == Function, &quot;anchor &quot; + i + &quot; well formed&quot;);
    });

    test(&quot;: _jsPlumb.makeDynamicAnchors (shorthand)&quot;, function () {
        var anchors = [
            [0.2, 0, 0, -1],
            [1, 0.2, 1, 0],
            [0.8, 1, 0, 1],
            [0, 0.8, -1, 0]
        ];
        var dynamicAnchor = _jsPlumb.makeDynamicAnchor(anchors);
        var a = dynamicAnchor.getAnchors();
        equal(a.length, 4, &quot;Dynamic Anchors has four anchors&quot;);
        for (var i = 0; i &lt; a.length; i++)
            ok(a[i].compute.constructor == Function, &quot;anchor &quot; + i + &quot; well formed&quot;);
    });

    test(&quot;: Connection.isVisible/setVisible&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c1 = _jsPlumb.connect({source: d1, target: d2});
        equal(true, c1.isVisible(), &quot;Connection is visible after creation.&quot;);
        c1.setVisible(false);
        equal(false, c1.isVisible(), &quot;Connection is not visible after calling setVisible(false).&quot;);
        equal(c1.getConnector().canvas.style.display, &quot;none&quot;);
        c1.setVisible(true);
        equal(true, c1.isVisible(), &quot;Connection is visible after calling setVisible(true).&quot;);
        equal(c1.getConnector().canvas.style.display, &quot;&quot;);
    });


    test(&quot;: Endpoint.isVisible/setVisible basic test (no connections)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1);
        equal(true, e1.isVisible(), &quot;Endpoint is visible after creation.&quot;);
        e1.setVisible(false);
        equal(false, e1.isVisible(), &quot;Endpoint is not visible after calling setVisible(false).&quot;);
        equal(e1.canvas.style.display, &quot;none&quot;);
        e1.setVisible(true);
        equal(true, e1.isVisible(), &quot;Endpoint is visible after calling setVisible(true).&quot;);
        equal(e1.canvas.style.display, &quot;block&quot;);
    });

    test(&quot;: Endpoint.isVisible/setVisible (one connection, other Endpoint&#x27;s visibility should track changes in the source, because it has only this connection.)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1), e2 = _jsPlumb.addEndpoint(d2);
        equal(true, e1.isVisible(), &quot;Endpoint is visible after creation.&quot;);
        var c1 = _jsPlumb.connect({source: e1, target: e2});
        e1.setVisible(false);
        equal(false, e1.isVisible(), &quot;Endpoint is not visible after calling setVisible(false).&quot;);
        equal(false, e2.isVisible(), &quot;other Endpoint is not visible either.&quot;);
        equal(false, c1.isVisible(), &quot;connection between the two is not visible either.&quot;);

        e1.setVisible(true);
        equal(true, e1.isVisible(), &quot;Endpoint is visible after calling setVisible(true).&quot;);
        equal(true, e2.isVisible(), &quot;other Endpoint is visible too&quot;);
        equal(true, c1.isVisible(), &quot;connection between the two is visible too.&quot;);
    });

    test(&quot;: Endpoint.isVisible/setVisible (one connection, other Endpoint&#x27;s visibility should not track changes in the source, because it has another connection.)&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var e1 = _jsPlumb.addEndpoint(d1), e2 = _jsPlumb.addEndpoint(d2, { maxConnections: 2 }), e3 = _jsPlumb.addEndpoint(d3);
        equal(true, e1.isVisible(), &quot;Endpoint is visible after creation.&quot;);
        var c1 = _jsPlumb.connect({source: e1, target: e2});
        var c2 = _jsPlumb.connect({source: e2, target: e3});

        e1.setVisible(false);
        equal(false, e1.isVisible(), &quot;Endpoint is not visible after calling setVisible(false).&quot;);
        equal(true, e2.isVisible(), &quot;other Endpoint should still be visible.&quot;);
        equal(true, e3.isVisible(), &quot;third Endpoint should still be visible.&quot;);
        equal(false, c1.isVisible(), &quot;connection between the two is not visible either.&quot;);
        equal(true, c2.isVisible(), &quot;other connection is visible.&quot;);

        e1.setVisible(true);
        equal(true, e1.isVisible(), &quot;Endpoint is visible after calling setVisible(true).&quot;);
        equal(true, e2.isVisible(), &quot;other Endpoint is visible too&quot;);
        equal(true, c1.isVisible(), &quot;connection between the two is visible too.&quot;);
        equal(true, c2.isVisible(), &quot;other connection is visible.&quot;);
    });

    // tests of the functionality that allows a user to specify that they want elements appended to the document body
    test(&quot; _jsPlumb.setContainer, specified with a selector&quot;, function () {
        _jsPlumb.setContainer(document.body);
        equal(document.getElementById(&quot;container&quot;).childNodes.length, 0, &quot;container has no nodes&quot;);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        equal(document.getElementById(&quot;container&quot;).childNodes.length, 2, &quot;container has two div elements&quot;);  // the divs we added have been added to the &#x27;container&#x27; div.
        // but we have told _jsPlumb to add its canvas to the body, so this connect call should not add another few elements to the container:
        _jsPlumb.connect({source: d1, target: d2});
        equal(document.getElementById(&quot;container&quot;).childNodes.length, 2, &quot;container still has two div elements&quot;);
    });

    // tests of the functionality that allows a user to specify that they want elements appended to some specific container.
    test(&quot; _jsPlumb.setContainer, specified with DOM element&quot;, function () {
        _jsPlumb.setContainer(document.getElementsByTagName(&quot;body&quot;)[0]);
        equal(0, document.getElementById(&quot;container&quot;).childNodes.length);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        equal(2, document.getElementById(&quot;container&quot;).childNodes.length, &quot;two divs added to the container&quot;);  // the divs we added have been added to the &#x27;container&#x27; div.
        // but we have told _jsPlumb to add its canvas to the body, so this connect call should not add another few elements to the container:
        var bodyElementCount = document.body.childNodes.length;
        _jsPlumb.connect({source: d1, target: d2});
        equal(2, document.getElementById(&quot;container&quot;).childNodes.length, &quot;still only two children in container; elements were added to the body by _jsPlumb&quot;);
        // test to see if 3 elements have been added
        equal(bodyElementCount + 3, document.body.childNodes.length, &quot;3 new elements added to the document body&quot;);
    });

    test(&quot; _jsPlumb.setContainer, moves managed nodes&quot;, function () {
        var c2 = _addDiv(&quot;c2&quot;, document.body);
        var c = document.getElementById(&quot;container&quot;);

        equal(c.childNodes.length, 0, &quot;container has no nodes&quot;);
        var d1 = _addDiv(&quot;d1&quot;, c);
        equal(c.childNodes.length, 1, &quot;container has one node&quot;);
        _jsPlumb.manage(&quot;d1&quot;, d1);

        // d2 has d1 as the parent so it should not end up having the container as its parent.
        var d2 = _addDiv(&quot;d2&quot;, d1);

        _jsPlumb.setContainer(&quot;c2&quot;);
        equal(d1.parentNode, c2, &quot;managed node with no connections was moved&quot;);
        equal(c.childNodes.length, 0, &quot;container has no nodes&quot;);
        equal(c2.childNodes.length, 1, &quot;container 2 has one node&quot;);
    });


    var _overlayTest = function(component, fn) {
        var o = component.getOverlays();
        for (var i in o)
            if (! fn(o[i])) return false;

        return true;
    };

    var _ensureContainer = function(component, container) {
        return _overlayTest(component, function(o) {

            return o.canvas ? o.canvas.parentNode == container :  o.getElement().parentNode == container;
        });
    };


    test(&quot; change Container programmatically&quot;, function () {

        _jsPlumb.setContainer(container);

        var newContainer = document.createElement(&quot;div&quot;);
        newContainer.id = &quot;newContainer&quot;;
        document.body.appendChild(newContainer);

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, {
                overlays: [
                    [ &quot;Label&quot;, { label: &quot;FOO&quot;, id: &quot;label&quot; }]
                ]
            }),
            e2 = _jsPlumb.addEndpoint(d2, {
                overlays: [
                    [ &quot;Label&quot;, { label: &quot;FOO&quot;, id: &quot;label&quot; }]
                ]
            }),
            e3 = _jsPlumb.addEndpoint(d1, {
                overlays: [
                    [ &quot;Label&quot;, { label: &quot;FOO&quot;, id: &quot;label&quot; }]
                ]
            });

        var c = _jsPlumb.connect({
            source: e1, target: e2,
            paintStyle: {
                outline: 4,
                outlineStyle: &quot;red&quot;,
                stroke: &quot;red&quot;,
                strokeWidth: 2
            },
            overlays: [
                &quot;Label&quot;, &quot;Arrow&quot;
            ]
        });

        equal(e1.canvas.parentNode, container, &quot;e1 canvas parent is container&quot;);

        equal(c.getConnector().canvas.parentNode, container, &quot;connector parent is container&quot;);

        ok(_ensureContainer(e1, container));
        ok(_ensureContainer(c, container));


        _jsPlumb.setContainer(newContainer);

        equal(e1.canvas.parentNode, newContainer, &quot;e1 canvas parent is newContainer&quot;);
        equal(c.getConnector().canvas.parentNode, newContainer, &quot;connector parent is newContainer&quot;);
        ok(_ensureContainer(e1, newContainer));
        ok(_ensureContainer(c, newContainer));
    });


    test(&quot; detachable defaults to true when connection made between two endpoints&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1), e2 = _jsPlumb.addEndpoint(d2),
            c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.isDetachable(), true, &quot;connection not detachable&quot;);
    });

    test(&quot; connection detachable when target endpoint has connectionsDetachable set to true&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1), e2 = _jsPlumb.addEndpoint(d2, {connectionsDetachable: true}),
            c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.isDetachable(), true, &quot;connection detachable because connectionsDetachable was set on target endpoint&quot;);
    });

    test(&quot; connection detachable when source endpoint has connectionsDetachable set to true&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {connectionsDetachable: true}), e2 = _jsPlumb.addEndpoint(d2),
            c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.isDetachable(), true, &quot;connection detachable because connectionsDetachable was set on source endpoint&quot;);
    });


    test(&quot; Connector has &#x27;type&#x27; member set&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(c.getConnector().type, &quot;Bezier&quot;, &quot;Bezier connector has type set&quot;);

        var c2 = _jsPlumb.connect({source: d1, target: d2, connector: &quot;Straight&quot;});
        equal(c2.getConnector().type, &quot;Straight&quot;, &quot;Straight connector has type set&quot;);

        var c3 = _jsPlumb.connect({source: d1, target: d2, connector: &quot;Flowchart&quot;});
        equal(c3.getConnector().type, &quot;Flowchart&quot;, &quot;Flowchart connector has type set&quot;);
    });

    test(&quot; Endpoints have &#x27;type&#x27; member set&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(c.endpoints[0].type, &quot;Dot&quot;, &quot;Dot endpoint has type set&quot;);

        var c2 = _jsPlumb.connect({source: d1, target: d2, endpoints: [&quot;Rectangle&quot;, &quot;Blank&quot;]});
        equal(c2.endpoints[1].type, &quot;Blank&quot;, &quot;Blank endpoint has type set&quot;);
        equal(c2.endpoints[0].type, &quot;Rectangle&quot;, &quot;Rectangle endpoint has type set&quot;);
    });

    test(&quot; Overlays have &#x27;type&#x27; member set&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);

        var c = _jsPlumb.connect({
            source: d1,
            target: d2,
            overlays: [ &quot;Arrow&quot;, &quot;Label&quot;, &quot;PlainArrow&quot;, &quot;Diamond&quot; ]
        });
        /*equal(c._jsPlumb.overlays[0].type, &quot;Arrow&quot;, &quot;Arrow overlay has type set&quot;);
        equal(c._jsPlumb.overlays[1].type, &quot;Label&quot;, &quot;Label overlay has type set&quot;);
        equal(c._jsPlumb.overlays[2].type, &quot;PlainArrow&quot;, &quot;PlainArrow overlay has type set&quot;);
        equal(c._jsPlumb.overlays[3].type, &quot;Diamond&quot;, &quot;Diamond overlay has type set&quot;);*/
        ok(_overlayTest(c, function(o) {
            return o.type != null;
        }, &quot;type is set&quot;));
    });


    test(&quot; _jsPlumb.hide, original one-arg version&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e = { isSource: true, isTarget: true, maxConnections: -1 },
            e1 = _jsPlumb.addEndpoint(d1, e),
            e2 = _jsPlumb.addEndpoint(d2, e),
            c1 = _jsPlumb.connect({source: e1, target: e2, overlays:[ [ &quot;Label&quot;, { id:&quot;lbl&quot;}]]});

        equal(true, c1.getOverlay(&quot;lbl&quot;).isVisible(), &quot;overlay is visible&quot;);
        equal(true, c1.isVisible(), &quot;Connection 1 is visible after creation.&quot;);
        equal(true, e1.isVisible(), &quot;endpoint 1 is visible after creation.&quot;);
        equal(true, e2.isVisible(), &quot;endpoint 2 is visible after creation.&quot;);

        _jsPlumb.hide(d1);

        equal(false, c1.getOverlay(&quot;lbl&quot;).isVisible(), &quot;overlay is no longer visible&quot;);
        equal(false, c1.isVisible(), &quot;Connection 1 is no longer visible.&quot;);
        equal(true, e1.isVisible(), &quot;endpoint 1 is still visible.&quot;);
        equal(true, e2.isVisible(), &quot;endpoint 2 is still visible.&quot;);

        _jsPlumb.show(d1);

        equal(true, c1.getOverlay(&quot;lbl&quot;).isVisible(), &quot;overlay is no visible again&quot;);
        equal(true, c1.isVisible(), &quot;Connection 1 is visible again.&quot;);
    });

    test(&quot; _jsPlumb.hide, two-arg version, endpoints should also be hidden&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e = { isSource: true, isTarget: true, maxConnections: -1 },
            e1 = _jsPlumb.addEndpoint(d1, e),
            e2 = _jsPlumb.addEndpoint(d2, e),
            c1 = _jsPlumb.connect({source: e1, target: e2});

        equal(true, c1.isVisible(), &quot;Connection 1 is visible after creation.&quot;);
        equal(true, e1.isVisible(), &quot;endpoint 1 is visible after creation.&quot;);
        equal(true, e2.isVisible(), &quot;endpoint 2 is visible after creation.&quot;);

        _jsPlumb.hide(&quot;d1&quot;, true);

        equal(false, c1.isVisible(), &quot;Connection 1 is no longer visible.&quot;);
        equal(false, e1.isVisible(), &quot;endpoint 1 is no longer visible.&quot;);
        equal(true, e2.isVisible(), &quot;endpoint 2 is still visible.&quot;);

        _jsPlumb.show(d1);  // now show d1, but do not alter the endpoints. e1 should still be hidden

        equal(true, c1.isVisible(), &quot;Connection 1 is visible again.&quot;);
        equal(false, e1.isVisible(), &quot;endpoint 1 is no longer visible.&quot;);
        equal(true, e2.isVisible(), &quot;endpoint 2 is still visible.&quot;);
    });

    test(&quot; _jsPlumb.show, two-arg version, endpoints should become visible&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e = { isSource: true, isTarget: true, maxConnections: -1 },
            e1 = _jsPlumb.addEndpoint(d1, e),
            e2 = _jsPlumb.addEndpoint(d2, e),
            c1 = _jsPlumb.connect({source: e1, target: e2});

        _jsPlumb.hide(&quot;d1&quot;, true);

        equal(false, c1.isVisible(), &quot;Connection 1 is no longer visible.&quot;);
        equal(false, e1.isVisible(), &quot;endpoint 1 is no longer visible.&quot;);
        equal(true, e2.isVisible(), &quot;endpoint 2 is still visible.&quot;);

        _jsPlumb.show(d1, true);  // now show d1, and alter the endpoints. e1 should be visible.

        equal(true, c1.isVisible(), &quot;Connection 1 is visible again.&quot;);
        equal(true, e1.isVisible(), &quot;endpoint 1 is visible again.&quot;);
        equal(true, e2.isVisible(), &quot;endpoint 2 is still visible.&quot;);
    });

    test(&quot; _jsPlumb.show, two-arg version, endpoints should become visible, but not all connections, because some other endpoints are  not visible.&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            e = { isSource: true, isTarget: true, maxConnections: -1 },
            e1 = _jsPlumb.addEndpoint(d1, e),
            e11 = _jsPlumb.addEndpoint(d1, e),
            e2 = _jsPlumb.addEndpoint(d2, e),
            e3 = _jsPlumb.addEndpoint(d3, e),
            c1 = _jsPlumb.connect({source: e1, target: e2}),
            c2 = _jsPlumb.connect({source: e11, target: e3});

        // we now have d1 connected to both d3 and d2.  we&#x27;ll hide d1, and everything on d1 should be hidden.

        _jsPlumb.hide(&quot;d1&quot;, true);

        equal(false, c1.isVisible(), &quot;connection 1 is no longer visible.&quot;);
        equal(false, c2.isVisible(), &quot;connection 2 is no longer visible.&quot;);
        equal(false, e1.isVisible(), &quot;endpoint 1 is no longer visible.&quot;);
        equal(false, e11.isVisible(), &quot;endpoint 1 is no longer visible.&quot;);
        equal(true, e2.isVisible(), &quot;endpoint 2 is still visible.&quot;);
        equal(true, e3.isVisible(), &quot;endpoint 3 is still visible.&quot;);

        // now, we will also hide d3. making d1 visible again should NOT result in c2 becoming visible, because the other endpoint
        // for c2 is e3, which is not visible.
        _jsPlumb.hide(d3, true);
        equal(false, e3.isVisible(), &quot;endpoint 3 is no longer visible.&quot;);

        _jsPlumb.show(d1, true);  // now show d1, and alter the endpoints. e1 should be visible, c1 should be visible, but c2 should not.

        equal(true, c1.isVisible(), &quot;Connection 1 is visible again.&quot;);
        equal(false, c2.isVisible(), &quot;Connection 2 is not visible.&quot;);
        equal(true, e1.isVisible(), &quot;endpoint 1 is visible again.&quot;);
        equal(true, e11.isVisible(), &quot;endpoint 11 is visible again.&quot;);
        equal(true, e2.isVisible(), &quot;endpoint 2 is still visible.&quot;);
        equal(false, e3.isVisible(), &quot;endpoint 3 is still not visible.&quot;);
    });

    test(&quot;show/hide Overlays&quot;, function() {
        var c = _jsPlumb.connect({source:_addDiv(&quot;d1&quot;), target:_addDiv(&quot;d2&quot;), overlays:[
            [ &quot;Label&quot;, { &quot;id&quot;:&quot;lbl&quot; } ]
        ]});

        equal(c.getOverlay(&quot;lbl&quot;).isVisible(), true, &quot;overlay is visible&quot;);
        c.hideOverlays();
        //equal(c.getOverlay(&quot;lbl&quot;).canvas.style.display, &quot;none&quot;, &quot;overlay not visible&quot;);
        equal(c.getOverlay(&quot;lbl&quot;).isVisible(), false, &quot;overlay is not visible&quot;);
        c.showOverlays();
        equal(c.getOverlay(&quot;lbl&quot;).isVisible(), true, &quot;overlay is visible&quot;);
    });

    //
     //test(&quot; _jsPlumb.hide, two-arg version, endpoints should also be hidden&quot;, function() {
     //var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
     //e = { isSource:true, isTarget:true, maxConnections:-1 },
     //e1 = _jsPlumb.addEndpoint(d1, e),
     //e2 = _jsPlumb.addEndpoint(d2, e),
     //c1 = _jsPlumb.connect({source:e1, target:e2});

     //equal(true, c1.isVisible(), &quot;Connection 1 is visible after creation.&quot;);
     //equal(true, e1.isVisible(), &quot;endpoint 1 is visible after creation.&quot;);
     //equal(true, e2.isVisible(), &quot;endpoint 2 is visible after creation.&quot;);

     //_jsPlumb.hide(&quot;d1&quot;, true);

     //equal(false, c1.isVisible(), &quot;Connection 1 is no longer visible.&quot;);
     //equal(false, e1.isVisible(), &quot;endpoint 1 is no longer visible.&quot;);
     //equal(true, e2.isVisible(), &quot;endpoint 2 is still visible.&quot;);
     //});

     //
     //test for issue 132: label leaves its element in the DOM after it has been
     //removed from a connection.
     //
    test(&quot; label cleans itself up properly&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, overlays: [
            [ &quot;Label&quot;, {id: &quot;label&quot;, cssClass: &quot;foo&quot;}]
        ]});
        ok(jsPlumb.getSelector(&quot;.foo&quot;).length == 1, &quot;label element exists in DOM&quot;);
        c.removeOverlay(&quot;label&quot;);
        ok(_length(c.getOverlays()) == 0, &quot;no overlays left on component&quot;);
        ok(jsPlumb.getSelector(&quot;.foo&quot;).length == 0 , &quot;label element does not exist in DOM&quot;);
    });


    test(&quot; arrow cleans itself up properly&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, overlays: [
            [ &quot;Arrow&quot;, {id: &quot;arrow&quot;}]
        ]});
        ok(c.getOverlay(&quot;arrow&quot;) != null, &quot;arrow overlay exists&quot;);
        c.removeOverlay(&quot;arrow&quot;);
        ok(c.getOverlay(&quot;arrow&quot;) == null, &quot;arrow overlay has been removed&quot;);
    });

    test(&quot; label overlay getElement function&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, overlays: [
            [ &quot;Label&quot;, {id: &quot;label&quot;}]
        ]});
        ok(c.getOverlay(&quot;label&quot;).getElement() != null, &quot;label overlay exposes element via getElement method&quot;);
    });


    test(&quot; label overlay provides getLabel and setLabel methods&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, overlays: [
            [ &quot;Label&quot;, {id: &quot;label&quot;, label: &quot;foo&quot;}]
        ]});
        var o = c.getOverlay(&quot;label&quot;), e = o.getElement();
        equal(e.innerHTML, &quot;foo&quot;, &quot;label text is set to original value&quot;);
        o.setLabel(&quot;baz&quot;);
        equal(e.innerHTML, &quot;baz&quot;, &quot;label text is set to new value &#x27;baz&#x27;&quot;);
        equal(o.getLabel(), &quot;baz&quot;, &quot;getLabel function works correctly with String&quot;);
        // now try functions
        var aFunction = function () {
            return &quot;aFunction&quot;;
        };
        o.setLabel(aFunction);
        equal(e.innerHTML, &quot;aFunction&quot;, &quot;label text is set to new value from Function&quot;);
        equal(o.getLabel(), aFunction, &quot;getLabel function works correctly with Function&quot;);
    });

    test(&quot; label overlay custom css class&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, overlays: [
            [ &quot;Label&quot;, {
                id: &quot;label&quot;,
                cssClass: &quot;foo&quot;
            }]
        ]});
        var o = c.getOverlay(&quot;label&quot;);
        ok(jsPlumb.hasClass(o.getElement(), &quot;foo&quot;), &quot;label overlay has custom css class&quot;);
    });

    test(&quot; label overlay custom css class in labelStyle&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, overlays: [
            [ &quot;Label&quot;, {
                id: &quot;label&quot;,
                labelStyle: {
                    cssClass: &quot;foo&quot;
                }
            }]
        ]});
        var o = c.getOverlay(&quot;label&quot;);
        ok(jsPlumb.hasClass(o.getElement(), &quot;foo&quot;), &quot;label overlay has custom css class&quot;);
    });


    test(&quot; label overlay - labelStyle&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2, overlays: [
            [ &quot;Label&quot;, {
                id: &quot;label&quot;,
                labelStyle: {
                    borderWidth: 2,
                    borderStyle: &quot;red&quot;,
                    fill: &quot;blue&quot;,
                    color: &quot;green&quot;,
                    padding: 10
                }
            }]
        ]});
        var o = c.getOverlay(&quot;label&quot;), el = o.getElement();
        equal(el.style.borderWidth, &quot;2px&quot;, &quot;border width 2&quot;);
        equal(el.style.borderColor, &quot;red&quot;, &quot;border color red&quot;);
        equal(el.style.backgroundColor, &quot;blue&quot;, &quot;bg color blue&quot;);
        equal(el.style.color, &quot;green&quot;, &quot;color green&quot;);

    });

    test(&quot; parameters object works for Endpoint&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;),
            f = function () {
                alert(&quot;FOO!&quot;);
            },
            e = _jsPlumb.addEndpoint(d1, {
                isSource: true,
                parameters: {
                    &quot;string&quot;: &quot;param1&quot;,
                    &quot;int&quot;: 4,
                    &quot;function&quot;: f
                }
            });
        ok(e.getParameter(&quot;string&quot;) === &quot;param1&quot;, &quot;getParameter(String) works correctly&quot;);
        ok(e.getParameter(&quot;int&quot;) === 4, &quot;getParameter(int) works correctly&quot;);
        ok(e.getParameter(&quot;function&quot;) == f, &quot;getParameter(Function) works correctly&quot;);
    });


    test(&quot; parameters object works for Connection&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            f = function () {
                alert(&quot;FOO!&quot;);
            };
        var c = _jsPlumb.connect({
            source: d1,
            target: d2,
            parameters: {
                &quot;string&quot;: &quot;param1&quot;,
                &quot;int&quot;: 4,
                &quot;function&quot;: f
            }
        });
        ok(c.getParameter(&quot;string&quot;) === &quot;param1&quot;, &quot;getParameter(String) works correctly&quot;);
        ok(c.getParameter(&quot;int&quot;) === 4, &quot;getParameter(int) works correctly&quot;);
        ok(c.getParameter(&quot;function&quot;) == f, &quot;getParameter(Function) works correctly&quot;);
    });

    test(&quot; parameters set on Endpoints and Connections are all merged, and merged correctly at that.&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;),
            d2 = _addDiv(&quot;d2&quot;),
            e = _jsPlumb.addEndpoint(d1, {
                isSource: true,
                parameters: {
                    &quot;string&quot;: &quot;sourceEndpoint&quot;,
                    &quot;int&quot;: 0,
                    &quot;function&quot;: function () {
                        return &quot;sourceEndpoint&quot;;
                    }
                }
            }),
            e2 = _jsPlumb.addEndpoint(d2, {
                isTarget: true,
                parameters: {
                    &quot;int&quot;: 1,
                    &quot;function&quot;: function () {
                        return &quot;targetEndpoint&quot;;
                    }
                }
            }),
            c = _jsPlumb.connect({source: e, target: e2, parameters: {
                &quot;function&quot;: function () {
                    return &quot;connection&quot;;
                }
            }});

        ok(c.getParameter(&quot;string&quot;) === &quot;sourceEndpoint&quot;, &quot;getParameter(String) works correctly&quot;);
        ok(c.getParameter(&quot;int&quot;) === 0, &quot;getParameter(int) works correctly&quot;);
        ok(c.getParameter(&quot;function&quot;)() == &quot;connection&quot;, &quot;getParameter(Function) works correctly&quot;);
    });

    // anchor manager tests.  a new and more comprehensive way of managing the paint, introduced in 1.3.5
    test(&quot; anchorManager registers standard connection&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1);
        equal(_jsPlumb.anchorManager.getEndpointsFor(&quot;d1&quot;).length, 1);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1);
        equal(_jsPlumb.anchorManager.getEndpointsFor(&quot;d2&quot;).length, 1);
        var c2 = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 2);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 2);
        equal(_jsPlumb.anchorManager.getEndpointsFor(&quot;d1&quot;).length, 2);
        equal(_jsPlumb.anchorManager.getEndpointsFor(&quot;d2&quot;).length, 2);
    });


    // anchor manager tests.  a new and more comprehensive way of managing the paint, introduced in 1.3.5
    test(&quot; anchorManager registers dynamic anchor connection, and removes it.&quot;, function () {
        var d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        var c = _jsPlumb.connect({source: d3, target: d4, anchors: [&quot;AutoDefault&quot;, &quot;AutoDefault&quot;]});

        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 1);

        var c2 = _jsPlumb.connect({source: d3, target: d4});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 2);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d4&quot;).length, 2);

        equal(_jsPlumb.anchorManager.getEndpointsFor(&quot;d3&quot;).length, 2);
        _jsPlumb.detach(c);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 1);
    });

    // anchor manager tests.  a new and more comprehensive way of managing the paint, introduced in 1.3.5
    test(&quot; anchorManager registers continuous anchor connection, and removes it.&quot;, function () {
        var d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        var c = _jsPlumb.connect({source: d3, target: d4, anchors: [&quot;Continuous&quot;, &quot;Continuous&quot;]});

        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 1);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d4&quot;).length, 1);

        _jsPlumb.detach(c);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 0);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d4&quot;).length, 0);

        _jsPlumb.reset();
        equal(_jsPlumb.anchorManager.getEndpointsFor(&quot;d4&quot;).length, 0);
    });

    test(&quot; Continuous anchor default face, no faces supplied&quot;, function () {
        var d3 = _addDiv(&quot;d3&quot;), ep = _jsPlumb.addEndpoint(d3, {
            anchor: &quot;Continuous&quot;
        });

        equal(ep.anchor.getDefaultFace(), &quot;top&quot;, &quot;default is top when no faces specified&quot;);
    });


    test(&quot; Continuous anchor default face, faces supplied&quot;, function () {
        var d3 = _addDiv(&quot;d3&quot;), ep = _jsPlumb.addEndpoint(d3, {
            anchor: [ &quot;Continuous&quot;, { faces: [ &quot;bottom&quot;, &quot;left&quot; ] } ]
        });

        equal(ep.anchor.getDefaultFace(), &quot;bottom&quot;, &quot;default is bottom&quot;);
    });

    asyncTest(&quot; setImage on Endpoint, with supplied onload&quot;, function () {

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), ep,
            e = {
                endpoint: [ &quot;Image&quot;, {
                    src: &quot;atom.png&quot;,
                    onload: function (imgEp) {
                        QUnit.start();
                        ok(imgEp._jsPlumb.img.src.indexOf(&quot;atom.png&quot;) != -1);
                        ep.setImage(&quot;littledot.png&quot;, function (imgEp) {
                            ok(imgEp._jsPlumb.img.src.indexOf(&quot;littledot.png&quot;) != -1);
                        });
                    }
                } ]
            };


        ep = _jsPlumb.addEndpoint(d1, e);

    });


// issue 190 - regressions with getInstance.  these tests ensure that generated ids are unique across
// instances.    

    test(&quot; id clashes between instances&quot;, function () {
        var d1 = document.createElement(&quot;div&quot;),
            d2 = document.createElement(&quot;div&quot;),
            _jsp2 = jsPlumb.getInstance();

        document.body.appendChild(d1);
        document.body.appendChild(d2);

        _jsPlumb.addEndpoint(d1);
        _jsp2.addEndpoint(d2);

        var id1 = d1.getAttribute(&quot;id&quot;),
            id2 = d2.getAttribute(&quot;id&quot;);

        var idx = id1.indexOf(&quot;_&quot;), idx2 = id1.lastIndexOf(&quot;_&quot;), v1 = id1.substring(idx, idx2);
        var idx3 = id2.indexOf(&quot;_&quot;), idx4 = id2.lastIndexOf(&quot;_&quot;), v2 = id2.substring(idx3, idx4);

        ok(v1 != v2, &quot;instance versions are different : &quot; + v1 + &quot; : &quot; + v2);

        _jsp2.unbindContainer();
    });

    test(&quot; id clashes between instances&quot;, function () {
        var d1 = document.createElement(&quot;div&quot;),
            d2 = document.createElement(&quot;div&quot;);

        document.body.appendChild(d1);
        document.body.appendChild(d2);

        _jsPlumb.addEndpoint(d1);
        _jsPlumb.addEndpoint(d2);

        var id1 = d1.getAttribute(&quot;id&quot;),
            id2 = d2.getAttribute(&quot;id&quot;);

        var idx = id1.indexOf(&quot;_&quot;), idx2 = id1.lastIndexOf(&quot;_&quot;), v1 = id1.substring(idx, idx2);
        var idx3 = id2.indexOf(&quot;_&quot;), idx4 = id2.lastIndexOf(&quot;_&quot;), v2 = id2.substring(idx3, idx4);

        ok(v1 == v2, &quot;instance versions are the same : &quot; + v1 + &quot; : &quot; + v2);
    });



    test(&quot; importDefaults&quot;, function () {
        _jsPlumb.Defaults.Anchors = [&quot;LeftMiddle&quot;, &quot;RightMiddle&quot;];
        var d1 = _addDiv(&quot;d1&quot;),
            d2 = _addDiv(d2),
            c = _jsPlumb.connect({source: d1, target: d2}),
            e = c.endpoints[0];

        equal(e.anchor.x, 0, &quot;left middle anchor&quot;);
        equal(e.anchor.y, 0.5, &quot;left middle anchor&quot;);

        _jsPlumb.importDefaults({
            Anchors: [&quot;TopLeft&quot;, &quot;TopRight&quot;]
        });

        var conn = _jsPlumb.connect({source: d1, target: d2}),
            e1 = conn.endpoints[0], e2 = conn.endpoints[1];

        equal(e1.anchor.x, 0, &quot;top leftanchor&quot;);
        equal(e2.anchor.y, 0, &quot;top left anchor&quot;);
        equal(e2.anchor.x, 1, &quot;top right anchor&quot;);
        equal(e2.anchor.y, 0, &quot;top right anchor&quot;);

    });


    test(&quot; restoreDefaults&quot;, function () {
        _jsPlumb.importDefaults({
            Anchors: [&quot;TopLeft&quot;, &quot;TopRight&quot;]
        });

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), conn = _jsPlumb.connect({source: d1, target: d2}),
            e1 = conn.endpoints[0], e2 = conn.endpoints[1];

        equal(e1.anchor.x, 0, &quot;top leftanchor&quot;);
        equal(e2.anchor.y, 0, &quot;top left anchor&quot;);
        equal(e2.anchor.x, 1, &quot;top right anchor&quot;);
        equal(e2.anchor.y, 0, &quot;top right anchor&quot;);

        _jsPlumb.restoreDefaults();

        var conn2 = _jsPlumb.connect({source: d1, target: d2}),
            e3 = conn2.endpoints[0], e4 = conn2.endpoints[1];

        equal(e3.anchor.x, 0.5, &quot;bottom center anchor&quot;);
        equal(e3.anchor.y, 1, &quot;bottom center anchor&quot;);
        equal(e4.anchor.x, 0.5, &quot;bottom center anchor&quot;);
        equal(e4.anchor.y, 1, &quot;bottom center anchor&quot;);
    });



// setId function

    test(&quot; setId, taking two strings, only default scope&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);

        _jsPlumb.Defaults.MaxConnections = -1;
        var e1 = _jsPlumb.addEndpoint(&quot;d1&quot;),
            e2 = _jsPlumb.addEndpoint(&quot;d2&quot;),
            e3 = _jsPlumb.addEndpoint(&quot;d1&quot;);

        assertEndpointCount(&quot;d1&quot;, 2, _jsPlumb);
        equal(e1.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);

        var c = _jsPlumb.connect({source: e1, target: e2}),
            c2 = _jsPlumb.connect({source: e2, target: e1});

        _jsPlumb.setId(&quot;d1&quot;, &quot;d3&quot;);
        assertEndpointCount(&quot;d3&quot;, 2, _jsPlumb);
        assertEndpointCount(&quot;d1&quot;, 0, _jsPlumb);

        equal(e1.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);

        equal(c.sourceId, &quot;d3&quot;, &quot;connection&#x27;s sourceId has changed&quot;);
        equal(c.source.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s source has changed&quot;);
        equal(c2.targetId, &quot;d3&quot;, &quot;connection&#x27;s targetId has changed&quot;);
        equal(c2.target.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s target has changed&quot;);
    });

    test(&quot; setId, taking a selector and a string, only default scope&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);

        _jsPlumb.Defaults.MaxConnections = -1;
        var e1 = _jsPlumb.addEndpoint(&quot;d1&quot;),
            e2 = _jsPlumb.addEndpoint(&quot;d2&quot;),
            e3 = _jsPlumb.addEndpoint(&quot;d1&quot;);

        assertEndpointCount(&quot;d1&quot;, 2, _jsPlumb);
        equal(e1.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);

        var c = _jsPlumb.connect({source: e1, target: e2}),
            c2 = _jsPlumb.connect({source: e2, target: e1});

        ok(_jsPlumb.getManagedElements()[&quot;d1&quot;] != null, &quot;d1 exists in managed elements&quot;);
        ok(_jsPlumb.getManagedElements()[&quot;d3&quot;] == null, &quot;d3 does not exist in managed elements&quot;);

        _jsPlumb.setId(jsPlumb.getSelector(&quot;#d1&quot;), &quot;d3&quot;);
        assertEndpointCount(&quot;d3&quot;, 2, _jsPlumb);
        assertEndpointCount(&quot;d1&quot;, 0, _jsPlumb);

        equal(e1.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);

        equal(c.sourceId, &quot;d3&quot;, &quot;connection&#x27;s sourceId has changed&quot;);
        equal(c.source.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s source has changed&quot;);
        equal(c2.targetId, &quot;d3&quot;, &quot;connection&#x27;s targetId has changed&quot;);
        equal(c2.target.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s target has changed&quot;);

        ok(_jsPlumb.getManagedElements()[&quot;d1&quot;] == null, &quot;d1 removed from managed elements&quot;);
        ok(_jsPlumb.getManagedElements()[&quot;d3&quot;] != null, &quot;d3 exists in managed elements&quot;);

    });

    test(&quot; setId, taking a DOM element and a string, only default scope&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);

        _jsPlumb.Defaults.MaxConnections = -1;
        var e1 = _jsPlumb.addEndpoint(&quot;d1&quot;),
            e2 = _jsPlumb.addEndpoint(&quot;d2&quot;),
            e3 = _jsPlumb.addEndpoint(&quot;d1&quot;);

        assertEndpointCount(&quot;d1&quot;, 2, _jsPlumb);
        equal(e1.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);

        var c = _jsPlumb.connect({source: e1, target: e2}),
            c2 = _jsPlumb.connect({source: e2, target: e1});

        _jsPlumb.setId(document.getElementById(&quot;d1&quot;), &quot;d3&quot;);
        assertEndpointCount(&quot;d3&quot;, 2, _jsPlumb);
        assertEndpointCount(&quot;d1&quot;, 0, _jsPlumb);

        equal(e1.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);

        equal(c.sourceId, &quot;d3&quot;, &quot;connection&#x27;s sourceId has changed&quot;);
        equal(c.source.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s source has changed&quot;);
        equal(c2.targetId, &quot;d3&quot;, &quot;connection&#x27;s targetId has changed&quot;);
        equal(c2.target.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s target has changed&quot;);
    });

    test(&quot; setId, taking two strings, mix of scopes&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);

        _jsPlumb.Defaults.MaxConnections = -1;
        var e1 = _jsPlumb.addEndpoint(&quot;d1&quot;),
            e2 = _jsPlumb.addEndpoint(&quot;d2&quot;),
            e3 = _jsPlumb.addEndpoint(&quot;d1&quot;);

        assertEndpointCount(&quot;d1&quot;, 2, _jsPlumb);
        equal(e1.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);

        var c = _jsPlumb.connect({source: e1, target: e2, scope: &quot;FOO&quot;}),
            c2 = _jsPlumb.connect({source: e2, target: e1});

        _jsPlumb.setId(&quot;d1&quot;, &quot;d3&quot;);
        assertEndpointCount(&quot;d3&quot;, 2, _jsPlumb);
        assertEndpointCount(&quot;d1&quot;, 0, _jsPlumb);

        equal(e1.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);

        equal(c.sourceId, &quot;d3&quot;, &quot;connection&#x27;s sourceId has changed&quot;);
        equal(c.source.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s source has changed&quot;);
        equal(c2.targetId, &quot;d3&quot;, &quot;connection&#x27;s targetId has changed&quot;);
        equal(c2.target.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s target has changed&quot;);
    });

    test(&quot; setId, taking a selector and a string, mix of scopes&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);

        _jsPlumb.Defaults.MaxConnections = -1;
        var e1 = _jsPlumb.addEndpoint(&quot;d1&quot;),
            e2 = _jsPlumb.addEndpoint(&quot;d2&quot;),
            e3 = _jsPlumb.addEndpoint(&quot;d1&quot;);

        assertEndpointCount(&quot;d1&quot;, 2, _jsPlumb);
        equal(e1.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);

        var c = _jsPlumb.connect({source: e1, target: e2, scope: &quot;FOO&quot;}),
            c2 = _jsPlumb.connect({source: e2, target: e1});

        _jsPlumb.setId(jsPlumb.getSelector(&quot;#d1&quot;), &quot;d3&quot;);
        assertEndpointCount(&quot;d3&quot;, 2, _jsPlumb);
        assertEndpointCount(&quot;d1&quot;, 0, _jsPlumb);

        equal(e1.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);

        equal(c.sourceId, &quot;d3&quot;, &quot;connection&#x27;s sourceId has changed&quot;);
        equal(c.source.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s source has changed&quot;);
        equal(c2.targetId, &quot;d3&quot;, &quot;connection&#x27;s targetId has changed&quot;);
        equal(c2.target.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s target has changed&quot;);
    });

    test(&quot; setId, taking a DOM element and a string, mix of scopes&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);

        _jsPlumb.Defaults.MaxConnections = -1;
        var e1 = _jsPlumb.addEndpoint(&quot;d1&quot;),
            e2 = _jsPlumb.addEndpoint(&quot;d2&quot;),
            e3 = _jsPlumb.addEndpoint(&quot;d1&quot;);

        assertEndpointCount(&quot;d1&quot;, 2, _jsPlumb);
        equal(e1.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);

        var c = _jsPlumb.connect({source: e1, target: e2, scope: &quot;FOO&quot;}),
            c2 = _jsPlumb.connect({source: e2, target: e1});

        _jsPlumb.setId(jsPlumb.getSelector(&quot;#d1&quot;)[0], &quot;d3&quot;);
        assertEndpointCount(&quot;d3&quot;, 2, _jsPlumb);
        assertEndpointCount(&quot;d1&quot;, 0, _jsPlumb);

        equal(e1.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);

        equal(c.sourceId, &quot;d3&quot;, &quot;connection&#x27;s sourceId has changed&quot;);
        equal(c.source.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s source has changed&quot;);
        equal(c2.targetId, &quot;d3&quot;, &quot;connection&#x27;s targetId has changed&quot;);
        equal(c2.target.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s target has changed&quot;);
    });

    test(&quot; setIdChanged, &quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);

        _jsPlumb.Defaults.MaxConnections = -1;
        var e1 = _jsPlumb.addEndpoint(&quot;d1&quot;),
            e2 = _jsPlumb.addEndpoint(&quot;d2&quot;),
            e3 = _jsPlumb.addEndpoint(&quot;d1&quot;);

        assertEndpointCount(&quot;d1&quot;, 2, _jsPlumb);
        equal(e1.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d1&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d1&quot;, &quot;anchor has correct element id&quot;);

        var c = _jsPlumb.connect({source: e1, target: e2}),
            c2 = _jsPlumb.connect({source: e2, target: e1});

        document.getElementById(&quot;d1&quot;).setAttribute(&quot;id&quot;, &quot;d3&quot;);

        _jsPlumb.setIdChanged(&quot;d1&quot;, &quot;d3&quot;);

        assertEndpointCount(&quot;d3&quot;, 2, _jsPlumb);
        assertEndpointCount(&quot;d1&quot;, 0, _jsPlumb);

        equal(e1.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e3.elementId, &quot;d3&quot;, &quot;endpoint has correct element id&quot;);
        equal(e1.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);
        equal(e3.anchor.elementId, &quot;d3&quot;, &quot;anchor has correct element id&quot;);

        equal(c.sourceId, &quot;d3&quot;, &quot;connection&#x27;s sourceId has changed&quot;);
        equal(c.source.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s source has changed&quot;);
        equal(c2.targetId, &quot;d3&quot;, &quot;connection&#x27;s targetId has changed&quot;);
        equal(c2.target.getAttribute(&quot;id&quot;), &quot;d3&quot;, &quot;connection&#x27;s target has changed&quot;);
    });

    test(&quot; setId, taking two strings, testing makeSource/makeTarget&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;);
        var d2 = _addDiv(&quot;d2&quot;);

        // setup d1 as a source
        _jsPlumb.makeSource(&quot;d1&quot;, {
            endpoint:&quot;Rectangle&quot;,
            parameters:{
                foo:&quot;foo&quot;
            }
        });
        // and d2 as a target
        _jsPlumb.makeTarget(&quot;d2&quot;, {
            endpoint:&quot;Rectangle&quot;
        });

        // connect them, and check that the endpoints are of tyoe Rectangle, per the makeSource/makeTarget
        // directives
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;});
        equal(c.endpoints[0].type, &quot;Rectangle&quot;, &quot;source endpoint is rectangle&quot;);
        equal(c.endpoints[1].type, &quot;Rectangle&quot;, &quot;target endpoint is rectangle&quot;);

        // now change the id of d1 and connect the new id, and check again that the source endpoint is Rectangle
        _jsPlumb.setId(d1, &quot;foo&quot;);
        _jsPlumb.setId(d2, &quot;bar&quot;);
        var c2 = _jsPlumb.connect({source: &quot;foo&quot;, target: &quot;bar&quot;});
        equal(c2.endpoints[0].type, &quot;Rectangle&quot;, &quot;source endpoint is rectangle&quot;);
        equal(c2.endpoints[1].type, &quot;Rectangle&quot;, &quot;target endpoint is rectangle&quot;);

    });

    test(&quot; endpoint hide/show should hide/show overlays&quot;, function () {
        _addDiv(&quot;d1&quot;);
        var e1 = _jsPlumb.addEndpoint(&quot;d1&quot;, {
                overlays: [
                    [ &quot;Label&quot;, { id: &quot;label&quot;, label: &quot;foo&quot; } ]
                ]
            }),
            o = e1.getOverlay(&quot;label&quot;);

        ok(o.isVisible(), &quot;overlay is initially visible&quot;);
        _jsPlumb.hide(&quot;d1&quot;, true);
        ok(!o.isVisible(), &quot;overlay is no longer visible&quot;);
    });

    test(&quot; connection hide/show should hide/show overlays&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;,
                overlays: [
                    [ &quot;Label&quot;, { id: &quot;label&quot;, label: &quot;foo&quot; } ]
                ]
            }),
            o = c.getOverlay(&quot;label&quot;);

        ok(o.isVisible(), &quot;overlay is initially visible&quot;);
        _jsPlumb.hide(&quot;d1&quot;, true);
        ok(!o.isVisible(), &quot;overlay is no longer visible&quot;);
    });

    test(&quot; select, basic test&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;}),
            s = _jsPlumb.select({source: &quot;d1&quot;});

        equal(s.length, 1, &quot;one connection selected&quot;);
        equal(s.get(0).sourceId, &quot;d1&quot;, &quot;d1 is connection source&quot;);

        s.setHover(true);
        ok(s.get(0).isHover(), &quot;connection has had hover set to true&quot;);
        s.setHover(false);
        ok(!(s.get(0).isHover()), &quot;connection has had hover set to false&quot;);
    });

    test(&quot; select, basic test with multiple scopes; dont filter on scope.&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;FOO&quot;}),
            c2 = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;BAR&quot;}),
            s = _jsPlumb.select({source: &quot;d1&quot;});

        equal(s.length, 2, &quot;two connections selected&quot;);
        equal(s.get(0).sourceId, &quot;d1&quot;, &quot;d1 is connection source&quot;);

        s.setHover(true);
        ok(s.get(0).isHover(), &quot;connection has had hover set to true&quot;);
        s.setHover(false);
        ok(!(s.get(0).isHover()), &quot;connection has had hover set to false&quot;);
    });

    test(&quot; select, basic test with multiple scopes; filter on scope&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;FOO&quot;}),
            c2 = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;BAR&quot;}),
            s = _jsPlumb.select({source: &quot;d1&quot;, scope: &quot;FOO&quot;});

        equal(s.length, 1, &quot;one connection selected&quot;);
        equal(s.get(0).sourceId, &quot;d1&quot;, &quot;d1 is connection source&quot;);

        s.setHover(true);
        ok(s.get(0).isHover(), &quot;connection has had hover set to true&quot;);
        s.setHover(false);
        ok(!(s.get(0).isHover()), &quot;connection has had hover set to false&quot;);
    });

    test(&quot; select, basic test with multiple scopes; filter on scopes&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;FOO&quot;}),
            c2 = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;BAR&quot;}),
            c3 = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;BAZ&quot;})
        s = _jsPlumb.select({source: &quot;d1&quot;, scope: [&quot;FOO&quot;, &quot;BAR&quot;]});

        equal(s.length, 2, &quot;two connections selected&quot;);
        equal(s.get(0).sourceId, &quot;d1&quot;, &quot;d1 is connection source&quot;);

        s.setHover(true);
        ok(s.get(0).isHover(), &quot;connection has had hover set to true&quot;);
        s.setHover(false);
        ok(!(s.get(0).isHover()), &quot;connection has had hover set to false&quot;);
    });

    test(&quot; select, basic test with multiple scopes; scope but no scope filter; single source id&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;FOO&quot;}),
            c2 = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;BAR&quot;}),
            c3 = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;BAZ&quot;}),
            c4 = _jsPlumb.connect({source: &quot;d2&quot;, target: &quot;d1&quot;, scope: &quot;BOZ&quot;}),
            s = _jsPlumb.select({source: &quot;d1&quot;});

        equal(s.length, 3, &quot;three connections selected&quot;);
        equal(s.get(0).sourceId, &quot;d1&quot;, &quot;d1 is connection source&quot;);

        s.setHover(true);
        ok(s.get(0).isHover(), &quot;connection has had hover set to true&quot;);
        s.setHover(false);
        ok(!(s.get(0).isHover()), &quot;connection has had hover set to false&quot;);
    });

    test(&quot; select, basic test with multiple scopes; filter on scopes; single source id&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;FOO&quot;}),
            c2 = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;BAR&quot;}),
            c3 = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;BAZ&quot;}),
            c4 = _jsPlumb.connect({source: &quot;d2&quot;, target: &quot;d1&quot;, scope: &quot;BOZ&quot;}),
            s = _jsPlumb.select({source: &quot;d1&quot;, scope: [&quot;FOO&quot;, &quot;BAR&quot;, &quot;BOZ&quot;]});

        equal(s.length, 2, &quot;two connections selected&quot;);
        equal(s.get(0).sourceId, &quot;d1&quot;, &quot;d1 is connection source&quot;);

        s.setHover(true);
        ok(s.get(0).isHover(), &quot;connection has had hover set to true&quot;);
        s.setHover(false);
        ok(!(s.get(0).isHover()), &quot;connection has had hover set to false&quot;);
    });

    test(&quot; setHoverSuspended overrides setHover on connections&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;FOO&quot;}),
            c2 = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;BAR&quot;}),
            c3 = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;BAZ&quot;}),
            c4 = _jsPlumb.connect({source: &quot;d2&quot;, target: &quot;d1&quot;, scope: &quot;BOZ&quot;}),
            s = _jsPlumb.select({source: &quot;d1&quot;, scope: [&quot;FOO&quot;, &quot;BAR&quot;, &quot;BOZ&quot;]});

        _jsPlumb.setHoverSuspended(true);
        s.setHover(true);
        ok(s.get(0).isHover() == false, &quot;connection did not set hover as jsplumb overrides it&quot;);
        _jsPlumb.setHoverSuspended(false);
        s.setHover(true);
        ok(s.get(0).isHover(), &quot;connection did set hover as jsplumb override removed&quot;);
    });

    test(&quot; select, basic test with multiple scopes; filter on scope; dont supply sourceid&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;FOO&quot;}),
            c2 = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;BAR&quot;}),
            s = _jsPlumb.select({ scope: &quot;FOO&quot; });

        equal(s.length, 1, &quot;two connections selected&quot;);
        equal(s.get(0).sourceId, &quot;d1&quot;, &quot;d1 is connection source&quot;);

        s.setHover(true);
        ok(s.get(0).isHover(), &quot;connection has had hover set to true&quot;);
        s.setHover(false);
        ok(!(s.get(0).isHover()), &quot;connection has had hover set to false&quot;);
    });

    test(&quot; select, basic test with multiple scopes; filter on scope; dont supply sourceid&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, scope: &quot;FOO&quot;}),
            c2 = _jsPlumb.connect({source: &quot;d2&quot;, target: &quot;d1&quot;, scope: &quot;BAR&quot;}),
            s = _jsPlumb.select({ scope: &quot;FOO&quot; });

        equal(s.length, 1, &quot;two connections selected&quot;);
        equal(s.get(0).sourceId, &quot;d1&quot;, &quot;d1 is connection source&quot;);

        s.setHover(true);
        ok(s.get(0).isHover(), &quot;connection has had hover set to true&quot;);
        s.setHover(false);
        ok(!(s.get(0).isHover()), &quot;connection has had hover set to false&quot;);
    });

    test(&quot; select, two connections, with overlays&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({
                source: &quot;d1&quot;,
                target: &quot;d2&quot;,
                overlays: [
                    [&quot;Label&quot;, {id: &quot;l&quot;}]
                ]
            }),
            c2 = _jsPlumb.connect({
                source: &quot;d1&quot;,
                target: &quot;d2&quot;,
                overlays: [
                    [&quot;Label&quot;, {id: &quot;l&quot;}]
                ]
            }),
            s = _jsPlumb.select({source: &quot;d1&quot;});

        equal(s.length, 2, &quot;two connections selected&quot;);
        ok(s.get(0).getOverlay(&quot;l&quot;) != null, &quot;connection has overlay&quot;);
        ok(s.get(1).getOverlay(&quot;l&quot;) != null, &quot;connection has overlay&quot;);
    });

    test(&quot; select, chaining with setHover and hideOverlay&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({
            source: &quot;d1&quot;,
            target: &quot;d2&quot;,
            overlays: [
                [&quot;Label&quot;, {id: &quot;l&quot;}]
            ]
        });
        s = _jsPlumb.select({source: &quot;d1&quot;});

        s.setHover(false).hideOverlay(&quot;l&quot;);

        ok(!(s.get(0).isHover()), &quot;connection is not hover&quot;);
        ok(!(s.get(0).getOverlay(&quot;l&quot;).isVisible()), &quot;overlay is not visible&quot;);
    });

    test(&quot; select, .each function&quot;, function () {
        for (var i = 1; i &lt; 6; i++) {
            _addDiv(&quot;d&quot; + i);
            _addDiv(&quot;d&quot; + (i * 10));
            _jsPlumb.connect({
                source: &quot;d&quot; + i,
                target: &quot;d&quot; + (i * 10)
            });
        }

        var s = _jsPlumb.select();
        equal(s.length, 5, &quot;there are five connections&quot;);

        var t = &quot;&quot;;
        s.each(function (connection) {
            t += &quot;f&quot;;
        });
        equal(&quot;fffff&quot;, t, &quot;.each is working&quot;);
    });

    test(&quot; select, multiple connections + chaining&quot;, function () {
        for (var i = 1; i &lt; 6; i++) {
            _addDiv(&quot;d&quot; + i);
            _addDiv(&quot;d&quot; + (i * 10));
            _jsPlumb.connect({
                source: &quot;d&quot; + i,
                target: &quot;d&quot; + (i * 10),
                overlays: [
                    [&quot;Arrow&quot;, {location: 0.3}],
                    [&quot;Arrow&quot;, {location: 0.7}]
                ]
            });
        }

        var s = _jsPlumb.select().removeAllOverlays().setParameter(&quot;foo&quot;, &quot;bar&quot;).setHover(false).setLabel(&quot;baz&quot;);
        equal(s.length, 5, &quot;there are five connections&quot;);

        for (var j = 0; j &lt; 5; j++) {
            equal(_length(s.get(j).getOverlays()), 1, &quot;one overlay: the label&quot;);
            equal(s.get(j).getParameter(&quot;foo&quot;), &quot;bar&quot;, &quot;parameter foo has value &#x27;bar&#x27;&quot;);
            ok(!(s.get(j).isHover()), &quot;hover is set to false&quot;);
            equal(s.get(j).getLabel(), &quot;baz&quot;, &quot;label is set to &#x27;baz&#x27;&quot;);
        }
    });

    test(&quot; select, simple getter&quot;, function () {
        for (var i = 1; i &lt; 6; i++) {
            _addDiv(&quot;d&quot; + i);
            _addDiv(&quot;d&quot; + (i * 10));
            _jsPlumb.connect({
                source: &quot;d&quot; + i,
                target: &quot;d&quot; + (i * 10),
                label: &quot;FOO&quot;
            });
        }

        var lbls = _jsPlumb.select().getLabel();
        equal(lbls.length, 5, &quot;there are five labels&quot;);

        for (var j = 0; j &lt; 5; j++) {
            equal(lbls[j][0], &quot;FOO&quot;, &quot;label has value &#x27;FOO&#x27;&quot;);
        }
    });

    test(&quot; select, getter + chaining&quot;, function () {
        for (var i = 1; i &lt; 6; i++) {
            _addDiv(&quot;d&quot; + i);
            _addDiv(&quot;d&quot; + (i * 10));
            _jsPlumb.connect({
                source: &quot;d&quot; + i,
                target: &quot;d&quot; + (i * 10),
                label: &quot;FOO&quot;
            });
        }

        var params = _jsPlumb.select().removeAllOverlays().setParameter(&quot;foo&quot;, &quot;bar&quot;).getParameter(&quot;foo&quot;);
        equal(params.length, 5, &quot;there are five params&quot;);

        for (var j = 0; j &lt; 5; j++) {
            equal(params[j][0], &quot;bar&quot;, &quot;parameter has value &#x27;bar&#x27;&quot;);
        }
    });


    test(&quot; select, detach method&quot;, function () {
        for (var i = 1; i &lt; 6; i++) {
            _addDiv(&quot;d&quot; + i);
            _addDiv(&quot;d&quot; + (i * 10));
            _jsPlumb.connect({
                source: &quot;d&quot; + i,
                target: &quot;d&quot; + (i * 10),
                label: &quot;FOO&quot;
            });
        }

        var params = _jsPlumb.select().detach();

        equal(_jsPlumb.select().length, 0, &quot;there are no connections&quot;);
    });

    test(&quot; select, repaint method&quot;, function () {
        for (var i = 1; i &lt; 6; i++) {
            _addDiv(&quot;d&quot; + i);
            _addDiv(&quot;d&quot; + (i * 10));
            _jsPlumb.connect({
                source: &quot;d&quot; + i,
                target: &quot;d&quot; + (i * 10),
                label: &quot;FOO&quot;
            });
        }

        var len = _jsPlumb.select().repaint().length;

        equal(len, 5, &quot;there are five connections&quot;);
    });


    // selectEndpoints
    test(&quot; selectEndpoints, basic tests&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1),
            e2 = _jsPlumb.addEndpoint(d1);

        equal(_jsPlumb.selectEndpoints().length, 2, &quot;there are two endpoints&quot;);
        equal(_jsPlumb.selectEndpoints({element: &quot;d1&quot;}).length, 2, &quot;there are two endpoints on d1&quot;);
        equal(_jsPlumb.selectEndpoints({element: &quot;d2&quot;}).length, 0, &quot;there are 0 endpoints on d2&quot;);

        equal(_jsPlumb.selectEndpoints({source: &quot;d1&quot;}).length, 0, &quot;there are zero source endpoints on d1&quot;);
        equal(_jsPlumb.selectEndpoints({target: &quot;d1&quot;}).length, 0, &quot;there are zero target endpoints on d1&quot;);
        equal(_jsPlumb.selectEndpoints({source: &quot;d2&quot;}).length, 0, &quot;there are zero source endpoints on d2&quot;);
        equal(_jsPlumb.selectEndpoints({target: &quot;d2&quot;}).length, 0, &quot;there are zero target endpoints on d2&quot;);

        equal(_jsPlumb.selectEndpoints({source: &quot;d1&quot;, scope: &quot;FOO&quot;}).length, 0, &quot;there are zero source endpoints on d1 with scope FOO&quot;);

        _jsPlumb.addEndpoint(&quot;d2&quot;, { scope: &quot;FOO&quot;, isSource: true });
        equal(_jsPlumb.selectEndpoints({source: &quot;d2&quot;, scope: &quot;FOO&quot;}).length, 1, &quot;there is one source endpoint on d2 with scope FOO&quot;);

        equal(_jsPlumb.selectEndpoints({element: [&quot;d2&quot;, &quot;d1&quot;]}).length, 3, &quot;there are three endpoints between d2 and d1&quot;);
    });

    test(&quot; selectEndpoints, basic tests, various input argument formats&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1),
            e2 = _jsPlumb.addEndpoint(d1);

        equal(_jsPlumb.selectEndpoints({element: &quot;d1&quot;}).length, 2, &quot;using id, there are two endpoints on d1&quot;);
        equal(_jsPlumb.selectEndpoints({element: d1}).length, 2, &quot;using dom element, there are two endpoints on d1&quot;);
        equal(_jsPlumb.selectEndpoints({element: jsPlumb.getSelector(&quot;#d1&quot;)}).length, 2, &quot;using selector, there are two endpoints on d1&quot;);
        equal(_jsPlumb.selectEndpoints({element: jsPlumb.getSelector(d1)}).length, 2, &quot;using selector with dom element, there are two endpoints on d1&quot;);

    });

    test(&quot; selectEndpoints, basic tests, scope&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {scope: &quot;FOO&quot;}),
            e2 = _jsPlumb.addEndpoint(d1);

        equal(_jsPlumb.selectEndpoints({element: &quot;d1&quot;}).length, 2, &quot;using id, there are two endpoints on d1&quot;);
        equal(_jsPlumb.selectEndpoints({element: &quot;d1&quot;, scope: &quot;FOO&quot;}).length, 1, &quot;using id, there is one endpoint on d1 with scope &#x27;FOO&#x27;&quot;);
        _jsPlumb.addEndpoint(d1, {scope: &quot;BAR&quot;}),
            equal(_jsPlumb.selectEndpoints({element: &quot;d1&quot;, scope: &quot;FOO&quot;}).length, 1, &quot;using id, there is one endpoint on d1 with scope &#x27;BAR&#x27;&quot;);
        equal(_jsPlumb.selectEndpoints({element: &quot;d1&quot;, scope: [&quot;BAR&quot;, &quot;FOO&quot;]}).length, 2, &quot;using id, there are two endpoints on d1 with scope &#x27;BAR&#x27; or &#x27;FOO&#x27;&quot;);
    });

    test(&quot; selectEndpoints, isSource tests&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {isSource: true}),
            e2 = _jsPlumb.addEndpoint(d1),
            e3 = _jsPlumb.addEndpoint(d2, {isSource: true});

        equal(_jsPlumb.selectEndpoints({source: &quot;d1&quot;}).length, 1, &quot;there is one source endpoint on d1&quot;);
        equal(_jsPlumb.selectEndpoints({target: &quot;d1&quot;}).length, 0, &quot;there are zero target endpoints on d1&quot;);

        equal(_jsPlumb.selectEndpoints({source: &quot;d2&quot;}).length, 1, &quot;there is one source endpoint on d2&quot;);

        equal(_jsPlumb.selectEndpoints({source: [&quot;d2&quot;, &quot;d1&quot;]}).length, 2, &quot;there are two source endpoints between d1 and d2&quot;);
    });

    test(&quot; selectEndpoints, isTarget tests&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {isTarget: true}),
            e2 = _jsPlumb.addEndpoint(d1),
            e3 = _jsPlumb.addEndpoint(d2, {isTarget: true});

        equal(_jsPlumb.selectEndpoints({target: &quot;d1&quot;}).length, 1, &quot;there is one target endpoint on d1&quot;);
        equal(_jsPlumb.selectEndpoints({source: &quot;d1&quot;}).length, 0, &quot;there are zero source endpoints on d1&quot;);

        equal(_jsPlumb.selectEndpoints({target: &quot;d2&quot;}).length, 1, &quot;there is one target endpoint on d2&quot;);

        equal(_jsPlumb.selectEndpoints({target: [&quot;d2&quot;, &quot;d1&quot;]}).length, 2, &quot;there are two target endpoints between d1 and d2&quot;);
    });

    test(&quot; selectEndpoints, isSource + isTarget tests&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {isSource: true, isTarget: true}),
            e2 = _jsPlumb.addEndpoint(d1),
            e3 = _jsPlumb.addEndpoint(d1, {isSource: true}),
            e4 = _jsPlumb.addEndpoint(d1, {isTarget: true});

        equal(_jsPlumb.selectEndpoints({source: &quot;d1&quot;}).length, 2, &quot;there are two source endpoints on d1&quot;);
        equal(_jsPlumb.selectEndpoints({target: &quot;d1&quot;}).length, 2, &quot;there are two target endpoints on d1&quot;);

        equal(_jsPlumb.selectEndpoints({target: &quot;d1&quot;, source: &quot;d1&quot;}).length, 1, &quot;there is one source and target endpoint on d1&quot;);

        equal(_jsPlumb.selectEndpoints({element: &quot;d1&quot;}).length, 4, &quot;there are four endpoints on d1&quot;);

    });

    test(&quot; selectEndpoints, delete endpoints&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {isSource: true, isTarget: true});

        equal(_jsPlumb.selectEndpoints({element: &quot;d1&quot;}).length, 1, &quot;there is one endpoint on d1&quot;);
        _jsPlumb.selectEndpoints({source: &quot;d1&quot;}).remove();
        equal(_jsPlumb.selectEndpoints({element: &quot;d1&quot;}).length, 0, &quot;there are zero endpoints on d1&quot;);
    });

    test(&quot; selectEndpoints, detach connections&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {isSource: true, isTarget: true}),
            e2 = _jsPlumb.addEndpoint(d2, {isSource: true, isTarget: true});

        _jsPlumb.connect({source: e1, target: e2});

        equal(e1.connections.length, 1, &quot;there is one connection on d1&#x27;s endpoint&quot;);
        equal(e2.connections.length, 1, &quot;there is one connection on d2&#x27;s endpoint&quot;);

        _jsPlumb.selectEndpoints({source: &quot;d1&quot;}).detachAll();

        equal(e1.connections.length, 0, &quot;there are zero connections on d1&#x27;s endpoint&quot;);
        equal(e2.connections.length, 0, &quot;there are zero connections on d2&#x27;s endpoint&quot;);
    });

    test(&quot; selectEndpoints, hover tests&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {isSource: true, isTarget: true});

        equal(e1.isHover(), false, &quot;hover not set&quot;);
        _jsPlumb.selectEndpoints({source: &quot;d1&quot;}).setHover(true);
        equal(e1.isHover(), true, &quot;hover set&quot;);
        _jsPlumb.selectEndpoints({source: &quot;d1&quot;}).setHover(false);
        equal(e1.isHover(), false, &quot;hover no longer set&quot;);
    });

    test(&quot; selectEndpoints, setEnabled tests&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {isSource: true, isTarget: true});

        equal(e1.isEnabled(), true, &quot;endpoint is enabled&quot;);
        _jsPlumb.selectEndpoints({source: &quot;d1&quot;}).setEnabled(false);
        equal(e1.isEnabled(), false, &quot;endpoint not enabled&quot;);
    });

    test(&quot; selectEndpoints, setEnabled tests&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), _d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {isSource: true, isTarget: true});

        equal(e1.isEnabled(), true, &quot;endpoint is enabled&quot;);
        var e = _jsPlumb.selectEndpoints({source: &quot;d1&quot;}).isEnabled();
        equal(e[0][0], true, &quot;endpoint enabled&quot;);
        _jsPlumb.selectEndpoints({source: &quot;d1&quot;}).setEnabled(false);
        e = _jsPlumb.selectEndpoints({source: &quot;d1&quot;}).isEnabled();
        equal(e[0][0], false, &quot;endpoint not enabled&quot;);
    });

// setPaintStyle/getPaintStyle tests

    test(&quot; setPaintStyle&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), c = _jsPlumb.connect({source: d1, target: d2});
        c.setPaintStyle({stroke: &quot;FOO&quot;, strokeWidth: 999});
        equal(c._jsPlumb.paintStyleInUse.stroke, &quot;FOO&quot;, &quot;stroke was set&quot;);
        equal(c._jsPlumb.paintStyleInUse.strokeWidth, 999, &quot;strokeWidth was set&quot;);

        c.setHoverPaintStyle({stroke: &quot;BAZ&quot;, strokeWidth: 444});
        c.setHover(true);
        equal(c._jsPlumb.paintStyleInUse.stroke, &quot;BAZ&quot;, &quot;stroke was set&quot;);
        equal(c._jsPlumb.paintStyleInUse.strokeWidth, 444, &quot;strokeWidth was set&quot;);

        equal(c.getPaintStyle().stroke, &quot;FOO&quot;, &quot;getPaintStyle returns correct value&quot;);
        equal(c.getHoverPaintStyle().stroke, &quot;BAZ&quot;, &quot;getHoverPaintStyle returns correct value&quot;);
    });

    //
     //TODO figure out if we want this behaviour or not (components do not share paintStyle objects)
     //
     //test(&quot; clone paint style&quot;, function() {
     //var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
     //c = _jsPlumb.connect({source:d1, target:d2, paintStyle:ps}),
     //c2 = _jsPlumb.connect({source:d1, target:d3}),
     //ps = {stroke:&quot;FOO&quot;, strokeWidth:999};

     //c2.setPaintStyle(ps);

     //ps.foo = &quot;bar&quot;;
     //equal(null, c.getPaintStyle().foo, &quot;foo is not set in c paint style&quot;);
     //equal(null, c2.getPaintStyle().foo, &quot;foo is not set in c2 paint style&quot;);
     //});


// ------------------------------- manage -----------------------------------------

    test(&quot;Manage fires events&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), f1 = false;
        _jsPlumb.bind(&quot;manageElement&quot;, function() {
            f1 = true;
        });

        _jsPlumb.manage(&quot;d1&quot;, d1);
        ok(f1, &quot;manageElement event fired&quot;);

        delete _jsPlumb.getManagedElements()[&quot;d1&quot;];
        f1 = false;
        _jsPlumb.manage(&quot;d1&quot;, d1, true);
        ok(!f1, &quot;manageElement event not fired for transient element&quot;);
    });


// ******************* getEndpoints ************************************************

    test(&quot; getEndpoints&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);

        _jsPlumb.addEndpoint(&quot;d1&quot;);
        _jsPlumb.addEndpoint(&quot;d2&quot;);
        _jsPlumb.addEndpoint(&quot;d1&quot;);

        var e = _jsPlumb.getEndpoints(&quot;d1&quot;),
            e2 = _jsPlumb.getEndpoints(&quot;d2&quot;);
        equal(e.length, 2, &quot;two endpoints on d1&quot;);
        equal(e2.length, 1, &quot;one endpoint on d2&quot;);
    });

// ******************  connection type tests - types, type extension, set types, get types etc. also since 2.0.0
// tests for multiple makeSource/makeTarget on a single element (distinguished by their type/filter params) *****************

    test(&quot; set connection type on existing connection&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            cssClass: &quot;FOO&quot;,
            endpoint:&quot;Rectangle&quot;
        };

        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        c.setType(&quot;basic&quot;);
        equal(c.getPaintStyle().strokeWidth, 4, &quot;paintStyle strokeWidth is 4&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;paintStyle stroke is yellow&quot;);
        equal(c.getHoverPaintStyle().stroke, &quot;blue&quot;, &quot;paintStyle stroke is yellow&quot;);
        equal(c.getHoverPaintStyle().strokeWidth, 4, &quot;hoverPaintStyle strokeWidth is 6&quot;);
        ok(_jsPlumb.hasClass(c.canvas, &quot;FOO&quot;), &quot;FOO class was set on canvas&quot;);
        equal(c.endpoints[0].type, &quot;Dot&quot;, &quot;endpoint is not of type rectangle, because that only works for new connections&quot;);
    });

    test(&quot; add connection type on existing connection&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            cssClass: &quot;FOO&quot;
        };

        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        c.addType(&quot;basic&quot;);
        equal(c.getPaintStyle().strokeWidth, 4, &quot;paintStyle strokeWidth is 4&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;paintStyle stroke is yellow&quot;);
        equal(c.getHoverPaintStyle().stroke, &quot;blue&quot;, &quot;paintStyle stroke is yellow&quot;);
        equal(c.getHoverPaintStyle().strokeWidth, 4, &quot;hoverPaintStyle strokeWidth is 6&quot;);
        ok(_jsPlumb.hasClass(c.canvas, &quot;FOO&quot;), &quot;FOO class was set on canvas&quot;);
    });

    test(&quot; set connection type on existing connection then change type&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            cssClass: &quot;FOO&quot;
        };
        var otherType = {
            connector: &quot;Bezier&quot;,
            paintStyle: { stroke: &quot;red&quot;, strokeWidth: 14 },
            hoverPaintStyle: { stroke: &quot;green&quot; },
            cssClass: &quot;BAR&quot;
        };

        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        _jsPlumb.registerConnectionType(&quot;other&quot;, otherType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        c.setType(&quot;basic&quot;);
        equal(c.getPaintStyle().strokeWidth, 4, &quot;paintStyle strokeWidth is 4&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;paintStyle stroke is yellow&quot;);
        equal(c.getHoverPaintStyle().stroke, &quot;blue&quot;, &quot;hoverPaintStyle stroke is blue&quot;);
        equal(c.getHoverPaintStyle().strokeWidth, 4, &quot;hoverPaintStyle strokeWidth is 6&quot;);
        ok(_jsPlumb.hasClass(c.canvas, &quot;FOO&quot;), &quot;FOO class was set on canvas&quot;);

        c.setType(&quot;other&quot;);
        equal(c.getPaintStyle().strokeWidth, 14, &quot;paintStyle strokeWidth is 14&quot;);
        equal(c.getPaintStyle().stroke, &quot;red&quot;, &quot;paintStyle stroke is red&quot;);
        equal(c.getHoverPaintStyle().stroke, &quot;green&quot;, &quot;hoverPaintStyle stroke is green&quot;);
        equal(c.getHoverPaintStyle().strokeWidth, 14, &quot;hoverPaintStyle strokeWidth is 14&quot;);
        ok(!_jsPlumb.hasClass(c.canvas, &quot;FOO&quot;), &quot;FOO class was removed from canvas&quot;);
        ok(_jsPlumb.hasClass(c.canvas, &quot;BAR&quot;), &quot;BAR class was set on canvas&quot;);
    });

    test(&quot; set connection type on existing connection, overlays should be set&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            overlays: [
                &quot;Arrow&quot;
            ]
        };

        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        c.setType(&quot;basic&quot;);
        equal(_length(c.getOverlays()), 1, &quot;one overlay&quot;);
    });

    test(&quot; set connection type on existing connection, overlays should be removed with second type&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            overlays: [
                &quot;Arrow&quot;
            ]
        };
        var otherType = {
            connector: &quot;Bezier&quot;
        };
        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        _jsPlumb.registerConnectionType(&quot;other&quot;, otherType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        c.setType(&quot;basic&quot;);
        c.getConnector().testFlag = true;
        equal(_length(c.getOverlays()), 1, &quot;one overlay after setting &#x60;basic&#x60; type&quot;);
        // set a flag on the overlay; we will test later that re-adding the basic type will not cause a whole new overlay
        // to be created
        _head(c.getOverlays()).testFlag = true;

        c.setType(&quot;other&quot;);
        equal(_length(c.getOverlays()), 0, &quot;no overlays after setting type to &#x60;other&#x60;, which has no overlays&quot;);
        equal(c.getPaintStyle().strokeWidth, _jsPlumb.Defaults.PaintStyle.strokeWidth, &quot;paintStyle strokeWidth is default&quot;);

        c.addType(&quot;basic&quot;);
        equal(_length(c.getOverlays()), 1, &quot;one overlay after reinstating &#x60;basic&#x60; type&quot;);
        ok(c.getConnector().testFlag, &quot;connector is the one that was created on first application of basic type&quot;);
        ok(_head(c.getOverlays()).testFlag, &quot;overlay is the one that was created on first application of basic type&quot;);
    });


    test(&quot; set connection type on existing connection, anchors and connectors created only once&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            anchor:&quot;Continuous&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            overlays: [
                &quot;Arrow&quot;
            ]
        };
        var otherType = {
            connector: &quot;Bezier&quot;,
            anchor:&quot;AutoDefault&quot;
        };

        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        _jsPlumb.registerConnectionType(&quot;other&quot;, otherType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        c.setType(&quot;basic&quot;);
        c.getConnector().testFlag = true;
        c.endpoints[0].anchor.testFlag = &quot;source&quot;;
        c.endpoints[1].anchor.testFlag = &quot;target&quot;;
        _head(c.getOverlays()).testFlag = true;

        c.setType(&quot;other&quot;);
        c.getConnector().testFlag = true;
        ok(c.endpoints[0].anchor.testFlag == null, &quot;test flag not set on source anchor&quot;);
        ok(c.endpoints[1].anchor.testFlag == null, &quot;test flag not set on target anchor&quot;);

        c.addType(&quot;basic&quot;);
        equal(_length(c.getOverlays()), 1, &quot;one overlay after reinstating &#x60;basic&#x60; type&quot;);
        ok(c.getConnector().testFlag, &quot;connector is the one that was created on first application of basic type&quot;);
        equal(c.endpoints[0].anchor.testFlag, &quot;source&quot;, &quot;test flag still set on source anchor: anchor was reused&quot;);
        equal(c.endpoints[1].anchor.testFlag, &quot;target&quot;, &quot;test flag still set on target anchor: anchor was reused&quot;);
        ok(_head(c.getOverlays()).testFlag, &quot;overlay is the one that was created on first application of basic type&quot;);
        ok(_head(c.getOverlays()).path.parentNode != null, &quot;overlay was reattached to the DOM correctly&quot;);
    });

    test(&quot; set connection type on existing connection, hasType + toggleType&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            overlays: [
                &quot;Arrow&quot;
            ]
        };

        _jsPlumb.registerConnectionTypes({
            &quot;basic&quot;: basicType
        });

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        c.setType(&quot;basic&quot;);
        equal(c.hasType(&quot;basic&quot;), true, &quot;connection has &#x27;basic&#x27; type&quot;);
        c.toggleType(&quot;basic&quot;);
        equal(c.hasType(&quot;basic&quot;), false, &quot;connection does not have &#x27;basic&#x27; type&quot;);
        equal(c.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;connection has default stroke style&quot;);
        c.toggleType(&quot;basic&quot;);
        equal(c.hasType(&quot;basic&quot;), true, &quot;connection has &#x27;basic&#x27; type&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has yellow stroke style&quot;);
        equal(_length(c.getOverlays()), 1, &quot;one overlay&quot;);

    });

    test(&quot; set connection type on existing connection, merge tests&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            overlays: [
                &quot;Arrow&quot;
            ],
            cssClass: &quot;FOO&quot;
        };
        // this tests all three merge types: connector should overwrite, strokeWidth should be inserted into
        // basic type&#x27;s params, and arrow overlay should be added to list to end up with two overlays
        var otherType = {
            connector: &quot;Bezier&quot;,
            paintStyle: { strokeWidth: 14 },
            overlays: [
                [&quot;Arrow&quot;, {location: 0.25}]
            ],
            cssClass: &quot;BAR&quot;
        };
        _jsPlumb.registerConnectionTypes({
            &quot;basic&quot;: basicType,
            &quot;other&quot;: otherType
        });

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2, overlays:[  [ &quot;Label&quot;, {id:&quot;LBL&quot;, label:&quot;${lbl}&quot; } ] ]});

        equal(_length(c.getOverlays()), 1, &quot;connectoin has one overlay to begin with&quot;);

        c.setType(&quot;basic&quot;, {lbl:&quot;FOO&quot;});
        equal(c.hasType(&quot;basic&quot;), true, &quot;connection has &#x27;basic&#x27; type&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has yellow stroke style&quot;);
        equal(c.getPaintStyle().strokeWidth, 4, &quot;connection has strokeWidth 4&quot;);
        equal(_length(c.getOverlays()), 2, &quot;two overlays after setting type to &#x27;basic&#x27;&quot;);
        equal(c.getOverlay(&quot;LBL&quot;).getLabel(), &quot;FOO&quot;, &quot;overlay&#x27;s label set via setType parameter&quot;);
        ok(_jsPlumb.hasClass(c.canvas, &quot;FOO&quot;), &quot;FOO class was set on canvas&quot;);

        c.addType(&quot;other&quot;, {lbl:&quot;BAZ&quot;});
        equal(c.hasType(&quot;basic&quot;), true, &quot;connection has &#x27;basic&#x27; type&quot;);
        equal(c.hasType(&quot;other&quot;), true, &quot;connection has &#x27;other&#x27; type&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has yellow stroke style&quot;);
        equal(c.getPaintStyle().strokeWidth, 14, &quot;connection has strokeWidth 14&quot;);
        equal(_length(c.getOverlays()), 3, &quot;three overlays after adding &#x27;other&#x27; type&quot;);
        ok(_jsPlumb.hasClass(c.canvas, &quot;FOO&quot;), &quot;FOO class is still set on canvas&quot;);
        ok(_jsPlumb.hasClass(c.canvas, &quot;BAR&quot;), &quot;BAR class was set on canvas&quot;);
        equal(c.getOverlay(&quot;LBL&quot;).getLabel(), &quot;BAZ&quot;, &quot;overlay&#x27;s label updated via addType parameter is correct&quot;);

        c.removeType(&quot;basic&quot;, {lbl:&quot;FOO&quot;});
        equal(c.hasType(&quot;basic&quot;), false, &quot;connection does not have &#x27;basic&#x27; type&quot;);
        equal(c.hasType(&quot;other&quot;), true, &quot;connection has &#x27;other&#x27; type&quot;);
        equal(c.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;connection has default stroke style&quot;);
        equal(c.getPaintStyle().strokeWidth, 14, &quot;connection has strokeWidth 14&quot;);
        equal(_length(c.getOverlays()), 2, &quot;two overlays after removing &#x27;basic&#x27; type&quot;);
        ok(!_jsPlumb.hasClass(c.canvas, &quot;FOO&quot;), &quot;FOO class was removed from canvas&quot;);
        ok(_jsPlumb.hasClass(c.canvas, &quot;BAR&quot;), &quot;BAR class is still set on canvas&quot;);
        equal(c.getOverlay(&quot;LBL&quot;).getLabel(), &quot;FOO&quot;, &quot;overlay&#x27;s label updated via removeType parameter is correct&quot;);

        c.toggleType(&quot;other&quot;);
        equal(c.hasType(&quot;other&quot;), false, &quot;connection does not have &#x27;other&#x27; type&quot;);
        equal(c.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;connection has default stroke style&quot;);
        equal(c.getPaintStyle().strokeWidth, _jsPlumb.Defaults.PaintStyle.strokeWidth, &quot;connection has default strokeWidth&quot;);
        equal(_length(c.getOverlays()), 1, &quot;one overlay after toggling &#x27;other&#x27; type. this is the original overlay now.&quot;);
        ok(!_jsPlumb.hasClass(c.canvas, &quot;BAR&quot;), &quot;BAR class was removed from canvas&quot;);

        c.removeOverlay(&quot;LBL&quot;);
        equal(_length(c.getOverlays()), 0, &quot;zero overlays after removing the original overlay.&quot;);
    });

    test(&quot;connection type tests, check overlays do not disappear&quot;, function () {
        var connectionTypes = {};
        connectionTypes[&quot;normal&quot;] = {
            paintStyle: {
                stroke: &quot;gray&quot;,
                strokeWidth: 3,
                cssClass: &quot;normal&quot;
            },
            hoverPaintStyle: {
                stroke: &quot;#64c8c8&quot;,
                strokeWidth: 3
            }
        };
        connectionTypes[&quot;selected&quot;] = {
            paintStyle: {
                stroke: &quot;blue&quot;,
                strokeWidth: 3,
                cssClass: &quot;selected&quot;

            },
            hoverPaintStyle: {
                stroke: &quot;#64c8c8&quot;,
                strokeWidth: 3
            }
        };

        _jsPlumb.registerConnectionTypes(connectionTypes);

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({
            source: d1,
            target: d2,
            detachable: true,
            overlays: [
                [&quot;Label&quot;,
                    {
                        label: &quot;hello&quot;,
                        location: 50,
                        id: &quot;myLabel1&quot;,
                        cssClass: &quot;connectionLabel&quot;
                    }
                ]
            ],
            type: &quot;normal&quot;
        });

        var labelOverlay = c.getOverlay(&quot;myLabel1&quot;);
        ok(labelOverlay != null, &quot;label overlay was retrieved&quot;);
        labelOverlay.setLabel(&quot;foo&quot;);
        ok(labelOverlay.getLabel() === &quot;foo&quot;, &quot;label set correctly on overlay&quot;);

        c.addType(&quot;selected&quot;);
        labelOverlay = c.getOverlay(&quot;myLabel1&quot;);
        ok(labelOverlay != null, &quot;label overlay was not blown away&quot;);
        c.removeType(&quot;selected&quot;);
        labelOverlay = c.getOverlay(&quot;myLabel1&quot;);
        ok(labelOverlay != null, &quot;label overlay was not blown away&quot;);

        // see issue #311
        //ok(labelOverlay.getLabel() === &quot;foo&quot;, &quot;label set correctly on overlay&quot;);
    });

    test(&quot;endpoint type tests, check overlays do not disappear&quot;, function () {
        var epTypes = {};
        epTypes[&quot;normal&quot;] = {
            paintStyle: {
                fill: &quot;gray&quot;,
                cssClass: &quot;normal&quot;
            }
        };
        epTypes[&quot;selected&quot;] = {
            paintStyle: {
                fill: &quot;blue&quot;,
                cssClass: &quot;selected&quot;

            },
            hoverPaintStyle: {
                stroke: &quot;#64c8c8&quot;,
                strokeWidth: 3
            }
        };

        _jsPlumb.registerEndpointTypes(epTypes);

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e = _jsPlumb.addEndpoint(d1, {
            overlays: [
                [&quot;Label&quot;,
                    {
                        label: &quot;hello&quot;,
                        location: 50,
                        id: &quot;myLabel1&quot;,
                        cssClass: &quot;connectionLabel&quot;
                    }
                ]
            ],
            type: &quot;normal&quot;
        });

        ok(e.getOverlay(&quot;myLabel1&quot;) != null, &quot;label overlay was retrieved&quot;);

        e.addType(&quot;selected&quot;);
        ok(e.getOverlay(&quot;myLabel1&quot;) != null, &quot;label overlay was not blown away&quot;);
        e.removeType(&quot;selected&quot;);
        ok(e.getOverlay(&quot;myLabel1&quot;) != null, &quot;label overlay was not blown away&quot;);
    });

    test(&quot; connection type tests, space separated arguments&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            overlays: [
                &quot;Arrow&quot;
            ]
        };
        // this tests all three merge types: connector should overwrite, strokeWidth should be inserted into
        // basic type&#x27;s params, and arrow overlay should be added to list to end up with two overlays
        var otherType = {
            connector: &quot;Bezier&quot;,
            paintStyle: { strokeWidth: 14 },
            overlays: [
                [&quot;Arrow&quot;, {location: 0.25}]
            ]
        };
        _jsPlumb.registerConnectionTypes({
            &quot;basic&quot;: basicType,
            &quot;other&quot;: otherType
        });

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        c.setType(&quot;basic other&quot;);
        equal(c.hasType(&quot;basic&quot;), true, &quot;connection has &#x27;basic&#x27; type&quot;);
        equal(c.hasType(&quot;other&quot;), true, &quot;connection has &#x27;other&#x27; type&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has yellow stroke style&quot;);
        equal(c.getPaintStyle().strokeWidth, 14, &quot;connection has strokeWidth 14&quot;);
        equal(_length(c.getOverlays()), 2, &quot;two overlays&quot;);

        c.toggleType(&quot;other basic&quot;);
        equal(c.hasType(&quot;basic&quot;), false, &quot;after toggle, connection does not have &#x27;basic&#x27; type&quot;);
        equal(c.hasType(&quot;other&quot;), false, &quot;after toggle, connection does not have &#x27;other&#x27; type&quot;);
        equal(c.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;after toggle, connection has default stroke style&quot;);
        equal(c.getPaintStyle().strokeWidth, _jsPlumb.Defaults.PaintStyle.strokeWidth, &quot;after toggle, connection has default strokeWidth&quot;);
        equal(_length(c.getOverlays()), 0, &quot;after toggle, no overlays&quot;);

        c.toggleType(&quot;basic other&quot;);
        equal(c.hasType(&quot;basic&quot;), true, &quot;after toggle again, connection has &#x27;basic&#x27; type&quot;);
        equal(c.hasType(&quot;other&quot;), true, &quot;after toggle again, connection has &#x27;other&#x27; type&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;after toggle again, connection has yellow stroke style&quot;);
        equal(c.getPaintStyle().strokeWidth, 14, &quot;after toggle again, connection has strokeWidth 14&quot;);
        equal(_length(c.getOverlays()), 2, &quot;after toggle again, two overlays&quot;);

        c.removeType(&quot;other basic&quot;);
        equal(c.hasType(&quot;basic&quot;), false, &quot;after remove, connection does not have &#x27;basic&#x27; type&quot;);
        equal(c.hasType(&quot;other&quot;), false, &quot;after remove, connection does not have &#x27;other&#x27; type&quot;);
        equal(c.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;after remove, connection has default stroke style&quot;);
        equal(c.getPaintStyle().strokeWidth, _jsPlumb.Defaults.PaintStyle.strokeWidth, &quot;after remove, connection has default strokeWidth&quot;);
        equal(_length(c.getOverlays()), 0, &quot;after remove, no overlays&quot;);

        c.addType(&quot;other basic&quot;);
        equal(c.hasType(&quot;basic&quot;), true, &quot;after add, connection has &#x27;basic&#x27; type&quot;);
        equal(c.hasType(&quot;other&quot;), true, &quot;after add, connection has &#x27;other&#x27; type&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;after add, connection has yellow stroke style&quot;);
        // NOTE here we added the types in the other order to before, so strokeWidth 4 - from basic - should win.
        equal(c.getPaintStyle().strokeWidth, 4, &quot;after add, connection has strokeWidth 4&quot;);
        equal(_length(c.getOverlays()), 2, &quot;after add, two overlays&quot;);
    });

    test(&quot; connection type tests, fluid interface&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            overlays: [
                &quot;Arrow&quot;
            ]
        };
        // this tests all three merge types: connector should overwrite, strokeWidth should be inserted into
        // basic type&#x27;s params, and arrow overlay should be added to list to end up with two overlays
        var otherType = {
            connector: &quot;Bezier&quot;,
            paintStyle: { strokeWidth: 14 },
            overlays: [
                [&quot;Arrow&quot;, {location: 0.25}]
            ]
        };
        _jsPlumb.registerConnectionTypes({
            &quot;basic&quot;: basicType,
            &quot;other&quot;: otherType
        });

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            c = _jsPlumb.connect({source: d1, target: d2}),
            c2 = _jsPlumb.connect({source: d2, target: d3});

        _jsPlumb.select().addType(&quot;basic&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has yellow stroke style&quot;);
        equal(c2.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has yellow stroke style&quot;);

        _jsPlumb.select().toggleType(&quot;basic&quot;);
        equal(c.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;connection has default stroke style&quot;);
        equal(c2.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;connection has default stroke style&quot;);

        _jsPlumb.select().addType(&quot;basic&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has yellow stroke style&quot;);
        equal(c2.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has yellow stroke style&quot;);

        _jsPlumb.select().removeType(&quot;basic&quot;).addType(&quot;other&quot;);
        equal(c.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;connection has default stroke style&quot;);
        equal(c2.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;connection has default stroke style&quot;);


    });

    test(&quot; connection type tests, two types, check separation&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 }
        };
        // this tests all three merge types: connector should overwrite, strokeWidth should be inserted into
        // basic type&#x27;s params, and arrow overlay should be added to list to end up with two overlays
        var otherType = {
            paintStyle: { stroke: &quot;red&quot;, strokeWidth: 14 }
        };
        _jsPlumb.registerConnectionTypes({
            &quot;basic&quot;: basicType,
            &quot;other&quot;: otherType
        });

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            c = _jsPlumb.connect({source: d1, target: d2}),
            c2 = _jsPlumb.connect({source: d2, target: d3});
        c.setType(&quot;basic&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;first connection has yellow stroke style&quot;);
        c2.setType(&quot;other&quot;);

        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;first connection has yellow stroke style&quot;);


    });

    test(&quot; setType when null&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        c.setType(null);
        equal(c.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;connection has default stroke style&quot;);

    });

    test(&quot; setType to unknown type&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        c.setType(&quot;foo&quot;);
        equal(c.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;connection has default stroke style&quot;);

    });

    test(&quot; setType to mix of known and unknown types&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        _jsPlumb.registerConnectionType(&quot;basic&quot;, {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            overlays: [
                &quot;Arrow&quot;
            ]
        });

        c.setType(&quot;basic foo&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has basic type&#x27;s stroke style&quot;);

        c.toggleType(&quot;foo&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has basic type&#x27;s stroke style&quot;);

        c.removeType(&quot;basic baz&quot;);
        equal(c.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;connection has default stroke style&quot;);

        c.addType(&quot;basic foo bar baz&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has basic type&#x27;s stroke style&quot;);

    });

    test(&quot; create connection using type parameter&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);

        _jsPlumb.Defaults.PaintStyle = {stroke: &quot;blue&quot;, strokeWidth: 34};

        _jsPlumb.registerConnectionTypes({
            &quot;basic&quot;: {
                connector: &quot;Flowchart&quot;,
                paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
                hoverPaintStyle: { stroke: &quot;blue&quot; },
                overlays: [
                    &quot;Arrow&quot;
                ],
                endpoint:&quot;Rectangle&quot;
            },
            &quot;other&quot;: {
                paintStyle: { strokeWidth: 14 }
            }
        });

        equal(_jsPlumb.Defaults.PaintStyle.stroke, &quot;blue&quot;, &quot;default value has not been messed up&quot;);

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(c.getPaintStyle().stroke, _jsPlumb.Defaults.PaintStyle.stroke, &quot;connection has default stroke style&quot;);

        c = _jsPlumb.connect({source: d1, target: d2, type: &quot;basic other&quot;});
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has basic type&#x27;s stroke style&quot;);
        equal(c.getPaintStyle().strokeWidth, 14, &quot;connection has other type&#x27;s strokeWidth&quot;);
        equal(c.endpoints[0].type, &quot;Rectangle&quot;, &quot;endpoint is of type rectangle&quot;);

    });

    test(&quot; makeSource connection type is honoured&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);

        _jsPlumb.Defaults.PaintStyle = {stroke: &quot;blue&quot;, strokeWidth: 34};

        _jsPlumb.registerConnectionTypes({
            &quot;basic&quot;: {
                connector: &quot;Flowchart&quot;,
                paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
                hoverPaintStyle: { stroke: &quot;blue&quot; },
                overlays: [
                    &quot;Arrow&quot;
                ],
                endpoint:&quot;Rectangle&quot;
            }
        });

        _jsPlumb.makeSource(d1, {
            connectionType:&quot;basic&quot;
        });

        var c = _jsPlumb.connect({source: d1, target: d2, type:&quot;basic&quot;});
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has basic type&#x27;s stroke style&quot;);
        equal(c.getPaintStyle().strokeWidth, 4, &quot;connection has basic type&#x27;s strokeWidth&quot;);
        equal(c.endpoints[0].type, &quot;Rectangle&quot;, &quot;endpoint is of type rectangle&quot;);

        _jsPlumb.detach(c);

        _jsPlumb.makeTarget(d2, {
            endpoint:&quot;Blank&quot;
        });

        support.dragConnection(d1, d2);
        c = _jsPlumb.select().get(0);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;connection has basic type&#x27;s stroke style&quot;);
        equal(c.getPaintStyle().strokeWidth, 4, &quot;connection has basic type&#x27;s strokeWidth&quot;);
        equal(c.endpoints[0].type, &quot;Rectangle&quot;, &quot;source endpoint is of type rectangle&quot;);
        equal(c.endpoints[1].type, &quot;Blank&quot;, &quot;target endpoint is of type Blank - it was overriden from the type&#x27;s endpoint.&quot;);
    });

    test(&quot; setType, scope&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        _jsPlumb.registerConnectionType(&quot;basic&quot;, {
            connector: &quot;Flowchart&quot;,
            scope: &quot;BANANA&quot;,
            detachable: false,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            overlays: [
                &quot;Arrow&quot;
            ]
        });

        _jsPlumb.Defaults.ConnectionsDetachable = true;//just make sure we&#x27;ve setup the test correctly.

        c.setType(&quot;basic&quot;);
        equal(c.scope, &quot;BANANA&quot;, &quot;scope is correct&quot;);
        equal(c.isDetachable(), false, &quot;not detachable&quot;);

    });

    test(&quot; setType, parameters&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);

        _jsPlumb.registerConnectionType(&quot;basic&quot;, {
            parameters: {
                foo: 1,
                bar: 2,
                baz: 6785962437582
            }
        });

        _jsPlumb.registerConnectionType(&quot;frank&quot;, {
            parameters: {
                bar: 5
            }
        });

        // first try creating one with the parameters
        c = _jsPlumb.connect({source: d1, target: d2, type: &quot;basic&quot;});

        equal(c.getParameter(&quot;foo&quot;), 1, &quot;foo param correct&quot;);
        equal(c.getParameter(&quot;bar&quot;), 2, &quot;bar param correct&quot;);

        c.addType(&quot;frank&quot;);
        equal(c.getParameter(&quot;foo&quot;), 1, &quot;foo param correct&quot;);
        equal(c.getParameter(&quot;bar&quot;), 5, &quot;bar param correct&quot;);
    });

    test(&quot; set connection type on existing connection, parameterised type&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;${strokeColor}&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; }
        };

        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        c.setType(&quot;basic&quot;, { strokeColor: &quot;yellow&quot; });
        equal(c.getPaintStyle().strokeWidth, 4, &quot;paintStyle strokeWidth is 4&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;paintStyle stroke is yellow&quot;);
        equal(c.getHoverPaintStyle().stroke, &quot;blue&quot;, &quot;paintStyle stroke is yellow&quot;);
        equal(c.getHoverPaintStyle().strokeWidth, 4, &quot;hoverPaintStyle strokeWidth is 6&quot;);
    });

    test(&quot; create connection with parameterised type&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;${strokeColor}&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            overlays:[
                [&quot;Label&quot;, {id:&quot;one&quot;, label:&quot;one&quot; }],
                [&quot;Label&quot;, {id:&quot;two&quot;, label:&quot;${label}&quot; }],
                [&quot;Label&quot;, {id:&quot;three&quot;, label:&quot;${missing}&quot; }]
            ]
        };

        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({
                source: d1,
                target: d2,
                type: &quot;basic&quot;,
                data: { strokeColor: &quot;yellow&quot;, label:&quot;label&quot; }
            });

        equal(c.getPaintStyle().strokeWidth, 4, &quot;paintStyle strokeWidth is 4&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;paintStyle stroke is yellow&quot;);
        equal(c.getHoverPaintStyle().stroke, &quot;blue&quot;, &quot;paintStyle stroke is yellow&quot;);
        equal(c.getHoverPaintStyle().strokeWidth, 4, &quot;hoverPaintStyle strokeWidth is 6&quot;);

        var o1 = c.getOverlay(&quot;one&quot;);
        equal(o1.getLabel(),&quot;one&quot;, &quot;static label set correctly&quot;);
        var o2 = c.getOverlay(&quot;two&quot;);
        equal(o2.getLabel(), &quot;label&quot;, &quot;parameterised label with provided value set correctly&quot;);
        var o3 = c.getOverlay(&quot;three&quot;);
        equal(o3.getLabel(), &quot;&quot;, &quot;parameterised label with missing value set correctly&quot;);
    });

    test(&quot; create connection with parameterised type, label&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            overlays: [
                [ &quot;Label&quot;, { label: &quot;${label}&quot;, id: &quot;label&quot;} ]
            ]
        };

        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({
                source: d1,
                target: d2,
                type: &quot;basic&quot;,
                data: { label: &quot;LABEL&quot; }
            }),
            l = c.getOverlay(&quot;label&quot;);

        equal(l.getLabel(), &quot;LABEL&quot;, &quot;label is set correctly&quot;);

    });

    test(&quot; create connection with parameterised type, label, value empty&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            overlays: [
                [ &quot;Label&quot;, { label: &quot;${label}&quot;, id: &quot;label&quot;} ]
            ]
        };

        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({
                source: d1,
                target: d2,
                type: &quot;basic&quot;,
                data: {  }
            }),
            l = c.getOverlay(&quot;label&quot;);

        equal(l.getLabel(), &quot;&quot;, &quot;label is blank when no value provided&quot;);

    });

    test(&quot; reapply parameterised type&quot;, function () {
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;${strokeColor}&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; }
        };

        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            c = _jsPlumb.connect({
                source: d1,
                target: d2
            });

        c.addType(&quot;basic&quot;, { strokeColor: &quot;yellow&quot; });
        equal(c.getPaintStyle().strokeWidth, 4, &quot;paintStyle strokeWidth is 4&quot;);
        equal(c.getPaintStyle().stroke, &quot;yellow&quot;, &quot;paintStyle stroke is yellow&quot;);
        equal(c.getHoverPaintStyle().stroke, &quot;blue&quot;, &quot;paintStyle stroke is yellow&quot;);
        equal(c.getHoverPaintStyle().strokeWidth, 4, &quot;hoverPaintStyle strokeWidth is 6&quot;);

        c.reapplyTypes({ strokeColor: &quot;green&quot; });
        equal(c.getPaintStyle().stroke, &quot;green&quot;, &quot;paintStyle stroke is now green&quot;);
    });

    test(&quot; setType, scope, two types&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            c = _jsPlumb.connect({source: d1, target: d2});

        _jsPlumb.registerConnectionType(&quot;basic&quot;, {
            connector: &quot;Flowchart&quot;,
            scope: &quot;BANANA&quot;,
            detachable: false,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            overlays: [
                &quot;Arrow&quot;
            ]
        });

        _jsPlumb.registerConnectionType(&quot;frank&quot;, {
            scope: &quot;OVERRIDE&quot;,
            detachable: true
        });

        _jsPlumb.Defaults.ConnectionsDetachable = true;//just make sure we&#x27;ve setup the test correctly.

        c.setType(&quot;basic frank&quot;);
        equal(c.scope, &quot;OVERRIDE&quot;, &quot;scope is correct&quot;);
        equal(c.isDetachable(), true, &quot;detachable&quot;);

    });

    test(&quot; create connection from Endpoints - type should be passed through.&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {
                connectionType: &quot;basic&quot;
            }),
            e2 = _jsPlumb.addEndpoint(d2, {
                connectionType: &quot;basic&quot;
            });

        _jsPlumb.registerConnectionTypes({
            &quot;basic&quot;: {
                paintStyle: { stroke: &quot;blue&quot;, strokeWidth: 4 },
                hoverPaintStyle: { stroke: &quot;red&quot; },
                overlays: [
                    &quot;Arrow&quot;
                ]
            },
            &quot;other&quot;: {
                paintStyle: { strokeWidth: 14 }
            }
        });

        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(c.getPaintStyle().stroke, &quot;blue&quot;, &quot;connection has default stroke style&quot;);
    });

    test(&quot; simple Endpoint type tests.&quot;, function () {
        _jsPlumb.registerEndpointType(&quot;basic&quot;, {
            paintStyle: {fill: &quot;blue&quot;},
            cssClass: &quot;FOO&quot;
        });

        _jsPlumb.registerEndpointType(&quot;other&quot;, {
            paintStyle: {fill: &quot;blue&quot;},
            cssClass: &quot;BAR&quot;
        });

        var d = _addDiv(&#x27;d1&#x27;), e = _jsPlumb.addEndpoint(d);
        e.setType(&quot;basic&quot;);
        equal(e.getPaintStyle().fill, &quot;blue&quot;, &quot;fill style is correct&quot;);
        ok(jsPlumb.hasClass(e.canvas, &quot;FOO&quot;), &quot;css class was set&quot;);
        e.removeType(&quot;basic&quot;);
        ok(!jsPlumb.hasClass(e.canvas, &quot;FOO&quot;), &quot;css class was removed&quot;);

        // add basic type again; FOO should be back
        e.addType(&quot;basic&quot;);
        ok(jsPlumb.hasClass(e.canvas, &quot;FOO&quot;), &quot;css class was set&quot;);
        // now set type to something else: FOO should be removed.
        e.setType(&quot;other&quot;);
        ok(!jsPlumb.hasClass(e.canvas, &quot;FOO&quot;), &quot;FOO css class was removed&quot;);
        ok(jsPlumb.hasClass(e.canvas, &quot;BAR&quot;), &quot;BAR css class was added&quot;);

        // toggle type: now BAR css class should be removed
        e.toggleType(&quot;other&quot;);
        ok(!jsPlumb.hasClass(e.canvas, &quot;BAR&quot;), &quot;BAR css class was removed&quot;);

        var d2 = _addDiv(&#x27;d2&#x27;), e2 = _jsPlumb.addEndpoint(d2, {type: &quot;basic&quot;});
        equal(e2.getPaintStyle().fill, &quot;blue&quot;, &quot;fill style is correct&quot;);
    });

    test(&quot; clearTypes&quot;, function () {
        _jsPlumb.registerEndpointType(&quot;basic&quot;, {
            paintStyle: {fill: &quot;blue&quot;},
            cssClass: &quot;FOO&quot;
        });

        var d = _addDiv(&#x27;d1&#x27;), e = _jsPlumb.addEndpoint(d);
        e.setType(&quot;basic&quot;);
        equal(e.getPaintStyle().fill, &quot;blue&quot;, &quot;fill style is correct&quot;);
        ok(jsPlumb.hasClass(e.canvas, &quot;FOO&quot;), &quot;css class was set&quot;);

        e.clearTypes();
        ok(!jsPlumb.hasClass(e.canvas, &quot;FOO&quot;), &quot;FOO css class was removed&quot;);
    });

    test(&quot; new Endpoint, prefer endpointStyle to paintStyle.&quot;, function () {

        var d = _addDiv(&#x27;d1&#x27;),
            e = _jsPlumb.addEndpoint(d, {
                paintStyle: {fill: &quot;blue&quot;},
                endpointStyle: {fill: &quot;green&quot;},
                hoverPaintStyle: {fill: &quot;red&quot;},
                endpointHoverStyle: {fill: &quot;yellow&quot;}
            });

        equal(e.getPaintStyle().fill, &quot;green&quot;, &quot;fill style is correct&quot;);
        e.setHover(true);
        equal(e.getHoverPaintStyle().fill, &quot;yellow&quot;, &quot;fill style is correct&quot;);
    });

    test(&quot; Endpoint type, prefer endpointStyle to paintStyle.&quot;, function () {
        _jsPlumb.registerEndpointType(&quot;basic&quot;, {
            paintStyle: {fill: &quot;blue&quot;},
            endpointStyle: {fill: &quot;green&quot;},
            hoverPaintStyle: {fill: &quot;red&quot;},
            endpointHoverStyle: {fill: &quot;yellow&quot;}
        });

        var d = _addDiv(&#x27;d1&#x27;), e = _jsPlumb.addEndpoint(d);
        e.setType(&quot;basic&quot;);
        equal(e.getPaintStyle().fill, &quot;green&quot;, &quot;fill style is correct&quot;);
        e.setHover(true);
        equal(e.getHoverPaintStyle().fill, &quot;yellow&quot;, &quot;fill style is correct&quot;);
    });

    test(&quot; create connection from Endpoints - with connector settings in Endpoint type.&quot;, function () {

        _jsPlumb.registerEndpointTypes({
            &quot;basic&quot;: {
                connector: &quot;Flowchart&quot;,
                connectorOverlays: [
                    &quot;Arrow&quot;
                ],
                connectorStyle: {stroke: &quot;green&quot; },
                connectorHoverStyle: {strokeWidth: 534 },
                paintStyle: { fill: &quot;blue&quot; },
                hoverPaintStyle: { stroke: &quot;red&quot; },
                overlays: [
                    &quot;Arrow&quot;
                ]
            },
            &quot;other&quot;: {
                paintStyle: { fill: &quot;red&quot; }
            }
        });

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {
                type: &quot;basic&quot;
            }),
            e2 = _jsPlumb.addEndpoint(d2);

        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(e1.getPaintStyle().fill, &quot;blue&quot;, &quot;endpoint has fill style specified in Endpoint type&quot;);
        equal(c.getPaintStyle().stroke, &quot;green&quot;, &quot;connection has stroke style specified in Endpoint type&quot;);
        equal(c.getHoverPaintStyle().strokeWidth, 534, &quot;connection has hover style specified in Endpoint type&quot;);
        equal(c.getConnector().type, &quot;Flowchart&quot;, &quot;connector is Flowchart&quot;);
        equal(_length(c._jsPlumb.overlays), 1, &quot;connector has one overlay&quot;);
        equal(_length(e1._jsPlumb.overlays), 1, &quot;endpoint has one overlay&quot;);
    });

    test(&quot; create connection from Endpoints - type should be passed through.&quot;, function () {

        _jsPlumb.registerConnectionTypes({
            &quot;basic&quot;: {
                paintStyle: { stroke: &quot;bazona&quot;, strokeWidth: 4 },
                hoverPaintStyle: { stroke: &quot;red&quot; },
                overlays: [
                    &quot;Arrow&quot;
                ]
            }
        });

        _jsPlumb.registerEndpointType(&quot;basic&quot;, {
            connectionType: &quot;basic&quot;,
            paintStyle: {fill: &quot;GAZOODA&quot;}
        });

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {
                type: &quot;basic&quot;
            }),
            e2 = _jsPlumb.addEndpoint(d2);

        c = _jsPlumb.connect({source: e1, target: e2});
        equal(e1.getPaintStyle().fill, &quot;GAZOODA&quot;, &quot;endpoint has correct paint style, from type.&quot;);
        equal(c.getPaintStyle().stroke, &quot;bazona&quot;, &quot;connection has paint style from connection type, as specified in endpoint type. sweet!&quot;);
    });

    test(&quot; endpoint type&quot;, function () {
        _jsPlumb.registerEndpointTypes({&quot;example&quot;: {hoverPaintStyle: null}});
        //OR
        //jsPlumb.registerEndpointType(&quot;example&quot;, {hoverPaintStyle: null});

        var d = _addDiv(&quot;d&quot;);
        _jsPlumb.addEndpoint(d, {type: &quot;example&quot;});
        _jsPlumb.repaint(d);

        expect(0);
    });


    test(&quot; multiple makeSource registrations, switched by connectionType&quot;, function () {
        _jsPlumb.importDefaults({
            PaintStyle:{strokeWidth:10, stroke:&quot;red&quot;}
        });
        var basicType = {
            connector: &quot;Flowchart&quot;,
            paintStyle: { stroke: &quot;yellow&quot;, strokeWidth: 4 },
            hoverPaintStyle: { stroke: &quot;blue&quot; },
            cssClass: &quot;FOO&quot;
        };
        var otherType = {
            connector: &quot;Straight&quot;,
            paintStyle: { stroke: &quot;red&quot;, strokeWidth: 14 },
            hoverPaintStyle: { stroke: &quot;green&quot; },
            cssClass: &quot;BAR&quot;
        };

        _jsPlumb.registerConnectionType(&quot;basic&quot;, basicType);
        _jsPlumb.registerConnectionType(&quot;other&quot;, otherType);
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);

        _jsPlumb.makeSource(d1, {
            connectionType:&quot;basic&quot;,
            endpoint:&quot;Blank&quot;
        });

        // make a connection with type not provided; we should get the jsplumb defaults, as no default makeSource
        // registration has been made.
        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(c.getPaintStyle().strokeWidth, 10, &quot;connect without type specified gives default type&quot;);
        ok(!jsPlumb.hasClass(c.getConnector().canvas, &quot;FOO&quot;), &quot;css class not set on connector&quot;);

        // make a connection whose type matches a register makeSource type; we should get its params.
        var c2 = _jsPlumb.connect({source: d1, target: d2, type:&quot;basic&quot;});
        equal(c2.getPaintStyle().strokeWidth, 4, &quot;connect with type specified matches&quot;);
        ok(jsPlumb.hasClass(c2.getConnector().canvas, &quot;FOO&quot;), &quot;css class set on connector&quot;);
        equal(c2.endpoints[0].type, &quot;Blank&quot;, &quot;source endpoint is blank, per basic type spec&quot;);

        // next makeSource with a different type and try to match it:
        _jsPlumb.makeSource(d1, {
            connectionType:&quot;other&quot;,
            endpoint:&quot;Rectangle&quot;
        });

        var c3 = _jsPlumb.connect({source: d1, target: d2, type:&quot;other&quot;});
        equal(c3.getPaintStyle().strokeWidth, 14, &quot;connect with type specified matches&quot;);
        ok(jsPlumb.hasClass(c3.getConnector().canvas, &quot;BAR&quot;), &quot;css class set on connector&quot;);
        equal(c3.endpoints[0].type, &quot;Rectangle&quot;, &quot;source endpoint is Rectangle, per basic type spec&quot;);


        // finally add a default registration and connect without specifying type


        /*var c2 = _jsPlumb.connect({source: d1, target: d2, type:&quot;other&quot;});
        equal(c2.getPaintStyle().strokeWidth, 14, &quot;connect with type specified matches&quot;);*/

    });


// elements


    test(&quot;svg gradients cleaned up correctly&quot;, function() {

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var c = _jsPlumb.connect({source:d1, target:d2, paintStyle:{
            gradient: {stops: [
                [0, &quot;#678678&quot;],
                [0.5, &quot;#09098e&quot;],
                [1, &quot;#678678&quot;]
            ]},
            strokeWidth: 5,
            stroke: &quot;#678678&quot;,
            dashstyle: &quot;2 2&quot;
        }});

        var defs = c.canvas.querySelectorAll(&quot;defs&quot;);
        equal(defs.length, 1, &quot;1 defs element&quot;);

        _jsPlumb.draggable(d1);

        support.dragANodeAround(d1);

        defs = c.canvas.querySelectorAll(&quot;defs&quot;);
        equal(defs.length, 1, &quot;1 defs element&quot;);
    });

    test(&quot;node drag events&quot;, function() {

        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var started = false, dragged = false, stopped = false;

        _jsPlumb.draggable(d1, {
            start:function() { started = true; },
            drag:function() { dragged = true; },
            stop:function() { stopped = true; }
        });

        support.dragANodeAround(d1);

        ok(started, &quot;start event fired&quot;);
        ok(dragged, &quot;drag event fired&quot;);
        ok(stopped, &quot;stop event fired&quot;);

        started = false; dragged = false; stopped = false;
        var started2 = false, dragged2 = false, stopped2 = false;

        _jsPlumb.draggable(d1, {
            start:function() { started2 = true; },
            drag:function() { dragged2 = true; },
            stop:function() { stopped2 = true; },
            force:true
        });

        support.dragANodeAround(d1);

        ok(started, &quot;start event fired&quot;);
        ok(dragged, &quot;drag event fired&quot;);
        ok(stopped, &quot;stop event fired&quot;);
        ok(started2, &quot;2nd start event fired&quot;);
        ok(dragged2, &quot;2nd drag event fired&quot;);
        ok(stopped2, &quot;2nd stop event fired&quot;);
    });

// ------------- utility functions - math stuff, mostly --------------------------

    var tolerance = 0.00000005, withinTolerance = function (v1, v2, msg) {
        if (Math.abs(v1 - v2) &lt; tolerance) ok(true, msg + &quot;; expected &quot; + v1 + &quot; and got it&quot;);
        else {
            ok(false, msg + &quot;; expected &quot; + v1 + &quot; got &quot; + v2);
        }
    };

    var types = [
        { v: { &quot;foo&quot;: &quot;bar&quot; }, t: &quot;Object&quot; },
        { v: null, t: &quot;Null&quot; },
        { v: 123, t: &quot;Number&quot; },
        { v: &quot;foo&quot;, t: &quot;String&quot; },
        { v: [1, 2, 3], t: &quot;Array&quot; },
        { v: true, t: &quot;Boolean&quot; },
        { v: new Date(), t: &quot;Date&quot; },
        { v: function () {
        }, t: &quot;Function&quot; }
    ];

    test(&quot;jsPlumbUtil typeof functions&quot;, function () {
        for (var i = 0; i &lt; types.length; i++) {
            var v = types[i].v, f = jsPlumbUtil[&quot;is&quot; + types[i].t];
            // first, test that the object type is identified correctly
            equal(f(v), true, types[i].t + &quot; is recognised as &quot; + types[i].t);
            // now test that everything else is recognised as not being of this type
            for (var j = 0; j &lt; types.length; j++) {
                if (i != j) {
                    var v2 = types[j].v;
                    equal(f(v2), false, types[j].t + &quot; is not recognised as &quot; + types[i].t);
                }
            }
        }
    });

    test(&quot;jsPlumb.extend, filter values&quot;, function () {
        var n = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;],
            t = {&quot;hello&quot;: &quot;hello&quot;, &quot;foo&quot;: &quot;replaced&quot;},
            f = {&quot;foo&quot;: &quot;new&quot;, &quot;bar&quot;: &quot;bar&quot;};

        jsPlumb.extend(t, f, n);
        equal(t.foo, &quot;new&quot;);
        equal(t.hello, &quot;hello&quot;);
        equal(t.bar, &quot;bar&quot;);
    });

    // -- geometry tests have been moved into the jtk-geom project (because that&#x27;s where the code is now) ---

    //
     // test the merge function in jsplumb util: it should create an entirely new object
     //
    test(&quot; jsPlumbUtil.merge&quot;, function () {
        var a = {
                foo: &quot;a_foo&quot;,
                bar: &quot;a_bar&quot;,
                nested: {
                    foo: &quot;a_foo&quot;,
                    bar: &quot;a_bar&quot;
                },
                becomeArray: &quot;foo&quot;,
                becomeArray2: [&quot;foo&quot;]
            },
            b = {
                foo: &quot;b_foo&quot;,
                nested: {
                    foo: &quot;b_foo&quot;
                },
                becomeArray: &quot;bar&quot;,
                becomeArray2: &quot;bar&quot;
            },
            c = jsPlumbUtil.merge(a, b, [ &quot;becomeArray&quot;, &quot;becomeArray2&quot;]);

        equal(c.foo, &quot;b_foo&quot;, &quot;c has b&#x27;s foo&quot;);
        equal(c.nested.foo, &quot;b_foo&quot;, &quot;c has b&#x27;s nested foo&quot;);
        // the &#x27;becomeArray&#x27; values should have been folded into an array
        equal(c.becomeArray.length, 2, &quot;2 values in becomeArray member&quot;);
        // the &#x27;becomeArray2&#x27; value from &#x27;b&#x27; should have been added to &#x27;a&#x27;
        equal(c.becomeArray2.length, 2, &quot;2 values in becomeArray member&quot;);

        // now change c&#x27;s foo. b should be unchanged.
        c.foo = &quot;c_foo&quot;;
        equal(b.foo, &quot;b_foo&quot;, &quot;b has b&#x27;s foo&quot;);
        c.nested.foo = &quot;c_foo&quot;;
        equal(b.nested.foo, &quot;b_foo&quot;, &quot;b has b&#x27;s nested foo&quot;);
        equal(a.nested.foo, &quot;a_foo&quot;, &quot;a has a&#x27;s nested foo&quot;);
    });



    // tests for a bug that i found in 1.3.16, in which an array would not overwrite an existing string.	
    test(&quot; jsPlumbUtil.merge, array overwriting string&quot;, function () {
        var a = {
                foo: &quot;foo&quot;,
                bar: &quot;bar&quot;
            },
            b = {
                foo: [ &quot;bar&quot;, &quot;baz&quot; ],
                bar: {
                    bar: &quot;baz&quot;
                }
            },
            c = jsPlumbUtil.merge(a, b);

        equal(c.foo[0], &quot;bar&quot;, &quot;array was copied correctly&quot;);
        equal(c.bar.bar, &quot;baz&quot;, &quot;object was copied correctly&quot;);
    });

    test(&quot; jsPlumbUtil.clone&quot;, function () {
        var a = {
                nested: {
                    foo: &quot;a_foo&quot;
                }
            },
            b = jsPlumbUtil.clone(a);
        equal(b.nested.foo, &quot;a_foo&quot;, &quot;b has a&#x27;s nested foo&quot;);
        equal(a.nested.foo, &quot;a_foo&quot;, &quot;a has a&#x27;s nested foo&quot;);
        b.nested.foo = &quot;b_foo&quot;;
        equal(b.nested.foo, &quot;b_foo&quot;, &quot;b has b&#x27;s nested foo&quot;);
        equal(a.nested.foo, &quot;a_foo&quot;, &quot;a has a&#x27;s nested foo&quot;);
    });

    test(&quot;jsPlumbUtil.replace&quot;, function () {
        var d, data = function () {
            return {
                foo: {
                    bar: {
                        baz: 23
                    },
                    ber: [
                        {},
                        {
                            baz: 22
                        }
                    ]
                }
            };
        };

        var s1 = &quot;foo.bar.baz&quot;,
            s2 = &quot;foo.ber[1].baz&quot;,
            s3 = &quot;foo.ber[0]&quot;,
            f1 = &quot;foo.qux&quot;,
            f2 = &quot;foo.bar.qux&quot;,
            f3 = &quot;foo.ber[3]&quot;,
            f4 = &quot;foo.ber[0].qux&quot;,
            f5 = &quot;foo.qux.qux&quot;,
            f6 = &quot;foo.qux[6].qux&quot;;
        ;

        d = data();
        jsPlumbUtil.replace(d, s1, 99);
        equal(d.foo.bar.baz, 99, s1 + &quot; successful&quot;);

        d = data();
        jsPlumbUtil.replace(d, s2, 99);
        equal(d.foo.ber[1].baz, 99, s2 + &quot; successful&quot;);

        d = data();
        jsPlumbUtil.replace(d, s3, 99);
        equal(d.foo.ber[0], 99, s3 + &quot; successful&quot;);

        d = data();
        jsPlumbUtil.replace(d, f1, 99);
        equal(d.foo.qux, 99, f1 + &quot; successful&quot;);

        d = data();
        jsPlumbUtil.replace(d, f2, 99);
        equal(d.foo.bar.qux, 99, f2 + &quot; successful&quot;);

        d = data();
        jsPlumbUtil.replace(d, f3, 99);
        equal(d.foo.ber[3], 99, f3 + &quot; successful&quot;);

        d = data();
        jsPlumbUtil.replace(d, f4, 99);
        equal(d.foo.ber[0].qux, 99, f4 + &quot; successful&quot;);

        d = data();
        jsPlumbUtil.replace(d, f5, 99);
        equal(d.foo.qux.qux, 99, f5 + &quot; successful&quot;);

        d = data();
        jsPlumbUtil.replace(d, f6, 99);
        equal(d.foo.qux[6].qux, 99, f6 + &quot; successful&quot;);

        // null test
        jsPlumbUtil.replace(null, f6, 99);
        ok(true, &quot;null argument ignored by util.replace&quot;);

    });


    test(&quot; arc segment tests&quot;, function () {
        var r = 10, circ = 2 * Math.PI * r;
        // first, an arc up and to the right (clockwise)
        var params = { r: r, x1: 0, y1: 0, x2: 10, y2: -10, cx: 10, cy: 0 };
        var s = new jsPlumb.Segments[&quot;Arc&quot;](params);
        // segment should be one quarter of the circumference
        equal(s.getLength(), 0.25 * circ, &quot;length of segment is correct&quot;);
        // point 0 is (0,0)
        var p1 = s.pointOnPath(0);
        within(p1.x, 0, ok, &quot;start x is correct&quot;);
        within(p1.y, 0, ok, &quot;start y is correct&quot;);
        // point 1 is (10, -10)
        var p2 = s.pointOnPath(1);
        within(p2.x, 10, ok, &quot;end x is correct&quot;);
        within(p2.y, -10, ok, &quot;end y is correct&quot;);
        // point at loc 0.5 is (2.92, -7.07))
        var p3 = s.pointOnPath(0.5);
        within(p3.x, 10 - (Math.sqrt(2) / 2 * 10), ok, &quot;end x is correct&quot;);
        within(p3.y, -(Math.sqrt(2) / 2 * 10), ok, &quot;end y is correct&quot;);
        // gradients
        equal(s.gradientAtPoint(0), -Infinity, &quot;gradient at location 0 is -Infinity&quot;);
        equal(s.gradientAtPoint(1), 0, &quot;gradient at location 1 is 0&quot;);
        within(s.gradientAtPoint(0.5), -1, ok, &quot;gradient at location 0.5 is -1&quot;);

        // an arc up and to the left (anticlockwise)
        params = { r: r, x1: 0, y1: 0, x2: -10, y2: -10, cx: -10, cy: 0, ac: true };
        s = new jsPlumb.Segments[&quot;Arc&quot;](params);
        equal(s.getLength(), 0.25 * circ, &quot;length of segment is correct&quot;);
        // point 0 is (0,0)
        p1 = s.pointOnPath(0);
        within(p1.x, 0, ok, &quot;start x is correct&quot;);
        within(p1.y, 0, ok, &quot;start y is correct&quot;);
        // point 1 is (-10, -10)
        p2 = s.pointOnPath(1);
        within(p2.x, -10, ok, &quot;end x is correct&quot;);
        within(p2.y, -10, ok, &quot;end y is correct&quot;);
        // point at loc 0.5 is (-2.92, -7.07))
        p3 = s.pointOnPath(0.5);
        within(p3.x, -2.9289321881345245, ok, &quot;end x is correct&quot;);
        within(p3.y, -7.071067811865477, ok, &quot;end y is correct&quot;);
        // gradients
        equal(s.gradientAtPoint(0), -Infinity, &quot;gradient at location 0 is -Infinity&quot;);
        equal(s.gradientAtPoint(1), 0, &quot;gradient at location 1 is 0&quot;);
        within(s.gradientAtPoint(0.5), 1, ok, &quot;gradient at location 0.5 is 1&quot;);


        // clockwise, 180 degrees
        params = { r: r, x1: 0, y1: 0, x2: 0, y2: 20, cx: 0, cy: 10 };
        s = new jsPlumb.Segments[&quot;Arc&quot;](params);
        equal(s.getLength(), 0.5 * circ, &quot;length of segment is correct&quot;);
        p1 = s.pointOnPath(0);
        within(p1.x, 0, ok, &quot;start x is correct&quot;);
        within(p1.y, 0, ok, &quot;start y is correct&quot;);
        p2 = s.pointOnPath(1);
        within(p2.x, 0, ok, &quot;end x is correct&quot;);
        within(p2.y, 20, ok, &quot;end y is correct&quot;);
        var p3 = s.pointOnPath(0.5);
        within(p3.x, 10, ok, &quot;end x is correct&quot;);
        within(p3.y, 10, ok, &quot;end y is correct&quot;);
        // gradients
        equal(s.gradientAtPoint(0), 0, &quot;gradient at location 0 is 0&quot;);
        equal(s.gradientAtPoint(1), 0, &quot;gradient at location 1 is 0&quot;);
        equal(s.gradientAtPoint(0.5), Infinity, &quot;gradient at location 0.5 is Infinity&quot;);


        // anticlockwise, 180 degrees
        params = { r: r, x1: 0, y1: 0, x2: 0, y2: -20, cx: 0, cy: -10, ac: true };
        s = new jsPlumb.Segments[&quot;Arc&quot;](params);
        equal(s.getLength(), 0.5 * circ, &quot;length of segment is correct&quot;);
        p1 = s.pointOnPath(0);
        within(p1.x, 0, ok, &quot;start x is correct&quot;);
        within(p1.y, 0, ok, &quot;start y is correct&quot;);
        p2 = s.pointOnPath(1);
        within(p2.x, 0, ok, &quot;end x is correct&quot;);
        within(p2.y, -20, ok, &quot;end y is correct&quot;);
        var p3 = s.pointOnPath(0.5);
        within(p3.x, 10, ok, &quot;end x is correct&quot;);
        within(p3.y, -10, ok, &quot;end y is correct&quot;);


        // clockwise, 270 degrees
        params = { r: r, x1: 0, y1: 0, x2: -10, y2: 10, cx: 0, cy: 10 };
        s = new jsPlumb.Segments[&quot;Arc&quot;](params);
        equal(s.getLength(), 0.75 * circ, &quot;length of segment is correct&quot;);
        p1 = s.pointOnPath(0);
        within(p1.x, 0, ok, &quot;start x is correct&quot;);
        within(p1.y, 0, ok, &quot;start y is correct&quot;);
        p2 = s.pointOnPath(1);
        within(p2.x, -10, ok, &quot;end x is correct&quot;);
        within(p2.y, 10, ok, &quot;end y is correct&quot;);
        var p3 = s.pointOnPath(0.5);
        within(p3.x, 7.071067811865477, ok, &quot;end x is correct&quot;);
        within(p3.y, 17.071067811865477, ok, &quot;end y is correct&quot;);


        // anticlockwise, 90 degrees
        params = { r: r, x1: 0, y1: 0, x2: -10, y2: 10, cx: 0, cy: 10, ac: true };
        s = new jsPlumb.Segments[&quot;Arc&quot;](params);
        equal(s.getLength(), 0.25 * circ, &quot;length of segment is correct&quot;);
        p1 = s.pointOnPath(0);
        within(p1.x, 0, ok, &quot;start x is correct&quot;);
        within(p1.y, 0, ok, &quot;start y is correct&quot;);
        p2 = s.pointOnPath(1);
        within(p2.x, -10, ok, &quot;end x is correct&quot;);
        within(p2.y, 10, ok, &quot;end y is correct&quot;);
        var p3 = s.pointOnPath(0.5);
        within(p3.x, -7.071067811865477, ok, &quot;end x is correct&quot;);
        within(p3.y, 2.9289321881345245, ok, &quot;end y is correct&quot;);


        // anticlockwise, 270 degrees
        params = { r: r, x1: 0, y1: 0, x2: 10, y2: 10, cx: 0, cy: 10, ac: true };
        s = new jsPlumb.Segments[&quot;Arc&quot;](params);
        equal(s.getLength(), 0.75 * circ, &quot;length of segment is correct&quot;);
        p1 = s.pointOnPath(0);
        within(p1.x, 0, ok, &quot;start x is correct&quot;);
        within(p1.y, 0, ok, &quot;start y is correct&quot;);
        p2 = s.pointOnPath(1);
        within(p2.x, 10, ok, &quot;end x is correct&quot;);
        within(p2.y, 10, ok, &quot;end y is correct&quot;);
        var p3 = s.pointOnPath(0.5);
        within(p3.x, -7.071067811865477, ok, &quot;end x is correct&quot;);
        within(p3.y, 17.071067811865477, ok, &quot;end y is correct&quot;);


    });

// *********************************** jsPlumbUtil.extend tests *****************************************************

    test(&quot; jsPlumbUtil.extend, single parent&quot;, function () {

        var Parent = function (arg) {
            this.aValue = &quot;parent&quot;;
            this.inputArg = arg;
            console.log(&quot;FOO&quot;);
        };
        Parent.prototype = {
            id: function () {
                return &quot;parent&quot;;
            },
            id2: function () {
                return &quot;parent2&quot;;
            }
        };

        // extend parent and call with no constructor args and nothing overridden.
        var Child = function () {
            Parent.apply(this, arguments);
        };
        jsPlumbUtil.extend(Child, Parent);
        var aChild = new Child();
        equal(aChild.id(), &quot;parent&quot;, &quot;child has inherited parent&#x27;s id method&quot;);
        equal(aChild.id2(), &quot;parent2&quot;, &quot;child has inherited parent&#x27;s id2 method&quot;);
        equal(aChild.aValue, &quot;parent&quot;, &quot;child has inherited parent&#x27;s aValue property&quot;);
        ok(typeof aChild.inputArg == &quot;undefined&quot;, &quot;input argument was undefined&quot;);

        // extend parent and call with a constructor arg
        var anotherChild = new Child(&quot;foo&quot;);
        equal(anotherChild.inputArg, &quot;foo&quot;, &quot;input argument was &#x27;foo&#x27;&quot;);

        // extend parent with a constructor, then call it and check child&#x27;s constructor was run.
        var Child2 = function (arg) {
            Parent.apply(this, arguments);
            this.inputArg = arg + &quot; from child&quot;;
        };
        jsPlumbUtil.extend(Child2, Parent);
        var thirdChild = new Child2(&quot;foo&quot;);
        equal(thirdChild.inputArg, &quot;foo from child&quot;, &quot;input argument was &#x27;foo from child&#x27;&quot;);

        // extend parent with a prototype that overrides the id method
        var Child3 = function () {
            Parent.apply(this, arguments);
        };

        jsPlumbUtil.extend(Child3, Parent, {
            id: function () {
                return &quot;child&quot;;
            },
            id2: function () {
                return &quot;child2&quot;;
            }
        });
        var fourthChild = new Child3(&quot;fourthChild&quot;);
        equal(fourthChild.inputArg, &quot;fourthChild&quot;, &quot;input arg was overriden correctly&quot;);
        equal(fourthChild.id(), &quot;child&quot;, &quot;id method from prototype was overridden&quot;);
        equal(fourthChild.id2(), &quot;child2&quot;, &quot;id method from prototype was overridden&quot;);
    });

    test(&quot; jsPlumbUtil.extend, multiple parents&quot;, function () {

        var Mother = function (arg) {
            this.aValue = &quot;mother&quot;;
            this.inputArg = arg;
            console.log(&quot;Mother&quot;);
        };
        Mother.prototype = {
            id: function () {
                return &quot;mother&quot;;
            },
            mother: function () {
                return &quot;mother&quot;;
            }
        };

        var Father = function (arg) {
            this.aValue = &quot;father&quot;;
            this.inputArg = arg;
            console.log(&quot;Father&quot;);
        };
        Father.prototype = {
            id: function () {
                return &quot;father&quot;;
            },
            father: function () {
                return &quot;father&quot;;
            }
        };

        // extend parent and call with no constructor args and nothing overridden.
        var Child = function () {
            Mother.apply(this, arguments);
            Father.apply(this, arguments);
        };

        jsPlumbUtil.extend(Child, [Mother, Father]);
        var aChild = new Child();
        equal(aChild.id(), &quot;father&quot;, &quot;child has inherited father&#x27;s id method&quot;);
        equal(aChild.mother(), &quot;mother&quot;, &quot;child has inherited mother&#x27;s method&quot;);
        equal(aChild.father(), &quot;father&quot;, &quot;child has inherited father&#x27;s method&quot;);
        equal(aChild.aValue, &quot;father&quot;, &quot;child has inherited father&#x27;s aValue property&quot;);
        ok(typeof aChild.inputArg == &quot;undefined&quot;, &quot;input argument was undefined&quot;);

        // extend parent and call with a constructor arg
        var anotherChild = new Child(&quot;foo&quot;);
        equal(anotherChild.inputArg, &quot;foo&quot;, &quot;input argument was &#x27;foo&#x27;&quot;);

        // extend parents with a constructor, then call it and check child&#x27;s constructor was run.
        var Child2 = function (arg) {
            Mother.apply(this, arguments);
            Father.apply(this, arguments);
            this.inputArg = arg + &quot; from child&quot;;
        };
        jsPlumbUtil.extend(Child2, [Mother, Father]);
        var thirdChild = new Child2(&quot;foo&quot;);
        equal(thirdChild.inputArg, &quot;foo from child&quot;, &quot;input argument was &#x27;foo from child&#x27;&quot;);

        // extend parents with a prototype that overrides the id method
        var Child3 = function () {
            Mother.apply(this, arguments);
            Father.apply(this, arguments);
        };
        jsPlumbUtil.extend(Child3, [Mother, Father], {
            id: function () {
                return &quot;child&quot;;
            }
        });
        var fourthChild = new Child3(&quot;fourthChild&quot;);
        equal(fourthChild.inputArg, &quot;fourthChild&quot;, &quot;input arg was overriden correctly&quot;);
        equal(fourthChild.id(), &quot;child&quot;, &quot;id method from prototype was overridden&quot;);
    });

    test(&quot; jsPlumb.getSelector, simple case&quot;, function () {
        _addDiv(&quot;d1&quot;);
        var s = _jsPlumb.getSelector(&quot;#d1&quot;);
        equal(s.length, 1, &quot;d1 found by getSelector&quot;);
    });

    test(&quot; jsPlumb.getSelector, with context node given as selector&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;);
        var d = makeContent(&quot;&lt;div id=&#x27;foo&#x27;&gt;&lt;/div&gt;&quot;);
        d1.appendChild(jsPlumb.getElement(d));
        var s = _jsPlumb.getSelector(d1, &quot;#foo&quot;);
        equal(s.length, 1, &quot;foo found by getSelector with context d1&quot;);
        equal(s[0].getAttribute(&quot;id&quot;), &quot;foo&quot;, &quot;foo found by getSelector with context d1&quot;);
    });

    test(&quot; jsPlumb.getSelector, with context node given as DOM element&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;);
        var d = makeContent(&quot;&lt;div id=&#x27;foo&#x27;&gt;&lt;/div&gt;&quot;);
        d1.appendChild(jsPlumb.getElement(d));
        var s = _jsPlumb.getSelector(d1, &quot;#foo&quot;);
        equal(s.length, 1, &quot;foo found by getSelector with context d1&quot;);
        equal(s[0].getAttribute(&quot;id&quot;), &quot;foo&quot;, &quot;foo found by getSelector with context d1&quot;);
    });

    test(&quot; addClass method of Connection&quot;, function () {
        _addDiv(&quot;d1&quot;);
            _addDiv(&quot;d2&quot;);
            var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, overlays:[
                [ &quot;Label&quot;, { id:&quot;label&quot;, label:&#x27;hey&#x27;}]
            ]}), o = c.getOverlay(&quot;label&quot;);
            c.addClass(&quot;foo&quot;);
            ok(!(jsPlumb.hasClass(c.endpoints[0].canvas, &quot;foo&quot;)), &quot;endpoint does not have class &#x27;foo&#x27;&quot;);
            ok(c.canvas.className.baseVal.indexOf(&quot;foo&quot;) != -1, &quot;connection has class &#x27;foo&#x27;&quot;);
            c.addClass(&quot;bar&quot;, true);
            ok(jsPlumb.hasClass(c.endpoints[0].canvas, &quot;bar&quot;), &quot;endpoint has class &#x27;bar&#x27;&quot;);
            c.removeClass(&quot;bar&quot;, true);
            ok(c.canvas.className.baseVal.indexOf(&quot;bar&quot;) == -1, &quot;connection doesn&#x27;t have class &#x27;bar&#x27;&quot;);
            ok(!jsPlumb.hasClass(c.endpoints[0].canvas, &quot;bar&quot;), &quot;endpoint doesnt have class &#x27;bar&#x27;&quot;);

            ok(jsPlumb.hasClass(o.canvas, &quot;foo&quot;), &quot;overlay has class foo&quot;);

            c.addClass(&quot;foo2&quot;);
            ok(jsPlumb.hasClass(o.canvas, &quot;foo2&quot;), &quot;overlay has class foo2&quot;);
            ok(c.canvas.className.baseVal.indexOf(&quot;foo2&quot;) != -1, &quot;connection has class &#x27;foo2&#x27;&quot;);

            c.removeClass(&quot;foo2&quot;);
            ok(!jsPlumb.hasClass(o.canvas, &quot;foo2&quot;), &quot;overlay no longer has class foo2&quot;);
            ok(c.canvas.className.baseVal.indexOf(&quot;foo2&quot;) == -1, &quot;connection no longer has class &#x27;foo2&#x27;&quot;);

            c.addClass(&quot;foo2&quot;, true);
            ok(!jsPlumb.hasClass(o.canvas, &quot;foo2&quot;), &quot;overlay doesnt have class foo2&quot;);
            ok(c.canvas.className.baseVal.indexOf(&quot;foo2&quot;) != -1, &quot;connection has class &#x27;foo2&#x27;&quot;);
    });

    test(&quot; addClass via jsPlumb.select&quot;, function () {
        _addDiv(&quot;d1&quot;);
        _addDiv(&quot;d2&quot;);
        equal(_jsPlumb.select().length, 0, &quot;there are no connections&quot;);
        var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;});
        equal(_jsPlumb.select().length, 1, &quot;there is one connection&quot;);
        _jsPlumb.select().addClass(&quot;foo&quot;);
        ok(!(jsPlumb.hasClass(c.endpoints[0].canvas, &quot;foo&quot;)), &quot;endpoint does not have class &#x27;foo&#x27;&quot;);
        _jsPlumb.select().addClass(&quot;bar&quot;, true);
        ok(jsPlumb.hasClass(c.endpoints[0].canvas, &quot;bar&quot;), &quot;endpoint hasclass &#x27;bar&#x27;&quot;);
        _jsPlumb.select().removeClass(&quot;bar&quot;, true);
        ok(!(jsPlumb.hasClass(c.endpoints[0].canvas, &quot;bar&quot;)), &quot;endpoint doesn&#x27;t have class &#x27;bar&#x27;&quot;);
    });

// ******************* override pointer events ********************
    test(&quot;pointer-events, jsPlumb.connect&quot;, function () {
        if (_jsPlumb.getRenderMode() == jsPlumb.SVG) {
            _addDivs([&quot;d1&quot;, &quot;d2&quot;]);
            var c = _jsPlumb.connect({source: &quot;d1&quot;, target: &quot;d2&quot;, &quot;pointer-events&quot;: &quot;BANANA&quot;});
            equal(jsPlumb.getSelector(c.getConnector().canvas, &quot;path&quot;)[0].getAttribute(&quot;pointer-events&quot;), &quot;BANANA&quot;, &quot;pointer events passed through to svg elements&quot;);
        }
        else
            expect(0);
    });

    test(&quot;connector-pointer-events, jsPlumb.addEndpoint&quot;, function () {
        if (_jsPlumb.getRenderMode() == jsPlumb.SVG) {
            _addDivs([&quot;d1&quot;, &quot;d2&quot;]);
            var e1 = _jsPlumb.addEndpoint(&quot;d1&quot;, { &quot;connector-pointer-events&quot;: &quot;BANANA&quot; });
            var c = _jsPlumb.connect({source: e1, target: &quot;d2&quot;});
            equal(jsPlumb.getSelector(c.getConnector().canvas, &quot;path&quot;)[0].getAttribute(&quot;pointer-events&quot;), &quot;BANANA&quot;, &quot;pointer events passed through to svg elements&quot;);
        }
        else
            expect(0);
    });


    test(&quot;: jsPlumbUtil.isEmpty&quot;, function () {
        var e = {};
        equal(jsPlumbUtil.isEmpty(e), true, &quot;e is empty&quot;);
        e.foo = &quot;bar&quot;;
        equal(jsPlumbUtil.isEmpty(e), false, &quot;e is not empty&quot;);
        equal(jsPlumbUtil.isEmpty(null), true, &quot;null object is considered empty&quot;);
    });

    test(&quot; : DOM adapter addClass/hasClass/removeClass&quot;, function () {
        var d1 = _addDiv(d1), // d1 is a DOM element
            _d1 = jsPlumb.getSelector(d1);  // _d1 is a selector. we will test using each one.

        // add a single class and test for its existence	
        jsPlumb.addClass(d1, &quot;FOO&quot;);
        equal(d1.className, &quot;FOO&quot;, &quot;element has class FOO, using selector&quot;);
        ok(jsPlumb.hasClass(_d1, &quot;FOO&quot;), &quot;element has class FOO, according to hasClass method, DOM element&quot;);
        ok(jsPlumb.hasClass(d1, &quot;FOO&quot;), &quot;element has class FOO, according to hasClass method, selector&quot;);

        // add multiple classes and test for their existence
        jsPlumb.addClass(_d1, &quot;BAZ BAR SHAZ&quot;);
        ok(jsPlumb.hasClass(_d1, &quot;BAZ&quot;), &quot;element has class BAZ, according to hasClass method, DOM element&quot;);
        ok(jsPlumb.hasClass(_d1, &quot;BAR&quot;), &quot;element has class BAR, according to hasClass method, DOM element&quot;);
        ok(jsPlumb.hasClass(_d1, &quot;SHAZ&quot;), &quot;element has class SHAZ, according to hasClass method, DOM element&quot;);

        // remove one class
        jsPlumb.removeClass(d1, &quot;BAR&quot;);
        ok(!jsPlumb.hasClass(_d1, &quot;BAR&quot;), &quot;element doesn&#x27;t have class BAR, according to hasClass method, DOM element&quot;);

        // remove two more classes
        jsPlumb.removeClass(d1, &quot;BAZ SHAZ&quot;);
        ok(!jsPlumb.hasClass(_d1, &quot;BAZ&quot;), &quot;element doesn&#x27;t have class BAZ, according to hasClass method, DOM element&quot;);
        ok(!jsPlumb.hasClass(_d1, &quot;SHAZ&quot;), &quot;element doesn&#x27;t have class SHAZ, according to hasClass method, DOM element&quot;);

        // check FOO is still there
        ok(jsPlumb.hasClass(_d1, &quot;FOO&quot;), &quot;element has class FOO, according to hasClass method, DOM element&quot;);

        // now for an SVG element.
        var s1 = jsPlumbUtil.svg.node(&quot;svg&quot;);
        document.body.appendChild(s1);
        jsPlumb.addClass(s1, &quot;SFOO&quot;);
        ok(jsPlumb.hasClass(s1, &quot;SFOO&quot;), &quot;SVG element has class SFOO, according to hasClass method, DOM element&quot;);

        jsPlumb.addClass(s1, &quot;BAZ BAR SHAZ&quot;);

        // remove one class
        jsPlumb.removeClass(s1, &quot;BAR&quot;);
        ok(!jsPlumb.hasClass(s1, &quot;BAR&quot;), &quot;SVG element doesn&#x27;t have class BAR, according to hasClass method, DOM element&quot;);

        // remove two more classes
        jsPlumb.removeClass(s1, &quot;BAZ SHAZ&quot;);
        ok(!jsPlumb.hasClass(s1, &quot;BAZ&quot;), &quot;SVG element doesn&#x27;t have class BAZ, according to hasClass method, DOM element&quot;);
        ok(!jsPlumb.hasClass(s1, &quot;SHAZ&quot;), &quot;SVG element doesn&#x27;t have class SHAZ, according to hasClass method, DOM element&quot;);

        // check SFOO is still there
        ok(jsPlumb.hasClass(s1, &quot;SFOO&quot;), &quot;SVG element has class SFOO, according to hasClass method, DOM element&quot;);

        // set class for d1 to be BAZ only
        jsPlumb.setClass(d1, &quot;BAZ&quot;);
        equal(d1.className, &quot;BAZ&quot;, &quot;element has only the class set with setClass&quot;);
    });

    test(&quot; : DOM adapter addClass/removeClass, multiple elements, with selector&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        jsPlumb.addClass(d1, &quot;BAZ&quot;);
        jsPlumb.addClass(d2, &quot;BAZ&quot;);

        var els = jsPlumb.getSelector(&quot;.BAZ&quot;);

        // add a single class and test for its existence	
        jsPlumb.addClass(els, &quot;FOO&quot;);
        ok(jsPlumb.hasClass(d1, &quot;FOO&quot;), &quot;d1 has class FOO&quot;);
        ok(jsPlumb.hasClass(d2, &quot;FOO&quot;), &quot;d1 has class FOO&quot;);

        // remove a single class and test for its non-existence.
        jsPlumb.removeClass(els, &quot;FOO&quot;);
        ok(!jsPlumb.hasClass(d1, &quot;FOO&quot;), &quot;d1 doesn&#x27;t have class FOO&quot;);
        ok(!jsPlumb.hasClass(d2, &quot;FOO&quot;), &quot;d1 doesn&#x27;t have class FOO&quot;);

    });

    test(&quot;DOM adapter addClass/removeClass, multiple elements, with array of DOM elements&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        jsPlumb.addClass(d1, &quot;BAZ&quot;);
        jsPlumb.addClass(d2, &quot;BAZ&quot;);

        var els = [ d1, d2 ];

        // add a single class and test for its existence	
        jsPlumb.addClass(els, &quot;FOO&quot;);
        ok(jsPlumb.hasClass(d1, &quot;FOO&quot;), &quot;d1 has class FOO&quot;);
        ok(jsPlumb.hasClass(d2, &quot;FOO&quot;), &quot;d1 has class FOO&quot;);

        // remove a single class and test for its non-existence.
        jsPlumb.removeClass(els, &quot;FOO&quot;);
        ok(!jsPlumb.hasClass(d1, &quot;FOO&quot;), &quot;d1 doesn&#x27;t have class FOO&quot;);
        ok(!jsPlumb.hasClass(d2, &quot;FOO&quot;), &quot;d1 doesn&#x27;t have class FOO&quot;);
    });

    test(&quot;DOM adapter addClass/removeClass, multiple elements, with array of IDs&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        jsPlumb.addClass(d1, &quot;BAZ&quot;);
        jsPlumb.addClass(d2, &quot;BAZ&quot;);

        var els = [ &quot;d1&quot;, &quot;d2&quot; ];

        // add a single class and test for its existence	
        jsPlumb.addClass(els, &quot;FOO&quot;);
        ok(jsPlumb.hasClass(d1, &quot;FOO&quot;), &quot;d1 has class FOO&quot;);
        ok(jsPlumb.hasClass(d2, &quot;FOO&quot;), &quot;d1 has class FOO&quot;);

        // remove a single class and test for its non-existence.
        jsPlumb.removeClass(els, &quot;FOO&quot;);
        ok(!jsPlumb.hasClass(d1, &quot;FOO&quot;), &quot;d1 doesn&#x27;t have class FOO&quot;);
        ok(!jsPlumb.hasClass(d2, &quot;FOO&quot;), &quot;d1 doesn&#x27;t have class FOO&quot;);
    });


    test(&quot; : DOM adapter addClass and removeClass at the same time, pass as arrays&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;);
        jsPlumb.addClass(d1, &quot;BAZ FOO BAR&quot;);
        ok(jsPlumb.hasClass(d1, &quot;BAZ&quot;), &quot;d1 has class BAZ&quot;);
        ok(jsPlumb.hasClass(d1, &quot;FOO&quot;), &quot;d1 has class FOO&quot;);
        ok(jsPlumb.hasClass(d1, &quot;BAR&quot;), &quot;d1 has class BAR&quot;);

        // add qux, remove foo and bar.
        jsPlumb.updateClasses(d1, [&quot;QUX&quot;, &quot;BOZ&quot;], [&quot;FOO&quot;, &quot;BAR&quot;]);
        ok(jsPlumb.hasClass(d1, &quot;QUX&quot;), &quot;d1 has class QUX&quot;);
        ok(jsPlumb.hasClass(d1, &quot;BOZ&quot;), &quot;d1 has class BOZ&quot;);
        ok(jsPlumb.hasClass(d1, &quot;BAZ&quot;), &quot;d1 has class BAZ&quot;);
        ok(!jsPlumb.hasClass(d1, &quot;FOO&quot;), &quot;d1 has not class FOO&quot;);
        ok(!jsPlumb.hasClass(d1, &quot;BAR&quot;), &quot;d1 has not class BAR&quot;);
    });

    test(&quot; : DOM adapter addClass and removeClass at the same time, pass as strings&quot;, function () {
        var d1 = _addDiv(&quot;d1&quot;);
        jsPlumb.addClass(d1, &quot;BAZ FOO BAR&quot;);
        ok(jsPlumb.hasClass(d1, &quot;BAZ&quot;), &quot;d1 has class BAZ&quot;);
        ok(jsPlumb.hasClass(d1, &quot;FOO&quot;), &quot;d1 has class FOO&quot;);
        ok(jsPlumb.hasClass(d1, &quot;BAR&quot;), &quot;d1 has class BAR&quot;);

        // add qux, remove foo and bar.
        jsPlumb.updateClasses(d1, &quot;QUX BOZ&quot;, &quot;FOO BAR&quot;);
        ok(jsPlumb.hasClass(d1, &quot;QUX&quot;), &quot;d1 has class QUX&quot;);
        ok(jsPlumb.hasClass(d1, &quot;BOZ&quot;), &quot;d1 has class BOZ&quot;);
        ok(jsPlumb.hasClass(d1, &quot;BAZ&quot;), &quot;d1 has class BAZ&quot;);
        ok(!jsPlumb.hasClass(d1, &quot;FOO&quot;), &quot;d1 has not class FOO&quot;);
        ok(!jsPlumb.hasClass(d1, &quot;BAR&quot;), &quot;d1 has not class BAR&quot;);
    });

    test(&quot;endpointStyle on connect method&quot;, function () {
        _addDivs([&quot;d1&quot;, &quot;d2&quot;]);
        var c = _jsPlumb.connect({
            source: &quot;d1&quot;,
            target: &quot;d2&quot;,
            endpointStyle: { fill: &quot;blue&quot; }
        });

        equal(c.endpoints[0].canvas.childNodes[0].childNodes[0].getAttribute(&quot;fill&quot;), &quot;blue&quot;, &quot;endpoint style passed through by connect method&quot;);
    });

    test(&quot;recalculateOffsets&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;);

        var d2 = _addDiv(&quot;d2&quot;, d1);
        d2.style.left = &quot;250px&quot;;
        d2.style.top = &quot;120px&quot;;

        var d3 = _addDiv(&quot;d3&quot;, d1);
        d3.style.left = &quot;150px&quot;;
        d3.style.top = &quot;220px&quot;;

        _jsPlumb.connect({source:d2, target:d3});
        _jsPlumb.draggable(d1);

        var o = _jsPlumb.getDragManager().getElementsForDraggable(&quot;d1&quot;)[&quot;d2&quot;];
        equal(250, o.offset.left, &quot;d2 is at left=250&quot;);

        d2.style.left = &quot;1250px&quot;;
        _jsPlumb.recalculateOffsets(d1);
        var o = _jsPlumb.getDragManager().getElementsForDraggable(&quot;d1&quot;)[&quot;d2&quot;];
        equal(1250, o.offset.left, &quot;d2 is at left=1250&quot;);

    });

    /**
     * Tests that the &#x60;getOffset&#x60; function correctly ignores body scroll when adjusting for parent element scroll.
     * @method Test.offset_body_scroll
     */
    test(&quot;offset body scroll&quot;, function() {
        expect(0);
    });



    test(&quot;endpointStyle on connect method, with makeSource prepared element&quot;, function () {
        _addDivs([&quot;d1&quot;, &quot;d2&quot;]);
        _jsPlumb.makeSource(&quot;d1&quot;);

        var c = _jsPlumb.connect({
            source: &quot;d1&quot;,
            target: &quot;d2&quot;,
            endpointStyle: { fill: &quot;blue&quot; }
        });

        equal(c.endpoints[0].canvas.childNodes[0].childNodes[0].getAttribute(&quot;fill&quot;), &quot;blue&quot;, &quot;endpoint style passed through by connect method&quot;);
    });



    test(&quot;setContainer does not cause multiple event registrations (issue 307)&quot;, function () {
        _addDivs([&quot;box1&quot;, &quot;box2&quot;, &quot;canvas&quot;]);

         _jsPlumb.importDefaults({
         Container: &#x27;canvas&#x27;
         });

        _jsPlumb.setContainer(&#x27;canvas&#x27;);

        var connection = _jsPlumb.connect({
            source: &#x27;box1&#x27;,
            id: &#x27;connector1&#x27;,
            target: &#x27;box2&#x27;,
            anchors: [&#x27;Bottom&#x27;, &#x27;Left&#x27;]
        });

        var clickCount = 0;
        var labelDef = {
            id: &#x27;label-1&#x27;,
            label: &#x27;labeltext&#x27;,
            events: {
                click: function (event) {
                    console.log(&#x27;click on label&#x27;);
                    clickCount++;
                }
            }
        };
        var o = connection.addOverlay([&#x27;Label&#x27;, labelDef]);

        _jsPlumb.trigger(connection.getOverlay(&quot;label-1&quot;).canvas, &quot;click&quot;);

        equal(clickCount, 1, &quot;1 click on overlay registered&quot;);

    });



    var _detachThisConnection = function(c) {
        var idx = c.endpoints[1].connections.indexOf(c);
        support.detachConnection(c.endpoints[1], idx);
    };


     /**
     * Tests endpoint mouse interaction via event triggering: the ability to drag a connection to another
      * endpoint, what happens when it is full, if it is disabled etc.
     * @method jsPlumb.Test.EndpointEventTriggering
     */
     test(&quot;connections via mouse between Endpoints configured with addEndpoint&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {isSource:true, isTarget:true}),
            e2 = _jsPlumb.addEndpoint(d2, {isSource:true, isTarget:true});

        equal(_jsPlumb.select().length, 0, &quot;zero connections before drag&quot;);
        support.dragConnection(e1, e2);
        equal(_jsPlumb.select().length, 1, &quot;one connection after drag&quot;);

        _jsPlumb.select().detach();
        equal(_jsPlumb.select().length, 0, &quot;zero connections after detach&quot;);

         // now disable e1 and try to drag a new connection: it should fail
         e1.setEnabled(false);
         support.dragConnection(e1, e2);
         equal(_jsPlumb.select().length, 0, &quot;zero connections after drag from disabled endpoint&quot;);

         e1.setEnabled(true);
         support.dragConnection(e1, e2);
         equal(_jsPlumb.select().length, 1, &quot;one connection after drag from enabled endpoint&quot;);

         /*

         why does this fail? i get 0 instead of 1. it&#x27;s detaching existing connections?

         ok(e1.isFull(), &quot;endpoint 1 is full&quot;);
         support.dragConnection(e1, e2);
         equal(_jsPlumb.select().length, 1, &quot;one connection after drag from endpoint that is full&quot;);
         */

         support.detachConnection(e1, 0);
         equal(_jsPlumb.select().length, 0, &quot;zero connections after detach&quot;);
    });

    test(&quot;connections via mouse between elements configured with makeSource/makeTarget&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        _jsPlumb.makeSource(&quot;d1&quot;);
        _jsPlumb.makeSource(&quot;d4&quot;);
        _jsPlumb.makeTarget(&quot;d2&quot;);
        _jsPlumb.makeTarget(&quot;d3&quot;);

        equal(_jsPlumb.select().length, 0, &quot;zero connections before drag&quot;);
        support.dragConnection(d1, d2);
        equal(_jsPlumb.select().length, 1, &quot;one connection after drag from source to target&quot;);
        var cd1d2 = _jsPlumb.select().get(0);
        equal(cd1d2.source.id, &quot;d1&quot;, &quot;source of first connection is correct&quot;);
        equal(cd1d2.target.id, &quot;d2&quot;, &quot;target of first connection is correct&quot;);

        support.dragConnection(d1, d3);
        equal(_jsPlumb.select().length, 2, &quot;two connections after drag from source to target&quot;);
        var cd1d3 = _jsPlumb.select().get(1);
        equal(cd1d3.source.id, &quot;d1&quot;, &quot;source of second connection is correct&quot;);
        equal(cd1d3.target.id, &quot;d3&quot;, &quot;target of second connection is correct&quot;);

        // now we will drag the connection from d1-d2 by its target endpoint and put it on d3.
        support.relocateTarget(cd1d2, d3);
        equal(cd1d2.target.id, &quot;d3&quot;, &quot;target of first connection has changed to d3&quot;);
        equal(_jsPlumb.select().length, 2, &quot;two connections after relocate&quot;);

        support.dragConnection(d3, d1);
        equal(_jsPlumb.select().length, 2, &quot;two connections after failed drag from target to source&quot;);

        // now drag the source of d1-d2 to be d4.
        support.relocateSource(cd1d2, d4);
        equal(cd1d2.source.id, &quot;d4&quot;, &quot;source of first connection has changed to d4&quot;);
        equal(_jsPlumb.select().length, 2, &quot;two connections after relocate&quot;);

    });

    test(&quot;issue 415: spurious endpoints after dragging&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        _jsPlumb.makeSource([ &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot; ], {
            maxConnections:-1
        });
        _jsPlumb.makeTarget([ &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot; ], {
            maxConnections:-1
        });

        ok(_jsPlumb.isSource(d4), &quot;d4 is a connection source&quot;);
        ok(_jsPlumb.isTarget(d4), &quot;d4 is a connection target&quot;);

        var d1d2 = support.dragConnection(d1, d2);
        equal(_jsPlumb.select().length, 1, &quot;one connection after drag&quot;);

        var d2d3 = support.dragConnection(d2, d3);
        equal(_jsPlumb.select().length, 2, &quot;two connections after drag&quot;);

        equal(_jsPlumb.selectEndpoints().length, 4, &quot;four endpoints before relocations&quot;);

        support.relocateTarget(d1d2, d4);
        equal(d1d2.target.id, &quot;d4&quot;, &quot;target of first connection has changed to d4&quot;);

        equal(_jsPlumb.select().length, 2, &quot;two connections after relocations&quot;);
        equal(_jsPlumb.selectEndpoints().length, 4, &quot;four endpoints after relocations&quot;);

        support.relocateSource(d2d3, d4);

        equal(d2d3.source.id, &quot;d4&quot;, &quot;source of second connection has changed to d4&quot;);
        equal(_jsPlumb.select().length, 2, &quot;two connections after relocations&quot;);
        equal(_jsPlumb.selectEndpoints().length, 4, &quot;four endpoints after relocations&quot;);

    });

    test(&quot;drag connection so it turns into a self-loop. ensure endpoints registered correctly. target not continuous anchor so not hidden (issue 419)&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        _jsPlumb.makeSource([ &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot; ], { maxConnections: -1 });
        _jsPlumb.makeTarget([ &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot; ], { maxConnections: -1 });

        ok(_jsPlumb.isSource(d1), &quot;d1 is a connection source&quot;);
        ok(_jsPlumb.isTarget(d2), &quot;d2 is a connection target&quot;);

        // as a test: connect d3 to itself. 2 endpoints?
        var d3d3 = support.dragConnection(d3, d3);
        equal(_jsPlumb.selectEndpoints().length, 2, &quot;two endpoints&quot;);

        var d2d1 = support.dragConnection(d2, d1);
        equal(_jsPlumb.select().length, 2, &quot;one connection after drag&quot;);

        support.relocateSource(d2d1, d1);
        equal(d2d1.endpoints[0].elementId, &quot;d1&quot;, &quot;source endpoint is on d1 now&quot;);
        equal(_jsPlumb.selectEndpoints().length, 4, &quot;four endpoints after relocations&quot;);

        support.relocateSource(d2d1, d2);
        equal(d2d1.endpoints[0].elementId, &quot;d2&quot;, &quot;source endpoint is on d2 now&quot;);
        ok(d2d1.endpoints[1].canvas.parentNode != null, &quot;target canvas put back into DOM&quot;);
    });

    test(&quot;drag connection so it turns into a self-loop. ensure endpoints registered correctly. target is continuous anchor so is hidden. (issue 419)&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        _jsPlumb.makeSource([ &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot; ], { maxConnections: -1, anchor:&quot;Continuous&quot; });
        _jsPlumb.makeTarget([ &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot; ], { maxConnections: -1, anchor:&quot;Continuous&quot; });

        var d2d1 = support.dragConnection(d2, d1);
        equal(_jsPlumb.select().length, 1, &quot;one connection after drag&quot;);

        support.relocateSource(d2d1, d1);
        equal(d2d1.endpoints[0].elementId, &quot;d1&quot;, &quot;source endpoint is on d1 now&quot;);
        // NOTE in this test we are not using Continuous anchors so we do not expect the target to have been
        // removed. the next test uses Continuous anchors and it checks the target has been removed.
        //ok(d2d1.endpoints[1].canvas.parentNode == null, &quot;target canvas removed from DOM&quot;);

        support.relocateSource(d2d1, d2);
        equal(d2d1.endpoints[0].elementId, &quot;d2&quot;, &quot;source endpoint is on d2 now&quot;);
        ok(d2d1.endpoints[1].canvas.parentNode != null, &quot;target canvas put back into DOM&quot;);
    });


    test(&quot;endpoint:connectionsDetachable mouse interaction&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {
                isSource:true, isTarget:true,
                connectionsDetachable:false
            }),
            e2 = _jsPlumb.addEndpoint(d2, {isSource:true, isTarget:true});

        equal(_jsPlumb.select().length, 0, &quot;zero connections before drag&quot;);
        support.dragConnection(e1, e2);
        equal(_jsPlumb.select().length, 1, &quot;one connection after drag&quot;);

        support.detachConnection(e1, 0);
        equal(_jsPlumb.select().length, 1, &quot;one connection still after attempted detach&quot;);
    });

    test(&quot;connection:detachable false, mouse interaction&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1),
            e2 = _jsPlumb.addEndpoint(d2);

        equal(_jsPlumb.select().length, 0, &quot;zero connections before connect&quot;);
        _jsPlumb.connect({source:e1, target:e2, detachable:false});
        equal(_jsPlumb.select().length, 1, &quot;one connection after connect&quot;);
        support.detachConnection(e1, 0);
        equal(_jsPlumb.select().length, 1, &quot;one connection still after attempted detach&quot;);
    });

    test(&quot;connection:detachable true by default, mouse interaction&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1),
            e2 = _jsPlumb.addEndpoint(d2);

        equal(_jsPlumb.select().length, 0, &quot;zero connections before connect&quot;);
        _jsPlumb.connect({source:e1, target:e2});
        equal(_jsPlumb.select().length, 1, &quot;one connection after connect&quot;);
        support.detachConnection(e1, 0);
        equal(_jsPlumb.select().length, 0, &quot;zero connections after detach&quot;);
    });

    test(&quot;connectionDetached event is fired when no beforeDrop is active&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, {
            isTarget:true
        });
        var e2 = _jsPlumb.addEndpoint(d2, {isSource:true});
        var evt = false;
        _jsPlumb.bind(&#x27;connectionDetached&#x27;, function (info) {
            evt = true;
        });
        support.dragConnection(e2, e1);
        equal(e1.connections.length, 1, &quot;one connection&quot;);

        support.detachConnection(e1, 0);

        equal(e1.connections.length, 0, &quot;no connections&quot;);
        ok(evt == true, &quot;event was fired&quot;);
    });

    test(&quot;beforeDrop returning false prevents connectionDetached event&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, {
            beforeDrop:function() {
                return false;
            },
            isTarget:true
        });
        var e2 = _jsPlumb.addEndpoint(d2, {isSource:true});
        var evt = false, abortEvent = false;
        _jsPlumb.bind(&#x27;connectionDetached&#x27;, function (info) {
            evt = true;
        });
        _jsPlumb.bind(&#x27;connectionAborted&#x27;, function (info) {
            abortEvent = true;
        });
        support.dragConnection(e2, e1);
        ok(evt == false, &quot;event was not fired&quot;);
        equal(e1.connections.length, 0, &quot;no connections&quot;);
        ok(abortEvent == true, &quot;connectionAborted event was fired&quot;);
    });

    test(&quot;connectionAborted event&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);

        var e2 = _jsPlumb.addEndpoint(d2, {isSource:true});
        var evt = false, abortEvent = false;
        _jsPlumb.bind(&#x27;connectionDetached&#x27;, function (info) {
            evt = true;
        });
        _jsPlumb.bind(&#x27;connectionAborted&#x27;, function (info) {
            abortEvent = true;
        });
        support.dragAndAbortConnection(e2);
        ok(evt == false, &quot;connectionDetached event was not fired&quot;);
        equal(e2.connections.length, 0, &quot;no connections&quot;);
        ok(abortEvent == true, &quot;connectionAborted event was fired&quot;);
    });

test(&quot;endpoint: suspendedElement set correctly&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            e1 = _jsPlumb.addEndpoint(d1, { isSource:true, isTarget:true }),
            e2 = _jsPlumb.addEndpoint(d2, {isSource:true, isTarget:true}),
            e3 = _jsPlumb.addEndpoint(d3, {isSource:true, isTarget:true});

        equal(_jsPlumb.select().length, 0, &quot;zero connections before drag&quot;);
        var c = support.dragConnection(e1, e2);
        equal(_jsPlumb.select().length, 1, &quot;one connection after drag&quot;);

        support.relocateTarget(c, e3, {
            beforeMouseUp:function() {
                equal(c.suspendedElement, d2, &quot;suspended element is set&quot;);
                equal(c.suspendedEndpoint, e2, &quot;suspended endpoint is set&quot;);
            },
            after :function() {
                equal(c.suspendedElement, null, &quot;suspended element is cleared&quot;);
                equal(c.suspendedEndpoint, null, &quot;suspended endpoint is cleared&quot;);
            }
        });
    });

    /*

    // future state.

    test(&quot;beforeDrop fired before onMaxConnections&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var bd = false;
        var e1 = _jsPlumb.addEndpoint(d1, {
            beforeDrop:function() {
                bd = true;
                return true;
            },
            isTarget:true,
            onMaxConnections:function() {
                ok(bd === true, &quot;beforeDrop was called before onMaxConnections&quot;);
            }
        });
        var e2 = _jsPlumb.addEndpoint(d2, {isSource:true, maxConnections:-1});
        support.dragConnection(e2, e1);
        equal(e1.connections.length, 1, &quot;one connection&quot;);
        equal(bd, true, &quot;beforeDrop was called&quot;);
        bd = false;
        support.dragConnection(e2, e1);
        equal(e1.connections.length, 1, &quot;one connection&quot;);
    });
    */

    test(&quot;drag connection between two endpoints&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isTarget:true, maxConnections:-1 });
        var e2 = _jsPlumb.addEndpoint(d2, {isSource:true, maxConnections:-1 });

        var c1 = _jsPlumb.connect({source:e2, target:e1});
        equal(e1.connections.length, 1, &quot;one conn now&quot;);

        var c2 = support.dragConnection(e2, e1);
        equal(e1.connections.length, 2, &quot;two conns now&quot;);
    });

    test(&quot;drag connection between two endpoints but endpoints are full&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            d3 = _addDiv(&quot;d3&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isTarget:true });
        var e2 = _jsPlumb.addEndpoint(d2, { isSource:true });
        var e3 = _jsPlumb.addEndpoint(d3, { isSource:true });

        var c1 = _jsPlumb.connect({source:e2, target:e1});
        equal(e1.connections.length, 1, &quot;one conn now&quot;);

        var c2 = support.dragConnection(e3, e1);
        equal(e1.connections.length, 1, &quot;one conn now&quot;);
    });

    /*
    test(&quot;endpoint:connectionSourceDetachable false, mouse interaction&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, {connectionSourceDetachable:false, maxConnections:-1}),
            e2 = _jsPlumb.addEndpoint(d2, {maxConnections:-1});

        equal(_jsPlumb.select().length, 0, &quot;zero connections before connect&quot;);
        _jsPlumb.connect({source:e1, target:e2});
        equal(_jsPlumb.select().length, 1, &quot;one connection after connect&quot;);

        support.detachConnection(e1, 0);
        equal(_jsPlumb.select().length, 1, &quot;one connection still after attempted detach of connection source&quot;);

        _jsPlumb.connect({source:e2, target:e1});
        equal(_jsPlumb.select().length, 2, &quot;two connections after connect&quot;);
        support.detachConnection(e1, 1);
        equal(_jsPlumb.select().length, 1, &quot;one connection after successful target detach&quot;);
    });*/

    test(&quot;endpoint:beforeDetach listener via mouse interaction&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), r = 0, s = 0, bd = 0,
            e1 = _jsPlumb.addEndpoint(d1, {
                isSource:true, isTarget:true

            }),
            e2 = _jsPlumb.addEndpoint(d2, {isSource:true, isTarget:true});

        _jsPlumb.bind(&quot;beforeDetach&quot;, function() {
            r = true;
            return true;
        });

        _jsPlumb.bind(&quot;beforeDrag&quot;, function() {
            bd++;
            return true;
        });

        _jsPlumb.bind(&quot;beforeStartDetach&quot;, function() {
            s = true;
            return true;
        });

        equal(_jsPlumb.select().length, 0, &quot;zero connections before drag&quot;);
        support.dragConnection(e1, e2);
        equal(_jsPlumb.select().length, 1, &quot;one connection after drag&quot;);


        support.detachConnection(e1, 0);
        equal(_jsPlumb.select().length, 0, &quot;connection detached&quot;);

        equal(bd, 1, &quot;beforeDrag called once&quot;);
        equal(r, 1, &quot;beforeDetach interceptor called once&quot;);
        equal(s, 1, &quot;beforeStartDetach interceptor called once&quot;);

    });


    test(&quot;unbind a single event listener does not unbind them all&quot;, function() {
        var i = 0;
        var l1 = function() {
            i += 5;
        };
        var l2 = function() {
            i -= 6;
        };
        var d1 = _addDiv(&quot;d1&quot;),
            d2 = _addDiv(&quot;d2&quot;);

        _jsPlumb.bind(&quot;connection&quot;, l1);
        _jsPlumb.bind(&quot;connection&quot;, l2);

        _jsPlumb.connect({source:d1, target:d2});

        equal(i, -1,&quot;both listeners fired&quot;);
        i = 0;

        // first test existing: unbind with no args unbinds everything.
        _jsPlumb.unbind(&quot;connection&quot;);
        _jsPlumb.connect({source:d1, target:d2});
        equal(i, 0, &quot;no listeners fired&quot;);

        // rebind and check
        _jsPlumb.bind(&quot;connection&quot;, l1);
        _jsPlumb.bind(&quot;connection&quot;, l2);
        _jsPlumb.connect({source:d1, target:d2});
        equal(i, -1,&quot;both listeners fired&quot;);

        i = 0;
        // unbind one.
        _jsPlumb.unbind(&quot;connection&quot;, l2);
        _jsPlumb.connect({source:d1, target:d2});
        equal(i, 5, &quot;only listener l1 fired&quot;);

        i = 0;
        _jsPlumb.unbind(l1);
        _jsPlumb.connect({source:d1, target:d2});
        equal(i, 0, &quot;no listeners fired&quot;);

    });

    test(&quot;bind multiple listeners via array (multiple events, one function)&quot;, function() {
        var count = 0;
        _jsPlumb.bind([&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;], function() {
            count++;
        });

        _jsPlumb.fire(&quot;foo&quot;);
        equal(count, 1, &quot;count is 1&quot;);
        _jsPlumb.fire(&quot;bar&quot;);
        equal(count, 2, &quot;count is 2&quot;);
        _jsPlumb.fire(&quot;baz&quot;);
        equal(count, 3, &quot;count is 3&quot;);
    });


// -----------------issue 383, setDraggable doesnt work with list-like arguments

    test(&quot;setDraggable with array&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;, null, &quot;aTest&quot;);
        var d2 = _addDiv(&quot;d2&quot;, null, &quot;aTest&quot;);

        ok(!_jsPlumb.isAlreadyDraggable(d1), &quot;d1 is not draggable&quot;);
        ok(!_jsPlumb.isAlreadyDraggable(d2), &quot;d2 is not draggable&quot;);
        var d = document.getElementsByClassName(&quot;aTest&quot;);

        // first make them draggable
        if(typeof d === &quot;function&quot;) {
            expect(2);
        }
        else
        {
            _jsPlumb.draggable(d);
            ok(_jsPlumb.isElementDraggable(d1), &quot;d1 is now draggable&quot;);
            ok(_jsPlumb.isElementDraggable(d2), &quot;d2 is now draggable&quot;);

            // now disable
            _jsPlumb.setDraggable(d, false);
            ok(!_jsPlumb.isElementDraggable(d1), &quot;d1 is not draggable&quot;);
            ok(!_jsPlumb.isElementDraggable(d2), &quot;d2 is not draggable&quot;);

            // and enable
            _jsPlumb.toggleDraggable(d);
            ok(_jsPlumb.isElementDraggable(d1), &quot;d1 is draggable after toggle &quot;);
            ok(_jsPlumb.isElementDraggable(d2), &quot;d2 is draggable after toggle&quot;);
        }
    });

// ------------------ issue 402...offset cache not cleared always --------------------
    test(&quot;offset cache cleared&quot;, function() {
       var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        _jsPlumb.connect({source:d1, target:d2});
        var cd = _jsPlumb.getCachedData(&quot;d1&quot;);
       ok(cd.o != null, &quot;d1 is cached&quot;);

        // reset and then move d1. get cached data and offset should have been updated.
        _jsPlumb.reset();
        d1.style.position = &quot;absolute&quot;;
        d1.style.left = &quot;5000px&quot;;
        var cd2 = _jsPlumb.getCachedData(&quot;d1&quot;);
        ok(cd2.o == null, &quot;cache data cleared&quot;);
        _jsPlumb.connect({source:d1, target:d2});
        var cd3 = _jsPlumb.getCachedData(&quot;d1&quot;);
        ok(cd3.o != null, &quot;d1 is cached&quot;);

        // delete every endpoint and then move d1. get cached data and offset should have been updated.
        _jsPlumb.deleteEveryEndpoint();
        d1.style.position = &quot;absolute&quot;;
        d1.style.left = &quot;5000px&quot;;
        var cd2 = _jsPlumb.getCachedData(&quot;d1&quot;);
        ok(cd2.o == null, &quot;cache data cleared&quot;);
        _jsPlumb.connect({source:d1, target:d2});
        var cd3 = _jsPlumb.getCachedData(&quot;d1&quot;);
        ok(cd3.o != null, &quot;d1 is cached&quot;);
    });

// ---------------------- issue 405, jsPlumb.empty doesnt remove connections (cannot reproduce) -----------------------

    test(&quot;jsPlumb.empty removes connections&quot;, function() {
        var p = _addDiv(&quot;p&quot;),
            d1 = _addDiv(&quot;d1&quot;, p),
            d2 = _addDiv(&quot;d2&quot;, p);

        _jsPlumb.connect({source:d1, target:d2});
        ok(_jsPlumb.select().length == 1, &quot;1 connection&quot;);

        _jsPlumb.empty(p);
        ok(document.getElementById(&quot;d1&quot;) == null);
        ok(_jsPlumb.select().length == 0, &quot;0 connections&quot;);
    });



//  -- connection dragging tests

    test(&quot;connection dragging, simple drag and detach case&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        support.dragConnection(d1, d2);
        equal(_jsPlumb.select().length, 1, &quot;1 connection in jsplumb instance.&quot;);
        var c = _jsPlumb.select().get(0);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        _detachThisConnection(c);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 0, &quot;0 connections registered for d1 after mouse detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 0, &quot;0 connections registered for d2 after mouse detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
        equal(_jsPlumb.select().length, 0, &quot;0 connections in jsplumb instance.&quot;);

    });

    /**
     * Tests the &#x60;extract&#x60; parameter on a &#x60;makeSource&#x60; call: extract provides a map of attribute names that you want to
     * read fom the source element when a drag starts, and whose values end up in the connection&#x27;s data, keyed by the
     * value from the extract map. In this test we get the attribute &#x60;foo&#x60; and insert its value into the connection&#x27;s
     * data, keyed as &#x60;fooAttribute&#x60;.
     */
    test(&quot;connection dragging, extractor atts defined on source&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        d1.setAttribute(&quot;foo&quot;, &quot;the value of foo&quot;);
        _jsPlumb.makeSource([d1, d2, d3], {
            extract:{
                &quot;foo&quot;:&quot;fooAttribute&quot;
            }
        });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        var con = support.dragConnection(d1, d2);
        equal(_jsPlumb.select().length, 1, &quot;1 connection in jsplumb instance.&quot;);
        equal(con.getData().fooAttribute, &quot;the value of foo&quot;, &quot;attribute values extracted properly&quot;);
    });

    test(&quot;connection dragging, simple drag and detach case, beforeDetach interceptor says no.&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.bind(&quot;beforeDetach&quot;, function() { return false; });
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        support.dragConnection(d1, d2);
        equal(_jsPlumb.select().length, 1, &quot;1 connection in jsplumb instance.&quot;);
        var c = _jsPlumb.select().get(0);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        _detachThisConnection(c);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;still 1 connection registered for d1 after attempted mouse detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;still 1 connection registered for d2 after attempted mouse detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
        equal(_jsPlumb.select().length, 1, &quot;1 connection in jsplumb instance.&quot;);

    });

    test(&quot;connection dragging, simple drag and detach case, reattach=true on connection prevents detach.&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        support.dragConnection(d1, d2);
        equal(_jsPlumb.select().length, 1, &quot;1 connection in jsplumb instance.&quot;);
        var c = _jsPlumb.select().get(0);
        c.setReattach(true);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        _detachThisConnection(c);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;still 1 connection registered for d1 after attempted mouse detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;still 1 connection registered for d2 after attempted mouse detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
        equal(_jsPlumb.select().length, 1, &quot;1 connection in jsplumb instance.&quot;);

    });

    test(&quot;connection dragging, simple move target case&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateTarget(c, d3);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 0, &quot;0 connections registered for d2 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 1, &quot;1 connection registered for d3 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);

        //alert(&quot;ensure continuous anchor endpoint cleaned up in this case (simple target move)&quot;);
    });

    // DRAG SOURCE TO ANOTHER SOURCE
    test(&quot;connection dragging, simple move source case&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateSource(c, d3);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 0, &quot;0 connections registered for d1 after mouse move&quot;);
        equal(_jsPlumb.selectEndpoints().length, 2, &quot;two endpoints; there is one connection&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 1, &quot;1 connection registered for d3 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);

    });

    test(&quot;connection dragging, simple move source case, continuous anchors&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.importDefaults({Anchor:&quot;Continuous&quot;});
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateSource(c, d3);
        equal(_jsPlumb.selectEndpoints().length, 2, &quot;two endpoints; there is one connection&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 0, &quot;0 connections registered for d1 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 1, &quot;1 connection registered for d3 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);

    });

    test(&quot;connection dragging, simple move target case, beforeDetach aborts the move&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.bind(&quot;beforeDetach&quot;, function() { return false; });
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateTarget(c, d3);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after aborted mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after aborted mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 0, &quot;0 connections registered for d3 after aborted mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
    });

    test(&quot;connection dragging, simple move source case, beforeDetach aborts the move&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.bind(&quot;beforeDetach&quot;, function() { return false; });
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateSource(c, d3);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after aborted mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after aborted mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 0, &quot;0 connections registered for d3 after aborted mouse move&quot;);
    });

    test(&quot;connection dragging, simple move case, connection reattach=true aborts the move&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        c.setReattach(true);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        _detachThisConnection(c);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after aborted mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after aborted mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 0, &quot;0 connections registered for d3 after aborted mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
    });

    test(&quot;connection dragging, redrop on original target&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateTarget(c, d2);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
    });

    // DRAG SOURCE AND REDROP ON ORIGINAL
    test(&quot;connection dragging, redrop on original source&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateSource(c, d1);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
    });


    // DRAG SOURCE TO AN ELEMENT NO CONFIGURED AS SOURCE (SHOULD DETACH)
    test(&quot;connection dragging, move source to element not configured as drag source&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3, d4], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateSource(c, d4);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 0, &quot;0 connections registered for d1 after mouse move&quot;);
        equal(_jsPlumb.selectEndpoints().length, 0, &quot;zero endpoints; there are no connections&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 0, &quot;0 connections registered for d2 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 0, &quot;0 connections registered for d3 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
    });

    // DRAG SOURCE TO AN ELEMENT NO CONFIGURED AS SOURCE BUT DETACH DISABLED (SHOULDNT CARE)
    test(&quot;connection dragging, move source to element not configured as drag source, beforeDetach cancels connection&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        _jsPlumb.bind(&quot;beforeDetach&quot;, function() { return false; });
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3, d4], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateSource(c, d4);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse move&quot;);
        equal(_jsPlumb.selectEndpoints().length, 2, &quot;2 endpoints; there is 1 connection&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d4&quot;).length, 0, &quot;0 connection registered for d4 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
    });

    // DRAG SOURCE TO ANOTHER SOURCE BUT BEFORE DROP SAYS NO
    test(&quot;connection dragging, move source to element not configured as drag source, beforeDrop cancels connection&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        _jsPlumb.bind(&quot;beforedrop&quot;, function() { return false; });
        _jsPlumb.makeSource([d1, d2, d3], { });
        _jsPlumb.makeTarget([d1, d2, d3, d4], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateSource(c, d4);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 0, &quot;0 connections registered for d1 after mouse move&quot;);
        equal(_jsPlumb.selectEndpoints().length, 0, &quot;0 endpoints; there are no connections&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 0, &quot;0 connections registered for d2 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d4&quot;).length, 0, &quot;0 connections registered for d4 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
    });

    // DRAG TARGET TO ANOTHER SOURCE (BUT NOT A TARGET); SHOULD DETACH
    test(&quot;connection dragging, move source to element not configured as drag source&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        _jsPlumb.makeSource([d1, d2, d3, d4], { });
        _jsPlumb.makeTarget([d1, d2, d3], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateTarget(c, d4);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 0, &quot;0 connections registered for d1 after mouse move&quot;);
        equal(_jsPlumb.selectEndpoints().length, 0, &quot;zero endpoints; there are no connections&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 0, &quot;0 connections registered for d2 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 0, &quot;0 connections registered for d3 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
    });


    // DRAG TARGET TO ANOTHER SOURCE (BUT NOT A TARGET), BUT DETACH DISABLED. SHOULDNT CARE.
    test(&quot;connection dragging, move source to element not configured as drag source, beforeDetach cancels connection&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);
        _jsPlumb.bind(&quot;beforeDetach&quot;, function() { return false; });
        _jsPlumb.makeSource([ d1, d2, d3, d4 ], { });
        _jsPlumb.makeTarget([ d1, d2, d3 ], { });

        var c = _jsPlumb.connect({source: d1, target: d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateTarget(c, d4);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse move&quot;);
        equal(_jsPlumb.selectEndpoints().length, 2, &quot;2 endpoints; there is 1 connection&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d4&quot;).length, 0, &quot;0 connection registered for d4 after mouse move&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
    });

    /**
     * Tests that &#x60;endpoint&#x60; and &#x60;anchor&#x60; in a makeSource definition are honoured. The next test uses a connection type
     * but has the makeSource override the anchor.
     */
    test(&quot;connection dragging, makeSource sets source endpoint and anchor&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.makeSource([d1, d2, d3], { endpoint:&quot;Rectangle&quot;, anchor:&quot;Left&quot;});
        _jsPlumb.makeTarget([d1, d2, d3]);

        support.dragConnection(d1, d2);
        equal(_jsPlumb.select().length, 1, &quot;1 connection in jsplumb instance.&quot;);
        var c = _jsPlumb.select().get(0);

        equal(c.endpoints[0].type, &quot;Rectangle&quot;, &quot;source endpoint is Rectangle&quot;);
        equal(c.endpoints[0].anchor.x, 0, &quot;x=0 in anchor&quot;);
        equal(c.endpoints[0].anchor.y, 0.5, &quot;y=0.5 in anchor&quot;);
        equal(c.endpoints[1].type, _jsPlumb.Defaults.Endpoint, &quot;target endpoint is the default&quot;);
    });

    /**
     * Tests that makeSource, when given &#x60;endpoint&#x60; and/or &#x60;anchor&#x60; values, will override any that were derived
     * from an applied type.
     */
    test(&quot;connection dragging, makeSource overrides source endpoint and anchor&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.registerConnectionType(&quot;basic&quot;, {
            endpoint:&quot;Blank&quot;,
            anchor:&quot;Right&quot;
        });
        _jsPlumb.makeSource(d1, { connectionType:&quot;basic&quot;, endpoint:&quot;Rectangle&quot;, anchor:&quot;Left&quot;});
        _jsPlumb.makeSource(d2, { connectionType:&quot;basic&quot;});
        _jsPlumb.makeTarget([d1, d2, d3]);

        support.dragConnection(d1, d3);
        equal(_jsPlumb.select().length, 1, &quot;1 connection in jsplumb instance.&quot;);
        var c = _jsPlumb.select().get(0);

        support.dragConnection(d2, d3);
        equal(_jsPlumb.select().length, 2, &quot;2 connections in jsplumb instance.&quot;);
        var c2 = _jsPlumb.select().get(1);

        equal(c.endpoints[0].type, &quot;Rectangle&quot;, &quot;source endpoint was overridden to be Rectangle&quot;);
        equal(c.endpoints[0].anchor.x, 0, &quot;x=0 in overridden anchor&quot;);
        equal(c.endpoints[0].anchor.y, 0.5, &quot;y=0.5 in overridden anchor&quot;);

        equal(c2.endpoints[0].type, &quot;Blank&quot;, &quot;source endpoint is Blank in endpoint derived from type&quot;);
        equal(c2.endpoints[0].anchor.x, 1, &quot;x=1 in anchor derived from type&quot;);
        equal(c2.endpoints[0].anchor.y, 0.5, &quot;y=0.5 in anchor derived from type&quot;);

    });

    /**
     * Tests that makeSource, when given &#x60;endpoint&#x60; and/or &#x60;anchor&#x60; values, will override any that were derived
     * from an applied type.
     */
    test(&quot;connection dragging, makeSource overrides source endpoint and anchor&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.registerConnectionType(&quot;basic&quot;, {
            endpoint:&quot;Blank&quot;,
            anchor:&quot;Right&quot;
        });
        _jsPlumb.makeSource(d1, { connectionType:&quot;basic&quot;});
        _jsPlumb.makeTarget(d2);
        _jsPlumb.makeTarget(d3, { endpoint:&quot;Rectangle&quot;, anchor:&quot;Left&quot; });

        support.dragConnection(d1, d3);
        equal(_jsPlumb.select().length, 1, &quot;1 connection in jsplumb instance.&quot;);
        var c = _jsPlumb.select().get(0);

        support.dragConnection(d1, d2);
        equal(_jsPlumb.select().length, 2, &quot;2 connections in jsplumb instance.&quot;);
        var c2 = _jsPlumb.select().get(1);

        equal(c.endpoints[1].type, &quot;Rectangle&quot;, &quot;target endpoint was overridden to be Rectangle&quot;);
        equal(c.endpoints[1].anchor.x, 0, &quot;x=0 in overridden anchor&quot;);
        equal(c.endpoints[1].anchor.y, 0.5, &quot;y=0.5 in overridden anchor&quot;);

        equal(c2.endpoints[1].type, &quot;Blank&quot;, &quot;target endpoint is Blank in endpoint derived from type&quot;);
        equal(c2.endpoints[1].anchor.x, 1, &quot;x=1 in anchor derived from type&quot;);
        equal(c2.endpoints[1].anchor.y, 0.5, &quot;y=0.5 in anchor derived from type&quot;);

    });

    test(&quot;connection dragging, makeTarget overrides endpoint and anchor&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.makeSource([d1, d2, d3]);
        _jsPlumb.makeTarget([d1, d2, d3], { endpoint:&quot;Rectangle&quot;, anchor:&quot;Top&quot; });

        support.dragConnection(d1, d2);
        equal(_jsPlumb.select().length, 1, &quot;1 connection in jsplumb instance.&quot;);
        var c = _jsPlumb.select().get(0);

        equal(c.endpoints[0].type, _jsPlumb.Defaults.Endpoint, &quot;source endpoint is the default&quot;);
        equal(c.endpoints[1].anchor.x, 0.5, &quot;x=0.5 in anchor&quot;);
        equal(c.endpoints[1].anchor.y, 0, &quot;y=0 in anchor&quot;);
        equal(c.endpoints[1].type, &quot;Rectangle&quot;, &quot;target endpoint is Rectangle&quot;);

    });


    // DETACH CONNECTION VIA SOURCE, DETACH ENABLED, ALLOWED
    // DETACH CONNECTION VIA SOURCE, DETACH DISABLED, DISALLOWED



    test(&quot;connection dragging&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.makeSource([d1,d2,d3], {
        });
        _jsPlumb.makeTarget([d1,d2,d3], {

        });
/*
        var c = _jsPlumb.connect({source:d1, target:d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after programmatic connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after programmatic connect&quot;);

        _jsPlumb.detach(c);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 0, &quot;0 connections registered for d1 after programmatic detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 0, &quot;0 connections registered for d2 after programmatic detach&quot;);

        c = _jsPlumb.connect({source:d1, target:d2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot; );
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        _detachThisConnection(c);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 0, &quot;0 connections registered for d1 after mouse detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 0, &quot;0 connections registered for d2 after mouse detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);

        // reconnect, check
        support.dragConnection(d1, d2);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);
        c = _jsPlumb.select().get(0);

        // move the target to d3, check
        support.relocateTarget(c, d3);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse relocate&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 0, &quot;0 connections registered for d2 after mouse relocate&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 1, &quot;1 connection registered for d3 after mouse relocate&quot;);

        // toss it away again, check
        _detachThisConnection(c);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 0, &quot;0 connections registered for d1 after mouse detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 0, &quot;0 connections registered for d2 after mouse detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 0, &quot;0 connections registered for d3 after mouse detach&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
*/
        // reconnect, check
        support.dragConnection(d1, d2);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);
        var c = _jsPlumb.select().get(0);
        equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse connect&quot;);
        equal(1, _jsPlumb.select().length, &quot;1 connection&quot;);

        //support.relocateSource(c, d3);
        //equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 0, &quot;0 connections registered for d1 after source relocate&quot;);
        //equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after source relocate&quot;);
        //equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d3&quot;).length, 1, &quot;1 connection registered for d3 after source relocate&quot;);
        //equal(_jsPlumb.anchorManager.getConnectionsFor(c.floatingId).length, 0, &quot;0 connections registered for temporary drag element after mouse detach&quot;);
    });




// ----------------------- draggables and posses ----------------------------------------------------

    test(&quot;dragging works&quot;, function() {
        var d = _addDiv(&quot;d1&quot;);
        d.style.position = &quot;absolute&quot;;
        d.style.left = &quot;50px&quot;;
        d.style.top = &quot;50px&quot;;

        _jsPlumb.draggable(d);

        support.dragNodeBy(d, 100, 100, {
            beforeMouseUp:function() {
                ok(d.classList.contains(&quot;jtk-drag&quot;), &quot;drag class set on element&quot;);
            },
            after:function() {
                ok(!d.classList.contains(&quot;jtk-drag&quot;), &quot;drag class no longer set on element&quot;);
            }
        });

        equal(150, parseInt(d.style.left, 10));
        equal(150, parseInt(d.style.top, 10));
    });

  test(&quot;dragging a posse works, elements as argument&quot;, function() {

        var d = _addDiv(&quot;d1&quot;);
        d.style.position = &quot;absolute&quot;;
        d.style.left = &quot;50px&quot;;
        d.style.top = &quot;50px&quot;;

        var d2 = _addDiv(&quot;d2&quot;);
        d2.style.position = &quot;absolute&quot;;
        d2.style.left = &quot;450px&quot;;
        d2.style.top = &quot;450px&quot;;

        _jsPlumb.draggable([d,d2]);
        _jsPlumb.addToPosse([d,d2], &quot;posse&quot;);

        support.dragNodeBy(d, 100, 100, {
            beforeMouseUp:function() {
                ok(d.classList.contains(&quot;jtk-drag&quot;), &quot;drag class set on element&quot;);
            },
            after:function() {
                ok(!d.classList.contains(&quot;jtk-drag&quot;), &quot;drag class no longer set on element&quot;);
            }
        });

        equal(150, parseInt(d.style.left, 10));
        equal(150, parseInt(d.style.top, 10));

        equal(550, parseInt(d2.style.left, 10));
        equal(550, parseInt(d2.style.top, 10));

        _jsPlumb.removeFromPosse(d2, &quot;posse&quot;);
        support.dragNodeBy(d, -100, -100);

        equal(50, parseInt(d.style.left, 10));
        equal(50, parseInt(d.style.top, 10));

        equal(550, parseInt(d2.style.left, 10));
        equal(550, parseInt(d2.style.top, 10));
    });

    test(&quot;dragging a posse works, element ids as argument&quot;, function() {
        var d = _addDiv(&quot;d1&quot;);
        d.style.position = &quot;absolute&quot;;
        d.style.left = &quot;50px&quot;;
        d.style.top = &quot;50px&quot;;

        var d2 = _addDiv(&quot;d2&quot;);
        d2.style.position = &quot;absolute&quot;;
        d2.style.left = &quot;450px&quot;;
        d2.style.top = &quot;450px&quot;;

        _jsPlumb.draggable([d,d2]);
        _jsPlumb.addToPosse([&quot;d1&quot;,&quot;d2&quot;], &quot;posse&quot;);

        support.dragNodeBy(d, 100, 100, {
            beforeMouseUp:function() {
                ok(d.classList.contains(&quot;jtk-drag&quot;), &quot;drag class set on element&quot;);
            },
            after:function() {
                ok(!d.classList.contains(&quot;jtk-drag&quot;), &quot;drag class no longer set on element&quot;);
            }
        });

        equal(150, parseInt(d.style.left, 10));
        equal(150, parseInt(d.style.top, 10));

        equal(550, parseInt(d2.style.left, 10));
        equal(550, parseInt(d2.style.top, 10));


        _jsPlumb.removeFromPosse(d2, &quot;posse&quot;);
        support.dragNodeBy(d, -100, -100);

        equal(50, parseInt(d.style.left, 10));
        equal(50, parseInt(d.style.top, 10));

        equal(550, parseInt(d2.style.left, 10));
        equal(550, parseInt(d2.style.top, 10));
    });

    test(&quot;connection dragging, redrop on original target endpoint&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        var e1 = _jsPlumb.addEndpoint(d1, { isSource:true });
        var e2 = _jsPlumb.addEndpoint(d2, { isTarget:true });

        var c = _jsPlumb.connect({source: e1, target: e2});
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

        support.relocateTarget(c, e2.canvas);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d1&quot;).length, 1, &quot;1 connection registered for d1 after mouse connect&quot;);
        equal(_jsPlumb.anchorManager.getConnectionsFor(&quot;d2&quot;).length, 1, &quot;1 connection registered for d2 after mouse connect&quot;);

    });


    test(&quot;draggable function, the various ways in which it can be called&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);

        _jsPlumb.draggable(d1); // by element
        _jsPlumb.draggable([&quot;d2&quot;, d3]);
        _jsPlumb.draggable(document.querySelectorAll(&quot;#d4&quot;));

        ok(jsPlumb.hasClass(d1, &quot;jtk-draggable&quot;), &quot;element registered as Element ok&quot;);
        ok(jsPlumb.hasClass(d2, &quot;jtk-draggable&quot;, &quot;elements registered as id in array ok&quot;));
        ok(jsPlumb.hasClass(d3, &quot;jtk-draggable&quot;, &quot;elements registered as Element in array ok&quot;));
        ok(jsPlumb.hasClass(d4, &quot;jtk-draggable&quot;, &quot;querySelectorAll output ok as input&quot;));
    });


    test(&quot;droppable function, the various ways in which it can be called&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;), d4 = _addDiv(&quot;d4&quot;);

        _jsPlumb.droppable(d1); // by element
        _jsPlumb.droppable([&quot;d2&quot;, d3]);
        _jsPlumb.droppable(document.querySelectorAll(&quot;#d4&quot;));

        ok(jsPlumb.hasClass(d1, &quot;jtk-droppable&quot;), &quot;element registered as Element ok&quot;);
        ok(jsPlumb.hasClass(d2, &quot;jtk-droppable&quot;, &quot;elements registered as id in array ok&quot;));
        ok(jsPlumb.hasClass(d3, &quot;jtk-droppable&quot;, &quot;elements registered as Element in array ok&quot;));
        ok(jsPlumb.hasClass(d4, &quot;jtk-droppable&quot;, &quot;querySelectorAll output ok as input&quot;));
    });

// click events on overlays

    test(&quot;overlay click event&quot;, function() {
            _addDiv(&quot;d1&quot;);
            _addDiv(&quot;d2&quot;);
        var count = 0;
            var c = _jsPlumb.connect({
                source: &quot;d1&quot;,
                target: &quot;d2&quot;,
                overlays:[
                    [ &quot;Label&quot;, {
                        id:&quot;label&quot;,
                        label:&#x27;hey&#x27;,
                        events:{
                            click:function() {
                                count++;
                            }
                        }
                    }],
                    [ &quot;Arrow&quot;, {
                        id:&quot;arrow&quot;,
                        events:{
                            click:function() {
                                count++
                            }
                        }
                    }]
            ]}), o = c.getOverlay(&quot;label&quot;), o2 = c.getOverlay(&quot;arrow&quot;);

        _jsPlumb.trigger(o.canvas, &quot;click&quot;);
        ok(count == 1, &quot;click event was triggered on label overlay&quot;);

        _jsPlumb.trigger(o2.path, &quot;click&quot;);
        ok(count == 2, &quot;click event was triggered on arrow overlay&quot;);
    });

    test(&quot;endpoint unmatched scopes&quot;, function() {
        var sourceEndpoint = {
                isSource: true,
                scope: &quot;blue&quot;
            }, targetEndpoint = {
                isTarget:true
            },
            d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, sourceEndpoint),
            e2 = _jsPlumb.addEndpoint(d2, targetEndpoint);

        var c = _jsPlumb.connect({source:e1, target:e2});

        ok(c == null, &quot;no connection as scopes dont match&quot;);
    });

    test(&quot;endpoint passes scope to connection, programmatic connection&quot;, function() {
        var sourceEndpoint = {
            isSource: true,
            scope: &quot;blue&quot;
            }, targetEndpoint = {
            isTarget:true,
                scope:&quot;blue&quot;
            },
            d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, sourceEndpoint),
            e2 = _jsPlumb.addEndpoint(d2, targetEndpoint);

            var c = _jsPlumb.connect({source:e1, target:e2});

        equal(c.scope, &quot;blue&quot;, &quot;connection scope is blue.&quot;);
    });

    test(&quot;endpoint passes scope to connection, connection via mouse&quot;, function() {
        var sourceEndpoint = {
                isSource: true,
                scope: &quot;blue&quot;
            }, targetEndpoint = {
                isTarget:true,
                scope:&quot;blue&quot;
            },
            d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e1 = _jsPlumb.addEndpoint(d1, sourceEndpoint),
            e2 = _jsPlumb.addEndpoint(d2, targetEndpoint);

        var c = support.dragConnection(e1, e2);

        equal(c.scope, &quot;blue&quot;, &quot;connection scope is blue.&quot;);
    });


// ------------------------------------------- groups ---------------------------------------------------------------

    var _addGroupAndDomElement = function(j, name, params) {
        var c = _addDiv(name, null, &quot;container&quot;)
        return _addGroup(j, name, c, []);
    };

    var _addGroup = function(j, name, container, members, params) {
         var g = j.addGroup(jsPlumb.extend({
            el:container,
            id:name,
            anchor:&quot;Continuous&quot;,
            endpoint:&quot;Blank&quot;
        }, params || {}));

        for (var i = 0; i &lt; members.length; i++) {
            j.addToGroup(name, members[i]);
        }

        return g;
    };

    var _dragToGroup = function(_jsPlumb, el, targetGroup) {
        targetGroup = _jsPlumb.getGroup(targetGroup);
        var tgo = jsPlumb.getOffset(targetGroup.getEl()),
            tgs = jsPlumb.getSize(targetGroup.getEl()),
            tx = tgo.left + (tgs[0] / 2),
            ty = tgo.top + (tgs[1] / 2);

        support.dragNodeTo(el, tx, ty);
    };
    var c1,c2,c3,c4,c5,c6,c1_1,c1_2,c2_1,c2_2,c3_1,c3_2,c4_1,c4_2,c5_1,c5_2, c6_1, c6_2, c_noparent;

    var _setupGroups = function(doNotMakeConnections) {
        c1 = _addDiv(&quot;container1&quot;, null, &quot;container&quot;, 0, 50);
        c2 = _addDiv(&quot;container2&quot;, null, &quot;container&quot;, 300, 50);
        c3 = _addDiv(&quot;container3&quot;, null, &quot;container&quot;, 600, 50);
        c4 = _addDiv(&quot;container4&quot;, null, &quot;container&quot;, 1000, 400);
        c5 = _addDiv(&quot;container5&quot;, null, &quot;container&quot;, 300, 400);
        c6 = _addDiv(&quot;container6&quot;, null, &quot;container&quot;, 800, 1000);

        c1_1 = _addDiv(&quot;c1_1&quot;, c1, &quot;w&quot;, 30, 30);
        c1_2 = _addDiv(&quot;c1_2&quot;, c1, &quot;w&quot;, 180, 130);
        c5_1 = _addDiv(&quot;c5_1&quot;, c5, &quot;w&quot;, 30, 30);
        c5_2 = _addDiv(&quot;c5_2&quot;, c5, &quot;w&quot;, 180, 130);
        c4_1 = _addDiv(&quot;c4_1&quot;, c4, &quot;w&quot;, 30, 30);
        c4_2 = _addDiv(&quot;c4_2&quot;, c4, &quot;w&quot;, 180, 130);
        c3_1 = _addDiv(&quot;c3_1&quot;, c3, &quot;w&quot;, 30, 30);
        c3_2 = _addDiv(&quot;c3_2&quot;, c3, &quot;w&quot;, 180, 130);
        c2_1 = _addDiv(&quot;c2_1&quot;, c2, &quot;w&quot;, 30, 30);
        c2_2 = _addDiv(&quot;c2_2&quot;, c2, &quot;w&quot;, 180, 130);
        c6_1 = _addDiv(&quot;c6_1&quot;, c6, &quot;w&quot;, 30, 30);
        c6_2 = _addDiv(&quot;c6_2&quot;, c6, &quot;w&quot;, 180, 130);

        c_noparent = _addDiv(&quot;c_noparent&quot;, null, &quot;w&quot;, 1000, 1000);

        _jsPlumb.draggable([c1_1,c1_2,c2_1,c2_2,c3_1,c3_2,c4_1,c4_2,c5_1,c5_2, c6_1, c6_2]);

        _addGroup(_jsPlumb, &quot;one&quot;, c1, [c1_1,c1_2], { constrain:true, droppable:false});
        _addGroup(_jsPlumb, &quot;two&quot;, c2, [c2_1,c2_2], {dropOverride:true});
        _addGroup(_jsPlumb, &quot;three&quot;, c3, [c3_1,c3_2],{ revert:false });
        _addGroup(_jsPlumb, &quot;four&quot;, c4, [c4_1,c4_2], { prune: true });
        _addGroup(_jsPlumb, &quot;five&quot;, c5, [c5_1,c5_2], { orphan:true, droppable:false });
        _addGroup(_jsPlumb, &quot;six&quot;, c6, [c6_1,c6_2], { orphan:true, droppable:false, proxied:false });

        if (!doNotMakeConnections) {

            _jsPlumb.connect({source: c1_1, target: c2_1});
            _jsPlumb.connect({source: c2_1, target: c3_1});
            _jsPlumb.connect({source: c3_1, target: c4_1});
            _jsPlumb.connect({source: c4_1, target: c5_1});

            _jsPlumb.connect({source: c1_1, target: c1_2});
            _jsPlumb.connect({source: c2_1, target: c2_2});
            _jsPlumb.connect({source: c3_1, target: c3_2});
            _jsPlumb.connect({source: c4_1, target: c4_2});
            _jsPlumb.connect({source: c5_1, target: c5_2});
            _jsPlumb.connect({source: c5_1, target: c3_2});

            _jsPlumb.connect({source: c5_1, target: c5, anchors: [&quot;Center&quot;, &quot;Continuous&quot;]});

            _jsPlumb.connect({source:c6_1, target:c1_1});
            _jsPlumb.connect({source:c1_2, target:c6_2});
        }
    };

    test(&quot;groups, simple access&quot;, function() {

        _setupGroups();

        // check a group has members
        equal(_jsPlumb.getGroup(&quot;four&quot;).getMembers().length, 2, &quot;2 members in group four&quot;);
        equal(_jsPlumb.getGroup(&quot;three&quot;).getMembers().length, 2, &quot;2 members in group three&quot;);
        // check an unknown group throws an error
        try {
            _jsPlumb.getGroup(&quot;unknown&quot;);
            ok(false, &quot;should not have been able to retrieve unknown group&quot;);
        }
        catch (e) {
            ok(true, &quot;unknown group retrieve threw exception&quot;);
        }

        // group4 is at [1000, 400]
        // its children are

        equal(parseInt(c4.style.left), 1000, &quot;c4 at 1000 left&quot;);
        equal(parseInt(c4.style.top), 400, &quot;c4 at 400 top&quot;);
        equal(parseInt(c4_1.style.left), 30, &quot;c4_1 at 30 left&quot;);
        equal(parseInt(c4_1.style.top), 30, &quot;c4_1 at 30 top&quot;);
        equal(parseInt(c4_2.style.left), 180, &quot;c4_2 at 180 left&quot;);
        equal(parseInt(c4_2.style.top), 130, &quot;c4_2 at 130 top&quot;);


        _jsPlumb.removeGroup(&quot;four&quot;, false);
        try {
            _jsPlumb.getGroup(&quot;four&quot;);
            ok(false, &quot;should not have been able to retrieve removed group&quot;);
        }
        catch (e) {
            ok(true, &quot;removed group subsequent retrieve threw exception&quot;);
        }
        ok(c4_1.parentNode != null, &quot;c4_1 not removed from DOM even though group was removed&quot;);
        // check positions of child nodes; they should have been adjusted.
        equal(parseInt(c4_1.style.left), 1030, &quot;c4_1 at 1030 left&quot;);
        equal(parseInt(c4_1.style.top), 430, &quot;c4_1 at 430 top&quot;);
        equal(parseInt(c4_2.style.left), 1180, &quot;c4_2 at 1180 left&quot;);
        equal(parseInt(c4_2.style.top), 530, &quot;c4_2 at 530 top&quot;);


        _jsPlumb.removeGroup(&quot;five&quot;, true);
        try {
            _jsPlumb.getGroup(&quot;five&quot;);
            ok(false, &quot;should not have been able to retrieve removed group&quot;);
        }
        catch (e) {
            ok(true, &quot;removed group subsequent retrieve threw exception&quot;);
        }
        ok(c5_1.parentNode == null, &quot;c5_1 removed from DOM because group 5 also removes its children on group removal&quot;);

        // reset: all groups should be removed
        _jsPlumb.reset();
        try {
            _jsPlumb.getGroup(&quot;three&quot;);
            ok(false, &quot;should not have been able to retrieve group after reset&quot;);
        }
        catch (e) {
            ok(true, &quot;retrieve group after reset threw exception&quot;);
        }

    });

    test(&quot;simple adding to group&quot;, function() {
        var g = _addGroupAndDomElement(_jsPlumb, &quot;g1&quot;);
        var d1 = _addDiv(&quot;d1&quot;);

        equal(g.getMembers().length, 0, &quot;0 members in group&quot;);

        _jsPlumb.addToGroup(g, d1);
        equal(g.getMembers().length, 1, &quot;1 member in group&quot;);

        var els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;g1&quot;);
        equal(countKeys(els), 1, &quot;1 element for group g1 to repaint&quot;);

        // add again; should ignore.
        _jsPlumb.addToGroup(g, d1);
        equal(g.getMembers().length, 1, &quot;1 member in group&quot;);

        var g2 = _addGroupAndDomElement(_jsPlumb, &quot;g2&quot;);
        _jsPlumb.addToGroup(g2, d1);
        equal(g.getMembers().length, 0, &quot;0 members in group g1 after node removal&quot;);
        equal(g2.getMembers().length, 1, &quot;1 member in group g2 after node addition&quot;);

        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;g1&quot;);
        equal(countKeys(els), 0, &quot;0 elements for group g1 to repaint&quot;);

        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;g2&quot;);
        equal(countKeys(els), 1, &quot;1 element for group g2 to repaint&quot;);

        var d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;);
        _jsPlumb.addToGroup(g2, [ d2, d3 ]);
        equal(g2.getMembers().length, 3, &quot;3 members in group g2 after node additions&quot;);
        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;g2&quot;);
        equal(countKeys(els), 3, &quot;3 elements for group g2 to repaint&quot;);

    });

    test(&quot;groups, dragging between groups, take one&quot;, function() {
        _setupGroups();
        var els;

        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;container3&quot;);
        equal(countKeys(els), 2, &quot;2 elements for group 3 to repaint&quot;);
        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;container4&quot;);
        equal(countKeys(els), 2, &quot;2 elements for group 4 to repaint&quot;);

        // drag 4_1 to group 3
        _dragToGroup(_jsPlumb, c4_1, &quot;three&quot;);
        equal(_jsPlumb.getGroup(&quot;four&quot;).getMembers().length, 1, &quot;1 member in group four after moving a node out&quot;);
        equal(_jsPlumb.getGroup(&quot;three&quot;).getMembers().length, 3, &quot;3 members in group three&quot;);

        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;container3&quot;);
        equal(countKeys(els), 3, &quot;3 elements for group 3 to repaint&quot;);

        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;container4&quot;);
        equal(countKeys(els), 1, &quot;1 element for group 4 to repaint&quot;);

        // drag 4_2 to group 5 (which is not droppable)
        equal(_jsPlumb.getGroup(&quot;five&quot;).getMembers().length, 2, &quot;2 members in group five before drop attempt&quot;);
        _dragToGroup(_jsPlumb, c4_2, &quot;five&quot;);
        equal(_jsPlumb.getGroup(&quot;four&quot;).getMembers().length, 0, &quot;move to group 5 fails, not droppable: 0 members in group four because it prunes&quot;);
        equal(_jsPlumb.getGroup(&quot;five&quot;).getMembers().length, 2, &quot;but still only 2 members in group five&quot;);

        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;container4&quot;);
        equal(countKeys(els), 0, &quot;0 elements for group 4 to repaint&quot;);

        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;container3&quot;);
        equal(countKeys(els), 3, &quot;3 elements for group 3 to repaint&quot;);

    });

    test(&quot;groups, moving between groups, take one&quot;, function() {
        _setupGroups();
        var els;

        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;container3&quot;);
        equal(countKeys(els), 2, &quot;2 elements for group 3 to repaint&quot;);
        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;container4&quot;);
        equal(countKeys(els), 2, &quot;2 elements for group 4 to repaint&quot;);

        var addEvt = false, removeEvt = false;
        _jsPlumb.bind(&quot;group:addMember&quot;, function() {
            addEvt = true;
        });
        _jsPlumb.bind(&quot;group:removeMember&quot;, function() {
            removeEvt = true;
        });
        // move 4_1 to group 3
        _jsPlumb.addToGroup(_jsPlumb.getGroup(&quot;three&quot;), c4_1);
        equal(_jsPlumb.getGroup(&quot;four&quot;).getMembers().length, 1, &quot;1 member in group four&quot;);
        equal(_jsPlumb.getGroup(&quot;three&quot;).getMembers().length, 3, &quot;3 members in group three&quot;);

        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;container3&quot;);
        equal(countKeys(els), 3, &quot;3 elements for group 3 to repaint&quot;);

        els = _jsPlumb.getDragManager().getElementsForDraggable(&quot;container4&quot;);
        equal(countKeys(els), 1, &quot;1 element for group 4 to repaint&quot;);


        ok(addEvt, &quot;add event was fired&quot;);
        ok(removeEvt, &quot;remove event was fired&quot;);

        // add again: it is already a member and should not be re-added
        addEvt = false;
        removeEvt = false;
        _jsPlumb.addToGroup(_jsPlumb.getGroup(&quot;three&quot;), c4_1);
        equal(_jsPlumb.getGroup(&quot;three&quot;).getMembers().length, 3, &quot;3 members in group three&quot;);
        ok(!addEvt, &quot;add event was NOT fired&quot;);
        ok(!removeEvt, &quot;remove event was NOT fired&quot;);

        // momve 4_2 to group 5 (which is not droppable)
//        equal(_jsPlumb.getGroup(&quot;five&quot;).getMembers().length, 2, &quot;2 members in group five before drop attempt&quot;);
//        _jsPlumb.addToGroup(_jsPlumb.getGroup(&quot;five&quot;), c4_2);
//        equal(_jsPlumb.getGroup(&quot;four&quot;).getMembers().length, 0, &quot;move to group 5 fails, not droppable: 0 members in group four because it prunes&quot;);
//        equal(_jsPlumb.getGroup(&quot;five&quot;).getMembers().length, 2, &quot;but still only 2 members in group five&quot;);

    });

    test(&quot;groups, dragging between groups, take 2&quot;, function() {
        _setupGroups();

        // drag 4_2 to group 1 (which is not droppable)
        equal(_jsPlumb.getGroup(&quot;one&quot;).getMembers().length, 2, &quot;2 members in group one before attempted drop from group 1&quot;);
        _dragToGroup(_jsPlumb, c4_2, &quot;one&quot;);
        equal(_jsPlumb.getGroup(&quot;four&quot;).getMembers().length, 1, &quot;1 member in group four (it prunes on drop outside)&quot;);
        equal(_jsPlumb.getGroup(&quot;one&quot;).getMembers().length, 2, &quot;2 members in group one after failed drop: group 1 not droppable&quot;);

        // drag 4_1 to group 2 (which is droppable)
        equal(_jsPlumb.getGroup(&quot;two&quot;).getMembers().length, 2, &quot;2 members in group two before drop from group 4&quot;);
        _dragToGroup(_jsPlumb, c4_1, &quot;two&quot;);
        equal(_jsPlumb.getGroup(&quot;four&quot;).getMembers().length, 0, &quot;0 members in group four after dropping el on group 2&quot;);
        equal(_jsPlumb.getGroup(&quot;two&quot;).getMembers().length, 3, &quot;3 members in group two after dropping el from group 4&quot;);

        // drag 1_2 to group 2 (group 1 has constrain switched on; should not drop even though 2 is droppable)
        _dragToGroup(_jsPlumb, c1_2, &quot;two&quot;);
        equal(_jsPlumb.getGroup(&quot;two&quot;).getMembers().length, 3, &quot;3 members in group two after attempting drop from group 1&quot;);
        equal(_jsPlumb.getGroup(&quot;one&quot;).getMembers().length, 2, &quot;2 members in group one after drop on group 2 failed due to constraint&quot;);

    });

    test(&quot;dragging nodes out of groups&quot;, function() {
        _setupGroups();
        // try dragging 1_2 right out of the box and dropping it. it should not work: c1 has constrain switched on.
        var c12o = _jsPlumb.getOffset(c1_2);
        support.dragtoDistantLand(c1_2);
        equal(_jsPlumb.getGroup(&quot;one&quot;).getMembers().length, 2, &quot;2 members in group one&quot;);
        // check the node has not actually moved.
        equal(c12o.left, _jsPlumb.getOffset(c1_2).left, &quot;c1_2 left position unchanged&quot;);
        equal(c12o.top, _jsPlumb.getOffset(c1_2).top, &quot;c1_2 top position unchanged&quot;);

        // try dragging 2_2 right out of the box and dropping it. it should not work: c1 has revert switched on.
        var c22o = _jsPlumb.getOffset(c2_2);
        support.dragtoDistantLand(c2_2);
        equal(_jsPlumb.getGroup(&quot;two&quot;).getMembers().length, 2, &quot;2 members in group two&quot;);
        // check the node has not actually moved.
        equal(c22o.left, _jsPlumb.getOffset(c2_2).left, &quot;c2_2 left position unchanged&quot;);
        equal(c22o.top, _jsPlumb.getOffset(c2_2).top, &quot;c2_2 top position unchanged&quot;);


        // c3, should also allow nodes to be dropped outside
        var c32o = _jsPlumb.getOffset(c3_2);
        support.dragtoDistantLand(c3_2);
        equal(_jsPlumb.getGroup(&quot;three&quot;).getMembers().length, 2, &quot;2 members in group three&quot;);
        // check the node has moved. but just not removed from the group.
        ok(c32o.left != _jsPlumb.getOffset(c3_2).left, &quot;c3_2 left position changed&quot;);
        ok(c32o.top != _jsPlumb.getOffset(c3_2).top, &quot;c3_2 top position changed&quot;);

        // c4 prunes nodes on drop outside
        support.dragtoDistantLand(c4_2);
        equal(_jsPlumb.getGroup(&quot;four&quot;).getMembers().length, 1, &quot;1 member in group four&quot;);
        ok(c4_2.parentNode == null, &quot;c4_2 removed from DOM&quot;);

        // c5 orphans nodes on drop outside (remove from group but not from DOM)
        support.dragtoDistantLand(c5_2);
        equal(_jsPlumb.getGroup(&quot;five&quot;).getMembers().length, 1, &quot;1 member in group five&quot;);
        ok(c5_2.parentNode != null, &quot;c5_2 still in DOM&quot;);
    });

    test(&quot;single group collapse and expand&quot;, function() {

        _setupGroups();

        equal(_jsPlumb.select({source:&quot;c3_1&quot;}).length, 2, &quot;2 source connections for c3_1&quot;);
        equal(_jsPlumb.select({target:&quot;c3_1&quot;}).length, 1, &quot;1 target connection for c3_1&quot;);
        _jsPlumb.collapseGroup(&quot;three&quot;);

        var c3_1conns = _jsPlumb.select({source:&quot;c3_1&quot;});
        equal(c3_1conns.length, 2, &quot;still 2 source connections for c3_1&quot;);
        equal(_jsPlumb.select({target:&quot;c3_1&quot;}).length, 1, &quot;still 1 target connection for c3_1&quot;);
        equal(_jsPlumb.select({source:&quot;container3&quot;}).length, 0, &quot;no source connections for container3. the connections are proxied.&quot;);
        equal(_jsPlumb.select({target:&quot;container3&quot;}).length, 0, &quot;no target connections for container3. the connections are proxied.&quot;);

        _jsPlumb.expandGroup(&quot;three&quot;);
        equal(_jsPlumb.select({source:&quot;container3&quot;}).length, 0, &quot;no connections for container3&quot;);
        equal(_jsPlumb.select({target:&quot;container3&quot;}).length, 0, &quot;no connections for container3&quot;);
        c3_1conns = _jsPlumb.select({source:&quot;c3_1&quot;});
        equal(c3_1conns.length, 2, &quot;still 2 source connections yet for c3_1&quot;);
        ok(c3_1conns.get(0).isVisible(), &quot;first c3_1 connection is visible&quot;);
        ok(c3_1conns.get(1).isVisible(), &quot;second c3_1 connection is visible&quot;);


    });

    test(&quot;group collapse that does not wish to be proxied.&quot;, function() {

        _setupGroups();

        equal(_jsPlumb.select({source:&quot;c6_1&quot;}).length, 1, &quot;1 source connection for c6_1&quot;);
        equal(_jsPlumb.select({target:&quot;c6_2&quot;}).length, 1, &quot;1 target connection for c6_2&quot;);
        _jsPlumb.collapseGroup(&quot;six&quot;);

        var c6_1conns = _jsPlumb.select({source:&quot;c6_1&quot;});
        equal(c6_1conns.length, 1, &quot;still 1 source connection for c6_1&quot;);
        equal(_jsPlumb.select({target:&quot;c6_2&quot;}).length, 1, &quot;still 1 target connection for c6_2&quot;);
        equal(c6_1conns.get(0).endpoints[0].elementId, &quot;c6_1&quot;, &quot;source endpoint unchanged for connection&quot;);
        ok(!c6_1conns.get(0).isVisible(), &quot;source connection is not visible.&quot;);

        _jsPlumb.expandGroup(&quot;six&quot;);
        ok(c6_1conns.get(0).isVisible(), &quot;source connection is visible.&quot;);

    });

    test(&quot;multiple group collapse and expand&quot;, function() {
        _setupGroups();

        equal(_jsPlumb.select({source:&quot;c3_1&quot;}).length, 2, &quot;2 source connections for c3_1&quot;);
        _jsPlumb.collapseGroup(&quot;three&quot;);
        var c3_1_source = _jsPlumb.select({source:&quot;c3_1&quot;});
        equal(c3_1_source.length, 2, &quot;still 2 source connections for c3_1&quot;);
        equal(c3_1_source.get(0).proxies[0].originalEp.elementId, &quot;c3_1&quot;, &quot;proxy configured correctly&quot;);
        ok(c3_1_source.get(1).proxies == null, &quot;second source connection from c3_1 not proxied as it goes to c3_2&quot;);
        ok(!c3_1_source.get(1).isVisible(), &quot;second source connection from c3_1 not visible as it goes to c3_2&quot;);

        _jsPlumb.collapseGroup(&quot;five&quot;);

        _jsPlumb.expandGroup(&quot;five&quot;);

        _jsPlumb.expandGroup(&quot;three&quot;);

        _jsPlumb.collapseGroup(&quot;three&quot;);
    });

    test(&quot;drop element on collapsed group&quot;, function()
    {
        _setupGroups(true);

        equal(_jsPlumb.select().length, 0, &quot;0 connections to start&quot;);

        // a connection to the group to be collapsed
        var c = _jsPlumb.connect({source:c4_2, target:c3_1});
        // a connection from the group to be collapsed
        var c2 = _jsPlumb.connect({source:c3_2, target:c1_1});
        // a connection between two other elements, but which will become owned by the collapse group.
        var c3 = _jsPlumb.connect({source:c2_1, target:c5_1});

        equal(_jsPlumb.select().length, 3, &quot;3 connections in total&quot;);

        // drop an element on a collapsed group
        // expand it afterwards
        // check everything is hunky dory
        _jsPlumb.collapseGroup(&quot;three&quot;);

        equal(c.proxies[1].originalEp.elementId, &quot;c3_1&quot;, &quot;target connection has been correctly proxied&quot;);
        ok(c.proxies[0] == null, &quot;source connection has been correctly proxied&quot;);

        equal(c2.proxies[0].originalEp.elementId, &quot;c3_2&quot;, &quot;source connection has been correctly proxied&quot;);
        ok(c2.proxies[1] == null, &quot;target connection has been correctly proxied&quot;);

        _dragToGroup(_jsPlumb, c4_2, &quot;three&quot;);
        equal(_jsPlumb.getGroup(&quot;three&quot;).getMembers().length, 3, &quot;there are 3 members in group 3 after node moved dropped &quot;);
        equal(_jsPlumb.getGroup(&quot;four&quot;).getMembers().length, 1, &quot;there is 1 member in group 4 after node moved out&quot;);

        ok(!c.isVisible(), &quot;original connection now between two members of collapsed group and is invisible.&quot;);
        ok(c.proxies[0] == null, &quot;source connection proxy removed now that the connection is internal&quot;);
        ok(c.proxies[1] == null, &quot;target connection proxy removed now that the connection is internal&quot;);
        equal(c.endpoints[0].elementId, &quot;c4_2&quot;, &quot;source endpoint reset to original&quot;);
        equal(c.endpoints[1].elementId, &quot;c3_1&quot;, &quot;target endpoint reset to original&quot;);

        _dragToGroup(_jsPlumb, c5_1, &quot;three&quot;);
        equal(_jsPlumb.getGroup(&quot;three&quot;).getMembers().length, 4, &quot;there are 4 members in group 3 after node moved dropped &quot;);
        equal(_jsPlumb.getGroup(&quot;five&quot;).getMembers().length, 1, &quot;there is 1 member in group 5 after node moved out&quot;);
        ok(c3.proxies[0] == null, &quot;source in connection dropped on collapsed group did not need to be proxied&quot;);
        equal(c3.endpoints[0].elementId, &quot;c2_1&quot;, &quot;source in connection dropped on collapsed group is unaltered&quot;);
        equal(c3.proxies[1].originalEp.elementId, &quot;c5_1&quot;, &quot;target in connection dropped on collapsed group has been correctly proxied&quot;);

        equal(_jsPlumb.select().length, 3, &quot;3 connections in total&quot;);




    });

    test(&quot;a series of group collapses and expansions&quot;, function()
    {
        _setupGroups(true);

        var c = _jsPlumb.connect({source: c2_1, target: c3_1}),
            ep1 = c.endpoints[0],
            ep2 = c.endpoints[1];

//        equal(_jsPlumb.getGroup(&quot;three&quot;).proxies.length, 0, &quot;there are 0 proxies in group 3 to begin&quot;);
//        equal(_jsPlumb.getGroup(&quot;four&quot;).proxies.length, 0, &quot;there are 0 proxies in group 4 to begin&quot;);

        equal(_jsPlumb.select().length, 1, &quot;one connection to begin&quot;);

        _jsPlumb.collapseGroup(&quot;two&quot;);
//        equal(_jsPlumb.getGroup(&quot;two&quot;).proxies.length, 1, &quot;there is 1 proxy in group 2&quot;);
//        equal(_jsPlumb.getGroup(&quot;three&quot;).proxies.length, 0, &quot;there are 0 proxies in group 3&quot;);

        equal(_jsPlumb.select().length, 1, &quot;one connection after collapse 2&quot;);

        _jsPlumb.collapseGroup(&quot;three&quot;);

        _jsPlumb.expandGroup(&quot;three&quot;);

        _jsPlumb.expandGroup(&quot;two&quot;);

        _jsPlumb.collapseGroup(&quot;three&quot;);
    });


    test(&quot;deletion of proxy connections cleans up their proxied connections.&quot;, function() {
        _setupGroups(true);

        var c = _jsPlumb.connect({source: c2_1, target: c3_1});

        equal(_jsPlumb.select().length, 1, &quot;one connection to begin&quot;);

        _jsPlumb.collapseGroup(&quot;two&quot;);
        equal(c.endpoints[0].elementId, &quot;container2&quot;, &quot;proxy configured for source after collapse&quot;);
        equal(c.proxies[0].originalEp.elementId, &quot;c2_1&quot;, &quot;source endpoint stashed correctly after collapse&quot;);

        // delete the proxy connection. it should clean up the original one. then when we collapse group three
        // there should be no connections of any sort.
        _jsPlumb.detach(c);
        equal(_jsPlumb.select().length, 0, &quot;no connections&quot;);
    });


    test(&quot;deletion of proxIED connections cleans up their proxy connections.&quot;, function() {
        _setupGroups(true);

        var c = _jsPlumb.connect({source: c2_1, target: c3_1});


        equal(_jsPlumb.select().length, 1, &quot;one connection to begin&quot;);

        _jsPlumb.collapseGroup(&quot;two&quot;);
        equal(c.endpoints[0].elementId, &quot;container2&quot;, &quot;proxy configured for source after collapse&quot;);
        equal(c.proxies[0].originalEp.elementId, &quot;c2_1&quot;, &quot;source endpoint stashed correctly after collapse&quot;);

        // delete the connection. it should clean up the original one. then when we collapse group three
        // there should be no connections of any sort.
        _jsPlumb.detach(c);
        equal(_jsPlumb.select().length, 0, &quot;there should be no connections left after detach&quot;);
        ok(c.proxies == null, &quot;proxies removed after detach&quot;);
    });

    test(&quot;indirect deletion of proxIED connections cleans up their proxy connections.&quot;, function() {
        _setupGroups(true);

        var c = _jsPlumb.connect({source: c2_1, target: c3_1});

        equal(_jsPlumb.select().length, 1, &quot;one connection to begin&quot;);

        _jsPlumb.collapseGroup(&quot;two&quot;);
        equal(c.endpoints[0].elementId, &quot;container2&quot;, &quot;proxy configured for source after collapse&quot;);
        equal(c.proxies[0].originalEp.elementId, &quot;c2_1&quot;, &quot;source endpoint stashed correctly after collapse&quot;);

        // delete the connection&#x27;s endpoint.
        _jsPlumb.deleteEndpoint(c.endpoints[1]);
        equal(_jsPlumb.select().length, 0, &quot;no connections&quot;);

    });

    test(&quot;move connections between group children via dragging connections&quot;, function() {
        _setupGroups(true);

        equal(_jsPlumb.select().length, 0, &quot;0 connections to start&quot;);

        // a connection to the group to be collapsed
        var c = _jsPlumb.connect({source: c4_2, target: c3_1});
        _jsPlumb.makeTarget(c2_1);

        equal(_jsPlumb.getGroup(&quot;four&quot;).connections.source.length, 1, &quot;one source conn in group 4&quot;);
        equal(_jsPlumb.getGroup(&quot;three&quot;).connections.target.length, 1, &quot;one target conn in group 3&quot;);

        support.relocateTarget(c, c2_1);
        equal(_jsPlumb.getGroup(&quot;four&quot;).connections.source.length, 1, &quot;one source conn in group 4 after move&quot;);
        equal(_jsPlumb.getGroup(&quot;three&quot;).connections.target.length, 0, &quot;zero target conns in group 3 after move&quot;);
        equal(_jsPlumb.getGroup(&quot;two&quot;).connections.target.length, 1, &quot;one target conn in group 2 after move&quot;);
    });

    test(&quot;cannot create duplicate group&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;);
        _jsPlumb.addGroup({el:d1, id:&quot;group&quot;});
        try {
            _jsPlumb.addGroup({el:d2, id:&quot;group&quot;});
            ok(false, &quot;should have thrown an error when trying to a duplicate group&quot;)
        }
        catch (e) {
            expect(0);
        }
    });

    test(&quot;cannot create a new Group with an element that is already configured as a Group&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;);
        _jsPlumb.addGroup({el:d1, id:&quot;group&quot;});
        try {
            _jsPlumb.addGroup({el:d1, id:&quot;group2&quot;});
            ok(false, &quot;should have thrown an error when trying to a add a group element as a new group&quot;)
        }
        catch (e) {
            expect(0);
        }

    });

    test(&quot;retrieve information about an element&#x27;s Group, by ID&quot;, function() {
        _setupGroups(true);
        equal(&quot;four&quot;, _jsPlumb.getGroupFor(&quot;c4_2&quot;).id, &quot;group id is correct, element referenced by ID&quot;);
    });

    test(&quot;retrieve information about an element&#x27;s Group, by element&quot;, function() {
        _setupGroups(true);
        equal(&quot;four&quot;, _jsPlumb.getGroupFor(document.getElementById(&quot;c4_2&quot;)).id, &quot;group id is correct, element referenced by ID&quot;);
    });

    test(&quot;retrieve information about a non existent element&#x27;s Group&quot;, function() {
        equal(null, _jsPlumb.getGroupFor(&quot;unknown&quot;), &quot;group is null because element doesn&#x27;t exist&quot;);
    });

    test(&quot;add elements that already have connections to a group&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;), d3 = _addDiv(&quot;d3&quot;),
            c = _jsPlumb.connect({source:d1, target:d2}),
            c2 = _jsPlumb.connect({source:d1, target:d3}),
            g = _addDiv(&quot;group&quot;);

        equal(2, _jsPlumb.select().length, &quot;there are two connections&quot;);

        var group = _jsPlumb.addGroup({
            el:g
        });

        // add d1; it has a connection to outside and also one to d3, which will be inside the group. add d3.
        group.add(d1); group.add(d3);
        // collapse the group. the connection from d1 should be proxied. the connection from d3 should not.
        _jsPlumb.collapseGroup(group);
        equal(2, _jsPlumb.select().length, &quot;there are two connections&quot;);
        // test for proxied
        equal(&quot;d1&quot;, c.proxies[0].originalEp.elementId, &quot;endpoint was proxied after collapse&quot;);
        // test for proxied
        equal(&quot;d1&quot;, c2.endpoints[0].elementId, &quot;endpoint to internal element was not proxied after collapse&quot;);
        equal(&quot;d3&quot;, c2.endpoints[1].elementId, &quot;endpoint to internal element was not proxied after collapse&quot;);
        equal(null, c2.proxies, &quot;connection 2 did not get proxies added&quot;);

        // expand and test proxy was cleared
        _jsPlumb.expandGroup(group);
        ok(c.proxies[0] == null, &quot;proxies removed after expand&quot;);
        // remove from the group and collapse
        group.remove(d1);
        _jsPlumb.collapseGroup(group);
        // test proxy was not attached
        ok(c.proxies[0] == null, &quot;proxies not setup since element was removed&quot;);

        // expand
        _jsPlumb.expandGroup(group);

        // add d1 again; it has a connection
        group.add(d1);
        // collapse the group. the connection from d1 should be proxied.
        _jsPlumb.collapseGroup(group);
        // test for proxied
        equal(&quot;d1&quot;, c.proxies[0].originalEp.elementId, &quot;endpoint was proxied after collapse&quot;);
        equal(2, group.getMembers().length, &quot;two members in group&quot;);

        group.removeAll();
        equal(0, group.getMembers().length, &quot;no members in group&quot;);
        _jsPlumb.expandGroup(group);

        c.proxies[0] = &quot;flag&quot;;

        _jsPlumb.collapseGroup(group);
        // test proxy was not attached
        ok(c.proxies[0] == &quot;flag&quot;, &quot;proxies not setup since all elements were removed&quot;);
    });

// -------------- endpoint clicks
    test(&quot;endpoint click&quot;, function() {
        var d = _addDiv(&quot;d1&quot;),
            e = _jsPlumb.addEndpoint(d),
            c = 0,
            ec = 0;

        _jsPlumb.bind(&quot;click&quot;, function() {
            c++;
        });

        _jsPlumb.bind(&quot;endpointClick&quot;, function() {
            ec++;
        });

        // the SVG element
        _jsPlumb.trigger(e.canvas.childNodes[0], &quot;click&quot;);

        // the path element
        _jsPlumb.trigger(e.canvas.childNodes[0].childNodes[0], &quot;click&quot;);

        // the main endpiint
        _jsPlumb.trigger(e.canvas, &quot;click&quot;);

        // each of those should have triggered a single click

        equal(ec, 3, &quot;3 endpoint clicks&quot;);
        equal(c, 0, &quot;no other clicks&quot;);
    });

    test(&quot;endpoint double click&quot;, function() {
        var d = _addDiv(&quot;d1&quot;),
            e = _jsPlumb.addEndpoint(d),
            c = 0,
            ec = 0;

        _jsPlumb.bind(&quot;dblclick&quot;, function() {
            c++;
        });

        _jsPlumb.bind(&quot;endpointDblClick&quot;, function() {
            ec++;
        });

        // the SVG element
        _jsPlumb.trigger(e.canvas.childNodes[0], &quot;dblclick&quot;);

        // the path element
        _jsPlumb.trigger(e.canvas.childNodes[0].childNodes[0], &quot;dblclick&quot;);

        // the main endpiint
        _jsPlumb.trigger(e.canvas, &quot;dblclick&quot;);

        // each of those should have triggered a single click

        equal(ec, 3, &quot;3 endpoint dbl clicks&quot;);
        equal(c, 0, &quot;no other dbl clicks&quot;);
    });

    test(&quot;connector click&quot;, function() {
        var d = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            conn = _jsPlumb.connect({source:d, target:d2}),
            c = 0;

        _jsPlumb.bind(&quot;click&quot;, function() {
            c++;
        });

        // the path element
        _jsPlumb.trigger(conn.canvas.childNodes[0], &quot;click&quot;);

        // the SVG element
        _jsPlumb.trigger(conn.canvas, &quot;click&quot;);

        // each of those should have triggered a single click

        equal(c, 2, &quot;2 clicks in total&quot;);
    });

    test(&quot;connector dbl click&quot;, function() {
        var d = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            conn = _jsPlumb.connect({source:d, target:d2}),
            c = 0;

        _jsPlumb.bind(&quot;dblclick&quot;, function() {
            c++;
        });

        // the path element
        _jsPlumb.trigger(conn.canvas.childNodes[0], &quot;dblclick&quot;);

        // the SVG element
        _jsPlumb.trigger(conn.canvas, &quot;dblclick&quot;);

        // each of those should have triggered a single click

        equal(c, 2, &quot;2 dblclicks in total&quot;);
    });

    test(&quot;overlay click&quot;, function() {
        var d = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            conn = _jsPlumb.connect({source:d, target:d2, overlays:[
                [ &quot;Arrow&quot;, { id:&quot;lbl&quot; }]
            ]}),
            lbl = conn.getOverlay(&quot;lbl&quot;),
            c = 0;

        _jsPlumb.bind(&quot;click&quot;, function() {
            c++;
        });

        // the path element
        _jsPlumb.trigger(lbl.canvas.childNodes[0], &quot;click&quot;);
        _jsPlumb.trigger(lbl.canvas.childNodes[1], &quot;click&quot;);

        // the SVG element
        _jsPlumb.trigger(lbl.canvas, &quot;click&quot;);

        // each of those should have triggered a single click

        equal(c, 3, &quot;3 clicks in total&quot;);
    });

    test(&quot;overlay dblclick&quot;, function() {
        var d = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            conn = _jsPlumb.connect({source:d, target:d2, overlays:[
                [ &quot;Arrow&quot;, { id:&quot;lbl&quot; }]
            ]}),
            lbl = conn.getOverlay(&quot;lbl&quot;),
            c = 0;

        _jsPlumb.bind(&quot;dblclick&quot;, function() {
            c++;
        });

        // the path element
        _jsPlumb.trigger(lbl.canvas.childNodes[0], &quot;dblclick&quot;);
        _jsPlumb.trigger(lbl.canvas.childNodes[1], &quot;dblclick&quot;);

        // the SVG element
        _jsPlumb.trigger(lbl.canvas, &quot;dblclick&quot;);

        // each of those should have triggered a single click

        equal(c, 3, &quot;3 dblclicks in total&quot;);
    });

    test(&quot;retrieve endpoint params, Dot endpoint&quot;, function() {
       var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
           e = _jsPlumb.connect({
               source:d1,
               target:d2,
               endpoint:[&quot;Dot&quot;, { radius:250 }]
           });

        equal(e.endpoints[0].endpoint.radius, 250, &quot;radius is set correctly and retrievable&quot;);
    });

    test(&quot;retrieve endpoint params, Rectangle endpoint&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;), d2 = _addDiv(&quot;d2&quot;),
            e = _jsPlumb.connect({
                source:d1,
                target:d2,
                endpoint:[&quot;Rectangle&quot;, { width:250, height:250 }]
            });

        equal(e.endpoints[0].endpoint.width, 250, &quot;width is set correctly and retrievable&quot;);
        equal(e.endpoints[0].endpoint.height, 250, &quot;height is set correctly and retrievable&quot;);
        ok(e.endpoints[0].endpoint.x != null, &quot;x is set and retrievable&quot;);
        ok(e.endpoints[0].endpoint.y != null, &quot;y is set and retrievable&quot;);
    });

// ---------------------------- pluggable size/position handler --------------------------------


    test(&quot;pluggable getSize&quot;, function() {
        var j = jsPlumb.getInstance(null, {
            getSize:function() { return [100,100]; }
        });

        var d = _addDiv(&quot;d&quot;);
        equal(j.getSize(d)[0], 100, &quot;width is set by pluggable function&quot;);
        equal(j.getSize(d)[1], 100, &quot;height is set by pluggable function&quot;);
    });


// -------------------------- drop precedence (required for nodes inside groups that are also droppables)
    test(&quot;drop precedence, set positive rank on element to upgrade&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;, null, null, 0, 0, 500, 500);
        var d2 = _addDiv(&quot;d2&quot;, d1, null, 200, 200, 50, 50);
        var d3 = _addDiv(&quot;d3&quot;, null, null, 700, 700, 50, 50);

        _addGroup(_jsPlumb, &quot;g1&quot;, d1, [d2]);

        _jsPlumb.makeTarget(d1);

        _jsPlumb.makeTarget(d2/*, {
            dropOptions:{
                rank:10
            }
        }*/);

        _jsPlumb.makeSource(d3);

        var sourceEvent = support.makeEvent(d3);
        var d2TargetEvent = support.makeEvent(d2);

        _jsPlumb.trigger(d3, &quot;mousedown&quot;, sourceEvent);
        _jsPlumb.trigger(document, &quot;mousemove&quot;, d2TargetEvent);


        ok(d2.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d2 has hover class&quot;);
        ok(!d1.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d1 does not have hover class; only d2 has, and it was first.&quot;);

        _jsPlumb.trigger(d2, &quot;mouseup&quot;, d2TargetEvent);

        equal(_jsPlumb.select().length, 1, &quot;one connection after drag from source to target&quot;);
        equal(d2, _jsPlumb.select().get(0).target, &quot;connection target is d2&quot;);

    });

    test(&quot;drop precedence, set negative rank on element to downgrade&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;, null, null, 0, 0, 500, 500);
        var d2 = _addDiv(&quot;d2&quot;, d1, null, 200, 200, 50, 50);
        var d3 = _addDiv(&quot;d3&quot;, null, null, 700, 700, 50, 50);

        _addGroup(_jsPlumb, &quot;g1&quot;, d1, [d2]);

        _jsPlumb.makeTarget(d1/*, {
            dropOptions:{
                rank:-10
            }
        }*/);

        _jsPlumb.makeTarget(d2);

        _jsPlumb.makeSource(d3);

        var sourceEvent = support.makeEvent(d3);
        var d2TargetEvent = support.makeEvent(d2);

        _jsPlumb.trigger(d3, &quot;mousedown&quot;, sourceEvent);
        _jsPlumb.trigger(document, &quot;mousemove&quot;, d2TargetEvent);


        ok(d2.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d2 has hover class&quot;);
        ok(!d1.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d1 does not have hover class; only d2 has, and it was first.&quot;);

        _jsPlumb.trigger(d2, &quot;mouseup&quot;, d2TargetEvent);

        equal(_jsPlumb.select().length, 1, &quot;one connection after drag from source to target&quot;);
        equal(d2, _jsPlumb.select().get(0).target, &quot;connection target is d2&quot;);

    });

    test(&quot;drop precedence, default ranks (order of droppable is ignored), group first&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;, null, null, 0, 0, 500, 500);
        var d2 = _addDiv(&quot;d2&quot;, d1, null, 200, 200, 50, 50);
        var d3 = _addDiv(&quot;d3&quot;, null, null, 700, 700, 50, 50);

        _addGroup(_jsPlumb, &quot;g1&quot;, d1, [d2]);

        _jsPlumb.makeTarget(d1);
        _jsPlumb.makeTarget(d2);

        _jsPlumb.makeSource(d3);

        var sourceEvent = support.makeEvent(d3);
        var d2TargetEvent = support.makeEvent(d2);

        _jsPlumb.trigger(d3, &quot;mousedown&quot;, sourceEvent);
        _jsPlumb.trigger(document, &quot;mousemove&quot;, d2TargetEvent);


        ok(d2.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d2 has hover class&quot;);
        ok(!d1.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d1 does not have hover class; only d2 has, even though it was second.&quot;);

        _jsPlumb.trigger(d2, &quot;mouseup&quot;, d2TargetEvent);

        equal(_jsPlumb.select().length, 1, &quot;one connection after drag from source to target&quot;);
        equal(d2, _jsPlumb.select().get(0).target, &quot;connection target is d2&quot;);

    });

    test(&quot;drop precedence, default ranks (order of droppable is ignored), group last&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;, null, null, 0, 0, 500, 500);
        var d2 = _addDiv(&quot;d2&quot;, d1, null, 200, 200, 50, 50);
        var d3 = _addDiv(&quot;d3&quot;, null, null, 700, 700, 50, 50);

        _addGroup(_jsPlumb, &quot;g1&quot;, d1, [d2]);

        _jsPlumb.makeTarget(d2);
        _jsPlumb.makeTarget(d1);

        _jsPlumb.makeSource(d3);

        var sourceEvent = support.makeEvent(d3);
        var d2TargetEvent = support.makeEvent(d2);

        _jsPlumb.trigger(d3, &quot;mousedown&quot;, sourceEvent);
        _jsPlumb.trigger(document, &quot;mousemove&quot;, d2TargetEvent);


        ok(d2.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d2 has hover class&quot;);
        ok(!d1.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d1 does not have hover class; only d2 has, and it was first.&quot;);

        _jsPlumb.trigger(d2, &quot;mouseup&quot;, d2TargetEvent);

        equal(_jsPlumb.select().length, 1, &quot;one connection after drag from source to target&quot;);
        equal(d2, _jsPlumb.select().get(0).target, &quot;connection target is d2&quot;);

    });

    test(&quot;drop precedence, equal ranks, order of droppable is used, group first&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;, null, null, 0, 0, 500, 500);
        var d2 = _addDiv(&quot;d2&quot;, d1, null, 200, 200, 50, 50);
        var d3 = _addDiv(&quot;d3&quot;, null, null, 700, 700, 50, 50);

        _addGroup(_jsPlumb, &quot;g1&quot;, d1, [d2]);

        _jsPlumb.makeTarget(d1, {
            dropOptions: {
                rank: 5
            }
        });
        _jsPlumb.makeTarget(d2, {
            dropOptions: {
                rank: 5
            }
        });

        _jsPlumb.makeSource(d3);

        var sourceEvent = support.makeEvent(d3);
        var d2TargetEvent = support.makeEvent(d2);

        _jsPlumb.trigger(d3, &quot;mousedown&quot;, sourceEvent);
        _jsPlumb.trigger(document, &quot;mousemove&quot;, d2TargetEvent);


        ok(d1.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d1 has hover class&quot;);
        ok(!d2.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d2 does not have hover class; only d1 has, and it was first.&quot;);

        _jsPlumb.trigger(d2, &quot;mouseup&quot;, d2TargetEvent);

        equal(_jsPlumb.select().length, 1, &quot;one connection after drag from source to target&quot;);
        equal(d1, _jsPlumb.select().get(0).target, &quot;connection target is d1&quot;);

    });

    test(&quot;drop precedence, equal ranks, order of droppable is used, group last&quot;, function() {
        var d1 = _addDiv(&quot;d1&quot;, null, null, 0, 0, 500, 500);
        var d2 = _addDiv(&quot;d2&quot;, d1, null, 200, 200, 50, 50);
        var d3 = _addDiv(&quot;d3&quot;, null, null, 700, 700, 50, 50);

        _addGroup(_jsPlumb, &quot;g1&quot;, d1, [d2]);

        _jsPlumb.makeTarget(d2, { rank:5 });
        _jsPlumb.makeTarget(d1, { rank:5 });

        _jsPlumb.makeSource(d3);

        var sourceEvent = support.makeEvent(d3);
        var d2TargetEvent = support.makeEvent(d2);

        _jsPlumb.trigger(d3, &quot;mousedown&quot;, sourceEvent);
        _jsPlumb.trigger(document, &quot;mousemove&quot;, d2TargetEvent);


        ok(d2.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d2 has hover class&quot;);
        ok(!d1.classList.contains(&quot;jtk-drag-hover&quot;), &quot;d1 does not have hover class; only d2 has, and it was first.&quot;);

        _jsPlumb.trigger(d2, &quot;mouseup&quot;, d2TargetEvent);

        equal(_jsPlumb.select().length, 1, &quot;one connection after drag from source to target&quot;);
        equal(d2, _jsPlumb.select().get(0).target, &quot;connection target is d2&quot;);

    });

};


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
