<html>
	<head>
		<title>jsPlumb 1.3.3 - documentation</title>
		<link rel="stylesheet" href="/mp.css"></link>
		<link rel="stylesheet" href="jsPlumbDoc.css"></link>	
	</head>
	<body>

<div class="menu"><a href="http://jsplumb.org" class="mplink" target="_top">view demo</a>&nbsp;|&nbsp;<a href="mailto:simon.porritt@gmail.com" class="mplink">contact me</a></div>

<div class="content">
		<div class="section">
			<h3><a id="summary">Summary</a></h3>
			jsPlumb allows you to connect elements on the screen using SVG, Canvas or VML, depending on the capabilities of the browser.
			<p>
				It can be used with jQuery, MooTools or YUI3 (or another library of your choice if you
				feel like implementing an adapter for it).
			</p>  

			<h5>Browser Compatibility</h5>
			<p>jsPlumb 1.3.3 has been tested on the following browsers:
				<ul>
					<li class="bullet">IE 6 on Windows XP</li>
					<li class="bullet">IE 7 on Windows XP</li>
					<li class="bullet">IE 8 on Windows XP</li>
					<li class="bullet">Firefox 3.5.8 on Windows XP</li>
					
					<li class="bullet">IE 9 on Windows 7</li>
					<li class="bullet">Chrome 12 on Windows 7</li>
					<li class="bullet">Firefox 3.5.8 on Windows 7</li>
					
					<li class="bullet">Firefox 3.6.3 on Ubuntu 10.04</li>
					<li class="bullet">Chrome on Ubuntu 10.04</li>
					
					<li class="bullet">Safari 4 on Mac Tiger</li>
					<li class="bullet">Safari 4 on Windows Vista</li>
					<li class="bullet">Safari 5.0.5 on Windows 7</li>
					<li class="bullet">Opera 10.54 on Windows XP</li>
				</ul>
			</p>
		</div>
		
		<div class="section">
			<h3><a id="changes">Changes since version 1.3.1</a></h3>
			<p>
			Version 1.3.3 contains a few new methods for working with Overlays, and a couple of bug fixes.  Since a few 1.3.x versions have been released in a short amount
			of time, I've left in the notes from 1.3.1, as there are a few backwards compatibility issues you may need to know about.		
			</p>
			<h5>New Features</h5>
				<ul>
					<li>added getOverlay(id) to Connection</li>
					<li>added hideOverlay(id) to Connection</li>
					<li>added showOverlay(id) to Connection</li>
					<li>added hide() to Overlay</li>
					<li>added show() to Overlay</li>
					<li>added setVisible(state) to Overlay</li>
				</ul>
			
			<h5>Issues Resolved</h5>
			<ul>
				<li><strong>120</strong> - dynamic anchors get confused by scrolled div</li>
				<li><strong>127</strong> - original event was lost in the jsPlumb shortcut bind methods</li>
			</ul>
			<p>
			Version 1.3.1 was a major new release of jsPlumb, containing several important new features, and a few changes that break backwards compatibility.
			</p>
			<p>
			Major new features include:
			</p>			
			<ul>
				<li>- introduced support for using SVG</li>
				<li>- removed dependency on Excanvas script for IE&lt;9. Jsplumb draws VML directly now.</li>
				<li>- introduced support for mouse events (click/doubleclick/enter/exit) for all browsers</li>
				<li>- introduced support for turning an entire element into a drag target for new connections</li>
			</ul>
			<p>
			Backwards Compatibility Issues:			
			</p>
			<ul>
				<li>
					<p>- you cannot create Endpoints/Connectors/Overlays directly anymore.  You must supply jsPlumb with a definition of what you
					 want, and it creates the actual object.  For example:</p>
	  				<pre>
OLD: 	jsPlumb.Defaults.Endpoint = new jsPlumb.Endpoints.Dot(45);
NEW:	jsPlumb.Defaults.Endpoint = [ "Dot", { radius:45 } ];
	  				</pre>	
				</li>					  	  	  	
			
				<li>
					<p>- Bezier connection requires a js object as argument now, instead of a single int</p>
					<pre>
OLD:  	connector: [ "Bezier", 150 ]
NEW: 	connector: [ "Bezier", { curviness:150 } ]
					</pre>
				</li>
				<li>
					<p>- Dot Endpoint requires a js object as argument now, instead of a single int</p>
					<pre>
OLD:	endpoint: [ "Dot", 10 ]
NEW:	endpoint: [ "Dot", { radius:10 } ]
					</pre>		
				</li>
				<li>
					<p>- getConnections has been reworked a little to make it easier to use.  See the API documentation.</p>
				</li>
				<li>
				<p>- The 'container' concept, as an argument to addEndpoint or connect, and in the jsPlumb defaults, has been 
				removed.  Created elements are now appended to the parent of the source element of a connection, or the parent of an element
				to which you are adding an Endpoint.
				</p>  
				</li>
				<li>
					<p>- The 'backgroundPaintStyle' concept has been replaced with 'outlineColor' and 'outlineWidth' members in paint style definitions.
					To use these, you must supply at least 'outlineWidth'; if 'outlineColor' is not supplied, jsPlumb will use black by default.
					</p>
				</li>
				<li>
					<p>- Functionality to drag an entire connection, by clicking and dragging the connector line, which was introduced for some browsers 
					in 1.2.6, has been removed.  I had several requests for a way to disable this, and got the distinct impression it was not
					very popular.
					</p>		
				</li>
				<li>
					<p>- The 'setDefaultNewCanvasSize' method on jsPlumb has been removed.  jsPlumb no longer uses excanvas to render
	  				VML; this method was there to support edge cases of VML usage. You probably were not even aware of this method's existence.
	  				</p>		
				</li>		
			</ul>
		</div>
		
		<div class="section">
			<h3><a id="init">Setup</a></h3>

<h4><a id="imports">Required Imports</a></h4>	
							<h4>jQuery</h4>
			<ul>
				<li class="bullet">jQuery 1.3.x or higher.</li>
				<li class="bullet">jQuery UI 1.7.x or 1.8.x (if you wish to support drag and drop).</li>
			</ul>
			<div class="code">
				<pre>&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.0/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.13/jquery-ui.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO/jquery.jsPlumb-1.3.3-all-min.js "&gt;&lt;/script&gt;</pre>
			</div>
			<h4>MooTools</h4>
				<ul>
					<li class="bullet">MooTools Core 1.2.4 or higher. jsPlumb has been tested with 1.2.4 and 1.3.3.</li>
					<li class="bullet">Drag.Move from MooTools More 1.2.4.4 or higher (if you wish to support drag and drop).</li>
				</ul>
			<div class="code">
			<pre>&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/mootools/1.3.3/mootools-yui-compressed.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO_MOO_TOOLS_MORE_1_3_2_1"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO/mootools.jsPlumb-1.3.3-all-min.js "&gt;&lt;/script&gt;</pre>
			</div>
			<h4>YUI3</h4>
			<ul>
				<li class="bullet">YUI 3.3.x.  jsPlumb has been tested on 3.3.0 only; it is possible other 3.x.x versions will work.</li>
			</ul>
			<div class="code">
			<pre>&lt;script type="text/javascript" src="http://yui.yahooapis.com/3.3.0/build/simpleyui/simpleyui-min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO/yui.jsPlumb-1.3.3-all-min.js "&gt;&lt;/script&gt;</pre>
			</div>
			
			<h4><a id="renderMode">Render Mode</a></h4>
			jsPlumb can use SVG, HTML5 Canvas elements or VML to render the various objects it adds to the display.  Most modern browsers support
			Canvas and SVG; IE&lt;9 browsers support neither.
			<p>
				By default, jsPlumb attempts to use <strong>jsPlumb.CANVAS</strong> as the render mode, falling back to <strong>jsPlumb.VML</strong> if the 
				browser is IE&lt;9.  You can change the render mode by making this call:  
			</p>
			<div class="code">
<pre>jsPlumb.setRenderMode(jsPlumb.SVG);</pre>			
			</div>
			if, for some reason, you set the render mode to be <strong>jsPlumb.VML</strong> but you're in any browser other than IE&lt;9, jsPlumb
			will use Canvas.
			<p>
			The <strong>jsPlumb.setRenderMode</strong> method returns you the render mode that jsPlumb actually ended up setting.  Valid values for setRenderMode are:
			</p>
			<ul>
				<li class="bullet">jsPlumb.CANVAS</li>
				<li class="bullet">jsPlumb.SVG</li>
				<li class="bullet">jsPlumb.VML</li>
			</ul>			
			
			<h4><a id="initializing">Initializing jsPlumb</a></h4>
			You should not start making calls to jsPlumb until the DOM has been initialized - perhaps no surprises there.  With YUI, though, the asynchronous
			nature of the script loading process means that you are not guaranteed that jsPlumb is ready as soon as the DOM is.  To handle this,
			you should bind to the "ready" event on jsPlumb (or the instance of jsPlumb you are working with):
			<div class="code">
			<pre>jsPlumb.bind("ready", function() {
...	
		
// your jsPlumb related init code goes here

...

});						
			</pre>
			</div>
			In 1.3.3 a helper method was added that can save you approximately 9 (count them!) characters:
			<div class="code">
			<pre>jsPlumb.ready(function() {
...	
		
// your jsPlumb related init code goes here

...

});						
			</pre>
			</div>
			<p>
			For jQuery and MooTools you do not actually need to do this; by the time the DOM ready event is fired in each of those libraries you can be sure 
			all the JS we need has been loaded.  But in terms of explicitly calling out that you are waiting for jsPlumb, it seems like a good practice to bind to the "ready" event.
			</p>
			<p>
			If you bind to the "ready" event after jsPlumb has already been initialized, your callback will be executed immediately.
			</p>			
			<h4><a id="unload">Unloading jsPlumb</a></h4>
			jsPlumb offers a method you can call when your page is unloading.  You should do this to insure
			against memory leaks.  You configure it like this:
				<div class="code">
<pre>
&lt;body onunload="jsPlumb.unload();"&gt;

...

&lt;/body&gt;
</pre>
				</div>
<h4><a id="multipleInstances">Multiple jsPlumb instances</a></h4>
			jsPlumb is registered on the browser's Window by default, providing one static instance
			for the whole page to use.  Should you need to, though, you can instantiate independent
			instances of jsPlumb, using the <strong>getInstance</strong> method, for example:
<div class="code">
<pre>
var firstInstance = jsPlumb.getInstance();
</pre>
</div>
The variable 'firstInstance' can now be treated exactly as you would treat the 'jsPlumb' variable - you can set
defaults, call the connect method, whatever:
<div class="code">
<pre>
firstInstance.Defaults.Connector = [ "Bezier", { curviness: 150 } ];
firstInstance.Defaults.Anchors = [ "TopCenter", "BottomCenter" ];

firstInstance.connect({source:"element1", target:"element2", scope:"someScope" });
</pre>
</div>

<strong>getInstance</strong> optionally takes an object that provides the defaults:
<div class="code">
<pre>
var secondInstance = jsPlumb.getInstance({
	PaintStyle:{ lineWidth:6, strokeStyle:"#567567", outlineColor:"black", outlineWidth:1 },
	Connector:[ "Bezier", { curviness: 30 } ],
	Endpoint:[ "Dot", { radius:5 } ],
	EndpointStyle : { fillStyle: "#567567"  },
	Anchor : [ 0.5, 0.5, 1, 1 ]
});

secondInstance.connect({ source:"element4", target:"element3", scope:"someScope" });
</pre>
</div>

		<h4><a id="zIndex">Z-index Considerations</a></h4>
		<p>
			You need to pay attention to the z-indices of the various parts of your UI when
			using jsPlumb, in particular to ensure that the elements that jsPlumb adds to
			the DOM do not overlay other parts of the interface. 
		</p>  
		<p>
			jsPlumb adds an element to the DOM for each Endpoint, Connector and Overlay. So
			for a connection having visible Endpoints at each end and a label in the middle,
			jsPlumb adds four elements to the DOM.  The actual elements it adds depend on the 
			renderer in use (Canvas/SVG/VML).  			
		</p>
		<p>
			To help you organise z-indices correctly, jsPlumb adds a CSS class to each type of
			element it adds. They are as follows:			
		</p>
		<table style="color:black;width:70%;font-size:90%;">
			<tr><td><strong>type of element</strong></td><td><strong>class added</strong></td></tr>
			<tr><td>Endpoint</td><td>_jsPlumb_endpoint</td></tr>
			<tr><td>Connector</td><td>_jsPlumb_connector</td></tr>
			<tr><td>Overlay</td><td>_jsPlumb_overlay</td></tr>
		</table>

		<h4><a id="containerDefault">Where does jsPlumb add elements?</a></h4>
		<p>
			It's important to understand where in the DOM jsPlumb will add any elements it creates,
			as it has a bearing on the markup you can use with jsPlumb.
		</p>
		<p>
			Prior to 1.3.0, jsPlumb added everything to the end of the <em>body</em> element. This
			has the advantage of being the most flexible arrangement in terms of supporting what
			elements can be connected, but in certain use cases produced unexpected results. Consider
			the arrangement where you have some connected elements in a tab: you would
			expect jsPlumb to add elements inside the tab, so that when the user switches tabs and
			the current one is hidden, all the jsPlumb stuff is hidden too.  But when the elements are 
			on the body, this does not happen!   
		</p>
		<p>
			For this reason, from 1.3.0 onwards, jsPlumb's default behaviour is to attach Endpoint elements to the parent
			of the element the Endpoint is attached to (<strong>not</strong> the actual element
			the Endpoint is attached to), and to attach Connector elements to the parent of
			the source Endpoint in the Connection. This results in all the elements of the
			Connection being siblings inside the same parent node, which jsPlumb requires, for
			various reasons arising from the trade off between doing lots of maths and the
			performance of the whole thing.
		</p>
		
		<p>
			In general, the default behaviour means that you cannot do things like this:
		</p>
		<div class="code">
<pre>
&lt;body&gt;
	&lt;div id="container0"&gt;
		&lt;div id="node0"&gt;&lt;/div&gt;
	&lt;/div&gt;
	&lt;div id="container1"&gt;
		&lt;div id="node1"&gt;&lt;/div&gt;
	&lt;/div&gt;
&lt;/body&gt;

&lt;script type="text/javascript"&gt;

	var e0 = jsPlumb.addEndpoint("node0"),
	e1 = jsPlumb.addEndpoint("node1");

	jsPlumb.connect({ source:e0, target:e1 });
&lt;/script&gt;
</pre>		
		</div>
<p>
because the elements created for 'e0' and 'e1' would have different parent nodes, and an attempt
to make a Connection between them would not work.  For the example just given, you would need to
register the Endpoints on the 'container' divs (and then quite possibly throw away the 'node' divs):  
</p>
		<div class="code">
<pre>
&lt;body&gt;
	&lt;div id="container0"&gt;
	&lt;/div&gt;
	&lt;div id="container1"&gt;
	&lt;/div&gt;
&lt;/body&gt;

&lt;script type="text/javascript"&gt;

	var e0 = jsPlumb.addEndpoint("container0"),
	e1 = jsPlumb.addEndpoint("container1");

	jsPlumb.connect({ source:e0, target:e1 });
&lt;/script&gt;
</pre>		
		</div>
	now 'e0' and 'e1' have the same parent - the <em>body</em> element. 
	
	<p>Remember that you can use the <strong>anchor</strong> parameter to an <strong>addEndpoint</strong>
	call to specify where on an element you want an Endpoint to appear.  Used in conjunction with
	CSS classes (discussed below), you can have an Endpoint on top of some element wherever you like. 
	</p>									
	<p><strong>Note regarding the drawEndpoints option on jsPlumb.connect</strong>: with the default behaviour, jsPlumb uses the offsetParent of
	the source endpoint in a connection to make final adjustments to the position of a connector. When drawEndpoints is set to false, there is no
	offsetParent of the source endpoint because it is not visible.  If your connection lies inside some container other than the document body,
	the connector will not be able to take that container's offset into account, and will most likely not be in the right place.  You should either
	use the "Blank" endpoint when you don't want to see one, or instruct jsPlumb to attach everything to the document body (see below). 
	</p>
	
	<h5>Overriding the default behaviour</h5>
	<p>
		From version 1.3.3, the <strong>container</strong> concept was reintroduced into jsPlumb, because there are use cases
		in which the default behaviour makes it difficult or impossible to build the UI you want. You can instruct jsPlumb to use some
		element as the parent of everything jsPlumb adds to the UI through usage of the <strong>jsPlumb.Defaults.Container</strong> property,
		or you can set a <strong>container</strong> parameter on calls to <strong>addEndpoint</strong> or <strong>connect</strong> (if this is set
		and a default is also set, this default value is actually used.  This may seem counter-intuitive, and could of course be changed if
		there is feedback from the community that this would be a good idea). Some examples:
	</p>
		
		Set a container to use as the default container, using a jQuery selector (you can supply MooTools/YUI selectors if that's the library you're using),
		and then add an Endpoint.  The canvas (or SVG/VML element) created will be a child of the document body:
		<div class="code">
<pre>
jsPlumb.Defaults.Container = $("body");
...
jsPlumb.addEndpoint(someDiv, { endpoint options });
</pre>		
		</div>
		
			Set a container to use as the default container, using an element id,
		and then connect two elements.  The canvases (or SVG/VML elements) created in this example will be children of the element with id "containerId":
		<div class="code">
<pre>
jsPlumb.Defaults.Container = "containerId";
...
jsPlumb.connect({ source:someDiv, target:someOtherDiv });
</pre>		
		</div>
		
		Pass a container to use into a jsPlumb.connect call, using a selector.  The canvases (or SVG/VML elements) created in this example will be children of the element with id "containerId":
		<div class="code">
<pre>
jsPlumb.connect({ source:someDiv, target:someOtherDiv, container:$("#containerId") });
</pre>		
		</div>
				Pass a container to use into a jsPlumb.addEndpoint call, using an element id. The canvas (or SVG/VML element) created in this example will be a child of the element with id "containerId":
		<div class="code">
<pre>
jsPlumb.addEndpoint(someDiv, { ..., container:"containerId" });
</pre>		
		</div>
		
		</div>
				
		<div class="section">
			<h3><a id="jsPlumbBasics">Basic Concepts</a></h3>
	
			jsPlumb is all about connecting things together, so the core abstraction in jsPlumb is the <strong>Connection</strong> object, which is itself
			broken down into these four concepts:

			<ul>
				<li><strong>Anchor</strong> - a location, relative to an element's origin, at which an Endpoint can exist. You do not create these yourself; you supply hints to the various jsPlumb functions, which create them as needed.  They have no visual representation; they are a logical position only. Anchors can be referenced by name, for the Anchors that jsPlumb ships with, or a four element array describing [ x, y, x orientation, y orientation ]. See the <a href="#anchors">anchors</a> section for more detail.<br/><br/></li>
				<li><strong>Endpoint</strong> - the visual representation of one end of a Connection.  You can create and attach these to elements 
				yourself, which you are required to do to support drag and drop, or have jsPlumb create them when creating a Connection 
				programmatically using jsPlumb.connect(...).  You can also join two Endpoints programmatically, by passing them as arguments to 
				jsPlumb.connect(...).<br/><br/></li>				
				<li><strong>Connector</strong> - the visual representation of the line connecting two elements in the page.  jsPlumb has three types of these available as defaults - a Bezier curve, a straight line, and 'flowchart' connectors. You do not interact with Connectors; you just specify definitions of them when you need to - see <a href="#definitions">Connector, Endpoint & Overlay Definitions</a> <br/><br/></li>
				<li><strong>Overlay</strong> - a UI component that is used to decorate a Connector, such as a label, arrow, etc.<br/><br/></li>
			</ul>
						
			<p>One Connection is made up of two Endpoints, a Connector, and zero or more Overlays working together to join two elements.</p>
			<p>jsPlumb's public API exposes only Connection and Endpoint, handling the creation and configuration of everything else internally.
			But you still need to be across the concepts encapsulated by Anchor, Connector and Overlay.
			</p>
			</div>
			
			<div class="section">
			<h3><a id="anchors">Anchors</a></h3>			
			<p>An Anchor models the notion of where on an element a Connector should connect.  jsPlumb has nine default anchor locations you
			can use to specify where the Connectors connect to elements: these are the four corners of an element,
			the center of the element, and the midpoint of each edge of the element:  
			<ul>
				<li class="bullet">TopCenter</li>
				<li class="bullet">TopRight</li>
				<li class="bullet">RightMiddle</li>
				<li class="bullet">BottomRight</li>
				<li class="bullet">BottomCenter</li>
				<li class="bullet">BottomLeft</li>
				<li class="bullet">LeftMiddle</li>
				<li class="bullet">TopLeft</li>
			</ul>
			
			Each of these string representations is just a wrapper around the underlying array-based syntax  [x, y, dx, dy], where x and y are
coordinates in the interval [0,1] specifying the position of the
anchor, and dx and dy are coordinates in the interval [-1, 1]
specifying the orientation of the curve incident to the anchor. For
example, [0, 0.5, -1, 0] defines a "LeftCenter" anchor with a
connector curve that emanates leftward from the anchor. Similarly,
[0.5, 0, 0, -1] defines a "CenterTop" anchor with a connector curve
emanating upwards. 	
<div class="code">
<pre>
jsPlumb.connect({...., anchor:"BottomCenter", ... }); 
</pre>
</div>
is identical to:
<div class="code">
<pre>
jsPlumb.connect({...., anchor:[ 0.5, 1, 0, 1 ], ... }); 
</pre>
</div>			

		<h3><a id="dynamicAnchors">Dynamic Anchors</a></h3>
	These are Anchors that can be positioned in one of a number of locations, choosing the one that is most appropriate each time something moves or is painted in the UI.
	<p>
	There is no special syntax to creating a DynamicAnchor; you just provide an array of individual Anchor specifications, eg:
	</p>
<div class="code">
<pre>
var dynamicAnchors = [ [ 0.2, 0, 0, -1 ],  [ 1, 0.2, 1, 0 ], 
			   [ 0.8, 1, 0, 1 ], [ 0, 0.8, -1, 0 ] ];
</pre>
</div>
<h4>	Default Dynamic Anchor</h4>
jsPlumb provides a dynamic anchor called "AutoDefault" that chooses from TopCenter, RightMiddle, BottomCenter and LeftMiddle:
<div class="code">
<pre>jsPlumb.connect({...., anchor:"AutoDefault", ... });</pre>
</div>

<h4>	Location Selection</h4>
The initial implementation of the algorithm that decides which location to choose just calculates which location is closest to the center of the 
other element in the connection.  It is possible that future versions of jsPlumb could support more sophisticated choice algorithms, if the need arose.
<h4>Draggable Connections</h4>
Dynamic Anchors and Draggable Connections can interoperate: jsPlumb locks the position of a dynamic anchor when you start to drag a connection from it,
and unlocks it once the connection is either established or abandoned. At that point you may see the position of the dynamic anchor change, as jsPlumb
optimises the connection.  <p>You can see this behaviour in the <a href="../html/jquery/draggableConnectorsDemo.html" target="_blank">draggable connections</a> demonstration, when
you drag a connection from the blue endpoint on window 1 to the blue endpoint on window 3 - the connection is established and then window 1's blue
endpoint jumps down to a location that is closer to window 3.</p> 	  
					</div>		
												
<div class="section">
		<h4><a id="definitions">Connector, Endpoint & Overlay Definitions</a></h4>
		Before we discuss Connector, Endpoints and Overlays, a quick word on definitions:  whenever you need to define a Connector, Endpoint or Overlay, you must use a "definition" of it, rather than constructing one
		directly.  This definition can be either a string that nominates the artifact you want to create:
		<div class="code">
<pre>jsPlumb.connect({
	source:"someDiv",
	target:"someOtherDiv",
	endpoint:"Rectangle"
});
</pre>
		</div>
		or an array consisting of both the artifact's name and the arguments you want to pass to its constructor:
		<div class="code">
<pre>jsPlumb.connect({
	source:"someDiv",
	target:"someOtherDiv",
	endpoint:[ "Rectangle", { cssClass:"myEndpoint", width:30, height:10 } ]
});
</pre>
		</div>
		there is also a three-argument method that allows you to specify two sets of parameters, which jsPlumb will merge together for you. The idea
		behind this is that you will often want to define common characteristics somewhere and reuse them across a bunch of different calls:
		<div class="code">
<pre>var common = {
	cssClass:"myCssClass"
};
jsPlumb.connect({
	source:"someDiv",
	target:"someOtherDiv",
	endpoint:[ "Rectangle", { width:30, height:10 }, common ]
});
</pre>
		</div>
	This syntax is supported for all Endpoint, Connector and Overlay definitions.  Here's an example using definitions for all three:	
		<div class="code">
<pre>var common = {
	cssClass:"myCssClass"
};
jsPlumb.connect({
	source:"someDiv",
	target:"someOtherDiv",
	endpoint:[ "Dot", { radius:5 }, common ],
	connector:[ "Bezier", { curviness:100 }, common ],
	overlays: [
		[ "Arrow", { foldback:0.2 }, common ],
		[ "Label", { cssClass:"labelClass" } ]	
	]
});
</pre>
		</div>		
		
		The allowed constructor parameters are different for each artifact you create, but every artifact takes a single JS object as argument,
		with the parameters as [key,value] pairs in that object.  See the relevant sections on <a href="#connectors">Connectors</a>,
		<a href="#endpoints">Endpoints</a> and <a href="#overlays">Overlays for information on supported parameters.</a>
				
	</div>


		<div class="section">
			<h3><a id="connectors">Connectors</a></h3>
			<p>Connectors are the lines that actually join elements of the UI.  jsPlumb has three connector implementations - a straight line, a Bezier curve, and
			"flowchart" connectors.  The default connector is the Bezier curve.  </p>
			<p>You optionally specify a Connector by setting the 'connector' property on a call to jsPlumb.connect or jsPlumb.addEndpoint(s). If you do not
			supply a value for 'connector', the default will be used (see <a href="#defaults">defaults</a>).</p>
			<p>You specify Connectors using the syntax described above in <a href="#definitions">Connector, Endpoint & Overlay Definitions.</a>Allowed 
			constructor values for each Connector type are described below:</p>
			
			<h4><a id="bezierConnector">Bezier Connector</a></h4>
			<p>The Bezier Connector provides a cubic Bezier path between the two Endpoints. It supports a single constructor argument:</p>
			<p>
			<strong>curviness</strong> - Optional; defaults to 150. This defines the distance in pixels that
			the Bezier's control points are situated from the anchor points.  This does not mean that your
			connector will pass through a point at this distance from your curve.  It is a hint to how you want the
			curve to travel. Rather than discuss Bezier curves at length here, because they are a complex topic,
			we refer you to <a href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank">Wikipedia.</a>
			</p>
			<h4><a id="straightConnector">Straight Connector</a></h4>
			<p>The Straight Connector draws a straight line between the two endpoints. No constructor arguments are supported; use the <strong>endpointStyle</strong>
			argument to a connect or addEndpoint call to control the appearance of one of these Connectors.  
			</p>
			<h4><a id="flowchartConnector">Flowchart Connector</a></h4>
			<p>This type of Connector draws a connection that consists of a series of vertical or horizontal segments - the classic flowchart look. A single constructor argument is supported:</p>
			<strong>stub</strong> - this is the minimum length, in pixels, of the initial stub that emanates from an Endpoint.  This parameter is optional, and defaults to 30 pixels.
			
		</div>
		
			<div class="section">
			<h3><a id="endpoints">Endpoint Types</a></h3>
			<p>An Endpoint is the UI component that marks the location of an Anchor, ie. the place where a Connector joins an
			element.  jsPlumb comes with three Endpoint implementations - Dot, Rectangle and Image. You optionally specify Endpoint properties using the
			<strong>endpoint</strong> parameter in a call to jsPlumb.connect, jsPlumb.addEndpoint or jsPlumb.makeTarget.
			</p>  
				<p>As with Connectors and Overlays, you specify Endpoints using the syntax described above in <a href="#definitions">Connector, Endpoint & Overlay Definitions.</a></p>
			
			The three available Endpoint types, and their constructor arguments, are as follows:
					<h4><a id="dotEndpoint">Dot Endpoint</a></h4>
					This Endpoint draw a dot on the screen. It supports a single constructor parameter:
					<p>
						<strong>radius</strong> - Optional; defaults to 10 pixels. Defines the radius of the dot.
					</p>
					<h4><a id="rectangleEndpoint">Rectangle Endpoint</a></h4>
						Draws a rectangle. Supported constructor parameters are:
					<p>
						<strong>width</strong> - Optional; defaults to 20 pixels. Defines the width of the rectangle.
					</p>
					<p>
						<strong>height</strong> - Optional; defaults to 20 pixels. Defines the height of the rectangle.
					</p>
					
					<h4><a id="imageEndpoint">Image Endpoint</a></h4>
						Draws an image from a given URL.  This Endpoint supports one constructor parameter:  
					<p>
						<strong>src</strong> - Required.  Specifies the URL of the image to use.
					</p>
					
									
			
			
		</div>
		
		<div class="section">
			<h3><a id="overlays">Overlay Types</a></h3>
			<p>
			Overlays are UI elements that are painted onto connections, such as labels or arrows.
			jsPlumb comes with four defaults:
			</p>
			<ul>
				<li><strong>Arrow</strong> - a configurable arrow that is painted at some point along the connector.  You can control the length and width of the Arrow, the 'foldback' point - a point the tail points fold back into, and the direction (allowed values are 1 and -1; 1 is the default and means point in the direction of the connection)</li>
				<li><strong>Label</strong> - a configurable label that is painted at some point along the connector.</li>
				<li><strong>PlainArrow</strong> - an Arrow shaped as a triangle, with no foldback.</li>
				<li><strong>Diamond</strong> - as the name suggests, a diamond.</li>
			</ul> 
			The last two are actually just configured instances of the generic Arrow overlay (see examples). 
			
			<p>You can specify one or more overlays when making a call to jsPlumb.connect or jsPlumb.addEndpoint (but not jsPlumb.makeTarget; overlays
			are always derived from what the source of a Connection defines)  The two cases are discussed below:</p>
			1. Specifying one or more overlays on a jsPlumb.connect call. In this example we'll create an Arrow with the default options for an Arrow, and
			a label with the text "foo":
			<div class="code">
			<pre>jsPlumb.connect({
	...
	overlays:[ 
		"Arrow", 
		[ "Label", { label:"foo", location:0.25 }, id:"myLabel" ]
	],
	...
});			
</pre>
			</div>
			This connection will have an arrow located halfway along it, and the label "foo" one quarter of the way along.  Notice the <strong>id</strong>
			parameter; it can be used later if you wish to remove the Overlay or change its visibility (see below).<br/><br/> 
			
			2. Specifying one or more overlays on a jsPlumb.addEndpoint call.  Note in this example that we use the parameter 'connectorOverlays' and not
			'overlays' as in the last example.  This is because 'overlays' will one day be used to support Endpoint Overlays:
			<div class="code">
			<pre>jsPlumb.addEndpoint("someDiv", {
	...
	connectorOverlays:[ 
		[ "Arrow", { width:10, length:30, location:1, id:"arrow" } ], 
		[ "Label", { label:"foo", id:"label" } ]
	],
	...
});</pre>
			</div>	
			This connection will have a 10x30 Arrow located right at the head of the connection, and the label "foo" located at the halfway point. Again,
			note that <strong>id</strong> parameter passed in to each Overlay spec.<br/><br/>
			
			 	
					<h4><a id="arrowOverlay">Arrow Overlay</a></h4>
					<p>This overlay draws an arrow, using four points: the head and two tail points, and a 'foldback' point, which permits the tail
					of the arrow to be indented. Available constructor arguments for this Overlay are </p>
					<ul>
					<li><strong>width</strong> - width of the tail of the arrow</li>
					<li><strong>length</strong> - distance from the tail of the arrow to the head</li>
					<li><strong>location</strong> - where, as a proportional value from 0 to 1 inclusive, the Arrow should appear on the Connector</li>
					<li><strong>direction</strong> - which way to point. Allowed values are 1 (the default, meaning forwards) and -1, meaning backwards </li>
					<li><strong>foldback</strong> - how far along the axis of the arrow the tail points foldback in to. Default is 0.623.</li>
					<li><strong>paintStyle</strong> - a style object in the form used for paintStyle values for Endpoints and Connectors</li>
					</ul>
					<h4><a id="plainArrowOverlay">PlainArrow Overlay</a></h4>
					<p>This is just a specialized instance of Arrow in which jsPlumb hardcodes 'foldback' to 1, meaning the tail of the Arrow is a flat edge.  All of the constructor parameters from Arrow apply for PlainArrow.</p>
					<h4><a id="diamondOverlay">Diamond Overlay</a></h4>
					<p>This is a specialized instance of Arrow in which jsPlumb hardcodes 'foldback' to 2, meaning the Arrow turns into a Diamond.  All of the constructor parameters from Arrow apply for PlainArrow.</p>
					<h4><a id="labelOverlay">Label Overlay</a></h4>
					This provides a text label to decorate Connectors with.  The available constructor arguments are:
					<ul>
						<li><strong>label</strong> - The text to display.  You can provide a function here instead of plain text: it is passed the Connection as an argument, and it should return a String.</li>
						<li><strong>cssClass</strong> - Optional css class to use for the Label.  This is now preferred over using the 'labelStyle' parameter.</li>
						<li><strong>labelStyle</strong> - (deprecated, use cssClass instead) Optional arguments for the label's appearance.  Valid entries in this JS object are:
							<ul>
								<li><em>font</em> - a font string in a format suitable for the Canvas element</li>
								<li><em>fillStyle</em> - the color to fill the label's background with. Optional.</li>
								<li><em>color</em> - the color of the label's text. Optional.</li>
								<li><em>padding</em> - optional padding for the label. This is expressed as a proportion of the width of the label, not in pixels or ems.</li>
								<li><em>borderWidth</em> - optional width in pixels for the label's border. Defaults to 0.</li>
								<li><em>borderStyle</em> - optional. The color to paint the border, if there is one.</li>
								
							</ul>
						
						</li>
						<li><strong>location</strong> - As for Arrow Overlay.  Where, proportionally from 0 to 1 inclusive, the label should appear.</li>
					</ul>
					
					<h4><a id="hideshowOverlay">Hiding/Showing Overlays</a></h4>
					<p>You can control the visibility of Overlays using the <strong>setVisible</strong> method of Overlays themselves, or with
					<strong>showOverlay(id)</strong> or <strong>hideOverlay(id)</strong> on a Connection.</p>
					<p>Remember the <strong>id</strong> parameter that we specified in the examples above?  This can be used to retrieve the Overlay
					from a Connection:</p>
					<div class="code">
<pre>var connection = jsPlumb.connect({
	...
	overlays:[ 
		"Arrow", 
		[ "Label", { label:"foo", location:0.25 }, id:"myLabel" ]
	],
	...
});		

// time passes

var overlay = connection.getOverlay("myLabel");
// now you can hide this Overlay:
overlay.setVisible(false);
// there are also hide/show methods:
overlay.show();
overlay.hide();

</pre>					
					</div>
					<p>However, Connection also has two convenience methods you could use instead:
					<div class="code">
<pre>var connection = jsPlumb.connect({
	...
	overlays:[ 
		"Arrow", 
		[ "Label", { label:"foo", location:0.25 }, id:"myLabel" ]
	],
	...
});		

// time passes

connection.hideOverlay("myLabel");

// more time passes

connection.showOverlay("myLabel");

</pre>					
					</div>
					
		<h4><a id="hideshowOverlay">Removing Overlays</a></h4>
		<p>Connection also has a <strong>removeOverlay</strong> method, that does what you might expect:
					<div class="code">
<pre>var connection = jsPlumb.connect({
	...
	overlays:[ 
		"Arrow", 
		[ "Label", { label:"foo", location:0.25 }, id:"myLabel" ]
	],
	...
});		

// time passes

connection.removeOverlay("myLabel");


</pre>					
					</div>							
	
		</div>
	
			
			<div class="section">
			<h3><a id="defaults">Defaults</a></h3>
			The easiest way to set a look and feel for your plumbing is to override the defaults that jsPlumb uses. If you
			do not do this you are forced to provide your overridden values on every call.  Every argument to the connect and addEndpoint methods has an
			associated default value in jsPlumb.<br/><br/>

			The defaults that ship with jsPlumb are stored in <em>jsPlumb.Defaults</em>, which is a Javascript object.  Valid entries, and their initial values, are:

			<div class="code">
<pre>
Anchor : "BottomCenter",
Anchors : [ null, null ],
AppendElementsToBody : false,
Connector : "Bezier",
DragOptions : { },
DropOptions : { },
Endpoint : "Dot",
Endpoints : [ null, null ],
EndpointStyle : { fillStyle : null },
EndpointStyles : [ null, null ],
EndpointHoverStyle : null,
EndpointHoverStyles : [ null, null ],
HoverPaintStyle : null,
LabelStyle : { color : "black" },
LogEnabled : false,
Overlays : [ ],
MaxConnections : 1,
MouseEventsEnabled : true,
PaintStyle : { lineWidth : 8, strokeStyle : "#456" },
RenderMode : "canvas",
Scope : "_jsPlumb_DefaultScope"
</pre>
			</div>
			<p>
			Note that in EndpointStyle, the default fillStyle is 'null'.  This instructs jsPlumb to use the strokeStyle
from the attached connector to fill the endpoint.</p>
<p>Note also that you can specify either or both (or neither) of 'EndpointStyle' and 'EndpointStyles'.  This allows you to specify a different
end point for each end of a connection.  'Endpoint' and 'Endpoints' use the same concept.  jsPlumb will look first in the
individual endpoint/endpoint style arrays, and then fall back to the single default version.</p>

			you can override these defaults by including this in a script somewhere:
			<div class="code">
<pre>
jsPlumb.Defaults.PaintStyle = {
	lineWidth:13,
	strokeStyle: 'rgba(200,0,0,100)'
}

jsPlumb.Defaults.DragOptions = { cursor: "crosshair" };

jsPlumb.Default.Endpoints = [ [ "Dot", 7 ], [ "Dot", 11 ] ];

jsPlumb.Defaults.EndpointStyles = [{ fillStyle:"#225588" }, { fillStyle:"#558822" }];</pre>
			</div>
			after the jsPlumb script has been loaded of course!  Here we have specified the following default behaviour:
			<ul>
				<li>- connectors are 13 pixels wide and painted with a semi-transparent red line</li>
				<li>- when dragging an element the crosshair cursor is used</li>
				<li>- the source endpoint is a dot of radius 7; the target endpoint is a dot of radius 11</li>
				<li>- the source endpoint is blue; the target endpoint is green</li>
			</ul>

		</div> 					

<div class="section">
			<h3><a id="simpleConnections">Connections</a></h3>
			<h4><a id="simpleConnections">Programmatic Connections</a></h4>
The most simple connection you can make with jsPlumb looks like this:
			<div class="code">
<pre>
jsPlumb.connect({source:"element1", target:"element2"});</pre>			
			</div>

		In this example we have created a Connection from 'element1' to 'element2'.  Remember that a Connection in jsPlumb consists of two Endpoints,
		a Connector, and zero or more Overlays.  But this call to 'connect' supplied none of those things, so jsPlumb uses the default values wherever it needs to.
		In this case, default values have been used for the following: 
		<ul>
			<li>- The type and appearance of each Endpoint in the Connection. jsPlumb's default for this is the "Dot" endpoint, of radius 10, with fill color "#456".</li>
			<li>- The Anchors that define where the connection's Endpoints appear on each element. The jsPlumb default is "BottomCenter"</li>			
			<li>- Whether or not each Endpoint can be a source or target for new Connections. The default is false.</li>
			<li>- The type and appearance of the Connection's Connector. The default is a "Bezier" connector of line width 8, and color "#456".</li>
		</ul>
		<p>
		So this call will result in an 8px Bezier, colored "#456", from the bottom center of 'element1' to the bottom center of 'element2', and each
		Endpoint will be a 10px radius Dot Endpoint, colored "#456".
		</p>
		<p>
		Let's beef up this call a little and tell jsPlumb what sort of Endpoints we want, and where we want them:		
		</p>
		<div class="code">
<pre>
jsPlumb.connect({
	source:"element1", 
	target:"element2",
	anchors:["RightMiddle", "LeftMiddle" ],
	endpoint:"Rectangle",
	endpointStyle:{ fillStyle: "yellow" }
});
</pre>			
			</div>
			
		<p>This is what we have told jsPlumb we want this time:</p>
		<ul>
			<li><strong>anchors</strong> - this array tells jsPlumb where the source and target Endpoints should be located on their parent elements. In this case,
			we use the shorthand syntax to name one of jsPlumb's default anchors; you can also specify custom locations (see <a href="#anchors">anchors</a>).
			Instead of <strong>anchors</strong> you can use <strong>anchor</strong>, if you want the source and target Endpoints to be located at the
			same place on their parent elements.			<br/>
			</li>
			<li>
				<strong>endpoint</strong>  - this tells jsPlumb to use the "Rectangle" Endpoint for both the source and target of the Connection.  As with anchors, 
				<strong>endpoint</strong> has a plural version that allows you to specify a different Endpoint for each end of the Connection.<br/>  
			</li>
			<li>
				<strong>endpointStyle</strong> - this is the definition of the appearance of the Endpoint you specified above.  Again, there is a
				plural equivalent of this that allows you to specify a different style for each end of the Connection. For more information about
				allowed values for this value, see <a href="#paintstyles">Connector, Endpoint & Overlay Styles</a>. 
			</li>
		</ul>		
		
		<h5>Reusing common settings between jsPlumb.connect calls</h5>
		<p>
			A fairly common situation you will find yourself in is wanting to create a bunch of Connections that have only minor differences
			between them.  To support that, <strong>jsPlumb.connect</strong> takes an optional second argument. For example:			 
		</p>
		<div class="code">
<pre>
var common = {
	anchors:[ "BottomCenter", "TopCenter" ],
	endpoints:["Dot", "Blank" ]
};

jsPlumb.connect({ source:"someElement", target:"someOtherElement" }, common);

jsPlumb.connect({ source:"aThirdElement", target:"yetAnotherElement" }, common);

</pre>			
			</div>							
					
		<h4><a id="draggableConnections">Connections using Drag and Drop</a></h4>
		To support drag and drop connections, you first need to set a few things up.  Every drag and drop connection needs at least a source
		Endpoint that the user can drag a connection from. Here's a simple example of how to create an Endpoint:
		<div class="code">
<pre>
var endpointOptions = { isSource:true };
var endpoint = jsPlumb.addEndpoint('elementId', endpointOptions);
</pre>		
</div>  	
	This Endpoint will act as a source for new Connections, and will use the jsPlumb defaults for its own appearance and that of any Connections that are drawn from it.							
	
		<h5>Tip: use the three-argument addEndpoint method for common data </h5>
		One thing that happens quite often is that you have an Endpoint whose appearance and behaviour is largely the
		same between usages on different elements, with just a few differences. 
		<div class="code">
<pre>
var exampleGreyEndpointOptions = {
	endpoint:"Rectangle",
	paintStyle:{ width:25, height:21, fillStyle:'#666' },
	isSource:true,
	connectorStyle : { strokeStyle:"#666" },
	isTarget:true
};
</pre>		
</div>  		
		Notice there is no 'anchor' set.  Here we apply it to two elements, at a different location in each:
		<div class="code">
<pre>
jsPlumb.addEndpoint('element1', { anchor:"BottomCenter" }, exampleGreyEndpointOptions)); 

jsPlumb.addEndpoint('element2', { anchor:"TopCenter" }, exampleGreyEndpointOptions));
</pre>		
</div>

<p>
Now that you have a source Endpoint, you need to either create a target Endpoint on some element, or notify jsPlumb that you wish to make an
entire element a drop target.  Let's look at how to attach a target Endpoint first:
</p>

		<div class="code">
<pre>var endpointOptions = { isTarget:true, endpoint:"Rectangle", paintStyle:{ fillStyle:"gray" } };
var endpoint = jsPlumb.addEndpoint("otherElementId", endpointOptions);
</pre>		
		</div>
		<p>
		This Endpoint, a gray rectangle, has declared that it can act as a drop target for Connections. 
</p>
<p>
Your other option for creating a drag and drop target is to make an entire element a drop target, using the <strong>jsPlumb.makeTarget</strong> method.
This method takes two arguments, the first of which specifies some element (or list of elements); the second specifies the Endpoint you wish to create on 
that element whenever a Connection is established on it.  In this example we will use the exact same target Endpoint we used before - the gray
rectangle - but we will tell jsPlumb that the element "aTargetDiv" will be the drop target:
</p>
		<div class="code">
<pre>var endpointOptions = { isTarget:true, endpoint:"Rectangle", paintStyle:{ fillStyle:"gray" } };
jsPlumb.makeTarget("aTargetDiv", endpointOptions);
</pre>		
		</div>
<p>
	The allowed values in 'endpointOptions' are identical for both the <strong>jsPlumb.addEndpoint</strong> and <strong>jsPlumb.makeTarget</strong> methods.
</p>		
		
		
<p>
There are many things you can set in an Endpoint options object; for a thorough list see the API documentation for Endpoint.  
</p>
<p>Here's an example of specifying that you want an Arrow overlay halfway along any Connection dragged from this Endpoint:</p>
<div class="code">
<pre>
var exampleGreyEndpointOptions = {
	endpoint:"Rectangle",
	paintStyle:{ width:25, height:21, fillStyle:'#666' },
	isSource:true,
	connectorStyle : { strokeStyle:"#666" },
	isTarget:true,
	connectorOverlays: [ [ "Arrow", { location:0.5 } ] ]
};
</pre>
</div>
This is an Endpoint that moves around the element it is attached to dependent on the location of other elements in the connections it is attached to
(a 'dynamic' anchor):
<div class="code">
<pre>
var exampleGreyEndpointOptions = {
	endpoint:"Rectangle",
	paintStyle:{ width:25, height:21, fillStyle:'#666' },
	isSource:true,
	connectorStyle : { strokeStyle:"#666" },
	isTarget:true,
	connectorOverlays: [ [ "Arrow", { location:0.5 } ] ]
	anchor:[ "TopCenter","RightMiddle","BottomCenter","LeftMiddle" ]
};
</pre>
</div>

<h5><a id="dragOptions">Drag Options</a></h5>
	These are options that will be passed through to the supporting library's drag API.  jsPlumb passes everything you supply here through, inserting
	wrapping functions if necessary for the various lifecycle events that jsPlumb needs to know about.  So if, for example, you pass a function to be
	called when dragging starts, jsPlumb will wrap that function with a function that does what jsPlumb needs to do, then call yours.
	<p>
	At the time of writing, jsPlumb supports jQuery, MooTools and YUI3, and each of those libraries uses different terminology.  In addition, jQuery's API is
	more fully featured, providing easy support for setting the zIndex and opacity of elements being dragged, as well as the 'scope' for a drag/drop (allowing
	you to specify more than one type of drag/drop pair), and hover classes for when a draggable is on the move or
	over a droppable. If you're using jQuery you can of course just supply these values on the dragOptions; to make it easier, jsPlumb's MooTools and YUI3 adapters recognize 
	these options and add appropriate callbacks for you.  
	</p> 
	<p>
	Given that the options here are library-specific, and they are all well-documented, we're going to discuss just the three drag options
	that behave the same way in all (see below for hoverClass):
		<ul>
		<li>opacity - the opacity of an element that is being dragged.  Should be a fraction between 0 and 1 inclusive.</li>
		<li>zIndex - the zIndex of an element that is being dragged.</li>
		<li>scope - the scope of the draggable.  can only be dropped on a droppable with the same scope.  this is discussed below.</li>
		</ul> 
	</p>
	
	<p>For more information about drag options, take a look at the <a href="http://docs.jquery.com/UI/Draggable" target="_blank">jQuery</a>, <a href="http://mootools.net/docs/more/Drag/Drag.Move" target="_blank">MooTools</a>, or <a href="http://developer.yahoo.com/yui/3/dd/" target="_blank">YUI3</a> docs.	
	</p>
	<p><strong>NOTE: there is an issue in Chrome that affects the 'cursor' argument to drag options in jQuery. See these links:</strong>
	</p><p>
<a href="http://forum.jquery.com/topic/draggable-cursor-option-does-not-work" target="_blank">http://forum.jquery.com/topic/draggable-cursor-option-does-not-work</a><br/>
<a href="http://forum.jquery.com/topic/chrome-text-select-cursor-on-drag" target="_blank">http://forum.jquery.com/topic/chrome-text-select-cursor-on-drag</a>
</p>
You should put something like this at the top of your JS to avoid it (perhaps not something so drastic as a document-wide override):	
<div class="code">
<pre>document.onselectstart = function () { return false; };</pre>
</div>		
	
	<h5><a id="dropOptions">Drop Options</a></h5>
	Drop options are treated by jsPlumb in the same way as drag options - they are passed through to the underlying library.  MooTools does not have drop options like jQuery and YUI3 do; droppable functionality in MooTools 
	is actually implemented by the Drag.Move class - the one used to initialise a draggable.  But when you setup an Endpoint in jsPlumb you should ignore
	that fact, and treat droppables like you would in jQuery or YUI3.  jsPlumb wires everything up for you under the hood.
	<p>There are three jQuery droppable options that jsPlumb treats as shortcuts in MooTools and YUI3, for the sake of consistency:</p>
		<ul>
			<li>hoverClass - the CSS class to attach to the droppable when a draggable is hovering over it.</li>
			<li>activeClass - the CSS class to attach to the droppable when a draggable is, um, being dragged.</li>
			<li>scope - the scope of the draggable.  The draggable can only be dropped on a droppable with the same scope.  This is discussed below.</li>
		</ul>   
	<p>For more information about drop options when using jQuery, see <a href="http://docs.jquery.com/UI/Droppable" target="_blank">here</a>.</p>
		
	<h5><a id="dragAndDropScope">Drag and Drop Scope</a></h5>
		jsPlumb borrowed the concept of 'scope' from jQuery's drag/drop implementation: the notion of
		which draggables can be dropped on which droppables.  In jsPlumb you can provide a 'scope' entry when 
		creating an Endpoint.  Here's the example grey Endpoint example with 'scope' added:
		
<div class="code">
<pre>
var exampleGreyEndpointOptions = {
	endpoint:"Rectangle",
	paintStyle:{ width:25, height:21, fillStyle:"#666" },
	isSource:true,
	connectionStyle : { strokeStyle:"#666" },
	isTarget:true,
	scope:"exampleGreyConnection"
};</pre>		
</div>  		
  										
	If you do not provide a 'scope' entry, jsPlumb uses a default scope.  Its value is accessible through this method:
	<div class="code">
<pre>
jsPlumb.getDefaultScope();
</pre>	
	</div>				
	If you want to change it for some reason you can do so with this method:
	<div class="code">
<pre>
jsPlumb.setDefaultScope("mySpecialDefaultScope");
</pre>	
	</div>			
	You can also, should you want to, provide the scope value separately on the drag/drop options, like this:
	<div class="code">
<pre>
var exampleGreyEndpointOptions = {
	endpoint:"Rectangle",
	painStyle:{ width:25, height:21, fillStyle:'#666' },
	isSource:true,
	connectionStyle : { strokeStyle:"#666" },
	isTarget:true,
	dragOptions:{ scope:"dragScope" },
	dropOptions:{ scope:"dropScope" }
};</pre>		
</div>  
			
	</div>	

		<div class="section">
			<h3><a id="paintstyles">Paint Styles</a></h3>
			Defining the appearance of Connectors, Endpoints (and Overlays, but this is deprecated in favour of using CSS classes) is achieved through a 'paintStyle' (or a quite similar name...keep reading)
			object passed as a parameter to one of jsPlumb.connect, jsPlumb.addEndpoint or jsPlumb.makeTarget. Depending on the method you are
			calling, the parameter names vary.
			<h5>Connector Paint Styles</h5>
			These are specified in a <em>paintStyle</em> parameter on a call to <strong>jsPlumb.connect</strong>:
			<div class="code">
<pre>jsPlumb.connect({
	source:"el1",
	target:"el2",
	paintStyle:{ strokeStyle:"blue", lineWidth:10 }
});
</pre>			
			</div>
			or in the <em>connectorPaintStyle</em> parameter on a call to <strong>jsPlumb.addEndpoint</strong>:
			<div class="code">
<pre>jsPlumb.addEndpoint({
	source:"el1",
	target:"el2",
	paintStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
	connectorPaintStyle:{ strokeStyle:"blue", lineWidth:10 }
});
</pre>			
			</div> 

Notice the <em>paintStyle</em> parameter in that example: it is the paint style for the Endpoint, which we'll discuss below.

			<h5>Endpoint Paint Styles</h5>
			These are specified in a <em>paintStyle</em> parameter on a call to <strong>jsPlumb.addEndpoint</strong>. This is the example from
			just above:
			<div class="code">
<pre>jsPlumb.addEndpoint("el1", {
	paintStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
	connectorPaintStyle:{ strokeStyle:"blue", lineWidth:10 }
});
</pre>			
			</div> 
			...or as the <em>endpointStyle</em> parameter to a jsPlumb.connect call:		
			<div class="code">
<pre>jsPlumb.connect({
	source:"el1",
	target:"el2",
	endpointStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
	paintStyle:{ strokeStyle:"blue", lineWidth:10 }
});
</pre>			
			</div>
			... or as an entry in the <em>endpointStyles</em> array passed to a jsPlumb.connect call:
					<div class="code">
<pre>jsPlumb.connect({
	source:"el1",
	target:"el2",
	endpointStyles:[ 
		{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
		{ fillStyle:"green" }
	],
	paintStyle:{ strokeStyle:"blue", lineWidth:10 }
});
</pre>			
			</div>
			or as the <em>paintStyle</em> entry in an <em>endpoint</em> parameter passed to a jsPlumb.makeTarget call:
					<div class="code">
<pre>jsPlumb.makeTarget("el1", {
	endpoint: {
		paintStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 }
	}
});
</pre>			
			</div>			
	In this example we've made "el1" into a drop target, and defined a paint style for the Endpoint jsPlumb will create when a Connection is
	established.
	
	<h5>Overlay Paint Styles</h5>
	The preferred way to set paint styles for Overlays is to use the <em>cssClass</em> parameter in the constructor arguments of an Overlay definition.
	
	<h4>Paint Style Parameters</h4>
	This is the full list of parameters you can set in a paintStyle object, but note that <strong>fillStyle</strong> is ignored by Connectors,
	and <strong>strokeStyle</strong> is ignored by Endpoints.  Also, if you create a Connection using jsPlumb.connect and do not specify any
	Endpoint styles, the Endpoints will derive their fillStyle from the Connector's strokeStyle.
	<p>
		fillStyle, strokeStyle and outlineColor can be specified using any valid CSS3 syntax.
	</p>
	<ul>
		<li><strong>fillStyle</strong> - color for an Endpoint, eg. rgba(100,100,100,50), "blue", "#456", "#993355", rgb(34, 56, 78).</li>
		<li><strong>strokeStyle</strong> - color for a Connector. see fillStyle examples.</li>
		<li><strong>lineWidth</strong> - width of a Connector's line. An integer.</li>
		<li><strong>outlineWidth</strong> - width of the outline for an Endpoint or Connector. An integer.</li>
		<li><strong>outlineColor</strong> - color of the outline for an Endpoint or Connector. see fillStyle examples.</li>
		<li><strong>dashstyle</strong> - VML and SVG only. This comes from VML, and allows you to create dashed or dotted lines.  It has a 
			better syntax than the equivalent attribute in SVG (<em>stroke-dasharray</em>, discussed below), so jsPlumb supports this for both renderers. 
			The <em>dashstyle</em> attribute is specified as an array of strokes and spaces, where each value is some multiple of <em>the width of 
			the Connector</em>, and that's where it's better than SVG, which uses pixels.
			<p>
			<a href="http://www.w3.org/TR/NOTE-VML" target="_blank">The VML spec</a> is a good place to find valid values for dashstyle. Note that
			jsPlumb does not support the string values for this attribute ("solid", "dashdot", etc).
			</p>
			<p>
			In SVG render mode, jsPlumb uses the <em>lineWidth</em> parameter in conjunction with the values in a <em>dashstyle</em> attribute
			to create an appropriate value for <em>stroke-dasharray</em>.
			</p>
		</li>
		<li><strong>stroke-dasharray</strong> - SVG only. This is the SVG equivalent of <em>dashstyle</em>.  
		<a href="http://www.w3.org/TR/SVG/painting.html" target="_blank">The SVG spec</a> discusses valid values for this parameter.  But be aware
		that jsPlumb does not convert this into a valid <em>dashstyle</em> attribute when using the VML renderer. Better to use <em>dashstyle</em>.
		</li>
		<li><strong>stroke-dashoffset</strong> - SVG only.  This is used in SVG to specify how far into the dash pattern to start painting.  For more information,
		see <a href="http://www.w3.org/TR/SVG/painting.html" target="_blank">the SVG spec.</a></li>
		<li><strong>joinstyle</strong> - VML and SVG only.  As with <em>dashstyle</em>, this is a VML attribute that jsPlumb supports for both VML
		and SVG - jsPlumb turns this into a <em>stroke-linejoin</em> attribute when rendering with SVG.  This attribute specifies how you want individual
		segments of connectors to be joined; the VML and SVG specs both have examples of this, of which many are the same between the two, which is
		why jsPlumb will automatically convert this attribute into the SVG equivalent.
		</li>
		<li><strong>stroke-linejoin</strong> - SVG only.  This is the equivalent of VML's <em>joinstyle</em> attribute, but as with <em>stroke-dasharray</em>,
		jsPlumb does not convert this into something approriate for VML.  So, using <em>joinstyle</em> will enable you to support more browsers with
		less effort.		
		</li>
	</ul>
	
	<h3><a id="hoverpaintstyles">Hover Paint Styles</a></h3>
	 		
	 		Connectors and Endpoints both support the concept of a "hover" paint style - a paint style to use when the mouse is hovering over
	 		the component.  These are specified in the exact same format as paint styles discussed above, but hover paint styles also inherit
	 		any values from the main paint style.  This is because you will typically want to just change the color, or perhaps outline color, of
	 		a Connector or Endpoint when the mouse is hovering, but leave everything else the same.  So having hover paint styles inherit their
	 		values precludes you from having to define things in more than one place.
	 		<p>
	 			The naming convention adopted for hover paint styles is pretty much to insert the word 'hover' into the corresponding main paint
	 			style parameters.  Here are a couple of examples:
	 		</p> 
	 					<div class="code">
<pre>jsPlumb.connect({
	source:"el1",
	target:"el2",
	paintStyle:{ strokeStyle:"blue", lineWidth:10 },
	hoverPaintStyle:{ strokeStyle:"red" },
	endpointStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
	endpointHoverStyle:{ fillStyle:"red" }
});
</pre>			
			</div>
			In this example we specified a hover style for both the Connector, and each of its Endpoints.  Here's the same thing, but using the plural
			version, to specify a different hover style for each Endpoint:
			
			
					<div class="code">
<pre>jsPlumb.connect({
	source:"el1",
	target:"el2",
	paintStyle:{ strokeStyle:"blue", lineWidth:10 },
	hoverPaintStyle:{ strokeStyle:"red" },
	endpointStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
	endpointHoverStyles:[ { fillStyle:"red" }, { fillStyle:"yellow" } ]
});
</pre>			
			</div>
	 		Calls to <strong>jsPlumb.addEndpoint</strong> and <strong>jsPlumb.makeTarget</strong> can also specify various hover paint styles:
	 								<div class="code">
<pre>jsPlumb.addEndpoint("el1", {
	paintStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
	hoverPaintStyle:{ fillStyle:"red" },
	connectorPaintStyle:{ strokeStyle:"blue", lineWidth:10 },
	connectorHoverPaintStyle:{ strokeStyle:"red", outlineColor:"yellow", outlineWidth:1 }
});
</pre>			
			</div> 
	 		
	 		Here we specified a hover paint style for both the Endpoint we are adding, and any Connections that are made from the Endpoint.
	 		<p><strong>jsPlumb.makeTarget</strong> also supports hover paint styles - here's the example from before, with one applied:</p>
	 		
	 							<div class="code">
<pre>jsPlumb.makeTarget("el1", {
	endpoint: {
		paintStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
		hoverPaintStyle:{ fillStyle:"red" }
	}
});
</pre>			
			</div>	
	
		Note that <strong>jsPlumb.makeTarget</strong> does not support Connector parameters. It is for creating targets only; Connector parameters 
		will be set by the source Endpoint in any Connections that are made to the element that you turned into a target by using this method.
	 		
	 		
			<h4><a id="gradients">Gradients</a></h4>
			The Canvas and SVG renderers both support gradients. The VML renderer does not.  jsPlumb uses its own syntax to define
			gradients, to abstract out the differences between the syntax required by canvas and that required by SVG.  
			<p>There are two types of gradients available - a 'linear' gradient, which consists of colored lines all
			going in one direction, and a 'radial' gradient, which consists of colored circles emanating from one circle to another.
			Because of their basic shape, jsPlumb supports only <em>linear</em> gradients for
			Connectors.  But for Endpoints, jsPlumb supports both <em>linear</em> and <em>radial</em> gradients.</p>
			
				<h5>Connector gradients</h5>
				To specify a linear gradient to use in a Connector, you must add a <em>gradient</em> object to your
				Connector's <em>paintStyle</em>, for instance:
<div class="code">
<pre>jsPlumb.connect({
	source : "window2",
	target : "window3",
	paintStyle:{
		gradient:{
			stops:[[0,"green"], [1,"red"]]
		},
		lineWidth:15
	}
});
</pre>
</div>
Here we have connected window2 to window3 with a 15 pixel wide connector that has a gradient from green to red.</p><p> Notice the <strong>gradient</strong> object and the
<strong>stops</strong> list inside it - the gradient consists of an arbitrary number of these "color stops".  Each color stop is comprised
of two values - [position, color].  Position must be a decimal value between 0 and 1 (inclusive), and indicates where the color
stop is situated as a fraction of the length of the entire gradient.  Valid values for
the colors in the <strong>stops</strong> list are the same as those that are valid for <strong>strokeStyle</strong> when describing a color.
			</p>
			As mentioned, the <strong>stops</strong> list can hold an arbitrary number of entries.  Here's an example of a gradient that goes from red to blue to green, and back again through blue to red:
<div class="code">
<pre>jsPlumb.connect({
	source : 'window2',
	target : 'window3',
	paintStyle : {
		gradient:{
			stops:[[0,'red'], [0.33,'blue'], [0.66,'green'], [0.33,'blue'], [1,'red']]
		},
		lineWidth : 15
	}
});
</pre>
</div>
<strong>Note:</strong> when using the VML renderer, jsPlumb will simply ignore the gradient directive
so it is best to ensure you also supply a <em>strokeStyle</em> in your paintStyle object, to give jsPlumb something to fall back on.  If you do not supply
a <em>strokeStyle</em> your Connectors will be painted black.  The previous example might look like this, for instance:
<div class="code">
<pre>jsPlumb.connect({
	source : 'window2',
	target : 'window3',
	paintStyle:{
		strokeStyle:'red',
		gradient:{
			stops:[[0,'red'], [0.33,'blue'], [0.66,'green'], [0.33,'blue'], [1,'red']]
		},
		lineWidth:15
	}
});
</pre>
</div>
Notice the <strong>strokeStyle:'red'</strong> directive at the beginning of the parameter list in <strong>paintStyle</strong>.
			<h5>Endpoint gradients</h5>
			Endpoint gradients are specified using the same syntax as Connector gradients.  You put the gradient specifier either in the
			<strong>endpoint</strong> member, or if you are specifying different Endpoints for each end of the Connector, in one or both of
			the values in the <strong>endpoints</strong> array.  Also, this information applies to the case that you are creating standalone
			Endpoints that you will be configuring for drag and drop creation of new Connections. 
			<p>
			This is an example of an Endpoint gradient that is different for each Endpoint in the Connector.  This comes from the main demo; it is
			the Connector joining Window 2 to Window 3:
			</p>
<div class="code">
<pre>var w23Stroke = 'rgb(189,11,11)';
jsPlumb.connect({
	source : 'window2',
	target : 'window3',
	paintStyle:{
		lineWidth:8,
		strokeStyle:w23Stroke
	},
 	anchors:[ [0.3,1,0,1], "TopCenter" ],
 	endpoint:"Rectangle",
 	endpointStyles:[
 		{ gradient : {stops:[[0, w23Stroke], [1, '#558822']] } },
    	{ gradient : {stops:[[0, w23Stroke], [1, '#882255']] } }
    ]
});
</pre>
</div>
The first entry in the gradient will be the one that is on the Connector end of the Endpoint.  You can of course have as many color stops as
you want in this gradient, just like with Connector gradients.
	<h5>Applying the gradient in Endpoints</h5>
	Only the Dot and Rectangle endpoints honour the presence of a gradient (and, remember, not in VML). The Image endpoint of course ignores a gradient
	as it does no painting of its own.
	<p>The type of gradient you will see depends on the Endpoint type:</p>
		<ul>
			<li><strong>Dot</strong> - renders a radial endpoint, with color stop 0 on the outside, progressing inwards as we move through color stops.
			<p>Radial gradients actually require more data than linear gradients - in a linear gradient we just move from one point to another, whereas
			in a radial gradient we move from one <em>circle</em> to another.  By default, jsPlumb will render a radial gradient using a source
			circle of the same radius as the Endpoint itself, and a target circle of 1/3 of the radius of the Endpoint (both circles share the
			same center as the Endpoint itself). This circle will be offset by radius/2 in each direction.</p>
			<p>You can supply your own values for these inside the gradient descriptor:</p>
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
jsPlumb.connect({
	source : 'window3',
	target : 'window4',
    paintStyle:{
    	lineWidth:10,
    	strokeStyle:w34Stroke
    },
    anchors:[ "RightMiddle", "LeftMiddle" ],
    endpointStyle:{
    	gradient : {
    		stops:[ [0, w34Stroke], [1, w34HlStroke] ],
    		offset:37.5,
    		innerRadius:40
    	},
    	radius:55
    }
 });
</pre>
</div>
Here we have instructed jsPlumb to make the gradient's inner radius 10px instead of the default 25/3 = 8 ish pixels, and the offset in each direction
will be 5px, instead of the default radius / 2 = 12.5 pixels.
<p>It is also possible to specify the offset and inner radius as percentages - enter the values as strings with a '%' symbol on the end:</p>
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
jsPlumb.connect({
	source : 'window3', 
	target : 'window4',
    paintStyle:{
    	lineWidth:10,
    	strokeStyle:w34Stroke
    },
	anchors:[ "RightMiddle", "LeftMiddle" ],
	endpointStyle:{
		gradient : {
			stops:[ [0, w34Stroke], [1, w34HlStroke] ],
			offset:'68%',
			innerRadius:'73%'
		},
		radius:25
	}
});
</pre>
</div>
This will give roughly the same output as the example above (the percentages are not entirely exact).<br/><br/>
			</li>
			<li><strong>Rectangle</strong> - renders a linear endpoint, with color stop 0 closest to the end of the Connector</li>
		</ul>
		</div>

		<div class="section">
			<h3><a id="cssclasses">CSS Class Reference</a></h3>
			jsPlumb attaches classes to each of the UI components it creates.
			<p>These class names are exposed on the jsPlumb object and can be overridden if you need to do so (see the third column in the table) </p>
			<table width="70%" class="table">
				<tr><th>Component</th><th>CSS Class</th><th>jsPlumb Member</th></tr>
				<tr><td>Connector</td><td>_jsPlumb_connector</td><td>connectorClass</td></tr>
				<tr><td>Endpoint</td><td>_jsPlumb_endpoint</td><td>endpointClass</td></tr>
				<tr><td>Overlay</td><td>_jsPlumb_overlay</td><td>overlayClass</td></tr>
			</table>
			<p>You would typically use these to establish appropriate z-indices for your UI.</p>			
		</div>
				
		<div class="section">
			<h3><a id="animation">Animation</a></h3>
			jsPlumb offers an 'animate' function, which wraps the underlying animation engine for whichever library you happen to be using and
			inserts a callback for jsPlumb to repaint whatever it needs to at each step.  You could of course do this yourself; it's a convenience
			method really.
			<p>The method signature is:</p>
<div class="code">
<pre>
jsPlumb.animate : function(el, properties, options) 
</pre>
</div>			
The arguments are as follows:
	<ul>
		<li><strong>el</strong> - element id, or element object from the library you're using.</li>
		<li><strong>properties</strong> - properties for the animation, such as duration etc.</li>
		<li><strong>options</strong> - options for the animation, such as callbacks etc.</li>
	</ul>
	
		</div>
		
			<div class="section">
			<h3><a id="connectionInfo">Retrieving Connection Information</a></h3>
			jsPlumb offers one fairly versatile method - <strong>getConnections</strong> - to retrieve information about the
			currently managed connections.  
			<p>Before you use this method you should understand jsPlumb's notion of 'scope' - documentation
			is <a href="#dragAndDropScope">here</a> </p>
			
			<h4>Retrieving connections for a single scope</h4>
			<p>To do this, you call getConnections with either no arguments, in which case jsPlumb uses the default scope, or with a string
			specifying one scope</p>
			<div class="code">
<pre>var connectionList = jsPlumb.getConnections();     // you get a list of Connection objects that are in the default scope.
</pre>			
			</div>
			Compare this with:
			<div class="code">
<pre>var connectionList = jsPlumb.getConnections("myScope");     // you get a list of Connection objects that are in "myScope".
</pre>			
			</div>
			<h4>More advanced filtering</h4>
			getConnections optionally takes a JS object specifying filter parameters, of which there are three:
			<ul>
				<li>scope - the scope(s) of the connection type(s) you wish to retrieve</li>
				<li>source - limits the returned connections to those that have this source id</li>
				<li>target - limits the returned connections to those that have this target id</li>
			</ul>			
			Each of these three parameters may be supplied as a string, or a list of strings - see the examples below.
			<p>
			The return value of a call to getConnection using a JS object as parameter varies on how many scopes you defined.  If you defined only
			a single scope then jsPlumb returns you a list of Connections in that scope.  Otherwise the return value is a dictionary whose keys are 
			scope names, and whose values are lists of Connections. For example, the following call:
			</p>
			<div class="code">
<pre>
	jsPlumb.getConnections({scope:["someScope", "someCustomScope"]});
</pre>
</div>
would result in this output:			
<div class="code">
<pre>
{
	"someScope" : [ 1..n Connections ],
	"someCustomScope": [ 1..m Connections ]
}
</pre>
</div>			
		The following examples show the various ways you can get connection information:
	<ul>
		<li>Get all connections:
			<div class="code">
<pre>
var c = jsPlumb.getAllConnections();  
</pre>
</div>						
		</li>
<li>Get all connections for the default scope only (return value is a list):
			<div class="code">
<pre>
var c = jsPlumb.getConnections();  
</pre>
</div>						
		</li>
		<li>Get all connections for the given scope (return value is a list):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({scope:"myTestScope"});  
</pre>
</div>						
		</li>
		<li>Get all connections for the given scopes (return value is a map of scope names to connection lists):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({scope:["myTestScope", "yourTestScope"]});  
</pre>
</div>						
		</li>
		<li>Get all connections for the given source (return value is a map of scope names to connection lists):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({source:"mySourceElement"});  
</pre>
</div>						
		</li>
		<li>Get all connections for the given sources (return value is a map of scope names to connection lists):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({source:["mySourceElement", "yourSourceElement"]});  
</pre>
</div>						
		</li>		
<li>Get all connections for the given target (return value is a map of scope names to connection lists):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({target:"myTargetElement"});  
</pre>
</div>						
		</li>				
<li>Get all connections for the given source and targets (return value is a map of scope names to connection lists):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({source:"mySourceElement", target:["target1", "target2"]});  
</pre>
</div>						
		</li>				
		
<li>Get all connections for the given scope, with the given source and target (return value is a list of connections):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({scope:'myScope", source:"mySourceElement", target:"myTargetElement"});  
</pre>
</div>						
		</li>				
		
	</ul>	

		</div>
		
		<div class="section">
			<h3><a id="events">Events</a></h3>
			jsPlumb supports binding to several different events, both on Connections, Endpoints and Overlays, and also on the jsPlumb
			object itself.  To bind events on any of these objects you use the <strong>jsPlumb.bind(object, event, callback)</strong> method, 
			<strong>except</strong> in the case of Overlays, in which you provide the event listeners in the Overlay's constructor arguments (example below). 
			
			<h4><a id="jsPlumbEvents">jsPlumb Events</a></h4>
			<ul>
				<li class="bullet"><strong>jsPlumbConnection</strong> - notification a Connection was established.  The callback is passed the new Connection as argument.</li>
				<li class="bullet"><strong>jsPlumbConnectionDetached</strong> - notification a Connection was detached.  The callback is passed the detached Connection as argument.</li>
				<li class="bullet"><strong>click</strong> - notification a Connection was clicked.  The callback is passed the Connection and the original mouse event.</li>
				<li class="bullet"><strong>dblclick</strong> - notification a Connection was double-clicked.  The callback is passed the Connection and the original mouse event.</li>
				<li class="bullet"><strong>endpointClick</strong> - notification an Endpoint was clicked.  The callback is passed the Endpoint and the original mouse event.</li>
				<li class="bullet"><strong>endpointDblClick</strong> - notification an Endpoint was double-clicked.  The callback is passed the Endpoint and the original mouse event.</li>
			</ul>
			<h4><a id="connectionEvents">Connection Events</a></h4>			
			<ul>
				<li class="bullet"><strong>click</strong> - notification a Connection was clicked.  The callback is passed the Connection and the original mouse event.</li>
				<li class="bullet"><strong>dblclick</strong> - notification a Connection was double-clicked.  The callback is passed the Connection and the original mouse event.</li>
				<li class="bullet"><strong>mouseenter</strong> - notification the mouse entered the Connection's path.  The callback is passed the Connection and the original mouse event.</li>
				<li class="bullet"><strong>mouseexit</strong> - notification the mouse exited the Connection's.  The callback is passed the Connection and the original mouse event.</li>
			</ul>
			<h4><a id="endpointEvents">Endpoint Events</a></h4>			
			<ul>
				<li class="bullet"><strong>click</strong> - notification an Endpoint was clicked.  The callback is passed the Endpoint and the original mouse event.</li>
				<li class="bullet"><strong>dblclick</strong> - notification an Endpoint was double-clicked.  The callback is passed the Endpoint and the original mouse event.</li>
				<li class="bullet"><strong>mouseenter</strong> - notification the mouse entered the Endpoint.  The callback is passed the Endpoint and the original mouse event.</li>
				<li class="bullet"><strong>mouseexit</strong> - notification the mouse exited the Endpoint.  The callback is passed the Endpoint and the original mouse event.</li>
			</ul>
			<h4><a id="overlayEvents">Overlay Events</a></h4>
			Registering event listeners on an Overlay is a slightly different procedure - you provide them as arguments to the Overlay's 
			constructor.  This is because you never actually act on an 'Overlay' object.  Here's how to register a click listener on an Overlay:
			<div class="code">
<pre>jsPlumb.connect({
	source:"el1",
	target:"el2",
	overlays:[
		[ "Label", {
			events:{
				click:function(labelOverlay, originalEvent) { alert("you clicked on the label overlay for this connection :" + labelOverlay.connection) }
			}
		}] 	
	]
});
</pre>			
			</div>		
		</div>

				<div class="section">
			<a id="examples"><h3>jsPlumb.connect Examples</h3></a>
This section provides examples of how to use the programmatic API to establish Connections. 
			<p>
			The basic syntax of a call is that you execute 'connect', providing a source and a target, and optionally a paintStyle and preferences for where you
			want the plumbing to be anchored on each element, as well as the type of connector to use. 
			</p>
			<ul>
				<li>Connect window1 to window2 with the default settings:
					<div class="code">
						<pre>jsPlumb.connect({source:"window1", target:"window2"});</pre>
					</div>
This connects 'window1' to 'window2' using the jsPlumb defaults - a red Bezier curve Connector and black Dot Endpoints.
				</li>
				<li>Connect window1 to window2 with a 15 pixel wide yellow Connector, and a slightly brighter endpoint (remember the default Endpoint is a Dot):
					<div class="code">
<pre>jsPlumb.connect({
	source:'window1',
	target:'window2',
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'},
	endpointStyle:{fillStyle:'rgb(243,229,0)'}
});</pre>
					</div>
				</li>
				
				<li>Connect window1 to window2 with a 15 pixel wide yellow Connector, and a slightly brighter endpoint:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window1',
	target:'window2',
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'},
	endpointStyle:{fillStyle:'rgb(243,229,0)'}
});</pre>
					</div>
				</li>				
				<li>Connect window3 to 'window4' with a 10 pixel wide, semi opaque blue Connector, anchored to the left middle of window3, and the right middle of window4, with a Rectangle endpoint of width 10 and height 8:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window3',
	target:'window4',
	paintStyle:{ lineWidth:10, strokeStyle:'rgba(0, 0, 200, 0.5)' },
	anchors:["RightMiddle", "LeftMiddle"],
	endpoint:[ "Rectangle", { width:10, height:8 } ]
});</pre>
					</div>
				</li>
				<li>Connect window2 to window3 with a default Connector from the top center of window2 to the bottom center of window3, and rectangular endpoints:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window2',
	target:'window3',
	paintStyle:{lineWidth:8, strokeStyle:'rgb(189,11,11)'},
	anchors:["BottomCenter", "TopCenter"],
	endpoint:"Rectangle"
});</pre>
					</div>
				</li>


				<li>Connect window1 to window2 with a 15 px wide yellow Bezier. endpoints are a slightly lighter shade of yellow.
<div class="code">
<pre>jsPlumb.connect({
	source:'window1',
	target:'window2',
	anchors:["BottomCenter", [0.75,0,0,-1]],
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'},
	endpointStyle:{fillStyle:'rgb(243,229,0)'}
});</pre>
</div></li>
<li>Connect window3 to window4 with a 10px wide blue-ish half transparent Bezier. put endpoints underneath the element they attach to.
the endpoints have a radial gradient. both ways of specifying gradient positioning are shown here.
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
jsPlumb.connect( {
	source:'window3',
	target:'window4',
		 paintStyle:{lineWidth:10, strokeStyle:w34Stroke},
		 anchors:["RightMiddle", "LeftMiddle"],
		 endpointStyle:{ gradient : {stops:[[0, w34Stroke], [1, w34HlStroke]], offset:17.5, innerRadius:15 }, radius:35},
		 //endpointStyle:{ gradient : {stops:[[0, w34Stroke], [1, w34HlStroke]], offset:'78%', innerRadius:'73%'}, radius:35 },
		 endpointsOnTop:false
	}
);</pre>
</div></li>
<li>Connect window2 to window3 with an 8px red Bezier and default rectangular endpoints.  see also how the first anchor is
specified here - this is how you create anchors in locations jsPlumb does not offer shortcuts for.
the endpoints in this example have linear gradients applied.
<div class="code">
<pre>var w23Stroke = 'rgb(189,11,11)';
jsPlumb.connect({
	source:'window2',
	target:'window3',
	paintStyle:{lineWidth:8,strokeStyle:w23Stroke},
	anchors:[[0.3,1,0,1], "TopCenter"],
	endpoint:"Rectangle",
	endpointStyles:[{ gradient : {stops:[[0, w23Stroke], [1, '#558822']] }},
       				{ gradient : {stops:[[0, w23Stroke], [1, '#882255']] }}]
});</pre>
</div></li>

<li>Connect window5 to window6 from center to center, 5px wide line that is green and half transparent. the endpoints are
125px in radius and spill out from underneath their elements.
<div class="code">
<pre>jsPlumb.connect({
	source:'window5',
	target:'window6',
	anchors:["Center", "Center"],
	paintStyle:{lineWidth:5,strokeStyle:'rgba(0,255,0,0.5)'},
	endpointStyle:{radius:125}
});</pre>
</div></li>

<li>Connect window4 to window5 from bottom right to top left, with a 7px straight line purple connector, and an image as the endpoint,
placed on top of the element it is connected to.
<div class="code">
<pre>jsPlumb.connect({
	source:"window4",
	target:"window5",
	anchors:[ "BottomRight","TopLeft" ],
	paintStyle:{ lineWidth:7, strokeStyle:"rgb(131,8,135)" },
	endpoint:[ "Image", { src:"http://morrisonpitt.com/jsPlumb/img/endpointTest1.png" } ],
	connector:"Straight"
});</pre>
</div></li>


				<li>Connect window5 to window6 between their center points with a semi-opaque connector, and 125px endpoints:
					<div class="code">
<pre>jsPlumb.connect({
	source:"window5",
	target:"window6",
	anchors:[ "Center", "Center" ],
	paintStyle:{ lineWidth:5, strokeStyle:"rgba(0,255,0,0.5)" },
	endpointStyle:{ radius:125 }
});</pre>
					</div>
				</li>
				<li>Connect window7 to window8 with a 10 pixel wide blue Connector, anchored on the top left of window7 and the bottom right of window8:
					<div class="code">
<pre>jsPlumb.connect({
	source:"window7",
	target:"window8",
	paintStyle:{ lineWidth:10, strokeStyle:"blue" },
	anchors:[ "TopLeft", "BottomRight" ]
});
</pre>
					</div>
				</li>
				<li>Connect the bottom right corner of window4 to the top left corner of window5, with rectangular endpoints of size 40x40 and a hover color of light blue:
					<div class="code">
<pre>jsPlumb.connect({
	source:"window4",
	target:"window5",
	anchors:["BottomRight","TopLeft"],
	paintStyle:{lineWidth:7,strokeStyle:'rgb(131,8,135)'},
	hoverPaintStyle:{ strokeStyle:"rgb(0, 0, 135)" },
	endpointStyle:{ width:40, height:40 },
	endpoint:"Rectangle",
	connector:"Straight"
});</pre>
					</div>
				</li>
				<li>Connect window1 to window2 with the default paint settings but provide some drag options (which are passed through to the underlying library's draggable call):
					<div class="code">
						<pre>jsPlumb.connect({source:'window1', target:'window2', dragOptions:{cursor:'crosshair'}});</pre>
					</div>
				</li>
</div>
		
		<div class="section">
			<a id="dragAndDropExamples"><h3>Draggable Connections Examples</h3></a>
			This is a list of examples of how to use jsPlumb to create Connections using drag and drop.
			<p>
			The basic procedure is:
			<ol>
				<li>1a. Create Endpoints and register them on elements in your UI</li>
				<li>1b. alternatively, create a source endpoint and then make some element a drop target </li>
				<li>2. Drag and Drop</li>
			</ol>
			That's all there is to it.  Of course there are plenty of options you can set when doing this...it will be easier
			to show you some examples:
			</p>
			<ul>
				<li>Define an Endpoint with default appearance, that is both a source and target of new Connections:
<div class="code">
<pre>var endpointOptions = { isSource:true, isTarget:true }; 
</pre>
</div>				 				
				</li>
				
				<li>Register that Endpoint on window3, specifying that it should be located in the top center of the element:
<div class="code">
<pre>var window3Endpoint = jsPlumb.addEndpoint('window3', { anchor:"TopCenter" }, endpointOptions );  
</pre>
</div>
Notice here the usage of the three-argument addEndpoint  - we can reuse 'endpointOptions' with a different Anchor for another element.  This is a useful
practice to get into.<br/><br/>
				</li>
				
				<li>Now register that Endpoint on window4, specifying that it should be located in the bottom center of the element:
<div class="code">
<pre>var window4Endpoint = jsPlumb.addEndpoint('window4', { anchor:"BottomCenter" }, endpointOptions );  
</pre>
</div>
Now we have two Endpoints, both of which support drag and drop of new Connections.  We can use these to make a programmatic Connection, too, though:<br/><br/>
				</li>				
				
				<li>Connect window3 to window4 with a 25px wide yellow Bezier that has a 'curviness' of 175:
<div class="code">
<pre>jsPlumb.connect({ 
	source:window3Endpoint,
	target:window4Endpoint,
	connector: [ "Bezier", 175 ],
	paintStyle:{ lineWidth:25, strokeStyle:'yellow' }
});  
</pre>
</div>
				</li>
				
				<li>Define an Endpoint that creates Connections that are 20px wide straight lines, that is both a source and target of new Connections,
				and that has a 'scope' of 'blueline'. Also, this Endpoint mandates that once it is full, Connections can
				no longer be dragged from it (even if 'reattach' is specified on a Connection):
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dragAllowedWhenFull:false	 
}; 
</pre>
</div>				 				
				</li>
				
				<li>Define an Endpoint that will be anchored to "TopCenter".  It creates Connections that are 20px wide straight lines, that is both a source and target of new Connections,
				and that has a 'scope' of 'blueline'. Also, this Endpoint mandates that once it is full, Connections can
				no longer be dragged from it (even if 'reattach' is specified on a Connection):
<div class="code">
<pre>var endpointOptions = {
	anchor:"TopCenter", 
	isSource:true, 
	isTarget:true,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dragAllowedWhenFull:false	 
}; 
</pre>
</div>				 				
				</li>
				
				<li>Define an Endpoint that will create a dynamic anchor which can be positioned at "TopCenter" or "BottomCenter".  It creates Connections that are 20px wide straight lines, it is both a source and target of new Connections,
				and it has a 'scope' of 'blueline'. Also, this Endpoint mandates that once it is full, Connections can
				no longer be dragged from it (even if 'reattach' is specified on a Connection):
<div class="code">
<pre>var endpointOptions = {
	anchor:[ "TopCenter", "BottomCenter" ], 
	isSource:true, 
	isTarget:true,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dragAllowedWhenFull:false	 
}; 
</pre>
</div>				 				
				</li>
				
				<li>Exactly the same as before, but shows how you can use "anchors" instead of "anchor", if that makes you feel happier:
<div class="code">
<pre>var endpointOptions = {
	anchors:[ "TopCenter", "BottomCenter" ], 
	isSource:true, 
	isTarget:true,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dragAllowedWhenFull:false	 
}; 
</pre>
</div>				 				
				</li>								
				
<li>Define an Endpoint that is a 30px blue dot, creates Connections that are 20px wide straight lines, is both a source and target of new Connections,
				has a 'scope' of 'blueline', and has an event handler that pops up an alert (note: the event handler name means this example is jQuery - MooTools
				and YUI3 use different event handler names):
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	endpoint: [ "Dot", { radius:30 } ],
	style:{fillStyle:'blue'},
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dropOptions:{ drop:function(e, ui) { alert('drop!'); } }	 
}; 
</pre>
</div>				 				
				</li>
				
			<li>Same example as before, but this is for MooTools, and the Endpoint can support up to 5 connections (the default is 1):
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	endpoint: [ "Dot", { radius:30 } ],
	style:{ fillStyle:'blue' },
	maxConnections:5,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dropOptions:{ onDrop:function(e, ui) { alert('drop!'); } }	 
}; 
</pre>
</div>				 				
				</li>
				
				<li>Same example again, but maxConnections being set to -1 means that the Endpoint has no maximum limit of Connections:
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	endpoint: [ "Dot", {radius:30} ],
	style:{ fillStyle:'blue' },
	maxConnections:-1,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dropOptions:{ onDrop:function(e, ui) { alert('drop!'); } }	 
}; 
</pre>
</div>				 				
				</li>
				
				<li>Same example again, but for YUI3.  Note the drop callback is "drop:hit":
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	endpoint: [ "Dot", { radius:30 } ],
	style:{fillStyle:'blue'},
	maxConnections:-1,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dropOptions:{ "drop:hit":function(e, ui) { alert('drop!'); } }	 	
}; 
</pre>
</div>				 				
				</li>				
				
	<li>Assign a UUID to the endpoint options created above, and add as Endpoints to "window1" and "window2":
<div class="code">
<pre>
jsPlumb.addEndpoint("window1", { uuid:"abcdefg" }, endpointOptions );
jsPlumb.addEndpoint("window2", { uuid:"hijklmn" }, endpointOptions );
</pre>
</div>	
	</li>
	
	<li>Connect the two Endpoints we just registered on "window1" and "window2":
<div class="code">
<pre>
jsPlumb.connect({uuids:["abcdefg", "hijklmn"]});
</pre>
</div>	
	</li>
	
	<li>Create a source Endpoint, register it on some element, then make some other element a Connection target:
<div class="code">
<pre>
var sourceEndpoint = { isSource:true, endpoint:[ "Dot", { radius:50 } ] };
var targetEndpoint = { endpoint:[ "Rectangle", { width:10, height:10 } ] };
jsPlumb.addEndpoint( "window1", sourceEndpoint );
jsPlumb.makeTarget( "window2", targetEndpoint );
</pre>
</div>	
Notice that the endpoint definition we use on the target window does not include the "isTarget:true" directive.  jsPlumb ignores that flag when
creating a connection using an element as the target; but if you then tried to drag another connection to the Endpoint that was created, you would
not be able to.  To permit that, you would set 'isTarget:true' on the targetEndpoint options defined above.
	
	</li>
				
			</ul>
		</div>
		
		<div class="section">
			<h3><a id="utilityFunctions">Utility Functions</a></h3>
			<ul>
				<li>Detach window5 from all connections
					<div class="code">
						<pre>jsPlumb.detachAll("window5");</pre>
					</div>
				</li>
				<li>Hide all window5's connections
					<div class="code">
						<pre>jsPlumb.hide("window5");</pre>
					</div>
				</li>
				<li>Hide all window5's connections endpoints
					<div class="code">
						<pre>jsPlumb.hide("window5", true);</pre>
					</div>
				</li>
				<li>Show all window5's connections
					<div class="code">
						<pre>jsPlumb.show("window5");</pre>
					</div>
				</li>
				<li>Show all window5's connections and endpoints.  Note that in the case that you call jsPlumb.show with two arguments, jsPlumb
				will also not make a connection visible if it determines that the other endpoint in the connection is not visible.
					<div class="code">
						<pre>jsPlumb.show("window5", hide);</pre>
					</div>
				</li>				
				<li>Toggle the visibility of window5's connections
					<div class="code">
						<pre>jsPlumb.toggle("window5");</pre>
					</div>
				</li>
				<li>Force repaint of all of window5's connections
					<div class="code">
						<pre>jsPlumb.repaint("window5");</pre>
					</div>
				</li>
				<li>Force repaint of all of window5, window6 and window11's connections
					<div class="code">
						<pre>jsPlumb.repaint( [ "window5", "window6", "window11" ] );</pre>
					</div>
				</li>
				<li>Force repaint of every connection
					<div class="code">
						<pre>jsPlumb.repaintEverything();</pre>
					</div>
				</li>
				<li>Detach every connection
					<div class="code">
						<pre>jsPlumb.detachEverything();</pre>
					</div>
				</li>
				<li>Remove the given Endpoint from element "window1", deleting its Connections. 
					<div class="code">
						<pre>jsPlumb.removeEndpoint("window1", someEndpoint);</pre>
					</div>
				</li>
				<li>Remove all Endpoints for the element 'window1', deleting their Connections.
					<div class="code">
						<pre>jsPlumb.removeAllEndpoints("window1");</pre>
					</div>
				</li>	
				<li>Removes every Endpoint managed by this instance of jsPlumb, deleting all Connections.
				This is the same as jsPlumb.reset(), effectively, but it does not clear out the event listeners list. 
					<div class="code">
						<pre>jsPlumb.removeEveryEndpoint();</pre>
					</div>
				</li>
				<li>Deletes the given Endpoint and all its Connections. 
					<div class="code">
						<pre>jsPlumb.deleteEndpoint(endpoint);</pre>
					</div>
				</li>
				<li>Removes every endpoint, detaches every connection, and clears the event listeners list.  Returns jsPlumb instance to its initial state.  
					<div class="code">
						<pre>jsPlumb.reset();</pre>
					</div>
				</li>				
				<li>Set window1 to be not draggable, no matter what some jsPlumb command may request.
					<div class="code">
						<pre>jsPlumb.setDraggable("window1", false);</pre>
					</div>
				</li>
				<li>Set window1 and window2 to be not draggable, no matter what some jsPlumb command may request.
					<div class="code">
						<pre>jsPlumb.setDraggable(["window1","window2"], false);</pre>
					</div>
				</li>
				<li>Sets whether or not elements that are connected are draggable by default.
				The default for this is true.
					<div class="code">
						<pre>jsPlumb.setDraggableByDefault(false);</pre>
					</div>
				</li>
				<li>Initialises window1 as a draggable element (all libraries)
				<div class="code">
					<pre>jsPlumb.draggable("window1");</pre>
				</div>
				</li>
				<li>Initialises window1 and window2 as draggable elements (all libraries)
				<div class="code">
					<pre>jsPlumb.draggable(["window1","window2"]);</pre>
				</div>
				</li>
				<li>Initialises window1 as a draggable element (all libraries)
				<div class="code">
					<pre>jsPlumb.draggable("window1");</pre>
				</div>
				</li>
				<li>Initialises all elements with class 'window' as draggable elements (jQuery)
				<div class="code">
					<pre>jsPlumb.draggable($(".window"));</pre>
				</div>
				</li>
				<li>Initialises all elements with class 'window' as draggable elements (MooTools)
				<div class="code">
					<pre>jsPlumb.draggable($$(".window"));</pre>
				</div>
				</li>
				<li>Initialises all elements with class 'window' as draggable elements (YIU3)
				<div class="code">
					<pre>jsPlumb.draggable(Y.all(".window"));</pre>
				</div>
				</li>
				<li>Initialises window1 as a draggable element (jQuery)
				<div class="code">
					<pre>jsPlumb.draggable($("#window1"));</pre>
				</div>
				</li>
				<li>Initialises window1 as a draggable element (MooTools)
				<div class="code">
					<pre>jsPlumb.draggable($("window1"));</pre>
				</div>
				</li>
				<li>Initialises window1 as a draggable element (YUI3)
				<div class="code">
					<pre>jsPlumb.draggable(Y.one("window1"));</pre>
				</div>
				</li>
			</ul>
		</div>
		
	
		
		
		<div class="section">
			<h3><a id="developingJsPlumb">Advanced Topics</a></h3>
			<h4><a id="which">Which files are which?</a></h4>
			In development, jsPlumb is broken up into seven scripts:
				<ul>
					<li>- jsPlumb-x.x.x.js
					<p>This is the main jsPlumb engine.</p>					
					</li>
					<li>- jsPlumb-defaults-x.x.x.js
					<p>This contains the default Anchor, Endpoint, Connector and Overlay implementations.</p>
					</li>
					<li>- jsPlumb-renderers-canvas-x.x.x.js
					<p>This contains the HTML5 canvas render code.</p>
					</li>
					<li>- jsPlumb-renderers-svg-x.x.x.js
					<p>This contains the SVG render code.</p>
					</li>
					<li>- jsPlumb-renderers-vml-x.x.x.js
					<p>This contains the VML render code.</p>
					</li>
					<li>- &lt;LIBRARY_PREFIX&gt;.jsPlumb-x.x.x.js
					<p>This contains library-specific helper methods.  jsPlumb ships with three of these - one each for jQuery, MooTools and YUI3. See below for information on how to create a new library implementation.</p>
					</li>
					<li>- jsBezier-0.2-min.js
					<p>These are the Bezier curve functions; they are maintained in a separate project called <a href="http://code.google.com/p/jsbezier/">jsBezier</a></p>
					</li>
				</ul>
			These seven files are packaged together to form the scripts that people use, for example:
			<ul>
				<li>jquery.jsPlumb-1.3.3-all.js
				<p>Contains jsPlumb-1.3.3.js, jsPlumb-defaults-1.3.3.js, jsPlumb-renderers-canvas-1.3.3.js, jsPlumb-renderers-svg-1.3.3.js, jsPlumb-renderers-vml-1.3.3.js, jquery.jsPlumb-1.3.3.js and jsBezier-0.2-min.js</p>
				</li>
				<li>jquery.jsPlumb-1.3.3-all-min.js
				<p>A minified version of the script above (minified using the YUI Compressor)</p>
				</li>
			</ul>
			<h4><a id="pluggableLibrarySupport">Pluggable Library Support</a></h4>
		Out of the box, jsPlumb can be run on top of jQuery, MooTools or YUI3.  This is achieved by
		delegating several core methods - tasks such as finding an element by id, finding an element's
		position or dimensions, initialising a draggable, etc - to the library in question.
		<p>To develop one of these, your test page should include the first two scripts discussed above, and
		then your own script containing your library specific functionality.  The existing implementations
		may be documented well enough for you to create your own, but contact me if you need assistance.  If you do this, it would be
		great to share it with everyone...</p>   

			<!-- h4><a id="customConnectors">Custom Connectors</a></h4>			
					
			You can provide your own connectors if you need to. A Connector consists of two functions, which work as a pair.  First a call is made to the <em>compute</em> function:

			<div class="code">
<pre>
this.compute = function(sourcePos, targetPos, sourceAnchor, targetAnchor, lineWidth) {
	...
	return dimensions;
}
</pre>
			</div>
			which is expected to return a list that the <em>paint</em> function can make sense of.  The first four entries in the
			list <strong>must be</strong> the [x,y,width,height] values for the canvas that the connector will be drawn on; jsPlumb will
			use this information to size the canvas prior to calling the Connector's <em>paint</em> function.  Therefore it
			is the Connector's responsibility to ensure that the returned dimensions describe a large enough space for
			the line that will be drawn on it.</p><p>The next four elements <strong>must be</strong> the coordinates of the two endpoints of the line
			you are going to draw.</p><p>The remainder of the items in the returned list are arbitrary, and will
			vary between Connector implementations; this list is passed in to a Connector's <em>paint</em> function, so each
			implementation will put into the list whatever it needs to paint itself.  For instance, the straight line
			connector only needs the [x,y] location of each end of the line it will paint, and that is one of the required entries, so
			it does not have to do anything extra,  whereas the Bezier connector adds the location of the two control points.  Other types of
			Connectors will do whatever is appropriate for their particular situation.
			</p>
			This is the method signature for the <em>paint</em> function:
			<div class="code">
				<pre>this.paint = function(dimensions, ctx) { .. }</pre>
			</div>

			here, the 'dimensions' argument to the 'paint' function is the return value of the 'compute' function.  The 'ctx' argument is the Canvas context; you
			will do all your drawing on this.
			</p>
			To change the connector from the default, specify it in your connect call:
			<div class="code">
				<pre>jsPlumb.connect({source:'someWindow', target:'otherWindow', connector:new jsPlumb.Connectors.Straight()});</pre>
			</div>
			note that you can use shorthand for connectors if you don't need to specify parameters to it:
			<div class="code">
				<pre>jsPlumb.connect({source:'someWindow', target:'otherWindow', connector:"Straight"});</pre>
			</div>
			This works in the same way as specifying Anchors as string does.
<p>
The section below this discusses Overlays, which allow you to decorate Connectors with
			things such as labels or arrows or whatever else you like. Overlays can only work with Connectors that implement a few helper functions.
			<h4>The concept of <strong>location</strong></h4>
			Before discussing the helper functions you first must be across the concept of 'location' as used by this mechanism.  The <em>location</em>
			on a connector can be a decimal value between 0 and 1 inclusive, which marks a proportionate amount of travel <em>along the path
			inscribed by the Connector</em>.  For a straight line connector this is a simple piece of maths, but for Bezier connectors it's a little
			bit more involved.
			<h4>Required Helper Methods</h4>
			<ul>
				<li><strong>pointOnPath(location)</strong> - returns an [x,y] point corresponding to the given location</li>
				<li><strong>pointAlongPathFrom(location, distance)</strong> - returns an [x,y] point corresponding to travelling 'distance' pixels along the connector from 'location'.</li>
				<li><strong>gradientAtPoint(location)</strong> - returns the connector's gradient at the given location.  For linear connectors such as Straight this is constant, but for Bezier connectors the gradient changes continually.</li>
				<li><strong>perpendicularToPathAt(location, distance, length)</strong> - returns a line that is perpendicular to (and centered on) the connector at 'distance' from the given location, with length 'length'.</li>
			</ul>
</p>
<h4><a id="customEndpoints">Custom Endpoints</a></h4>
<p>To create your own Endpoint implementation, you need to implement a single method:
				<div class="code"><pre>paint : function(anchorPoint, orientation, canvas, endpointStyle, connectorPaintStyle) { ... }</pre></div>
				The arguments to this method are as follows:
				<ul>
					<li>anchorPoint - [x,y] location of the anchor point on screen</li>
					<li>orientation - [x,y] hints for the general direction the anchor points to</li>
					<li>canvas - the canvas to draw into</li>
					<li>endpointStyle - Javascript object containing style directives as discussed above.  The contents of this are arbitrary, so if you write a new Endpoint that needs some extra settings, you can add them no hassle.</li>
					<li>connectorPaintStyle - the style being used to paint the associated Connector.</li>
				</ul>
			</p>
			<p>
				It is your responsibility to size and locate the canvas to suit your needs. jsPlumb provides the following
				helper method to assist you:
				<div class="code"><pre>jsPlumb.sizeCanvas(canvas, x, y, width, height);</pre></div>
				Allows you to locate the canvas on screen and to size it.
			</p>
<h4><a id="customOverlays">Custom Overlays</a></h4>
			Overlays can only work with Connectors that implement the methods <strong>pointOnPath</strong>, <strong>pointAlongPathFrom</strong>,
			<strong>gradientAtPoint</strong>, and <strong>perpendicularToPathAt</strong>.  These are discussed in more detail in the Custom Connectors section above.  Both of the Connectors
			that come with jsPlumb - Straight and Bezier -implement these methods; if you write a custom connector, or have written a custom connector, you will need to supply
			them.   
			<h4>Overlay Interface</h4>
			An Overlay is required to implement two methods in order to be usable by jsPlumb:
			<ul>
				<li><strong>computeMaxSize(connector, context)</strong> - returns an integer value indicating the larger of this overlay's width and height.  It is used by jsPlumb to ensure that the canvas is large enough to accomodate the overlay.  The examples below should help to clarify this.</li>
				<li><strong>draw(connector, ctx)</strong> - draws the overlay.  What happens in this method is up to the given implementation.</li>
			</ul>
			<h4>computeMaxSize methods</h4>
			This is the Arrow overlay's computeMaxSize method:
			<div class="code">
<pre>
this.computeMaxSize = function() { return width; }
</pre>			
			</div>
Here, <em>width</em> is a private member of Arrow that indicates the width of the arrow's tail.  So the Arrow overlay reports that figure as the width it needs.					
Contrast this with the Label Overlay's computeMaxSize method:
		<div class="code">
<pre>
this.computeMaxSize = function(connector, ctx) {
  	if (labelText) {
  		ctx.save();
        if (self.labelStyle.font) ctx.font = self.labelStyle.font;
         var t = ctx.measureText(labelText).width;			            
		// a fake text height measurement: use the width of upper case M
		var h = ctx.measureText("M").width;					
		labelPadding = self.labelStyle.padding || 0.25;
		labelWidth = t + (2 * t * labelPadding);
		labelHeight = h + (2 * h * labelPadding);
		ctx.restore();
		return Math.max(labelWidth, labelHeight);
  	}
 	return 0;
 };
</pre>			
			</div>
The Label overlay has to use the context to determine how big it will be on screen.

<h4>draw methods</h4>
To give you a taste for how you can interact with a connector, consider the first few lines of the Arrow overlay's draw method:
<div class="code">
<pre>
this.draw = function(connector, ctx) {
	// this is the arrow head position
	var hxy = connector.pointAlongPathFrom(self.loc, length / 2);		
	// this is the center of the tail
	var txy = connector.pointAlongPathFrom(self.loc, -length / 2), tx = txy[0], ty = txy[1];
	// this is the tail vector
	var tail = connector.perpendicularToPathAt(self.loc, -length / 2, width);
	
	...
</pre>
</div>
	<p>The first two calls to the connector use the <strong>pointAlongPathFrom</strong> method, which passes <em>self.loc</em> as the location of the
	point on the path, and <em>length / 2</em> as the number of pixels along the path to traverse.</p>
	<p><em>self.loc</em> is Arrow's internal member describing the location of the overlay, and it is a decimal (between 0 and 1 inclusive) that points to
	a location at some distance along the path inscribed by the connector.  So these first two calls get us [x,y] locations of points on 
	the connector that mark the head and tail points for the arrow.  
	</p>		
	<p>
	The <strong>connector.perpendicularToPathAt(self.loc, -length / 2, width)</strong> call returns a line description of a line that is perpendicular to, and centered on, the connector
	at "-length / 2" pixels from the given point, with the given width (width is an internal member of Arrow).  At this point, the Arrow object has the three main points it
	needs in order to draw itself.
	</p>
		</div-->
</div>

</body>

</html>