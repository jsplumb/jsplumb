<html>
	<head>
		<title>jsPlumb 1.4.0 - documentation</title>
		<link rel="stylesheet" href="/mp.css">
		<link rel="stylesheet" href="jsPlumbDoc.css">
	</head>
	<body>

<div class="menu">
	<a href="http://jsplumb.org" class="mplink" target="_top">view demo</a>
	&nbsp;|&nbsp;<a href="mailto:simon.porritt@gmail.com" class="mplink">contact me</a>
	&nbsp;|&nbsp;<a href="http://jsplumb.tumblr.com" class="mplink">jsPlumb on Tumblr</a>	
</div>

<!--
GWT

http://fishfilosophy.blogspot.com/2011/12/how-to-connect-gwt-widgets-using.html?spref=tw

-->

<div class="content">
		<div class="section">
			<h3><a id="summary">Summary</a></h3>
			jsPlumb allows you to connect elements on the screen using SVG, Canvas or VML, depending on the capabilities of the browser.
			<p>
				It can be used with jQuery, MooTools or YUI3 (or another library of your choice if you feel like implementing an adapter for it).
			</p>  

			<h5>Browser Compatibility</h5>
			<p>jsPlumb 1.4.0 runs on everything from IE6 up.  There are some caveats, though, because of various browser/library bugs:
				<ul>
					<li class="bullet">jQuery 1.6.x and 1.7.x have a bug in their SVG implementation for IE9 that causes hover events to not get fired.
					<li class="bullet">Safari 5.1 has an SVG bug that prevents mouse events from being passed through the transparent area of an SVG element</li>
					<li class="bullet">MooTools has a bug when using SVG in Firefox 11</li>
				<ul>
				
			</p>
		</div>
		
		<div class="section">		
			<h3><a id="changes">Changes between 1.4.0 and 1.3.8</a></h3>
			
			<h5>Backwards Compatibility</h5>
			Just a couple of minor points in this release:
			<ul>
				<li><strong>paintStyle</strong> and <strong>hoverPaintStyle</strong> are no longer exposed on Endpoint or Connection. Use <strong>setPaintStyle</strong>, <strong>getPaintStyle</strong>, <strong>setHoverPaintStyle</strong> and <strong>setHoverPaintStyle</strong> instead.</li>
			</ul>
			
			<h5>New Features</h5>
			<ul>
				<li class="bullet">Straight connector in Canvas renderer now supports simple dashstyle</li>	
				<li class="bullet">clearListeners, fire and bind methods in jsPlumb, Connection and Endpoint now return themselves, so you can use them in a 'fluent' style.</li>
				<li class="bullet">paintStyle and hoverPaintStyle are no longer exposed on Endpoint or Connection.</li>
				<li class="bullet">getPaintStyle and getHoverPaintStyle methods added to Endpoint and Connection.</li>
				<li class="bullet">HoverClass added to jsPlumb defaults.</li> 
				<li class="bullet">Several new methods added for working with targets and sources:
					<ul>
						<li>setTargetEnabled</li>
						<li>setSourceEnabled</li>
						<li>isTarget</li>
						<li>isSource</li>
						<li>toggleTargetEnabled</li>
						<li>toggleSourceEnabled</li>
						<li>isTargetEnabled</li>
						<li>isSourceEnabled</li>
						<li>unmakeSource</li>
						<li>unmakeTarget</li>
						<li>unmakeEverySource</li>
						<li>unmakeEveryTarget</li>
					</ul>
					<br/>
				</li>
				<li class="bullet">makeSource and makeTarget now return the current jsPlumb instance.</li>
				<li class="bullet">added optional 'gap' parameter to Flowchart connector params. Lets you leave a gap between the end of the connector and the element to which it is connected.</li>
				<li class="bullet">SvgEndpoint and VmlEndpoint classes are now exposed on the DOM window, which allows for subclassing (eg. when you want to make your own Endpoints)</li>
				<li class="bullet">removeAllOverlays was not cleaning up elements from the DOM properly. now fixed.</li>
				<li class="bullet">added connectionDrag and connectionDragStop events to the jsPlumb object. These events are fired when an existing connection is dragged, and when that drag stops.  The only argument passed to a listener on these events is the Connection that is being or has just been dragged.</li>
			</ul>

			<h5>Issues Resolved</h5>
			<ul>
				<li class="bullet"><strong>136</strong> - diamond/arrow overlays do not fire mouse events (SVG/VML renderers only)</li>
				<li class="bullet"><strong>223</strong> - extraneous IDs being created throughout the DOM</li>
				<li class="bullet"><strong>235</strong> - add setTargetEnabled and related methods</li>
				<li class="bullet"><strong>233</strong> - add getPaintStyle and getHoverPaintStyle to Connection and Endpoint.</li>
				<li class="bullet"><strong>238</strong> - overlays in canvas renderer for state machine connectors not appearing in the correct position.</li>
				<li class="bullet"><strong>239</strong> - document detachable/connectionsDetachable properly</li>
				<li class="bullet"><strong>242</strong> - typo in docs about diamond overlay</li>
				<li class="bullet"><strong>244</strong> - straight gradients rendered black or transparent</li>
				<li class="bullet"><strong>245</strong> - should not set scope on nodes when making them draggable via jsPlumb.draggable.</li>		
			</ul>
			
		</div>
		
		<div class="section">
			<h3><a id="init">Setup</a></h3>

            <h4><a id="imports">Required Imports</a></h4>
			<h4>jQuery</h4>
			    <ul>
				    <li class="bullet">jQuery 1.3.x or higher.</li>
				    <li class="bullet">jQuery UI 1.7.x or 1.8.x (if you wish to support drag and drop).</li>
			    </ul>
			    <div class="code">
<pre>&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.13/jquery-ui.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO/jquery.jsPlumb-1.4.0-all-min.js "&gt;&lt;/script&gt;</pre>
			</div>
			<h4>MooTools</h4>
				<ul>
					<li class="bullet">MooTools Core 1.2.4 or higher. jsPlumb has been tested with 1.2.4 and 1.3.3.</li>
					<li class="bullet">Drag.Move from MooTools More 1.2.4.4 or higher (if you wish to support drag and drop).</li>
				</ul>
			<div class="code">
			<pre>&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/mootools/1.3.3/mootools-yui-compressed.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO_MOO_TOOLS_MORE_1_3_2_1"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO/mootools.jsPlumb-1.4.0-all-min.js "&gt;&lt;/script&gt;</pre>
			</div>
			<h4>YUI3</h4>
			<ul>
				<li class="bullet">YUI 3.3.x.  jsPlumb has been tested on 3.3.0 only; it is possible other 3.x.x versions will work.</li>
			</ul>
			<div class="code">
			<pre>&lt;script type="text/javascript" src="http://yui.yahooapis.com/3.3.0/build/simpleyui/simpleyui-min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO/yui.jsPlumb-1.4.0-all-min.js "&gt;&lt;/script&gt;</pre>
			</div>
			
			<h4><a id="renderMode">Render Mode</a></h4>
			jsPlumb can use SVG, HTML5 Canvas elements or VML to render the various objects it adds to the display.  Most modern browsers support Canvas and SVG; IE&lt;9 browsers support neither.
			<p>
				By default, jsPlumb attempts to use <strong>jsPlumb.SVG</strong> as the render mode (prior to 1.3.4, the default renderer was Canvas), falling back to <strong>jsPlumb.VML</strong> if the 
				browser is IE&lt;9.  You can change the render mode by making this call:  
			</p>
			<div class="code">
<pre>jsPlumb.setRenderMode(jsPlumb.CANVAS);</pre>			
			</div>
			if, for some reason, you set the render mode to be <strong>jsPlumb.VML</strong> but you're in any browser other than IE, jsPlumb will use SVG.
			<p>
			The <strong>jsPlumb.setRenderMode</strong> method returns you the render mode that jsPlumb actually ended up setting.  Valid values for setRenderMode are:
			</p>
			<ul>
				<li class="bullet">jsPlumb.CANVAS</li>
				<li class="bullet">jsPlumb.SVG</li>
				<li class="bullet">jsPlumb.VML</li>
			</ul>			
			<h5>Performance Considerations</h5>
			<p>
			SVG uses less memory than Canvas and has support for mouse events built in, so I recommend using
			SVG unless you have a really good reason for wanting Canvas. Of course, you might consider that horrendous Safari bug a really good reason for wanting Canvas.
			</p>
			
			<h4><a id="initializing">Initializing jsPlumb</a></h4>
			You should not start making calls to jsPlumb until the DOM has been initialized - perhaps no surprises there.  With YUI, though, the asynchronous
			nature of the script loading process means that you are not guaranteed that jsPlumb is ready as soon as the DOM is.  To handle this,
			you should bind to the "ready" event on jsPlumb (or the instance of jsPlumb you are working with):
			<div class="code">
			<pre>jsPlumb.bind("ready", function() {
...	
		
// your jsPlumb related init code goes here

...

});						
			</pre>
			</div>
			There's a helper method that can save you approximately 9 (count them!) characters:
			<div class="code">
			<pre>jsPlumb.ready(function() {
...	
		
// your jsPlumb related init code goes here

...

});						
			</pre>
			</div>
			<p>
			For jQuery and MooTools you do not actually need to do this; by the time the DOM ready event is fired in each of those libraries you can be sure 
			all the JS we need has been loaded.  But in terms of explicitly calling out that you are waiting for jsPlumb, it seems like a good practice to bind to the "ready" event.
			</p>
			<p>
			If you bind to the "ready" event after jsPlumb has already been initialized, your callback will be executed immediately.
			</p>			

				
<h4><a id="multipleInstances">Multiple jsPlumb instances</a></h4>
			jsPlumb is registered on the browser's Window by default, providing one static instance
			for the whole page to use.  Should you need to, though, you can instantiate independent
			instances of jsPlumb, using the <strong>getInstance</strong> method, for example:
<div class="code">
<pre>
var firstInstance = jsPlumb.getInstance();
</pre>
</div>
The variable 'firstInstance' can now be treated exactly as you would treat the 'jsPlumb' variable - you can set
defaults, call the connect method, whatever:
<div class="code">
<pre>
firstInstance.importDefaults({
  Connector : [ "Bezier", { curviness: 150 } ],
  Anchors : [ "TopCenter", "BottomCenter" ]
});

firstInstance.connect({source:"element1", target:"element2", scope:"someScope" });
</pre>
</div>

<strong>getInstance</strong> optionally takes an object that provides the defaults:
<div class="code">
<pre>
var secondInstance = jsPlumb.getInstance({
	PaintStyle:{ lineWidth:6, strokeStyle:"#567567", outlineColor:"black", outlineWidth:1 },
	Connector:[ "Bezier", { curviness: 30 } ],
	Endpoint:[ "Dot", { radius:5 } ],
	EndpointStyle : { fillStyle: "#567567"  },
	Anchor : [ 0.5, 0.5, 1, 1 ]
});

secondInstance.connect({ source:"element4", target:"element3", scope:"someScope" });
</pre>
</div>

		<h4><a id="zIndex">Z-index Considerations</a></h4>
		<p>
			You need to pay attention to the z-indices of the various parts of your UI when
			using jsPlumb, in particular to ensure that the elements that jsPlumb adds to
			the DOM do not overlay other parts of the interface. 
		</p>  
		<p>
			jsPlumb adds an element to the DOM for each Endpoint, Connector and Overlay. So
			for a connection having visible Endpoints at each end and a label in the middle,
			jsPlumb adds four elements to the DOM.  The actual elements it adds depend on the 
			renderer in use (Canvas/SVG/VML).  			
		</p>
		<p>
			To help you organise z-indices correctly, jsPlumb adds a CSS class to each type of
			element it adds. They are as follows:			
		</p>
		<table style="color:black;width:70%;font-size:90%;">
			<tr><td><strong>type of element</strong></td><td><strong>class added</strong></td></tr>
			<tr><td>Endpoint</td><td>_jsPlumb_endpoint</td></tr>
			<tr><td>Connector</td><td>_jsPlumb_connector</td></tr>
			<tr><td>Overlay</td><td>_jsPlumb_overlay</td></tr>
		</table>

		<h4><a id="containerDefault">Where does jsPlumb add elements?</a></h4>
		<p>
			It's important to understand where in the DOM jsPlumb will add any elements it creates,
			as it has a bearing on the markup you can use with jsPlumb.
		</p>
		<p>
			Prior to 1.3.0, jsPlumb added everything to the end of the <em>body</em> element. This
			has the advantage of being the most flexible arrangement in terms of supporting what
			elements can be connected, but in certain use cases produced unexpected results. Consider
			the arrangement where you have some connected elements in a tab: you would
			expect jsPlumb to add elements inside the tab, so that when the user switches tabs and
			the current one is hidden, all the jsPlumb stuff is hidden too.  But when the elements are 
			on the body, this does not happen!   
		</p>
		<p>
			For this reason, from 1.3.0 onwards, jsPlumb's default behaviour is to attach Endpoint elements to the parent
			of the element the Endpoint is attached to (<strong>not</strong> the actual element
			the Endpoint is attached to), and to attach Connector elements to the parent of
			the source Endpoint in the Connection. This results in all the elements of the
			Connection being siblings inside the same parent node, which jsPlumb requires, for
			various reasons arising from the trade off between doing lots of maths and the
			performance of the whole thing.
		</p>
		
		<p>
			In general, the default behaviour means that you cannot do things like this:
		</p>
		<div class="code">
<pre>
&lt;body&gt;
	&lt;div id="container0"&gt;
		&lt;div id="node0"&gt;&lt;/div&gt;
	&lt;/div&gt;
	&lt;div id="container1"&gt;
		&lt;div id="node1"&gt;&lt;/div&gt;
	&lt;/div&gt;
&lt;/body&gt;

&lt;script type="text/javascript"&gt;

	var e0 = jsPlumb.addEndpoint("node0"),
	e1 = jsPlumb.addEndpoint("node1");

	jsPlumb.connect({ source:e0, target:e1 });
&lt;/script&gt;
</pre>		
		</div>
<p>
because the elements created for 'e0' and 'e1' would have different parent nodes, and an attempt
to make a Connection between them would not work.  For the example just given, you would need to
register the Endpoints on the 'container' divs (and then quite possibly throw away the 'node' divs):  
</p>
		<div class="code">
<pre>
&lt;body&gt;
	&lt;div id="container0"&gt;
	&lt;/div&gt;
	&lt;div id="container1"&gt;
	&lt;/div&gt;
&lt;/body&gt;

&lt;script type="text/javascript"&gt;

	var e0 = jsPlumb.addEndpoint("container0"),
	e1 = jsPlumb.addEndpoint("container1");

	jsPlumb.connect({ source:e0, target:e1 });
&lt;/script&gt;
</pre>		
		</div>
	now 'e0' and 'e1' have the same parent - the <em>body</em> element. 
	
	<p>Remember that you can use the <strong>anchor</strong> parameter to an <strong>addEndpoint</strong>
	call to specify where on an element you want an Endpoint to appear.  Used in conjunction with
	CSS classes (discussed below), you can have an Endpoint on top of some element wherever you like. 
	</p>									
	<p><strong>Note regarding the drawEndpoints option on jsPlumb.connect</strong>: with the default behaviour, jsPlumb uses the offsetParent of
	the source endpoint in a connection to make final adjustments to the position of a connector. When drawEndpoints is set to false, there is no
	offsetParent of the source endpoint because it is not visible.  If your connection lies inside some container other than the document body,
	the connector will not be able to take that container's offset into account, and will most likely not be in the right place.  You should either
	use the "Blank" endpoint when you don't want to see one, or instruct jsPlumb to attach everything to the document body (see below). 
	</p>
	
	<h5>Overriding the default behaviour</h5>
	<p>
From version 1.3.3, the <strong>container</strong> concept was reintroduced into jsPlumb, because there are use cases in which the default behaviour makes it difficult or impossible to build the UI you want. You can instruct jsPlumb to use some element as the parent of everything jsPlumb adds to the UI through usage of the <strong>jsPlumb.Defaults.Container</strong> property, or you can set a <strong>container</strong> parameter on calls to <strong>addEndpoint</strong> or <strong>connect</strong> (if this is set and a default is also set, this default value is actually used.  This may seem counter-intuitive, and could of course be changed if there is feedback from the community that this would be a good idea). Some examples:
	</p>
		
Set a container to use as the default container, using a jQuery selector (you can supply MooTools/YUI selectors if that's the library you're using), and then add an Endpoint.  The canvas (or SVG/VML element) created will be a child of the document body:
		<div class="code">
<pre>
jsPlumb.Defaults.Container = $("body");
...
jsPlumb.addEndpoint(someDiv, { endpoint options });
</pre>		
		</div>
		
			Set a container to use as the default container, using an element id,
		and then connect two elements.  The elements created in this example will be children of the element with id "containerId":
		<div class="code">
<pre>
jsPlumb.Defaults.Container = "containerId";
...
jsPlumb.connect({ source:someDiv, target:someOtherDiv });
</pre>		
		</div>
		
		Pass a container to use into a jsPlumb.connect call, using a selector.  The elements created in this example will be children of the element with id "containerId":
		<div class="code">
<pre>
jsPlumb.connect({ source:someDiv, target:someOtherDiv, container:$("#containerId") });
</pre>		
		</div>
				Pass a container to use into a jsPlumb.addEndpoint call, using an element id. The element created in this example will be a child of the element with id "containerId":
		<div class="code">
<pre>
jsPlumb.addEndpoint(someDiv, { ..., container:"containerId" });
</pre>		
		</div>

		<h4><a id="elementDragging">Element Dragging</a></h4>
		A common feature of interfaces using jsPlumb is that the elements are draggable.  Unless you absolutely need to configure this behaviour using your library's underlying method, you should use <strong>jsPlumb.draggable(...)</strong>:
<div class="code">
<pre>jsPlumb.draggable("elementId");</pre>
</div>
You can also pass a selector from your library in to this method:
<div class="code">
<pre>jsPlumb.draggable($(".someClass");</pre>
</div>
This method is just a wrapper for the underlying library's draggable functionality, and there is a two-argument version in which the second argument is passed down to the underlying library.  A common requirement when using jQuery, for instance, is to set the containment of elements that you are making draggable.  Here's how you would tell jsPlumb to initialise some set of elements to be draggable but only inside their parent:
<div class="code">
<pre>jsPlumb.draggable($(".someClass", {
	containment:"parent"
});</pre>
</div>
		<h5>Dragging nested elements</h5>
jsPlumb takes nesting into account when handling draggable elements. For example, say you have this markup:
<div class="code">
<pre>
&lt;div id="container"&gt;
  &lt;div class="childType1"&gt;&lt;/div&gt;
  &lt;div class="childType2"&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>
</div>
..and then you connect one of those child divs to something, and make "container" draggable:
<div class="code">
<pre>
jsPlumb.connect({
	source:$("#container .childType1"),
	target:"somehere else"
});

jsPlumb.draggable("container");
</pre>
</div>
Now when you drag "container", jsPlumb will have noticed that there are nested elements that have connections, and they will be updated.  Note that the order of operations is not important here: if "container" was already draggable when you connected one of its children to something, you would get the same result.


		</div>
				
		<div class="section">
			<h3><a id="jsPlumbBasics">Basic Concepts</a></h3>			
	
			jsPlumb is all about connecting things together, so the core abstraction in jsPlumb is the <strong>Connection</strong> object, which is itself
			broken down into these four concepts:

			<ul>
				<li><strong>Anchor</strong> - a location, relative to an element's origin, at which an Endpoint can exist. You do not create these yourself; you 
				supply hints to the various jsPlumb functions, which create them as needed.  They have no visual representation; they are a logical position only. Anchors can be referenced by name, for the Anchors that jsPlumb ships with, or a four element array describing [ x, y, x orientation, y orientation ]. 
				See the <a href="#anchors">anchors</a> section for more detail.<br/><br/></li>
				<li><strong>Endpoint</strong> - the visual representation of one end of a Connection.  You can create and attach these to elements yourself, which you are required to do to support drag and drop, or have jsPlumb create them when creating a Connection programmatically using jsPlumb.connect(...).  You can also join two Endpoints programmatically, by passing them as arguments to jsPlumb.connect(...).<br/><br/></li>				
				<li><strong>Connector</strong> - the visual representation of the line connecting two elements in the page.  jsPlumb has four types of these 
				available as defaults - a Bezier curve, a straight line, 'flowchart' connectors and 'state machine connectors. You do not interact with Connectors; 
				you just specify definitions of them when you need to - see <a href="#definitions">Connector, Endpoint &amp; Overlay Definitions</a> <br/><br/></li>
				<li><strong>Overlay</strong> - a UI component that is used to decorate a Connector, such as a Label, Arrow, etc.<br/><br/></li>
			</ul>
						
			<p>One Connection is made up of two Endpoints, a Connector, and zero or more Overlays working together to join two elements.</p>
			<p>jsPlumb's public API exposes only Connection and Endpoint, handling the creation and configuration of everything else internally. But you still need to be across the concepts encapsulated by Anchor, Connector and Overlay.
			</p>
			</div>
			
			<div class="section">
			<h3><a id="anchors">Anchors</a></h3>			
	
			An Anchor models the notion of where on an element a Connector should connect.  There are three main types of Anchors:
			<ul>
			<li/>
				<li class="bullet">'Static' anchors - these are fixed to some point on an element and do not move.  They can be specified using a string to
				identify one of the defaults that jsPlumb ships with, or an array describing the location (see below)<br/><br/></li>				
				<li class="bullet">'Dynamic' anchors - these are lists of Static anchors from which jsPlumb picks the most appropriate one each time a Connection
				is painted.  The algorithm used to determine the most appropriate anchor picks the one that is closest to the center of the other element in
				the Connection. A future version of jsPlumb might support a pluggable algorithm to make this decision.<br/><br/></li>
				<li class="bullet">'Continuous' anchors - These anchors, introduced in 1.3.4, are not fixed to any specific loction; they are assigned to one of
				the four faces of an element depending on that element's orientation to the other element in the associated Connection.  Continuous anchors are slightly more computationally intensive than Static or Dynamic anchors because jsPlumb is required to calculate the position of every Connection during a paint cycle, rather than just Connections belonging to the element in motion.  These anchors were designed for use with the StateMachine connector that was also introduced in 1.3.4, but will work with any combination of Connector and Endpoint.<br/><br/></li> 
			</ul>  
					
			<h4><a id="staticAnchors">Static Anchors</a></h4>		
			jsPlumb has nine default anchor locations you can use to specify where the Connectors connect to elements: these are the four corners of an element,
			the center of the element, and the midpoint of each edge of the element:  
			<ul>
				<li class="bullet">TopCenter</li>
				<li class="bullet">TopRight</li>
				<li class="bullet">RightMiddle</li>
				<li class="bullet">BottomRight</li>
				<li class="bullet">BottomCenter</li>
				<li class="bullet">BottomLeft</li>
				<li class="bullet">LeftMiddle</li>
				<li class="bullet">TopLeft</li>
			</ul>
			
Each of these string representations is just a wrapper around the underlying array-based syntax  [x, y, dx, dy], where x and y are coordinates in the interval [0,1] specifying the position of the
anchor, and dx and dy are coordinates in the interval [-1, 1] specifying the orientation of the curve incident to the anchor. For example, [0, 0.5, -1, 0] defines a "LeftCenter" anchor with a connector curve that emanates leftward from the anchor. Similarly, [0.5, 0, 0, -1] defines a "CenterTop" anchor with a connector curve emanating upwards. 	


<div class="code">
<pre>
jsPlumb.connect({...., anchor:"BottomCenter", ... }); 
</pre>
</div>
is identical to:
<div class="code">
<pre>
jsPlumb.connect({...., anchor:[ 0.5, 1, 0, 1 ], ... }); 
</pre>
</div>		
In addition to supplying the location and orientation of an anchor, you can optionally supply two more parameters that define an offset in pixels from the given location.  Here's the anchor specified above, but with a 50 pixel offset below the element in the y axis:	
<div class="code">
<pre>
jsPlumb.connect({...., anchor:[ 0.5, 1, 0, 1, 0, 50 ], ... }); 
</pre>
</div>		

		<h4><a id="dynamicAnchors">Dynamic Anchors</a></h4>
	These are Anchors that can be positioned in one of a number of locations, choosing the one that is most appropriate each time something moves or is painted in the UI.
	<p>
	There is no special syntax to creating a DynamicAnchor; you just provide an array of individual Static Anchor specifications, eg:
	</p>
<div class="code">
<pre>
var dynamicAnchors = [ [ 0.2, 0, 0, -1 ],  [ 1, 0.2, 1, 0 ], 
			   [ 0.8, 1, 0, 1 ], [ 0, 0.8, -1, 0 ] ];

jsPlumb.connect({...., anchor:dynamicAnchors, ... }); 			   
</pre>
</div>
<h4>	Default Dynamic Anchor</h4>
jsPlumb provides a dynamic anchor called "AutoDefault" that chooses from TopCenter, RightMiddle, BottomCenter and LeftMiddle:
<div class="code">
<pre>jsPlumb.connect({...., anchor:"AutoDefault", ... });</pre>
</div>

<h4>	Location Selection</h4>
The initial implementation of the algorithm that decides which location to choose just calculates which location is closest to the center of the 
other element in the connection.  It is possible that future versions of jsPlumb could support more sophisticated choice algorithms, if the need arose.
<h4>Draggable Connections</h4>
Dynamic Anchors and Draggable Connections can interoperate: jsPlumb locks the position of a dynamic anchor when you start to drag a connection from it,
and unlocks it once the connection is either established or abandoned. At that point you may see the position of the dynamic anchor change, as jsPlumb
optimises the connection.  <p>You can see this behaviour in the <a href="../html/jquery/draggableConnectorsDemo.html" target="_blank">draggable connections</a> demonstration, when
you drag a connection from the blue endpoint on window 1 to the blue endpoint on window 3 - the connection is established and then window 1's blue
endpoint jumps down to a location that is closer to window 3.</p>


	<h4><a id="continuousAnchors">Continuous Anchors</a></h4>
	As discussed above, these are anchors whose positions are calculated by jsPlumb according to the orientation between elements in a Connection, and also how
	many other Continuous anchors happen to be sharing the element.  You specify that you want to use Continuous anchors using the string syntax you would use
	to specify one of the default Static Anchors, for example:
	
<div class="code">
<pre>
jsPlumb.connect({
	source:someDiv,
	target:someOtherDiv,
	anchor:"Continuous"
});
</pre>
</div>

Note in this example I specified only "anchor", rather than "anchors" - jsPlumb will use the same spec for both anchors.  But I could have said this:
<div class="code">
<pre>
jsPlumb.connect({
	source:someDiv,
	target:someOtherDiv,
	anchors:["BottomCenter", "Continuous"]
});
</pre>
</div>	 	  
..which would have resulted in the source element having a Static Anchor at BottomCenter.  In practise, though, it seems the Continuous Anchors work best if both 
elements in a Connection are using them.
<p>Note also that Continuous Anchors can be specified on <strong>addEndpoint</strong> calls:</p>
<div class="code">
<pre>
jsPlumb.addEndpoint(someDiv, {
	anchor:"Continuous",
	paintStyle:{ fillStyle:"red" }
});
</pre>
</div>	 	
...and in <strong>makeSource</strong>/<strong>makeTarget</strong>:
<div class="code">
<pre>
jsPlumb.makeSource(someDiv, {
	anchor:"Continuous",
	paintStyle:{ fillStyle:"red" }
});

jsPlumb.makeTarget(someDiv, {
	anchor:"Continuous",
	paintStyle:{ fillStyle:"red" }
});
</pre>
</div>	 
... and in the jsPlumb defaults:
<div class="code">
<pre>
jsPlumb.Defaults.Anchor = "Continuous";
</pre>
</div>  
					</div>		
												
<div class="section">
		<h4><a id="definitions">Connector, Endpoint &amp; Overlay Definitions</a></h4>
Before we discuss Connector, Endpoints and Overlays, a quick word on definitions:  whenever you need to define a Connector, Endpoint or Overlay, you must use a "definition" of it, rather than constructing one directly.  This definition can be either a string that nominates the artifact you want to create:
		<div class="code">
<pre>jsPlumb.connect({
	source:"someDiv",
	target:"someOtherDiv",
	endpoint:"Rectangle"
});
</pre>
		</div>
		or an array consisting of both the artifact's name and the arguments you want to pass to its constructor:
		<div class="code">
<pre>jsPlumb.connect({
	source:"someDiv",
	target:"someOtherDiv",
	endpoint:[ "Rectangle", { cssClass:"myEndpoint", width:30, height:10 } ]
});
</pre>
		</div>
There is also a three-argument method that allows you to specify two sets of parameters, which jsPlumb will merge together for you. The idea behind this is that you will often want to define common characteristics somewhere and reuse them across a bunch of different calls:
		<div class="code">
<pre>var common = {
	cssClass	:	"myCssClass",
	hoverClass	:	"myHoverClass"
};
jsPlumb.connect({
	source:"someDiv",
	target:"someOtherDiv",
	endpoint:[ "Rectangle", { width:30, height:10 }, common ]
});
</pre>
		</div>
	This syntax is supported for all Endpoint, Connector and Overlay definitions.  Here's an example using definitions for all three:	
		<div class="code">
<pre>var common = {
	cssClass:"myCssClass"
};
jsPlumb.connect({
	source:"someDiv",
	target:"someOtherDiv",
	endpoint:[ "Dot", { radius:5, hoverClass:"myEndpointHover" }, common ],
	connector:[ "Bezier", { curviness:100 }, common ],
	overlays: [
		[ "Arrow", { foldback:0.2 }, common ],
		[ "Label", { cssClass:"labelClass" } ]	
	]
});
</pre>
		</div>		
The allowed constructor parameters are different for each artifact you create, but every artifact takes a single JS object as argument, with the parameters as [key,value] pairs in that object.  See the relevant sections on <a href="#connectors">Connectors</a>, <a href="#endpoints">Endpoints</a> and <a href="#overlays">Overlays</a> for information on supported parameters.</a>
				
	</div>

		<div class="section">
			<h3><a id="connectors">Connectors</a></h3>
			<p>Connectors are the lines that actually join elements of the UI.  jsPlumb has four connector implementations - a straight line, a Bezier curve, "flowchart", and "state machine".  The default connector is the Bezier curve.</p>
			<p>You optionally specify a Connector by setting the 'connector' property on a call to jsPlumb.connect, jsPlumb.addEndpoint(s), jsPlumb.makeSource or jsPlumb.makeTarget. If you do not supply a value for 'connector', the default will be used (see <a href="#defaults">defaults</a>).</p>
			<p>You specify Connectors using the syntax described above in <a href="#definitions">Connector, Endpoint &amp; Overlay Definitions.</a> Allowed constructor values for each Connector type are described below:</p>		
			<h4><a id="bezierConnector">Bezier Connector</a></h4>
			<p>The Bezier Connector provides a cubic Bezier path between the two Endpoints. It supports a single constructor argument:</p>
			<p>
			<strong>curviness</strong> - Optional; defaults to 150. This defines the distance in pixels that
			the Bezier's control points are situated from the anchor points.  This does not mean that your
			connector will pass through a point at this distance from your curve.  It is a hint to how you want the
			curve to travel. Rather than discuss Bezier curves at length here, because they are a complex topic,
			refer instead to <a href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank">Wikipedia.</a>
			</p>
			<h4><a id="straightConnector">Straight Connector</a></h4>
			<p>The Straight Connector draws a straight line between the two endpoints. No constructor arguments are supported; use the <strong>endpointStyle</strong> and/or <strong>cssClass</strong>/<strong>connectorClass</strong> to a <strong>connect</strong>, <strong>addEndpoint</strong>, <strong>makeSource</strong> or <strong>makeTarget</strong> call to control the appearance of one of these Connectors.  
			</p>
			<h4><a id="flowchartConnector">Flowchart Connector</a></h4>
			<p>This type of Connector draws a connection that consists of a series of vertical or horizontal segments - the classic flowchart look. Two constructor arguments are supported:</p>
			<strong>stub</strong> - this is the minimum length, in pixels, of the initial stub that emanates from an Endpoint.  This parameter is optional, and defaults to 30 pixels.<br/>
			<strong>gap</strong> - optional, defaults to 0 pixels. Lets you specify a gap between the end of the connector and the elements to which it is attached.
			<p>This Connector supports Connection that start and end on the same element.</p>
			<h4><a id="stateMachineConnector">State Machine Connector</a></h4>
			<p>This Connector draws slightly curved lines (they are actually quadratic Bezier curves), similar to the State Machine connectors you may have seen in software like GraphViz.  Connections in which some element is both the source and the target (so-called 'loopback') are supported by these Connectors (as they are with Flowchart Connectors); in this case you get a circle. Supported parameters are:
			</p>
			<p>
			<strong>margin</strong> - Optional; defaults to 5.  Defines the distance from the element that the connector begins/ends.
			</p>
			<p>
			<strong>curviness</strong> - Optional, defaults to 10.  This has a similar effect to the curviness parameter on Bezier curves.
			</p>
			<p>
			<strong>proximityLimit</strong> - Optional, defaults to 80.  The minimum distance between the two ends of the Connector before it paints itself as 
			a straight line rather than a quadratic Bezier curve.
			</p>    
			
		</div>
		
			<div class="section">
			<h3><a id="endpoints">Endpoint Types</a></h3>
			<p>An Endpoint is the UI component that marks the location of an Anchor, ie. the place where a Connector joins an
			element.  jsPlumb comes with four Endpoint implementations - <strong>Dot</strong>, <strong>Rectangle</strong>, <strong>Blank</strong> and <strong>Image</strong>. You optionally specify Endpoint properties using the
			<strong>endpoint</strong> parameter in a call to jsPlumb.connect, jsPlumb.addEndpoint, jsPlumb.makeSource or jsPlumb.makeTarget.
			</p>  
				<p>As with Connectors and Overlays, you specify Endpoints using the syntax described above in <a href="#definitions">Connector, Endpoint &amp; Overlay Definitions.</a></p>
			
			The four available Endpoint types, and their constructor arguments, are as follows:
					<h4><a id="dotEndpoint">Dot Endpoint</a></h4>
					This Endpoint draw a dot on the screen. It supports three constructor parameters:
					<p>
						<strong>radius</strong> - Optional; defaults to 10 pixels. Defines the radius of the dot.
					</p>
					<p>
						<strong>cssClass</strong> - Optional.  A CSS class to attach to the element the Endpoint creates.
					</p>
					<p>
						<strong>hoverClass</strong> - Optional.  A CSS class to attach to the element the Endpoint creates whenever the mouse is hovering over the 
						element or an attached Connection.
					</p>
					<h4><a id="rectangleEndpoint">Rectangle Endpoint</a></h4>
						Draws a rectangle. Supported constructor parameters are:
					<p>
						<strong>width</strong> - Optional; defaults to 20 pixels. Defines the width of the rectangle.
					</p>
					<p>
						<strong>height</strong> - Optional; defaults to 20 pixels. Defines the height of the rectangle.
					</p>
					<p>
						<strong>cssClass</strong> - Optional.  A CSS class to attach to the element the Endpoint creates.
					</p>
					<p>
						<strong>hoverClass</strong> - Optional.  A CSS class to attach to the element the Endpoint creates whenever the mouse is hovering over the 
						element or an attached Connection.
					</p>
					<h4><a id="imageEndpoint">Image Endpoint</a></h4>
						Draws an image from a given URL.  This Endpoint supports three constructor parameters:  
					<p>
						<strong>src</strong> - Required.  Specifies the URL of the image to use.
					</p>
					<p>
						<strong>cssClass</strong> - Optional.  A CSS class to attach to the element the Endpoint creates.
					</p>
					<p>
						<strong>hoverClass</strong> - Optional.  A CSS class to attach to the element the Endpoint creates whenever the mouse is hovering over the 
						element or an attached Connection.
					</p>
					<h4><a id="blankEndpoint">Blank Endpoint</a></h4>
						Does not draw anything visible to the user.  As discussed previously, this Endpoint is probably not what you want if you need your users to be able to drag existing Connections - for that, use a Rectangle or Dot Endpoint ans assign to it a CSS class that causes it to be transparent.
																			
		</div>
		
		<div class="section">
			<h3><a id="overlays">Overlay Types</a></h3>
			<p>
			Overlays are UI elements that are painted onto connections, such as labels or arrows.
			jsPlumb comes with four defaults:
			</p>
			<ul>
				<li><strong>Arrow</strong> - a configurable arrow that is painted at some point along the connector.  You can control the length and width of the Arrow, the 'foldback' point - a point the tail points fold back into, and the direction (allowed values are 1 and -1; 1 is the default and means point in the direction of the connection)</li>
				<li><strong>Label</strong> - a configurable label that is painted at some point along the connector.</li>
				<li><strong>PlainArrow</strong> - an Arrow shaped as a triangle, with no foldback.</li>
				<li><strong>Diamond</strong> - as the name suggests, a diamond.</li>
			</ul> 
			The last two are actually just configured instances of the generic Arrow overlay (see examples). 
			
			<p>All Overlays support these two methods for getting/setting their location (location is a number between 0 and 1 inclusive, indicating some point along the path
			inscribed by the associated Connector):</p>
			<ul>
				<li class="bullet"><strong>getLocation</strong> - returns the current location</li>
				<li class="bullet"><strong>setLocation</strong> - sets the current location; valid values are decimals in the range 0-1 inclusive</li> 
			</ul>
			
			<p>You can specify one or more overlays when making a call to jsPlumb.connect, jsPlumb.addEndpoint or jsPlumb.makeSource (but not jsPlumb.makeTarget; overlays
			are always derived from what the source of a Connection defines)  The three cases are discussed below:</p>
			1. Specifying one or more overlays on a jsPlumb.connect call. In this example we'll create an Arrow with the default options for an Arrow, and
			a label with the text "foo":
			<div class="code">
			<pre>jsPlumb.connect({
	...
	overlays:[ 
		"Arrow", 
		[ "Label", { label:"foo", location:0.25 }, id:"myLabel" ]
	],
	...
});			
</pre>
			</div>
			This connection will have an arrow located halfway along it, and the label "foo" one quarter of the way along.  Notice the <strong>id</strong>
			parameter; it can be used later if you wish to remove the Overlay or change its visibility (see below).<br/><br/> 
			
			2. Specifying one or more overlays on a jsPlumb.addEndpoint call.  Note in this example that we use the parameter 'connectorOverlays' and not
			'overlays' as in the last example.  This is because 'overlays' would refer to Endpoint Overlays:
			<div class="code">
			<pre>jsPlumb.addEndpoint("someDiv", {
	...
	connectorOverlays:[ 
		[ "Arrow", { width:10, length:30, location:1, id:"arrow" } ], 
		[ "Label", { label:"foo", id:"label" } ]
	],
	...
});</pre>
			</div>	
			This connection will have a 10x30 Arrow located right at the head of the connection, and the label "foo" located at the halfway point. Again,
			note that <strong>id</strong> parameter passed in to each Overlay spec.<br/><br/>
			
			3. Specifying one or more overlays on a jsPlumb.makeSource call.  Note in this example that we again use the parameter 'connectorOverlays' and not
			'overlays'.  The 'endpoint' parameter to jsPlumb.makeSource supports everything you might pass to the second argument of a jsPlumb.addEndpoint call:
			<div class="code">
			<pre>jsPlumb.makeSource("someDiv", {
	...
	endpoint:{
		connectorOverlays:[ 
			[ "Arrow", { width:10, length:30, location:1, id:"arrow" } ], 
			[ "Label", { label:"foo", id:"label" } ]
		]
	}
	...
});</pre>
			</div>	
			This connection will have a 10x30 Arrow located right at the head of the connection, and the label "foo" located at the halfway point. Again,
			note that <strong>id</strong> parameter passed in to each Overlay spec.<br/><br/>
			
			 	
					<h4><a id="arrowOverlay">Arrow Overlay</a></h4>
					<p>This overlay draws an arrow, using four points: the head and two tail points, and a 'foldback' point, which permits the tail
					of the arrow to be indented. Available constructor arguments for this Overlay are </p>
					<ul>
					<li><strong>width</strong> - width of the tail of the arrow</li>
					<li><strong>length</strong> - distance from the tail of the arrow to the head</li>
					<li><strong>location</strong> - where, as a proportional value from 0 to 1 inclusive, the Arrow should appear on the Connector</li>
					<li><strong>direction</strong> - which way to point. Allowed values are 1 (the default, meaning forwards) and -1, meaning backwards </li>
					<li><strong>foldback</strong> - how far along the axis of the arrow the tail points foldback in to. Default is 0.623.</li>
					<li><strong>paintStyle</strong> - a style object in the form used for paintStyle values for Endpoints and Connectors</li>
					</ul>
					<h4><a id="plainArrowOverlay">PlainArrow Overlay</a></h4>
					<p>This is just a specialized instance of Arrow in which jsPlumb hardcodes 'foldback' to 1, meaning the tail of the Arrow is a flat edge.  All of the constructor parameters from Arrow apply for PlainArrow.</p>
					<h4><a id="diamondOverlay">Diamond Overlay</a></h4>
					<p>This is a specialized instance of Arrow in which jsPlumb hardcodes 'foldback' to 2, meaning the Arrow turns into a Diamond.  All of the constructor parameters from Arrow apply for Diamond.</p>
					<h4><a id="labelOverlay">Label Overlay</a></h4>
					This provides a text label to decorate Connectors with.  The available constructor arguments are:
					<ul>
						<li><strong>label</strong> - The text to display.  You can provide a function here instead of plain text: it is passed the Connection as an argument, and it should return a String.</li>
						<li><strong>cssClass</strong> - Optional css class to use for the Label.  This is now preferred over using the 'labelStyle' parameter.</li>
						<li><strong>labelStyle</strong> - (deprecated, use cssClass instead) Optional arguments for the label's appearance.  Valid entries in this JS object are:
							<ul>
								<li><em>font</em> - a font string in a format suitable for the Canvas element</li>
								<li><em>fillStyle</em> - the color to fill the label's background with. Optional.</li>
								<li><em>color</em> - the color of the label's text. Optional.</li>
								<li><em>padding</em> - optional padding for the label. This is expressed as a proportion of the width of the label, not in pixels or ems.</li>
								<li><em>borderWidth</em> - optional width in pixels for the label's border. Defaults to 0.</li>
								<li><em>borderStyle</em> - optional. The color to paint the border, if there is one.</li>
								
							</ul>
						
						</li>
						<li><strong>location</strong> - As for Arrow Overlay.  Where, proportionally from 0 to 1 inclusive, the label should appear.</li>
					</ul>

					The Label overlay offers two methods - getLabel and setLabel - for accessing/manipulating its content dynamically:
<div class="code">
<pre>
var c = jsPlumb.connect({
	source:"d1", 
	target:"d2", 
	overlays:[
		[ "Label", {label:"FOO", id:"label"}]
	]	
});					

...

var label = c.getOverlay("label");
console.log("Label is currently", label.getLabel());
label.setLabel("BAR");
console.log("Label is now", label.getLabel());
</pre>
</div>
In this example you can see that the Label Overlay is assigned an id of "label" in the connect call, and then retrieved using that id in the call to Connection's getOverlay method.
<p>Both Connections and Endpoints support Label Overlays, and because changing labels is quite a common operation, <strong>setLabel</strong> and <strong>getLabel</strong> methods have been added to these objects:
<div class="code">
<pre>
var conn = jsPlumb.connect({
	source:"d1", 
	target:"d2",
	label:"FOO"
});					

...

console.log("Label is currently", conn.getLabel());
conn.setLabel("BAR");
console.log("Label is now", conn.getLabel());
</pre>
</div>
These methods support passing in a Function instead of a String, and jsPlumb will create a label overlay for you if one does not yet exist when you call getLabel:
<div class="code">
<pre>
var conn = jsPlumb.connect({
	source:"d1", 
	target:"d2"
});					

...

conn.setLabel(function(c) {
	var s = new Date();
	return s.getTime() + "milliseconds have elapsed since 01/01/1970";
});
console.log("Label is now", conn.getLabel());
</pre>
</div>
					
					<h4><a id="hideshowOverlay">Hiding/Showing Overlays</a></h4>
					<p>You can control the visibility of Overlays using the <strong>setVisible</strong> method of Overlays themselves, or with
					<strong>showOverlay(id)</strong> or <strong>hideOverlay(id)</strong> on a Connection.</p>
					<p>Remember the <strong>id</strong> parameter that we specified in the examples above?  This can be used to retrieve the Overlay
					from a Connection:</p>
					<div class="code">
<pre>var connection = jsPlumb.connect({
	...
	overlays:[ 
		"Arrow", 
		[ "Label", { label:"foo", location:0.25 }, id:"myLabel" ]
	],
	...
});		

// time passes

var overlay = connection.getOverlay("myLabel");
// now you can hide this Overlay:
overlay.setVisible(false);
// there are also hide/show methods:
overlay.show();
overlay.hide();

</pre>					
					</div>
					<p>However, Connection and Endpoint also have two convenience methods you could use instead:
					<div class="code">
<pre>var connection = jsPlumb.connect({
	...
	overlays:[ 
		"Arrow", 
		[ "Label", { label:"foo", location:0.25 }, id:"myLabel" ]
	],
	...
});		

// time passes

connection.hideOverlay("myLabel");

// more time passes

connection.showOverlay("myLabel");

</pre>					
					</div>
					
		<h4><a id="hideshowOverlay">Removing Overlays</a></h4>
		<p>Connection and Endpoint also have a <strong>removeOverlay</strong> method, that does what you might expect:
					<div class="code">
<pre>var connection = jsPlumb.connect({
	...
	overlays:[ 
		"Arrow", 
		[ "Label", { label:"foo", location:0.25 }, id:"myLabel" ]
	],
	...
});		

// time passes

connection.removeOverlay("myLabel");


</pre>					
					</div>							
	
		</div>
	
			
			<div class="section">
			<h3><a id="defaults">Defaults</a></h3>
			The easiest way to set a look and feel for your plumbing is to override the defaults that jsPlumb uses. If you
			do not do this you are forced to provide your overridden values on every call.  Every argument to the connect and addEndpoint methods has an
			associated default value in jsPlumb.<br/><br/>

			The defaults that ship with jsPlumb are stored in <em>jsPlumb.Defaults</em>, which is a Javascript object.  Valid entries, and their initial values, are:

			<div class="code">
<pre>
Anchor : "BottomCenter",
Anchors : [ null, null ],
Connector : "Bezier",
ConnectionOverlays : [ ],
DragOptions : { },
DropOptions : { },
Endpoint : "Dot",
EndpointOverlays : [ ],
Endpoints : [ null, null ],
EndpointStyle : { fillStyle : null },
EndpointStyles : [ null, null ],
EndpointHoverStyle : null,
EndpointHoverStyles : [ null, null ],
HoverPaintStyle : null,
LabelStyle : { color : "black" },
LogEnabled : false,
Overlays : [ ],
MaxConnections : 1,
MouseEventsEnabled : true,
PaintStyle : { lineWidth : 8, strokeStyle : "#456" },
RenderMode : "svg",
Scope : "_jsPlumb_DefaultScope"
</pre>
			</div>
			<p>
			Note that in EndpointStyle, the default fillStyle is 'null'.  This instructs jsPlumb to use the strokeStyle
from the attached connector to fill the endpoint.</p>
<p>Note also that you can specify either or both (or neither) of 'EndpointStyle' and 'EndpointStyles'.  This allows you to specify a different
end point for each end of a connection.  'Endpoint' and 'Endpoints' use the same concept.  jsPlumb will look first in the
individual endpoint/endpoint style arrays, and then fall back to the single default version.</p>

			you can override these defaults by including this in a script somewhere:
			<div class="code">
<pre>
jsPlumb.Defaults.PaintStyle = {
	lineWidth:13,
	strokeStyle: 'rgba(200,0,0,100)'
}

jsPlumb.Defaults.DragOptions = { cursor: "crosshair" };

jsPlumb.Default.Endpoints = [ [ "Dot", 7 ], [ "Dot", 11 ] ];

jsPlumb.Defaults.EndpointStyles = [{ fillStyle:"#225588" }, { fillStyle:"#558822" }];</pre>
			</div>
			after the jsPlumb script has been loaded of course!  Here we have specified the following default behaviour:
			<ul>
				<li>- connectors are 13 pixels wide and painted with a semi-transparent red line</li>
				<li>- when dragging an element the crosshair cursor is used</li>
				<li>- the source endpoint is a dot of radius 7; the target endpoint is a dot of radius 11</li>
				<li>- the source endpoint is blue; the target endpoint is green</li>
			</ul>

			<h5>jsPlumb.importDefaults</h5>
From version 1.4.0 onwards there is a helper method called <strong>importDefaults</strong> that allows you to import a set of values with just one call to jsPlumb.  Here's the previous example using importDefaults:
			<div class="code">
<pre>
jsPlumb.importDefaults({
	PaintStyle : {
		lineWidth:13,
		strokeStyle: 'rgba(200,0,0,100)'
	},
	DragOptions : { cursor: "crosshair" },
	Endpoints : [ [ "Dot", 7 ], [ "Dot", 11 ] ],
	EndpointStyles : [{ fillStyle:"#225588" }, { fillStyle:"#558822" }]
});</pre>
			</div>

		</div> 					

<div class="section">
			<h3><a id="simpleConnections">Connections</a></h3>
			<h4><a id="simpleConnections">Programmatic Connections</a></h4>
The most simple connection you can make with jsPlumb looks like this:
			<div class="code">
<pre>
jsPlumb.connect({source:"element1", target:"element2"});</pre>			
			</div>

		In this example we have created a Connection from 'element1' to 'element2'.  Remember that a Connection in jsPlumb consists of two Endpoints,
		a Connector, and zero or more Overlays.  But this call to 'connect' supplied none of those things, so jsPlumb uses the default values wherever it needs to.
		In this case, default values have been used for the following: 
		<ul>
			<li>- The type and appearance of each Endpoint in the Connection. jsPlumb's default for this is the "Dot" endpoint, of radius 10, with fill color "#456".</li>
			<li>- The Anchors that define where the connection's Endpoints appear on each element. The jsPlumb default is "BottomCenter"</li>			
			<li>- Whether or not each Endpoint can be a source or target for new Connections. The default is false.</li>
			<li>- The type and appearance of the Connection's Connector. The default is a "Bezier" connector of line width 8, and color "#456".</li>
		</ul>
		<p>
		So this call will result in an 8px Bezier, colored "#456", from the bottom center of 'element1' to the bottom center of 'element2', and each
		Endpoint will be a 10px radius Dot Endpoint, colored "#456".
		</p>
		<p>
		Let's beef up this call a little and tell jsPlumb what sort of Endpoints we want, and where we want them:		
		</p>
		<div class="code">
<pre>
jsPlumb.connect({
	source:"element1", 
	target:"element2",
	anchors:["RightMiddle", "LeftMiddle" ],
	endpoint:"Rectangle",
	endpointStyle:{ fillStyle: "yellow" }
});
</pre>			
			</div>
			
		<p>This is what we have told jsPlumb we want this time:</p>
		<ul>
			<li><strong>anchors</strong> - this array tells jsPlumb where the source and target Endpoints should be located on their parent elements. In this case,
			we use the shorthand syntax to name one of jsPlumb's default anchors; you can also specify custom locations (see <a href="#anchors">anchors</a>).
			Instead of <strong>anchors</strong> you can use <strong>anchor</strong>, if you want the source and target Endpoints to be located at the
			same place on their parent elements.			<br/>
			</li>
			<li>
				<strong>endpoint</strong>  - this tells jsPlumb to use the "Rectangle" Endpoint for both the source and target of the Connection.  As with anchors, 
				<strong>endpoint</strong> has a plural version that allows you to specify a different Endpoint for each end of the Connection.<br/>  
			</li>
			<li>
				<strong>endpointStyle</strong> - this is the definition of the appearance of the Endpoint you specified above.  Again, there is a
				plural equivalent of this that allows you to specify a different style for each end of the Connection. For more information about
				allowed values for this value, see <a href="#paintstyles">Connector, Endpoint & Overlay Styles</a>. 
			</li>
		</ul>		
		
		<h5>Reusing common settings between jsPlumb.connect calls</h5>
		<p>
			A fairly common situation you will find yourself in is wanting to create a bunch of Connections that have only minor differences
			between them.  To support that, <strong>jsPlumb.connect</strong> takes an optional second argument. For example:			 
		</p>
		<div class="code">
<pre>
var common = {
	anchors:[ "BottomCenter", "TopCenter" ],
	endpoints:["Dot", "Blank" ]
};

jsPlumb.connect({ source:"someElement", target:"someOtherElement" }, common);

jsPlumb.connect({ source:"aThirdElement", target:"yetAnotherElement" }, common);

</pre>			
			</div>		
			
		<h5>Endpoints created by jsPlumb.connect</h5>
		<p>If you supply an element id or selector for either the source or target , jsPlumb.connect will automatically create an Endpoint on the 
		given element.  These automatically created Endpoints are not marked as drag source or targets, and cannot
		be interacted with.  For some situations this behaviour is perfectly fine, but for more interactive UIs you should set things up using the drag and drop
		method discussed below.</p>
		<p>Given that jsPlumb.connect creates its own Endpoints in some circumstances, in order to avoid leaving orphaned Endpoints around the place, if the Connection is subsequently
		deleted, these created Endpoints are deleted too.  Should you want to, you can override this behaviour by setting <strong>deleteEndpointsOnDetach</strong> to
		false in the connect call:</p>
		<div class="code">
<pre>
jsPlumb.connect({ 
	source:"aThirdElement", 
	target:"yetAnotherElement",
	deleteEndpointsOnDetach:false 
});
</pre>
</div>	

	<h5>Detaching Connections</h5>
	By default, connections made with jsPlumb.connect will be detachable via the mouse.  You can prevent this by either setting an appropriate default value:

		<div class="code">
<pre>
jsPlumb.importDefaults({ 
	...
	ConnectionsDetachable:false
	...
});
</pre>
</div>	

	Or by specifying it on the connect call like this:
		<div class="code">
<pre>
jsPlumb.connect({ 
	source:"aThirdElement", 
	target:"yetAnotherElement",
	detachable:false
});
</pre>
</div>		
								
					
		<h4><a id="draggableConnections">Connections using Drag and Drop</a></h4>
		To support drag and drop connections, you first need to set a few things up.  Every drag and drop connection needs at least a source
		Endpoint that the user can drag a connection from. Here's a simple example of how to create an Endpoint:
		<div class="code">
<pre>
var endpointOptions = { isSource:true };
var endpoint = jsPlumb.addEndpoint('elementId', endpointOptions);
</pre>		
</div>  	
	This Endpoint will act as a source for new Connections, and will use the jsPlumb defaults for its own appearance and that of any Connections that are drawn from it.							
	
		<h5>Tip: use the three-argument addEndpoint method for common data </h5>
		One thing that happens quite often is that you have an Endpoint whose appearance and behaviour is largely the
		same between usages on different elements, with just a few differences. 
		<div class="code">
<pre>
var exampleGreyEndpointOptions = {
	endpoint:"Rectangle",
	paintStyle:{ width:25, height:21, fillStyle:'#666' },
	isSource:true,
	connectorStyle : { strokeStyle:"#666" },
	isTarget:true
};
</pre>		
</div>  		
		Notice there is no 'anchor' set.  Here we apply it to two elements, at a different location in each:
		<div class="code">
<pre>
jsPlumb.addEndpoint('element1', { anchor:"BottomCenter" }, exampleGreyEndpointOptions)); 

jsPlumb.addEndpoint('element2', { anchor:"TopCenter" }, exampleGreyEndpointOptions));
</pre>		
</div>

<p>
Now that you have a source Endpoint, you need to either create a target Endpoint on some element, or notify jsPlumb that you wish to make an
entire element a drop target.  Let's look at how to attach a target Endpoint first:
</p>

		<div class="code">
<pre>var endpointOptions = { isTarget:true, endpoint:"Rectangle", paintStyle:{ fillStyle:"gray" } };
var endpoint = jsPlumb.addEndpoint("otherElementId", endpointOptions);
</pre>		
		</div>
		<p>
		This Endpoint, a gray rectangle, has declared that it can act as a drop target for Connections. 
</p>
<p>
jsPlumb also supports marking entire elements as drag sources or drag targets, using the <strong>makeSource</strong> and <strong>makeTarget</strong> methods.  This is a useful function for certain applications.  Each of these methods takes an Endpoint declaration which defines the Endpoint that jsPlumb will create after a Connection has been attached.  Let's take a look at makeTarget first:
</p>
<h4><a id="sourcesAndTargets">Elements as sources &amp; targets</a></h4>
jsPlumb also supports turning entire elements into Connection sources and targets, using the methods <strong>makeSource</strong> and <strong>makeTarget</strong>.  With these methods you mark an element as a source or target, and provide an Endpoint specification for jsPlumb to use when a Connection is established.  makeSource also gives you the ability to mark some child element as the place from which you wish to drag Connections, but still have the Connection on the main element after it has been established.
<p>These methods honour the jsPlumb defaults - if, for example you set up the default Anchors to be this:</p>
<div class="code">
<pre>
jsPlumb.Defaults.Anchors = [ "LeftMiddle", "BottomRight" ];
</pre>
</div>
... and then used makeSource and makeTarget without specifying Anchor locations, jsPlumb would use "LeftMiddle" for the makeSource element and "BottomRight" for the makeTarget element.
<p>
A further thing to note about makeSource and makeTarget is that from 1.4.0 onwards any prior calls to one of these methods is honoured by subsequent calls to jsPlumb.connect. This helps when you're building a UI that uses this functionality at runtime but which loads some initial data, and you want the statically loaded data to have the same appearance and behaviour as dynamically created connections (obviously quite a common use case).  
<p>For example:</p>
<div class="code">
<pre>
jsPlumb.makeSource("el1", {
	anchor:"Continuous",
	endpoint:["Rectangle", { width:40, height:20 }]
});

...

jsPlumb.connect({source:"el1", target:"el2"});
</pre>
</div>
In this example, the source of the connection will be a Rectangle of size 40x20, having a Continuous Anchor.
<p>You can override this behaviour by setting a <strong>newConnection</strong> parameter on the connect call:</p>
<div class="code">
<pre>
jsPlumb.makeSource("el1", {
	anchor:"Continuous",
	endpoint:["Rectangle", { width:40, height:20 }]
});

...

jsPlumb.connect({ source:"el1", target:"el2", newConnection:true });
</pre>
</div>
<h5><a id="makeTarget">jsPlumb.makeTarget</a></h5>
<p>
This method takes two arguments, the first of which specifies some element (or list of elements); the second specifies the Endpoint you wish to create on that element whenever a Connection is established on it.  In this example we will use the exact same target Endpoint we used before - the gray rectangle - but we will tell jsPlumb that the element "aTargetDiv" will be the drop target:
</p>
		<div class="code">
<pre>var endpointOptions = { 
  isTarget:true, 
  maxConnections:5,
  endpoint:"Rectangle", 
  paintStyle:{ fillStyle:"gray" } 
};
jsPlumb.makeTarget("aTargetDiv", endpointOptions);
</pre>		
		</div>
<p>
	The allowed values in 'endpointOptions' are identical for both the <strong>jsPlumb.addEndpoint</strong> and <strong>jsPlumb.makeTarget</strong> methods, but makeTarget supports an extended 
	anchor syntax that allows you more control over the location of the target endpoint.  This is discussed below.	
</p>		
<p>Notice in the 'endpointOptions' object above there is a 'isTarget' parameter set - this may seem incongruous, since you know you're going to make some element a target.  Remember that the endpointOptions object is the information jsPlumb will use to create an Endpoint on the given target element each time a Connection is established to it. It takes the exact same format as you would pass to addEndpoint; makeTarget is essentially a deferred addEndpoint call followed by a connect call.  So in this case, we're telling jsPlumb that any Endpoints it happens to create on some element that was configured by the makeTarget call are themselves Connection targets.
</p>
<h5>Unique Endpoint per Target </h5>
<p>jsPlumb will create a new Endpoint using the supplied information every time a new Connection is established on the target element, by default, but you can override this behaviour and tell jsPlumb that it should create at most one Endpoint, which it should attempt to use for subsequent Connections:
</p>
		<div class="code">
<pre>var endpointOptions = { 
  isTarget:true, 
  uniqueEndpoint:true,
  endpoint:"Rectangle", 
  paintStyle:{ fillStyle:"gray" } 
};
jsPlumb.makeTarget("aTargetDiv", endpointOptions);
</pre>		
		</div>
Here, the <strong>uniqueEndpoint</strong> parameter tells jsPlumb that there should be at most one Endpoint on this element.  Notice that 'maxConnections' is not set: the default is 1, so in this setup we have told jsPlumb that "aTargetDiv" can receive one Connection and no more.
<h5>Deleting Endpoints on Detach</h5>
By default, any Endpoints created using makeTarget have <strong>deleteEndpointsOnDetach</strong> set to true, which means that once all Connections to that Endpoint are removed, the Endpoint is deleted.  You can override this by setting the flag to true on the makeTarget call:
		<div class="code">
<pre>var endpointOptions = { 
  isTarget:true, 
  maxConnections:5,
  uniqueEndpoint:true,
  deleteEndpointsOnDetach:false,
  endpoint:"Rectangle", 
  paintStyle:{ fillStyle:"gray" } 
};
jsPlumb.makeTarget("aTargetDiv", endpointOptions);
</pre>		
		</div>
In this setup we have told jsPlumb to create an Endpoint the first time "aTargetElement" is connected to, and to not delete it even if there are no longer any Connections to it.  The created Endpoint will be reused for subsequent Connections, and can support a maximum of 5.

<h5>Detaching connections made with the mouse</h5>
As with jsPlumb.connect, connections made with the mouse after setting up Endpoints with one of the functions we've just covered will be, by default, detachable.  You can prevent this in the jsPlumb defaults, as previously mentioned:
		<div class="code">
<pre>jsPlumb.importDefaults({ 
	...
	ConnectionsDetachable:false,
	...
});
</pre>		
		</div>

	And you can also set this on a per-endpoint (or source/target) level, like in these examples:

		<div class="code">
<pre>jsPlumb.addEndpoint("someElementId", { 
	connectionsDetachable:false	
});

jsPlumb.makeSource("someOtherElement", {
	...
	connectionsDetachable:false,
	...
});

jsPlumb.makeTarget("yetAnotherElement", {
	...
	connectionsDetachable:false,
	...
});
</pre>		
		</div>

Note that in the jsPlumb defaults, by convention each word in a parameter is capitalised ("ConnectionsDetachable"), whereas for a call to one of these methods, we use camel case ("connectionsDetachable").


<h5>Target Anchors positions with makeTarget</h5>
<p>When using the makeTarget method, jsPlumb allows you to provide a callback function to be used to determine
the appropriate location of a target anchor for every new Connection dropped on the given target.  It may be the
case that you want to take some special action rather than just relying on one of the standard anchor mechanisms.
</p>
<p>This is achieved through an extended anchor syntax (note that this syntax is <strong>not supported</strong> in
the <strong>jsPlumb.addEndpoint</strong> method) that supplies a "positionFinder" to the anchor specification.  jsPlumb 
provides two of these by default; you can register your own on jsPlumb and refer to them by name, or just 
supply a function.  Here's a few examples:</p>
Instruct jsPlumb to place the target anchor at the exact location at which the mouse button was released on the
target element. Note that you tell jsPlumb the anchor is of type "Assign", and you then provide a "position"
parameter, which can be the name of some position finder, or a position finder function itself:
<div class="code">
<pre>
jsPlumb.makeTarget("someElement", {
  anchor:[ "Assign", { 
    position:"Fixed"
  }]
});
</pre>
</div>
<p><strong>Fixed</strong> is one of the two default position finders provided by jsPlumb. The other is <strong>Grid</strong>:
<div class="code">
<pre>
jsPlumb.makeTarget("someElement", {
  anchor:[ "Assign", { 
    position:"Grid",
    grid:[3,3]
  }]
});
</pre>
</div>
The Grid position finder takes a "grid" parameter that defines the size of the grid required. [3,3] means
3 rows and 3 columns.
<h5>Supplying your own position finder</h5>
<p>To supply your own position finder to jsPlumb you first need to create the callback function. First let's take a look at what the source code for the Grid position finder looks like:</p>
<div class="code">
<pre>
function(eventOffset, elementOffset, elementSize, constructorParams) {
  var dx = eventOffset.left - elementOffset.left, dy = eventOffset.top - elementOffset.top,
      gx = elementSize[0] / (constructorParams.grid[0]), 
      gy = elementSize[1] / (constructorParams.grid[1]),
      mx = Math.floor(dx / gx), my = Math.floor(dy / gy);

  return [ ((mx * gx) + (gx / 2)) / elementSize[0], ((my * gy) + (gy / 2)) / elementSize[1] ];
}
</pre>
</div>
The four arguments are:
<ul>
	<li class="bullet"><strong>eventOffset</strong> - Page left/top where the mouse button was released (a JS object containing left/top members like you get from a jQuery offset call)</li>
	<li class="bullet"><strong>elementOffset</strong> - JS offset object containing offsets for the element on which the Connection is to be created</li>
	<li class="bullet"><strong>elementSize</strong> - [width, height] array of the dimensions of the element on which the Connection is to be created</li>
	<li class="bullet"><strong>constructorParams</strong> - the parameters that were passed to the Anchor's constructor. In the example given above, those parameters are 'position' and 'grid'; you can pass arbitrary parameters.
</ul>
The return value of this function is an array of [x, y] - proportional values between 0 and 1 inclusive, such as you can pass to a static Anchor.
<p>To make your own position finder you need to create a function that takes those four arguments and returns an [x, y] position for the anchor, for example:</p>
<div class="code">
<pre>
jsPlumb.AnchorPositionFinders.MyFinder = function(dp, ep, es, params) {
	...		
	return [ some maths ];	
};
</pre>
</div>
Then refer to it in a makeTarget call:
<div class="code">
<pre>
jsPlumb.makeTarget("someElement", {  
  anchor:[ "Assign", { 
    position:"MyFinder",
    myCustomParameter:"foo",
    anInteger:5
  }]
});
</pre>
</div>

<h5><a id="makeSource">jsPlumb.makeSource</a></h5>
There are two use cases supported by this method.  The first is the case that you want to drag a Connection from the element itself and have an Endpoint attached to the element when a Connection is established.  The second is a more specialised case: you want to drag a Connection from the element, but once the Connection is established you want jsPlumb to move it so that its source is on some other element.  For an example of this second case, check out the <a href="../demo/jquery/stateMachineDemo.html">State Machine Connectors</a> demonstration.
<p>Here's an example code snippet for the basic use case of makeSource:</p>
<div class="code">
<pre>
jsPlumb.makeSource(someDiv, {
  paintStyle:{ fillStyle:"yellow" },
  endpoint:"Blank",
  anchor:"BottomCenter"
});
</pre>
</div>
<p>
Notice again that the second argument is the same as the second argument to an addEndpoint call.  makeSource is, essentially, a type of addEndpoint call.  In this example we have told jsPlumb that we will support dragging Connections directly from 'someDiv'.  Whenever a Connection is established between 'someDiv' and some other element, jsPlumb assigns an Endpoint at BottomCenter of 'someDiv', fills it yellow, and sets that Endpoint as the newly created Connection's source. 
</p>		
<p>Configuring an element to be an entire Connection source using makeSource means that the element cannnot itself be draggable.  There would be no way for jsPlumb to distinguish between the user attempting to drag the element and attempting to drag a Connection from the element.  If your UI works in such a way that that is acceptable then you'll be fine to use this method.  But if you want to drag Connections from some element but also have the element be draggable itself, you might want to consider the second use case.  First, a code snippet:</p>
<div class="code">
<pre>
jsPlumb.makeSource("someConnectionSourceDiv", {
  paintStyle:{ fillStyle:"yellow" },
  endpoint:"Blank",
  anchor:"BottomCenter",
  parent:"someDiv"
});
</pre>
</div>
<p>The only difference here is the inclusion of the 'parent' parameter.  It instructs jsPlumb to configure the source Endpoint on the element specified - in this case, "someDiv" (the value of this parameter may be a String id or a selector).</p>
<p>Again, I'd suggest taking a look at the <a href="../demo/jquery/stateMachineDemo.html">State Machine Connectors demonstration</a> for an example of this.</p>

<p>
There are many things you can set in an Endpoint options object; for a thorough list see the API documentation for Endpoint.  
</p>
<p>Here's an example of specifying that you want an Arrow overlay halfway along any Connection dragged from this Endpoint:</p>
<div class="code">
<pre>
var exampleGreyEndpointOptions = {
  endpoint:"Rectangle",
  paintStyle:{ width:25, height:21, fillStyle:'#666' },
  isSource:true,
  connectorStyle : { strokeStyle:"#666" },
  isTarget:true,
  connectorOverlays: [ [ "Arrow", { location:0.5 } ] ]
};
</pre>
</div>
This is an Endpoint that moves around the element it is attached to dependent on the location of other elements in the connections it is attached to (a 'dynamic' anchor):
<div class="code">
<pre>
var exampleGreyEndpointOptions = {
  endpoint:"Rectangle",
  paintStyle:{ width:25, height:21, fillStyle:'#666' },
  isSource:true,
  connectorStyle : { strokeStyle:"#666" },
  isTarget:true,
  connectorOverlays: [ [ "Arrow", { location:0.5 } ] ]
  anchor:[ "TopCenter","RightMiddle","BottomCenter","LeftMiddle" ]
};
</pre>
</div>
<h5><a id="targetSourceTest">Testing if an element is a target or source</a></h5>
You can test if some element has been made a connection source or target using these methods:
<ul>
<li class="bullet">isTarget</li>
<li class="bullet">isSource</li>
</ul>
<p>The return value is a boolean.</p>
<h5><a id="targetSourceToggle">Toggling an element as connection target or source</a></h5>
You can toggle the state of some source or target using these methods:
<ul>
<li class="bullet">setTargetEnabled</li>
<li class="bullet">setSourceEnabled</li>
</ul>
<p>The return value from these methods is the current jsPlumb instance, allowing you to chain them:</p>
<div class="code">
<pre>
jsPlumb.setTargetEnabled("aDivId").setSourceEnabled($(".aSelector"));
</pre>
</div>
<p>Note that if you call either of these methods on an element that was not originally configured as a target or source, nothing will happen.</p>
<p>You can check the enabled state of some target or source using these methods:
<ul>
<li class="bullet">isTargetEnabled</li>
<li class="bullet">isSourceEnabled</li>
</ul>
<h5><a id="targetSourceCancel">Canceling previous makeTarget and/or makeSource calls</a></h5>
jsPlumb offers four methods to let you cancel previous makeTarget or makeSource calls. Each of these methods returns the current jsPlumb instance, and so can be chained:
<ul>
<li class="bullet">unmakeTarget</li>
<li class="bullet">unmakeSource</li>
<li class="bullet">unmakeEveryTarget</li>
<li class="bullet">unmakeEverySource</li>
</ul>
<p>These last two are analogous to the <strong>removeEveryConnection</strong> and <strong>removeEveryEndpoint</strong> methods that have been in jsPlumb for a while now.</p>
<p>unmakeTarget and unmakeSource both take as argument the same sorts of values that makeTarget and makeSource accept - a string id, or a selector, or an array of either of these:</p>
<div class="code">
<pre>
jsPlumb.unmakeTarget("aDivId").unmakeSource($(".aSelector"));
</pre>
</div>


<h5><a id="dragOptions">Drag Options</a></h5>
	These are options that will be passed through to the supporting library's drag API.  jsPlumb passes everything you supply here through, inserting
	wrapping functions if necessary for the various lifecycle events that jsPlumb needs to know about.  So if, for example, you pass a function to be
	called when dragging starts, jsPlumb will wrap that function with a function that does what jsPlumb needs to do, then call yours.
	<p>
	At the time of writing, jsPlumb supports jQuery, MooTools and YUI3, and each of those libraries uses different terminology.  In addition, jQuery's API is
	more fully featured, providing easy support for setting the zIndex and opacity of elements being dragged, as well as the 'scope' for a drag/drop (allowing
	you to specify more than one type of drag/drop pair), and hover classes for when a draggable is on the move or
	over a droppable. If you're using jQuery you can of course just supply these values on the dragOptions; to make it easier, jsPlumb's MooTools and YUI3 adapters recognize 
	these options and add appropriate callbacks for you.  
	</p> 
	<p>
	Given that the options here are library-specific, and they are all well-documented, we're going to discuss just the three drag options
	that behave the same way in all (see below for hoverClass):
		<ul>
		<li><strong>opacity</strong> - the opacity of an element that is being dragged.  Should be a fraction between 0 and 1 inclusive.</li>
		<li><strong>zIndex</strong> - the zIndex of an element that is being dragged.</li>
		<li><strong>scope</strong> - the scope of the draggable.  can only be dropped on a droppable with the same scope.  this is discussed below.</li>
		</ul> 
	</p>
	
	<p>For more information about drag options, take a look at the <a href="http://docs.jquery.com/UI/Draggable" target="_blank">jQuery</a>, <a href="http://mootools.net/docs/more/Drag/Drag.Move" target="_blank">MooTools</a>, or <a href="http://developer.yahoo.com/yui/3/dd/" target="_blank">YUI3</a> docs.	
	</p>
	<p><strong>NOTE: there is an issue in Chrome that affects the 'cursor' argument to drag options in jQuery. See these links:</strong>
	</p><p>
<a href="http://forum.jquery.com/topic/draggable-cursor-option-does-not-work" target="_blank">http://forum.jquery.com/topic/draggable-cursor-option-does-not-work</a><br/>
<a href="http://forum.jquery.com/topic/chrome-text-select-cursor-on-drag" target="_blank">http://forum.jquery.com/topic/chrome-text-select-cursor-on-drag</a>
</p>
You should put something like this at the top of your JS to avoid it (perhaps not something so drastic as a document-wide override):	
<div class="code">
<pre>document.onselectstart = function () { return false; };</pre>
</div>		
	
	<h5><a id="dropOptions">Drop Options</a></h5>
	Drop options are treated by jsPlumb in the same way as drag options - they are passed through to the underlying library.  MooTools does not have drop options like jQuery and YUI3 do; droppable functionality in MooTools 
	is actually implemented by the Drag.Move class - the one used to initialise a draggable.  But when you setup an Endpoint in jsPlumb you should ignore
	that fact, and treat droppables like you would in jQuery or YUI3.  jsPlumb wires everything up for you under the hood.
	<p>There are three jQuery droppable options that jsPlumb treats as shortcuts in MooTools and YUI3, for the sake of consistency:</p>
		<ul>
			<li><strong>hoverClass</strong> - the CSS class to attach to the droppable when a draggable is hovering over it.</li>
			<li><strong>activeClass</strong> - the CSS class to attach to the droppable when a draggable is, um, being dragged.</li>
			<li><strong>scope</strong> - the scope of the draggable.  The draggable can only be dropped on a droppable with the same scope.  This is discussed below.</li>
		</ul>   
	<p>For more information about drop options when using jQuery, see <a href="http://docs.jquery.com/UI/Droppable" target="_blank">here</a>.</p>
		
	<h5><a id="dragAndDropScope">Drag and Drop Scope</a></h5>
		jsPlumb borrowed the concept of 'scope' from jQuery's drag/drop implementation: the notion of
		which draggables can be dropped on which droppables.  In jsPlumb you can provide a 'scope' entry when 
		creating an Endpoint.  Here's the example grey Endpoint example with 'scope' added:
		
<div class="code">
<pre>
var exampleGreyEndpointOptions = {
  endpoint:"Rectangle",
  paintStyle:{ width:25, height:21, fillStyle:"#666" },
  isSource:true,
  connectionStyle : { strokeStyle:"#666" },
  isTarget:true,
  scope:"exampleGreyConnection"
};</pre>		
</div>  		
  										
	If you do not provide a 'scope' entry, jsPlumb uses a default scope.  Its value is accessible through this method:
	<div class="code">
<pre>
jsPlumb.getDefaultScope();
</pre>	
	</div>				
	If you want to change it for some reason you can do so with this method:
	<div class="code">
<pre>
jsPlumb.setDefaultScope("mySpecialDefaultScope");
</pre>	
	</div>			
	You can also, should you want to, provide the scope value separately on the drag/drop options, like this:
	<div class="code">
<pre>
var exampleGreyEndpointOptions = {
  endpoint:"Rectangle",
  paintStyle:{ width:25, height:21, fillStyle:'#666' },
  isSource:true,
  connectionStyle : { strokeStyle:"#666" },
  isTarget:true,
  dragOptions:{ scope:"dragScope" },
  dropOptions:{ scope:"dropScope" }
};</pre>		
</div>  
			
	</div>	

	<div class="section">
		<h3><a id="parameters">Connection Parameters</a></h3>
		jsPlumb has a mechanism that allows you to set parameters on a per-connection basis.  This can be achieved in a few different ways:

		<ul>
			<li class="bullet">Providing parameters to a jsPlumb.connect call</li>
			<li class="bullet">Providing parameters to an addEndpoint call to/from which a connection is subsequently established using the mouse</li>
			<li class="bullet">using the <strong>setParameter</strong> or <strong>setParameters</strong> method on a Connection</li>
		</ul>
		Getting parameters is achieved through either the <strong>getParameter(key)</strong> or <strong>getParameters</strong> method on a Connection.
		<h4><a id="connectParameters">jsPlumb.connect</a></h4>
		Parameters can be passed in via an object literal to a jsPlumb.connect call:
		<div class="code">
<pre>var myConnection = jsPlumb.connect({
	source:"foo",
	target:"bar",
	parameters:{
		"p1":34,
		"p2":new Date(),
		"p3":function() { console.log("i am p3"); }
	}
});
</pre>
</div>
Note that they can be any valid Javascript objects - it's just an object literal.  You then access them like this:
		<div class="code">
<pre>myConnection.getParameter("p3")();     // prints 'i am p3' to the console.
</pre>
</div>

<h4><a id="addEndpointParameters">jsPlumb.addEndpoint</a></h4>
<p>The information in this section also applies to the <strong>makeSource</strong> and <strong>makeTarget</strong> functions</p>
<p>Using jsPlumb.addEndpoint, you can set parameters that will be copied in to any Connections that are established from or to the given Endpoint using the mouse.  (If you set parameters on both a source and target Endpoints and then connect them, the parameters set on the target Endpoint are copied in first, followed by those on the source. So the source Endpoint's parameters take precedence if they happen to have one or more with the same keys as those in the target).</p>
Consider this example:
		<div class="code">
<pre>var e1 = jsPlumb.addEndpoint("d1", {
	isSource:true,
	parameters:{
		"p1":34,
		"p2":new Date(),
		"p3":function() { console.log("i am p3"); }
	}
});

var e2 = jsPlumb.addEndpoint("d2", {
	isTarget:true,
	parameters:{
		"p5":343,
		"p3":function() { console.log("FOO FOO FOO"); }
	}
});

var conn = jsPlumb.connect({source:e1, target:e2});


</pre>
</div>

'conn' will have four parameters set on it, with the value for "p3" coming from the source Endpoint:
		<div class="code">
<pre>var params = conn.getParameters();
console.log(params.p1);   	// 34
console.log(params.p2);   	// Mon May 14 2012 12:57:12 GMT+1000 (EST) (or however your console prints out a Date)
console.log((params.p3)()); // "i am p3"  (note: we executed the function after retrieving it)
console.log(params.p5);   	// 343

</pre>
</div>


</div> <!-- /section -->
	
	<div class="section">
		<h3><a id="beforeDrop">Interceptors</a></h3>
		<p>
		Interceptors were new in jsPlumb 1.3.4.  They are basically event handlers from which you can return a value that tells jsPlumb to abort what it is that
		it was doing.  There are currently two interceptors supported - <strong>beforeDrop</strong>, which is called when the user has dropped a Connection onto some target, 
		and <strong>beforeDetach</strong>, which is called when the user is attempting to detach a Connection. 
		</p>
		<p>Interceptors can be registered via the <strong>bind</strong> method on jsPlumb just like any other event listeners, and they can also be passed in to
		the <strong>jsPlumb.addEndpoint</strong>, <strong>jsPlumb.makeSource</strong> and <strong>jsPlumb.makeTarget</strong>
		methods.  A future version of jsPlumb will support registering interceptors on Endpoints using the <strong>bind</strong> method as you can now with the jsPlumb object.
		Note that binding 'beforeDrop' (as an example) on jsPlumb itself is like a catch-all: it will be called every time a Connection is dropped on _any_ 
		Endpoint.  But passing a 'beforeDrop' callback into an Endpoint (and in the future, registering one using 'bind') constrains that callback to just the
		Endpoint in question.  		
		<h4><a id="beforeDrop">beforeDrop</a></h4>
		This event is fired when a new or existing connection has been dropped. Your callback is passed a JS object with these fields:
		<ul>
			<li><strong>sourceId</strong> - the id of the source element in the connection</li>
			<li><strong>targetId</strong> - the id of the target element in the connection</li>
			<li><strong>scope</strong> - the scope of the connection</li>
			<li><strong>connection</strong> - the actual Connection object.  You can access the 'endpoints' array in a Connection to get the Endpoints involved in the Connection, but be aware that when a Connection is being dragged, one of these Endpoints will always be a transient Endpoint that exists only for the life of the drag. To get the Endpoint on which the Connection is being dropped, use the 'dropEndpoint' member.</li>
			<li><strong>dropEndpoint</strong> - this is the actual Endpoint on which the Connection is being dropped.  This <strong>may be null</strong>, because it will not be set if the Connection is being dropped on an element on which makeTarget has been called. </li>
		</ul>

		If you return false (or nothing) from this callback, the new Connection is aborted and removed from the UI.
		<h4><a id="beforeDetach">beforeDetach</a></h4>
		This is called when the user has detached a Connection, which can happen for a number of reasons: by default, jsPlumb allows users to drag Connections off of target Endpoints, but this can also result from a programmatic 'detach' call.  Every case is treated the same by jsPlumb, so in fact it is possible for you to write code that attempts to detach a Connection but then denies itself!  You might want to be careful with that. 
		<p>Note that this interceptor is passed the actual Connection object; this is different from the beforeDrop
		interceptor discussed above: in this case, we've already got a Connection, but with beforeDrop we are yet 
		to confirm that a Connection should be created.</p>
		<p>Returning false - or nothing - from this callback will cause the detach to be abandoned, and the Connection will be reinstated or left on its current target.</p>
			
	</div>

		<div class="section">
			<h3><a id="paintstyles">Paint Styles</a></h3>
			Defining the appearance of Connectors, Endpoints (and Overlays, but this is deprecated in favour of using CSS classes) is achieved through a 'paintStyle' (or a quite similar name)
			object passed as a parameter to one of jsPlumb.connect, jsPlumb.addEndpoint, jsPlumb.makeSource or jsPlumb.makeTarget. Depending on the method you are calling, the parameter names vary.
			<h5>Connector Paint Styles</h5>
			These are specified in a <em>paintStyle</em> parameter on a call to <strong>jsPlumb.connect</strong>:
			<div class="code">
<pre>
jsPlumb.connect({
  source:"el1",
  target:"el2",
  paintStyle:{ strokeStyle:"blue", lineWidth:10 }
});
</pre>			
			</div>
			or in the <em>connectorPaintStyle</em> parameter on a call to <strong>jsPlumb.addEndpoint</strong> or <strong>jsPlumb.makeSource</strong>:
			<div class="code">
<pre>
jsPlumb.addEndpoint("el1", {
  paintStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
  connectorPaintStyle:{ strokeStyle:"blue", lineWidth:10 }
});
</pre>			
			</div>
			<div class="code">
<pre>
jsPlumb.makeSource("el1", {
  paintStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
  connectorPaintStyle:{ strokeStyle:"blue", lineWidth:10 }
});
</pre>			
			</div> 			
			 

Notice the <em>paintStyle</em> parameter in those examples: it is the paint style for the Endpoint, which we'll discuss below.

			<h5>Endpoint Paint Styles</h5>
			These are specified in a <em>paintStyle</em> parameter on a call to <strong>addEndpoint</strong>. This is the example from just above:
<div class="code">
<pre>
jsPlumb.addEndpoint("el1", {
  paintStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
  connectorPaintStyle:{ strokeStyle:"blue", lineWidth:10 }
});
</pre>			
</div> 
			...or as the <em>endpointStyle</em> parameter to a <strong>connect</strong> call:		
			<div class="code">
<pre>
jsPlumb.connect({
  source:"el1",
  target:"el2",
  endpointStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
  paintStyle:{ strokeStyle:"blue", lineWidth:10 }
});
</pre>			
			</div>
			... or as an entry in the <em>endpointStyles</em> array passed to a <strong>jsPlumb.connect</strong> call:
					<div class="code">
<pre>
jsPlumb.connect({
  source:"el1",
  target:"el2",
  endpointStyles:[ 
    { fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
    { fillStyle:"green" }
  ],
  paintStyle:{ strokeStyle:"blue", lineWidth:10 }
});
</pre>			
			</div>
			or as the <em>paintStyle</em> parameter passed to a <strong>makeTarget</strong> or <strong>makeSource</strong> call:
<div class="code">
<pre>
jsPlumb.makeTarget("el1", {
  ...
  paintStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
  ...
});
</pre>			
</div>
<div class="code">
<pre>
jsPlumb.makeSource("el1", {
  paintStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 }
  parent:"someOtherDivIJustPutThisHereToRemindYouYouCanDoThis"
});
</pre>			
			</div>						
	In the first example we  made "el1" into a drop target, and defined a paint style for the Endpoint jsPlumb will create when a Connection is
	established.  In the second we made "el1" a connection source and assigned the same values for the Endpoint jsPlumb will create when a Connection
	is dragged from that element.
	
	<h5>Overlay Paint Styles</h5>
	The preferred way to set paint styles for Overlays is to use the <em>cssClass</em> parameter in the constructor arguments of an Overlay definition.
	
	<h4>Paint Style Parameters</h4>
	This is the full list of parameters you can set in a paintStyle object, but note that <strong>fillStyle</strong> is ignored by Connectors,
	and <strong>strokeStyle</strong> is ignored by Endpoints.  Also, if you create a Connection using jsPlumb.connect and do not specify any
	Endpoint styles, the Endpoints will derive their fillStyle from the Connector's strokeStyle.
	<p>
		fillStyle, strokeStyle and outlineColor can be specified using any valid CSS3 syntax.
	</p>
	<ul>
		<li><strong>fillStyle</strong> - color for an Endpoint, eg. rgba(100,100,100,50), "blue", "#456", "#993355", rgb(34, 56, 78).</li>
		<li><strong>strokeStyle</strong> - color for a Connector. see fillStyle examples.</li>
		<li><strong>lineWidth</strong> - width of a Connector's line. An integer.</li>
		<li><strong>outlineWidth</strong> - width of the outline for an Endpoint or Connector. An integer.</li>
		<li><strong>outlineColor</strong> - color of the outline for an Endpoint or Connector. see fillStyle examples.</li>
		<li><strong>dashstyle</strong> - VML and SVG only. This comes from VML, and allows you to create dashed or dotted lines.  It has a 
			better syntax than the equivalent attribute in SVG (<em>stroke-dasharray</em>, discussed below), so jsPlumb supports this for both renderers. 
			The <em>dashstyle</em> attribute is specified as an array of strokes and spaces, where each value is some multiple of <em>the width of 
			the Connector</em>, and that's where it's better than SVG, which uses pixels.
			<p>
			<a href="http://www.w3.org/TR/NOTE-VML" target="_blank">The VML spec</a> is a good place to find valid values for dashstyle. Note that
			jsPlumb does not support the string values for this attribute ("solid", "dashdot", etc).
			</p>
			<p>
			In SVG render mode, jsPlumb uses the <em>lineWidth</em> parameter in conjunction with the values in a <em>dashstyle</em> attribute
			to create an appropriate value for <em>stroke-dasharray</em>.
			</p>
		</li>
		<li><strong>stroke-dasharray</strong> - SVG only. This is the SVG equivalent of <em>dashstyle</em>.  
		<a href="http://www.w3.org/TR/SVG/painting.html" target="_blank">The SVG spec</a> discusses valid values for this parameter.  But be aware
		that jsPlumb does not convert this into a valid <em>dashstyle</em> attribute when using the VML renderer. Better to use <em>dashstyle</em>.
		</li>
		<li><strong>stroke-dashoffset</strong> - SVG only.  This is used in SVG to specify how far into the dash pattern to start painting.  For more information,
		see <a href="http://www.w3.org/TR/SVG/painting.html" target="_blank">the SVG spec.</a></li>
		<li><strong>joinstyle</strong> - VML and SVG only.  As with <em>dashstyle</em>, this is a VML attribute that jsPlumb supports for both VML
		and SVG - jsPlumb turns this into a <em>stroke-linejoin</em> attribute when rendering with SVG.  This attribute specifies how you want individual
		segments of connectors to be joined; the VML and SVG specs both have examples of this, of which many are the same between the two, which is
		why jsPlumb will automatically convert this attribute into the SVG equivalent.
		</li>
		<li><strong>stroke-linejoin</strong> - SVG only.  This is the equivalent of VML's <em>joinstyle</em> attribute, but as with <em>stroke-dasharray</em>,
		jsPlumb does not convert this into something approriate for VML.  So, using <em>joinstyle</em> will enable you to support more browsers with
		less effort.		
		</li>
	</ul>
	
	<h3><a id="hoverpaintstyles">Hover Paint Styles</a></h3>
	 		
	 		Connectors and Endpoints both support the concept of a "hover" paint style - a paint style to use when the mouse is hovering over
	 		the component.  These are specified in the exact same format as paint styles discussed above, but hover paint styles also inherit
	 		any values from the main paint style.  This is because you will typically want to just change the color, or perhaps outline color, of
	 		a Connector or Endpoint when the mouse is hovering, but leave everything else the same.  So having hover paint styles inherit their
	 		values precludes you from having to define things in more than one place.
	 		<p>
	 			The naming convention adopted for hover paint styles is pretty much to insert the word 'hover' into the corresponding main paint
	 			style parameters.  Here are a couple of examples:
	 		</p> 
<div class="code">
<pre>
jsPlumb.connect({
  source:"el1",
  target:"el2",
  paintStyle:{ strokeStyle:"blue", lineWidth:10 },
  hoverPaintStyle:{ strokeStyle:"red" },
  endpointStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
  endpointHoverStyle:{ fillStyle:"red" }
});
</pre>			
</div>
			In this example we specified a hover style for both the Connector, and each of its Endpoints.  Here's the same thing, but using the plural version, to specify a different hover style for each Endpoint:	
<div class="code">
<pre>
jsPlumb.connect({
  source:"el1",
  target:"el2",
  paintStyle:{ strokeStyle:"blue", lineWidth:10 },
  hoverPaintStyle:{ strokeStyle:"red" },
  endpointStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
  endpointHoverStyles:[ { fillStyle:"red" }, { fillStyle:"yellow" } ]
});
</pre>			
</div>
	 		Calls to <strong>addEndpoint</strong>, <strong>makeSource</strong> and <strong>makeTarget</strong> can also specify various hover paint styles:
	 								<div class="code">
<pre>
jsPlumb.addEndpoint("el1", {
  paintStyle:{ fillStyle:"blue", outlineColor:"black", outlineWidth:1 },
  hoverPaintStyle:{ fillStyle:"red" },
  connectorPaintStyle:{ strokeStyle:"blue", lineWidth:10 },
  connectorHoverPaintStyle:{ strokeStyle:"red", outlineColor:"yellow", outlineWidth:1 }
});

jsPlumb.makeSource("el2", {
  paintStyle:{ fillStyle:"transparent", outlineColor:"yellow", outlineWidth:1 },
  hoverPaintStyle:{ fillStyle:"red" },
  connectorPaintStyle:{ strokeStyle:"green", lineWidth:3 },
  connectorHoverPaintStyle:{ strokeStyle:"#678", outlineColor:"yellow", outlineWidth:1 }
});

jsPlumb.makeTarget("el3", {
  paintStyle:{ fillStyle:"transparent", outlineColor:"yellow", outlineWidth:1 },
  hoverPaintStyle:{ fillStyle:"red" }
});
</pre>			
			</div> 
	 		
	 		In these examples we specified a hover paint style for both the Endpoint we are adding, and any Connections to/from the Endpoint.
	 		<p>	
		Note that <strong>makeTarget</strong> does not support Connector parameters. It is for creating targets only; Connector parameters will be set by the source Endpoint in any Connections that are made to the element that you turned into a target by using this method.</p>
	 			 		
			<h4><a id="gradients">Gradients</a></h4>
			The Canvas and SVG renderers both support gradients. The VML renderer does not.  jsPlumb uses its own syntax to define gradients, to abstract out the differences between the syntax required by canvas and that required by SVG.  
			<p>There are two types of gradients available - a 'linear' gradient, which consists of colored lines all
			going in one direction, and a 'radial' gradient, which consists of colored circles emanating from one circle to another.
			Because of their basic shape, jsPlumb supports only <em>linear</em> gradients for
			Connectors.  But for Endpoints, jsPlumb supports both <em>linear</em> and <em>radial</em> gradients.</p>
			
				<h5>Connector gradients</h5>
				To specify a linear gradient to use in a Connector, you must add a <em>gradient</em> object to your
				Connector's <em>paintStyle</em>, for instance:
<div class="code">
<pre>jsPlumb.connect({
	source : "window2",
	target : "window3",
	paintStyle:{
		gradient:{
			stops:[[0,"green"], [1,"red"]]
		},
		lineWidth:15
	}
});
</pre>
</div>
Here we have connected window2 to window3 with a 15 pixel wide connector that has a gradient from green to red.</p><p> Notice the <strong>gradient</strong> object and the
<strong>stops</strong> list inside it - the gradient consists of an arbitrary number of these "color stops".  Each color stop is comprised
of two values - [position, color].  Position must be a decimal value between 0 and 1 (inclusive), and indicates where the color
stop is situated as a fraction of the length of the entire gradient.  Valid values for
the colors in the <strong>stops</strong> list are the same as those that are valid for <strong>strokeStyle</strong> when describing a color.
			</p>
			As mentioned, the <strong>stops</strong> list can hold an arbitrary number of entries.  Here's an example of a gradient that goes from red to blue to green, and back again through blue to red:
<div class="code">
<pre>jsPlumb.connect({
	source : 'window2',
	target : 'window3',
	paintStyle : {
		gradient:{
			stops:[[0,'red'], [0.33,'blue'], [0.66,'green'], [0.33,'blue'], [1,'red']]
		},
		lineWidth : 15
	}
});
</pre>
</div>
<strong>Note:</strong> when using the VML renderer, jsPlumb will simply ignore the gradient directive
so it is best to ensure you also supply a <em>strokeStyle</em> in your paintStyle object, to give jsPlumb something to fall back on.  If you do not supply
a <em>strokeStyle</em> your Connectors will be painted black.  The previous example might look like this, for instance:
<div class="code">
<pre>jsPlumb.connect({
	source : 'window2',
	target : 'window3',
	paintStyle:{
		strokeStyle:'red',
		gradient:{
			stops:[[0,'red'], [0.33,'blue'], [0.66,'green'], [0.33,'blue'], [1,'red']]
		},
		lineWidth:15
	}
});
</pre>
</div>
Notice the <strong>strokeStyle:'red'</strong> directive at the beginning of the parameter list in <strong>paintStyle</strong>.
			<h5>Endpoint gradients</h5>
			Endpoint gradients are specified using the same syntax as Connector gradients.  You put the gradient specifier either in the
			<strong>endpoint</strong> member, or if you are specifying different Endpoints for each end of the Connector, in one or both of
			the values in the <strong>endpoints</strong> array.  Also, this information applies to the case that you are creating standalone
			Endpoints that you will be configuring for drag and drop creation of new Connections. 
			<p>
			This is an example of an Endpoint gradient that is different for each Endpoint in the Connector.  This comes from the main demo; it is
			the Connector joining Window 2 to Window 3:
			</p>
<div class="code">
<pre>var w23Stroke = 'rgb(189,11,11)';
jsPlumb.connect({
	source : 'window2',
	target : 'window3',
	paintStyle:{
		lineWidth:8,
		strokeStyle:w23Stroke
	},
 	anchors:[ [0.3,1,0,1], "TopCenter" ],
 	endpoint:"Rectangle",
 	endpointStyles:[
 		{ gradient : {stops:[[0, w23Stroke], [1, '#558822']] } },
    	{ gradient : {stops:[[0, w23Stroke], [1, '#882255']] } }
    ]
});
</pre>
</div>
The first entry in the gradient will be the one that is on the Connector end of the Endpoint.  You can of course have as many color stops as
you want in this gradient, just like with Connector gradients.
	<h5>Applying the gradient in Endpoints</h5>
	Only the Dot and Rectangle endpoints honour the presence of a gradient (and, remember, not in VML). The Image endpoint of course ignores a gradient
	as it does no painting of its own.
	<p>The type of gradient you will see depends on the Endpoint type:</p>
		<ul>
			<li><strong>Dot</strong> - renders a radial endpoint, with color stop 0 on the outside, progressing inwards as we move through color stops.
			<p>Radial gradients actually require more data than linear gradients - in a linear gradient we just move from one point to another, whereas
			in a radial gradient we move from one <em>circle</em> to another.  By default, jsPlumb will render a radial gradient using a source
			circle of the same radius as the Endpoint itself, and a target circle of 1/3 of the radius of the Endpoint (both circles share the
			same center as the Endpoint itself). This circle will be offset by radius/2 in each direction.</p>
			<p>You can supply your own values for these inside the gradient descriptor:</p>
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
jsPlumb.connect({
	source : 'window3',
	target : 'window4',
    paintStyle:{
    	lineWidth:10,
    	strokeStyle:w34Stroke
    },
    anchors:[ "RightMiddle", "LeftMiddle" ],
    endpointStyle:{
    	gradient : {
    		stops:[ [0, w34Stroke], [1, w34HlStroke] ],
    		offset:37.5,
    		innerRadius:40
    	},
    	radius:55
    }
 });
</pre>
</div>
Here we have instructed jsPlumb to make the gradient's inner radius 10px instead of the default 25/3 = 8 ish pixels, and the offset in each direction
will be 5px, instead of the default radius / 2 = 12.5 pixels.
<p>It is also possible to specify the offset and inner radius as percentages - enter the values as strings with a '%' symbol on the end:</p>
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
jsPlumb.connect({
	source : 'window3', 
	target : 'window4',
    paintStyle:{
    	lineWidth:10,
    	strokeStyle:w34Stroke
    },
	anchors:[ "RightMiddle", "LeftMiddle" ],
	endpointStyle:{
		gradient : {
			stops:[ [0, w34Stroke], [1, w34HlStroke] ],
			offset:'68%',
			innerRadius:'73%'
		},
		radius:25
	}
});
</pre>
</div>
This will give roughly the same output as the example above (the percentages are not entirely exact).<br/><br/>
			</li>
			<li><strong>Rectangle</strong> - renders a linear endpoint, with color stop 0 closest to the end of the Connector</li>
		</ul>
		
<h4><a id="svgvmlcss">Styling SVG/VML using CSS</a></h4>
	A nice way of controlling your UI's appearance is to make use of the fact that both SVG and VML can be styled using CSS.
	<p>This section will be expanded in the next few weeks to give some decent examples of how to do so</p>
			
		
		
		</div>

		<div class="section">
			<h3><a id="cssclasses">CSS Class Reference</a></h3>
			jsPlumb attaches classes to each of the UI components it creates.
			<p>These class names are exposed on the jsPlumb object and can be overridden if you need to do so (see the third column in the table) </p>
			<table width="70%" class="table">
				<tr><th>Component</th><th>CSS Class</th><th>jsPlumb Member</th></tr>
				<tr><td>Connector</td><td>_jsPlumb_connector</td><td>connectorClass</td></tr>
				<tr><td>Endpoint</td><td>_jsPlumb_endpoint</td><td>endpointClass</td></tr>
				<tr><td>Overlay</td><td>_jsPlumb_overlay</td><td>overlayClass</td></tr>
			</table>
			<p>You would typically use these to establish appropriate z-indices for your UI.</p>			
		</div>
				
		<div class="section">
			<h3><a id="animation">Animation</a></h3>
			jsPlumb offers an 'animate' function, which wraps the underlying animation engine for whichever library you happen to be using and
			inserts a callback for jsPlumb to repaint whatever it needs to at each step.  You could of course do this yourself; it's a convenience
			method really.
			<p>The method signature is:</p>
<div class="code">
<pre>
jsPlumb.animate : function(el, properties, options) 
</pre>
</div>			
The arguments are as follows:
	<ul>
		<li><strong>el</strong> - element id, or element object from the library you're using.</li>
		<li><strong>properties</strong> - properties for the animation, such as duration etc.</li>
		<li><strong>options</strong> - options for the animation, such as callbacks etc.</li>
	</ul>
	
		<h4>jQuery and the 'revert' option</h4>
		jQuery offers a 'revert' option that you can use to instruct it to revert a drag under some condition. This is
		rendered in the UI as an animation that returns the drag object from its current location to wherever it started
		out.  It's a nice feature.  Unfortunately, the animation that runs the revert does not offer any lifecycle
		callback methods - no 'step', no 'complete' - so its not possible for jsPlumb to know that the revert 
		animation is taking place.
	
		</div>
		
			<div class="section">
			<h3><a id="connectionInfo">Retrieving Connection Information</a></h3>
			There are two ways of retrieving connection information from jsPlumb. <strong>getConnections</strong>is the original method; from 1.4.0 onwards this method is supplemented by <a href="#selectConnections">jsPlumb.select</a>, a much more versatile variant.
			<h5>getConnections</h5>
			<p>Before you use this method you should understand jsPlumb's notion of 'scope' - documentation
			is <a href="#dragAndDropScope">here</a> </p>
			
			<h4>Retrieving connections for a single scope</h4>
			<p>To do this, you call getConnections with either no arguments, in which case jsPlumb uses the default scope, or with a string
			specifying one scope</p>
			<div class="code">
<pre>var connectionList = jsPlumb.getConnections();     // you get a list of Connection objects that are in the default scope.
</pre>			
			</div>
			Compare this with:
			<div class="code">
<pre>var connectionList = jsPlumb.getConnections("myScope");     // you get a list of Connection objects that are in "myScope".
</pre>			
			</div>
			<h4>More advanced filtering</h4>
			getConnections optionally takes a JS object specifying filter parameters, of which there are three:
			<ul>
				<li>scope - the scope(s) of the connection type(s) you wish to retrieve</li>
				<li>source - limits the returned connections to those that have this source id</li>
				<li>target - limits the returned connections to those that have this target id</li>
			</ul>			
			Each of these three parameters may be supplied as a string, which for source and target is an element id and for scope is the name of the scope, or a list of strings.  Also from 1.4.0 you can pass "*" in as the value for any of these - a wildcard, meaning any value.  See the examples below.
			<p>
			The return value of a call to getConnection using a JS object as parameter varies on how many scopes you defined.  If you defined only a single scope then jsPlumb returns you a list of Connections in that scope.  Otherwise the return value is a dictionary whose keys are  scope names, and whose values are lists of Connections. For example, the following call:
			</p>
			<div class="code">
<pre>
	jsPlumb.getConnections({scope:["someScope", "someCustomScope"]});
</pre>
</div>
would result in this output:			
<div class="code">
<pre>
{
	"someScope" : [ 1..n Connections ],
	"someCustomScope": [ 1..m Connections ]
}
</pre>
</div>	

There is an optional second parameter that tells getConnections to flatten its output and just return you an array.  The previous example with this parameter would look like this:
			<div class="code">
<pre>
	jsPlumb.getConnections({scope:["someScope", "someCustomScope"]}, true);
</pre>
</div>
would result in this output:			
<div class="code">
<pre>
[ 1..n Connections ]
</pre>
</div>	
		
		The following examples show the various ways you can get connection information:
	<ul>
		<li>Get all connections:
			<div class="code">
<pre>
var c = jsPlumb.getAllConnections();  
</pre>
</div>						
		</li>
<li>Get all connections for the default scope only (return value is a list):
			<div class="code">
<pre>
var c = jsPlumb.getConnections();  
</pre>
</div>						
		</li>
		<li>Get all connections for the given scope (return value is a list):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({scope:"myTestScope"});  
</pre>
</div>						
		</li>
		<li>Get all connections for the given scopes (return value is a map of scope names to connection lists):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({scope:["myTestScope", "yourTestScope"]});  
</pre>
</div>						
		</li>
		<li>Get all connections for the given source (return value is a map of scope names to connection lists):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({source:"mySourceElement"});  
</pre>
</div>						
		</li>
		<li>Get all connections for the given sources (return value is a map of scope names to connection lists):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({source:["mySourceElement", "yourSourceElement"]});  
</pre>
</div>						
		</li>		
<li>Get all connections for the given target (return value is a map of scope names to connection lists):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({target:"myTargetElement"});  
</pre>
</div>						
		</li>				
<li>Get all connections for the given source and targets (return value is a map of scope names to connection lists):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({source:"mySourceElement", target:["target1", "target2"]});  
</pre>
</div>						
		</li>				
		
<li>Get all connections for the given scope, with the given source and target (return value is a list of connections):
			<div class="code">
<pre>
var c = jsPlumb.getConnections({scope:'myScope", source:"mySourceElement", target:"myTargetElement"});  
</pre>
</div>						
		</li>				
		
	</ul>	

		</div>

		<div class="section">
			<h3><a id="selectConnections">Selecting Connections</a></h3>
			Introduced in 1.4.0, <strong>jsPlumb.select</strong> provides a fluid interface for working with lists of Connections.  The syntax used to specify which Connections you want is identical to that which you use for getConnections, but the return value is an object that supports most operations that you can perform on a Connection, and which is also chainable, for setter methods. Certain getter methods are also supported, but these are not chainable; they return an array consisting of all the Connections in the selection along with the return value for that Connection.
			<p>
			This is the full list of setter operations supported by jsPlumb.select:
			<ul>
				<li class="bullet">addOverlay</li>
				<li class="bullet">removeOverlay</li>
				<li class="bullet">removeOverlays</li>
				<li class="bullet">showOverlay</li>
				<li class="bullet">hideOverlay</li>
				<li class="bullet">showOverlays</li>
				<li class="bullet">hideOverlays</li>
				<li class="bullet">removeAllOverlays</li>
				<li class="bullet">setLabel</li>
				<li class="bullet">setPaintStyle</li>
				<li class="bullet">setHoverPaintStyle</li>
				<li class="bullet">setDetachable</li>
				<li class="bullet">setConnector</li>
				<li class="bullet">setParameter</li>
				<li class="bullet">setParameters</li>
				<li class="bullet">detach</li>
			</ul>

			Each of these operations returns a selector that can be chained.
			</p>
			These is the full list of getter operations supported by jsPlumb.select:
			<p>
				<ul>
				<li class="bullet">getLabel</li>
				<li class="bullet">getOverlay</li>
				<li class="bullet">isHover</li>
				<li class="bullet">isDetachable</li>
				<li class="bullet">getParameter</li>
				<li class="bullet">getParameters</li>
			</ul>

			Each of these operations returns an array whose entries are [ value, Connection ] arrays, where 'value' is the return value from the given Connection.  Remember that the return values from a getter are not chainable, but a getter may be called at the end of a chain of setters.
			</p>

			<p>Some examples:</p>
			Select all Connections and set their hover state to be false:

<div class="code">
<pre>
jsPlumb.select().setHover(false);
</pre>
</div>
			Select all Connections from "d1" and remove all Overlays:

<div class="code">
<pre>
jsPlumb.select({source:"d1"}).removeAllOverlays();
</pre>
</div>

Select all connections in scope "foo" and set their paint style to be a thick blue line:
<div class="code">
<pre>
jsPlumb.select({scope:"foo"}).setPaintStyle({ strokeStyle:"blue", lineWidth:5 });
</pre>
</div>
Select all Connections from "d1" and detach them:
<div class="code">
<pre>
jsPlumb.select({source:"d1"}).detach();
</pre>
</div>
<h5>.each iterator</h5>
The return value of jsPlumb.select has a <strong>.each</strong> function that allows you to iterate through the list, performing an operation on each one:
<div class="code">
<pre>
jsPlumb.select({scope:"foo"}).each(function(connection) {
	
		// do something 
});
</pre>
</div>
.each is itself chainable:
<div class="code">
<pre>
jsPlumb.select({scope:"foo"}).each(function(connection) {
	
		// do something 

}).setHover(true);
</pre>
</div>


<h5>Other properties/functions</h5>
<ul>
	<li class="bullet"><strong>length</strong> - this member reports the number of Connections in the selection</li>
	<li class="bullet"><strong>get(idx)</strong> - this function allows you to retrieve a Connection from the selection</li>
</ul>


		</div>
		
		<div class="section">
			<h3><a id="events">Events</a></h3>
			jsPlumb supports binding to several different events on Connections, Endpoints and Overlays, and also on the jsPlumb object itself.  
			
			<h4><a id="jsPlumbEvents">jsPlumb Events</a></h4>
			<p>To bind an event to jsPlumb itself, use <strong>jsPlumb.bind(event, callback)</strong>:</p>
			<div class="code">
<pre>
jsPlumb.bind("jsPlumbConnection", function(info) {
   .. update your model in here, maybe.
});
</pre>
</div>
<p>These are the events you can bind to on the jsPlumb class:</p>
			<ul>
				<li class="bullet"><strong>jsPlumbConnection</strong> - notification a Connection was established.
					<p>
						The first argument to the callback is an object with the following properties:					
					</p>
					<div class="code">
<pre>
{
  connection 		: 	the new Connection.  you can register listeners on this etc.
  sourceId 		:	id of the source element in the Connection
  targetId		:	id of the target element in the Connection
  source		:	the source element in the Connection
  target		:	the target element in the Connection
  sourceEndpoint	:	the source Endpoint in the Connection
  targetEndpoint	:	the targetEndpoint in the Connection
}
</pre>
					</div>
The second argument is the original mouse event that caused the Connection, if any.

					<p>
All of the source/target properties are actually available inside the Connection object, but - for one of those rubbish historical reasons - are provided separately because of a vagary of the <em>jsPlumbConnectionDetached</em> callback, which is discussed below.
</p>
				</li>
				<li class="bullet"><strong>jsPlumbConnectionDetached</strong> - notification a Connection was detached.  
					<p>
						As with <em>jsPlumbConnection</em>, the first argument to the callback is an object with the following properties:					
					</p>
					<div class="code">
<pre>
{
  connection		: 	the Connection that was detached.  
  sourceId		:	id of the source element in the Connection <em>before it was detached</em>
  targetId		:	id of the target element in the Connection before it was detached
  source		:	the source element in the Connection before it was detached
  target		:	the target element in the Connection before it was detached
  sourceEndpoint	:	the source Endpoint in the Connection before it was detached
  targetEndpoint	:	the targetEndpoint in the Connection before it was detached
}
</pre>

					</div>	
The second argument is the original mouse event that caused the disconnection, if any. 					
								
					<p>
As mentioned above, the source/target properties are provided separately from the Connection, because this event is fired whenever
a Connection is either detached and abandoned, or detached from some Endpoint and attached to another.  In the latter case, the
Connection that is passed to this callback is in an indeterminate state (that is, the Endpoints are still in the state they are
in when dragging, and do not reflect static reality), and so the source/target properties give you the real story.
</p>
<p> Like I said above, this is really just for rubbish historical reasons.  I'm attempting to document my way out of it!</p>
				
				</li>

				<li class="bullet"><strong>connectionDrag</strong> - notification an existing Connection is being dragged. The callback is passed the Connection.
				</li> 

				<li class="bullet"><strong>connectionDragStop</strong> - notification a Connection drag has stopped. This is only fired for existing Connections. The callback is passed the Connection that was just dragged.
				</li> 

				<li class="bullet"><strong>click</strong> - notification a Connection was clicked.  The callback is passed the Connection and the original mouse event.</li>
				<li class="bullet"><strong>dblclick</strong> - notification a Connection was double-clicked.  The callback is passed the Connection and the original mouse event.</li>
				<li class="bullet"><strong>endpointClick</strong> - notification an Endpoint was clicked.  The callback is passed the Endpoint and the original mouse event.</li>
				<li class="bullet"><strong>endpointDblClick</strong> - notification an Endpoint was double-clicked.  The callback is passed the Endpoint and the original mouse event.</li>
				<li class="bullet"><strong>contextmenu</strong> - a right-click on some given component.  jsPlumb will report right clicks on both Connections and Endpoints; the callback is passed the component that received the right-click.				
				<li class="bullet"><strong>beforeDrop</strong>
					This event is fired when a new or existing connection has been dropped. Your callback is passed a JS object with these fields:
					<ul>
						<li><strong>sourceId</strong> - the id of the source element in the connection</li>
						<li><strong>targetId</strong> - the id of the target element in the connection</li>
						<li><strong>scope</strong> - the scope of the connection</li>
						<li><strong>connection</strong> - the actual Connection object.  You can access the 'endpoints' array in a Connection to get the Endpoints involved in the Connection, but be aware that when a Connection is being dragged, one of these Endpoints will always be a transient Endpoint that exists only for the life of the drag. To get the Endpoint on which the Connection is being dropped, use the 'dropEndpoint' member.</li>
						<li><strong>dropEndpoint</strong> - this is the actual Endpoint on which the Connection is being dropped.  This <strong>may be null</strong>, because it will not be set if the Connection is being dropped on an element on which makeTarget has been called. </li>
					</ul>

					If you return false (or nothing) from this callback, the new Connection is aborted and removed from the UI.
				</li>					
				<!--li class="bullet"><strong>beforeDrag</strong>
					This event is fired when a new connection is about to be dragged.  Your callback function
					is passed the Connection that jsPlumb has just created.  If you return false (or nothing) 
					from this callback, the new Connection is aborted.
				</li-->
				<li class="bullet"><strong>beforeDetach</strong>
					This event is fired when a Connection is about to be detached, for whatever reason. Your callback function is passed the Connection that the user has just detached. Returning false from this interceptor aborts the Connection detach.
				</li>
							
			</ul>
			<h4><a id="connectionEvents">Connection Events</a></h4>		
			<p>To bind to an event on a Connection, you also use the <strong>bind</strong> method:</p>
			<div class="code">
<pre>
var connection = jsPlumb.connect({source:"d1", target:"d2"});
connection.bind("click", function(conn) {
	console.log("you clicked on ", conn);
});
</pre>
</div>
<p>These are the Connection events to which you can bind a listener:</p>
			<ul>
				<li class="bullet"><strong>click</strong> - notification a Connection was clicked.  The callback is passed the Connection and the original mouse event.</li>
				<li class="bullet"><strong>dblclick</strong> - notification a Connection was double-clicked.  The callback is passed the Connection and the original mouse event.</li>
				<li class="bullet"><strong>contextmenu</strong> - a right-click on the Connection. The callback is passed the Connection and the original event.
				<li class="bullet"><strong>mouseenter</strong> - notification the mouse entered the Connection's path.  The callback is passed the Connection and the original mouse event.</li>
				<li class="bullet"><strong>mouseexit</strong> - notification the mouse exited the Connection's.  The callback is passed the Connection and the original mouse event.</li>
			</ul>
			<h4><a id="endpointEvents">Endpoint Events</a></h4>			
			<p>To bind to an event on a Endpoint, you again use the <strong>bind</strong> method:</p>
			<div class="code">
<pre>
var endpoint = jsPlumb.addEndpoint("d1", { someOptions } );
endpoint.bind("click", function(endpoint) {
	console.log("you clicked on ", endpoint);
});
</pre>
</div>
<p>These are the Endpoint events to which you can bind a listener:</p>
			<ul>
				<li class="bullet"><strong>click</strong> - notification an Endpoint was clicked.  The callback is passed the Endpoint and the original mouse event.</li>
				<li class="bullet"><strong>dblclick</strong> - notification an Endpoint was double-clicked.  The callback is passed the Endpoint and the original mouse event.</li>
				<li class="bullet"><strong>contextmenu</strong> - a right-click on the Endpoint. The callback is passed the Endpoint and the original event.
				<li class="bullet"><strong>mouseenter</strong> - notification the mouse entered the Endpoint.  The callback is passed the Endpoint and the original mouse event.</li>
				<li class="bullet"><strong>mouseexit</strong> - notification the mouse exited the Endpoint.  The callback is passed the Endpoint and the original mouse event.</li>
			</ul>
			<h4><a id="overlayEvents">Overlay Events</a></h4>
			Registering event listeners on an Overlay is a slightly different procedure - you provide them as arguments to the Overlay's 
			constructor.  This is because you never actually act on an 'Overlay' object.  Here's how to register a click listener on an Overlay:
			<div class="code">
<pre>jsPlumb.connect({
  source:"el1",
  target:"el2",
  overlays:[
    [ "Label", {
      events:{
        click:function(labelOverlay, originalEvent) { 
          console.log("click on label overlay for :" + labelOverlay.component); 
        }
      }
    }],
    [ "Diamond", {
      events:{
        dblclick:function(diamondOverlay, originalEvent) { 
          console.log("double click on diamond overlay for : " + diamondOverlay.component); 
        }
      }
    }] 	
  ]
});
</pre>			
			</div>		
		Note that events registered on Diamond, Arrow or PlainArrow overlays will not fire with the Canvas renderer - they work only with the SVG and VML renderers. 
		</div>

				<div class="section">
			<a id="examples"><h3>jsPlumb.connect Examples</h3></a>
This section provides examples of how to use the programmatic API to establish Connections. 
			<p>
			The basic syntax of a call is that you execute 'connect', providing a source and a target, and optionally a paintStyle and preferences for where you
			want the plumbing to be anchored on each element, as well as the type of connector to use. 
			</p>
			<ul>
				<li>Connect window1 to window2 with the default settings:
					<div class="code">
						<pre>jsPlumb.connect({source:"window1", target:"window2"});</pre>
					</div>
This connects 'window1' to 'window2' using the jsPlumb defaults - a red Bezier curve Connector and black Dot Endpoints.
				</li>
				<li>Connect window1 to window2 with a 15 pixel wide yellow Connector, and a slightly brighter endpoint (remember the default Endpoint is a Dot):
					<div class="code">
<pre>jsPlumb.connect({
	source:'window1',
	target:'window2',
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'},
	endpointStyle:{fillStyle:'rgb(243,229,0)'}
});</pre>
					</div>
				</li>
				
				<li>Connect window1 to window2 with a 15 pixel wide yellow Connector, and a slightly brighter endpoint:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window1',
	target:'window2',
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'},
	endpointStyle:{fillStyle:'rgb(243,229,0)'}
});</pre>
					</div>
				</li>				
				<li>Connect window3 to 'window4' with a 10 pixel wide, semi opaque blue Connector, anchored to the left middle of window3, and the right middle of window4, with a Rectangle endpoint of width 10 and height 8:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window3',
	target:'window4',
	paintStyle:{ lineWidth:10, strokeStyle:'rgba(0, 0, 200, 0.5)' },
	anchors:["RightMiddle", "LeftMiddle"],
	endpoint:[ "Rectangle", { width:10, height:8 } ]
});</pre>
					</div>
				</li>
				<li>Connect window2 to window3 with a default Connector from the top center of window2 to the bottom center of window3, and rectangular endpoints:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window2',
	target:'window3',
	paintStyle:{lineWidth:8, strokeStyle:'rgb(189,11,11)'},
	anchors:["BottomCenter", "TopCenter"],
	endpoint:"Rectangle"
});</pre>
					</div>
				</li>


				<li>Connect window1 to window2 with a 15 px wide yellow Bezier. endpoints are a slightly lighter shade of yellow.
<div class="code">
<pre>jsPlumb.connect({
	source:'window1',
	target:'window2',
	anchors:["BottomCenter", [0.75,0,0,-1]],
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'},
	endpointStyle:{fillStyle:'rgb(243,229,0)'}
});</pre>
</div></li>
<li>Connect window3 to window4 with a 10px wide blue-ish half transparent Bezier. put endpoints underneath the element they attach to.
the endpoints have a radial gradient. both ways of specifying gradient positioning are shown here.
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
jsPlumb.connect( {
	source:'window3',
	target:'window4',
		 paintStyle:{lineWidth:10, strokeStyle:w34Stroke},
		 anchors:["RightMiddle", "LeftMiddle"],
		 endpointStyle:{ gradient : {stops:[[0, w34Stroke], [1, w34HlStroke]], offset:17.5, innerRadius:15 }, radius:35},
		 //endpointStyle:{ gradient : {stops:[[0, w34Stroke], [1, w34HlStroke]], offset:'78%', innerRadius:'73%'}, radius:35 },
		 endpointsOnTop:false
	}
);</pre>
</div></li>
<li>Connect window2 to window3 with an 8px red Bezier and default rectangular endpoints.  see also how the first anchor is
specified here - this is how you create anchors in locations jsPlumb does not offer shortcuts for.
the endpoints in this example have linear gradients applied.
<div class="code">
<pre>var w23Stroke = 'rgb(189,11,11)';
jsPlumb.connect({
	source:'window2',
	target:'window3',
	paintStyle:{lineWidth:8,strokeStyle:w23Stroke},
	anchors:[[0.3,1,0,1], "TopCenter"],
	endpoint:"Rectangle",
	endpointStyles:[{ gradient : {stops:[[0, w23Stroke], [1, '#558822']] }},
       				{ gradient : {stops:[[0, w23Stroke], [1, '#882255']] }}]
});</pre>
</div></li>

<li>Connect window5 to window6 from center to center, 5px wide line that is green and half transparent. the endpoints are
125px in radius and spill out from underneath their elements.
<div class="code">
<pre>jsPlumb.connect({
	source:'window5',
	target:'window6',
	anchors:["Center", "Center"],
	paintStyle:{lineWidth:5,strokeStyle:'rgba(0,255,0,0.5)'},
	endpointStyle:{radius:125}
});</pre>
</div></li>

<li>Connect window4 to window5 from bottom right to top left, with a 7px straight line purple connector, and an image as the endpoint,
placed on top of the element it is connected to.
<div class="code">
<pre>jsPlumb.connect({
	source:"window4",
	target:"window5",
	anchors:[ "BottomRight","TopLeft" ],
	paintStyle:{ lineWidth:7, strokeStyle:"rgb(131,8,135)" },
	endpoint:[ "Image", { src:"http://morrisonpitt.com/jsPlumb/img/endpointTest1.png" } ],
	connector:"Straight"
});</pre>
</div></li>


				<li>Connect window5 to window6 between their center points with a semi-opaque connector, and 125px endpoints:
					<div class="code">
<pre>jsPlumb.connect({
	source:"window5",
	target:"window6",
	anchors:[ "Center", "Center" ],
	paintStyle:{ lineWidth:5, strokeStyle:"rgba(0,255,0,0.5)" },
	endpointStyle:{ radius:125 }
});</pre>
					</div>
				</li>
				<li>Connect window7 to window8 with a 10 pixel wide blue Connector, anchored on the top left of window7 and the bottom right of window8:
					<div class="code">
<pre>jsPlumb.connect({
	source:"window7",
	target:"window8",
	paintStyle:{ lineWidth:10, strokeStyle:"blue" },
	anchors:[ "TopLeft", "BottomRight" ]
});
</pre>
					</div>
				</li>
				<li>Connect the bottom right corner of window4 to the top left corner of window5, with rectangular endpoints of size 40x40 and a hover color of light blue:
					<div class="code">
<pre>jsPlumb.connect({
	source:"window4",
	target:"window5",
	anchors:["BottomRight","TopLeft"],
	paintStyle:{lineWidth:7,strokeStyle:'rgb(131,8,135)'},
	hoverPaintStyle:{ strokeStyle:"rgb(0, 0, 135)" },
	endpointStyle:{ width:40, height:40 },
	endpoint:"Rectangle",
	connector:"Straight"
});</pre>
					</div>
				</li>
				<li>Connect window1 to window2 with the default paint settings but provide some drag options (which are passed through to the underlying library's draggable call):
					<div class="code">
						<pre>jsPlumb.connect({source:'window1', target:'window2', dragOptions:{cursor:'crosshair'}});</pre>
					</div>
				</li>
</div>
		
		<div class="section">
			<a id="dragAndDropExamples"><h3>Draggable Connections Examples</h3></a>
			This is a list of examples of how to use jsPlumb to create Connections using drag and drop.
			<p>
			The basic procedure is:
			<ol>
				<li>1a. Create Endpoints and register them on elements in your UI</li>
				<li>1b. alternatively, create a source endpoint and then make some element a drop target </li>
				<li>2. Drag and Drop</li>
			</ol>
			That's all there is to it.  Of course there are plenty of options you can set when doing this...it will be easier
			to show you some examples:
			</p>
			<ul>
				<li>Define an Endpoint with default appearance, that is both a source and target of new Connections:
<div class="code">
<pre>var endpointOptions = { isSource:true, isTarget:true }; 
</pre>
</div>				 				
				</li>
				
				<li>Register that Endpoint on window3, specifying that it should be located in the top center of the element:
<div class="code">
<pre>var window3Endpoint = jsPlumb.addEndpoint('window3', { anchor:"TopCenter" }, endpointOptions );  
</pre>
</div>
Notice here the usage of the three-argument addEndpoint  - we can reuse 'endpointOptions' with a different Anchor for another element.  This is a useful
practice to get into.<br/><br/>
				</li>
				
				<li>Now register that Endpoint on window4, specifying that it should be located in the bottom center of the element:
<div class="code">
<pre>var window4Endpoint = jsPlumb.addEndpoint('window4', { anchor:"BottomCenter" }, endpointOptions );  
</pre>
</div>
Now we have two Endpoints, both of which support drag and drop of new Connections.  We can use these to make a programmatic Connection, too, though:<br/><br/>
				</li>				
				
				<li>Connect window3 to window4 with a 25px wide yellow Bezier that has a 'curviness' of 175:
<div class="code">
<pre>jsPlumb.connect({ 
	source:window3Endpoint,
	target:window4Endpoint,
	connector: [ "Bezier", 175 ],
	paintStyle:{ lineWidth:25, strokeStyle:'yellow' }
});  
</pre>
</div>
				</li>
				
				<li>Define an Endpoint that creates Connections that are 20px wide straight lines, that is both a source and target of new Connections,
				and that has a 'scope' of 'blueline'. Also, this Endpoint mandates that once it is full, Connections can
				no longer be dragged from it (even if 'reattach' is specified on a Connection):
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dragAllowedWhenFull:false	 
}; 
</pre>
</div>				 				
				</li>
				
				<li>Define an Endpoint that will be anchored to "TopCenter".  It creates Connections that are 20px wide straight lines, that is both a source and target of new Connections,
				and that has a 'scope' of 'blueline'. Also, this Endpoint mandates that once it is full, Connections can
				no longer be dragged from it (even if 'reattach' is specified on a Connection):
<div class="code">
<pre>var endpointOptions = {
	anchor:"TopCenter", 
	isSource:true, 
	isTarget:true,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dragAllowedWhenFull:false	 
}; 
</pre>
</div>				 				
				</li>
				
				<li>Define an Endpoint that will create a dynamic anchor which can be positioned at "TopCenter" or "BottomCenter".  It creates Connections that are 20px wide straight lines, it is both a source and target of new Connections,
				and it has a 'scope' of 'blueline'. Also, this Endpoint mandates that once it is full, Connections can
				no longer be dragged from it (even if 'reattach' is specified on a Connection):
<div class="code">
<pre>var endpointOptions = {
	anchor:[ "TopCenter", "BottomCenter" ], 
	isSource:true, 
	isTarget:true,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dragAllowedWhenFull:false	 
}; 
</pre>
</div>				 				
				</li>
				
				<li>Exactly the same as before, but shows how you can use "anchors" instead of "anchor", if that makes you feel happier:
<div class="code">
<pre>var endpointOptions = {
	anchors:[ "TopCenter", "BottomCenter" ], 
	isSource:true, 
	isTarget:true,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dragAllowedWhenFull:false	 
}; 
</pre>
</div>				 				
				</li>								
				
<li>Define an Endpoint that is a 30px blue dot, creates Connections that are 20px wide straight lines, is both a source and target of new Connections,
				has a 'scope' of 'blueline', and has an event handler that pops up an alert (note: the event handler name means this example is jQuery - MooTools
				and YUI3 use different event handler names):
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	endpoint: [ "Dot", { radius:30 } ],
	style:{fillStyle:'blue'},
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dropOptions:{ drop:function(e, ui) { alert('drop!'); } }	 
}; 
</pre>
</div>				 				
				</li>
				
			<li>Same example as before, but this is for MooTools, and the Endpoint can support up to 5 connections (the default is 1):
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	endpoint: [ "Dot", { radius:30 } ],
	style:{ fillStyle:'blue' },
	maxConnections:5,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dropOptions:{ onDrop:function(e, ui) { alert('drop!'); } }	 
}; 
</pre>
</div>				 				
				</li>
				
				<li>Same example again, but maxConnections being set to -1 means that the Endpoint has no maximum limit of Connections:
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	endpoint: [ "Dot", {radius:30} ],
	style:{ fillStyle:'blue' },
	maxConnections:-1,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dropOptions:{ onDrop:function(e, ui) { alert('drop!'); } }	 
}; 
</pre>
</div>				 				
				</li>
				
				<li>Same example again, but for YUI3.  Note the drop callback is "drop:hit":
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	endpoint: [ "Dot", { radius:30 } ],
	style:{fillStyle:'blue'},
	maxConnections:-1,
	connector : "Straight",
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dropOptions:{ "drop:hit":function(e, ui) { alert('drop!'); } }	 	
}; 
</pre>
</div>				 				
				</li>				
				
	<li>Assign a UUID to the endpoint options created above, and add as Endpoints to "window1" and "window2":
<div class="code">
<pre>
jsPlumb.addEndpoint("window1", { uuid:"abcdefg" }, endpointOptions );
jsPlumb.addEndpoint("window2", { uuid:"hijklmn" }, endpointOptions );
</pre>
</div>	
	</li>
	
	<li>Connect the two Endpoints we just registered on "window1" and "window2":
<div class="code">
<pre>
jsPlumb.connect({uuids:["abcdefg", "hijklmn"]});
</pre>
</div>	
	</li>
	
	<li>Create a source Endpoint, register it on some element, then make some other element a Connection target:
<div class="code">
<pre>
var sourceEndpoint = { isSource:true, endpoint:[ "Dot", { radius:50 } ] };
var targetEndpoint = { endpoint:[ "Rectangle", { width:10, height:10 } ] };
jsPlumb.addEndpoint( "window1", sourceEndpoint );
jsPlumb.makeTarget( "window2", targetEndpoint );
</pre>
</div>	
Notice that the endpoint definition we use on the target window does not include the "isTarget:true" directive.  jsPlumb ignores that flag when
creating a connection using an element as the target; but if you then tried to drag another connection to the Endpoint that was created, you would
not be able to.  To permit that, you would set 'isTarget:true' on the targetEndpoint options defined above.
	
	</li>
				
			</ul>
		</div>
		
		<div class="section">
			<h3><a id="utilityFunctions">Utility Functions</a></h3>
			<ul>
				<li>Detach window5 from all connections
					<div class="code">
						<pre>jsPlumb.detachAll("window5");</pre>
					</div>
				</li>
				<li>Hide all window5's connections
					<div class="code">
						<pre>jsPlumb.hide("window5");</pre>
					</div>
				</li>
				<li>Hide all window5's connections endpoints
					<div class="code">
						<pre>jsPlumb.hide("window5", true);</pre>
					</div>
				</li>
				<li>Show all window5's connections
					<div class="code">
						<pre>jsPlumb.show("window5");</pre>
					</div>
				</li>
				<li>Show all window5's connections and endpoints.  Note that in the case that you call jsPlumb.show with two arguments, jsPlumb
				will also not make a connection visible if it determines that the other endpoint in the connection is not visible.
					<div class="code">
						<pre>jsPlumb.show("window5", hide);</pre>
					</div>
				</li>				
				<li>Toggle the visibility of window5's connections
					<div class="code">
						<pre>jsPlumb.toggle("window5");</pre>
					</div>
				</li>
				<li>Force repaint of all of window5's connections
					<div class="code">
						<pre>jsPlumb.repaint("window5");</pre>
					</div>
				</li>
				<li>Force repaint of all of window5, window6 and window11's connections
					<div class="code">
						<pre>jsPlumb.repaint( [ "window5", "window6", "window11" ] );</pre>
					</div>
				</li>
				<li>Force repaint of every connection
					<div class="code">
						<pre>jsPlumb.repaintEverything();</pre>
					</div>
				</li>
				<li>Detach every connection that the given instance of jsPlumb is managing
					<div class="code">
						<pre>jsPlumb.detachEveryConnection();</pre>
					</div>
				</li>
				<li>Detach all connections from "window1"
					<div class="code">
						<pre>jsPlumb.detachAllConnections("window1");</pre>
					</div>
				</li>
				<li>Remove the given Endpoint from element "window1", deleting its Connections. 
					<div class="code">
						<pre>jsPlumb.removeEndpoint("window1", someEndpoint);</pre>
					</div>
				</li>
				<li>Remove all Endpoints for the element 'window1', deleting their Connections.
					<div class="code">
						<pre>jsPlumb.removeAllEndpoints("window1");</pre>
					</div>
				</li>	
				<li>Removes every Endpoint managed by this instance of jsPlumb, deleting all Connections.
				This is the same as jsPlumb.reset(), effectively, but it does not clear out the event listeners list. 
					<div class="code">
						<pre>jsPlumb.removeEveryEndpoint();</pre>
					</div>
				</li>
				<li>Deletes the given Endpoint and all its Connections. 
					<div class="code">
						<pre>jsPlumb.deleteEndpoint(endpoint);</pre>
					</div>
				</li>
				<li>Removes every endpoint, detaches every connection, and clears the event listeners list.  Returns jsPlumb instance to its initial state.  
					<div class="code">
						<pre>jsPlumb.reset();</pre>
					</div>
				</li>	
				<li>Library-agnostic method to get a selector from the given selector specification.  This function is used mostly by the jsPlumb demos, to cut down on repeating code across the different libraries.  But perhaps you are writing something with jsPlumb that you also wisht to be library agnostic - this function can help you. The returned object, in each of jQuery, MooTools and YUI, has a ".each" iterator.
					<div class="code">
						<pre>var selector = jsPlumb.getSelector(".someSelector .spec");</pre>
					</div>					
				</li>
				<li>Set window1 to be not draggable, no matter what some jsPlumb command may request.
					<div class="code">
						<pre>jsPlumb.setDraggable("window1", false);</pre>
					</div>
				</li>
				<li>Set window1 and window2 to be not draggable, no matter what some jsPlumb command may request.
					<div class="code">
						<pre>jsPlumb.setDraggable(["window1","window2"], false);</pre>
					</div>
				</li>
				<li>Sets whether or not elements that are connected are draggable by default.
				The default for this is true.
					<div class="code">
						<pre>jsPlumb.setDraggableByDefault(false);</pre>
					</div>
				</li>
				<li>Initialises window1 as a draggable element (all libraries). Passes in an on drag callback
				<div class="code">
					<pre>jsPlumb.draggable("window1");</pre>
				</div>
				</li>
				<li>Initialises window1 and window2 as draggable elements (all libraries)
				<div class="code">
					<pre>jsPlumb.draggable(["window1","window2"]);</pre>
				</div>
				</li>
				<li>Initialises window1 as a draggable element (all libraries)
				<div class="code">
					<pre>jsPlumb.draggable("window1");</pre>
				</div>
				</li>
				<li>Initialises all elements with class 'window' as draggable elements (jQuery)
				<div class="code">
					<pre>jsPlumb.draggable($(".window"));</pre>
				</div>
				</li>
				<li>Initialises all elements with class 'window' as draggable elements (MooTools)
				<div class="code">
					<pre>jsPlumb.draggable($$(".window"));</pre>
				</div>
				</li>
				<li>Initialises all elements with class 'window' as draggable elements (YIU3)
				<div class="code">
					<pre>jsPlumb.draggable(Y.all(".window"));</pre>
				</div>
				</li>
				<li>Initialises window1 as a draggable element (jQuery)
				<div class="code">
					<pre>jsPlumb.draggable($("#window1"));</pre>
				</div>
				</li>
				<li>Initialises window1 as a draggable element (MooTools)
				<div class="code">
					<pre>jsPlumb.draggable($("window1"));</pre>
				</div>
				</li>
				<li>Initialises window1 as a draggable element (YUI3)
				<div class="code">
					<pre>jsPlumb.draggable(Y.one("window1"));</pre>
				</div>
				</li>
			</ul>
		</div>					
		
		<div class="section">
			<h3><a id="developingJsPlumb">Advanced Topics</a></h3>
			<h4><a id="which">Which files are which?</a></h4>
			In development, jsPlumb is broken up into nine scripts:
				<ul>
					<li>- jsPlumb-util-x.x.x.js
					<p>There are the jsPlumb utility functions (and some base classes).</p>					
					</li>
					<li>- jsPlumb-x.x.x.js
					<p>This is the main jsPlumb engine.</p>					
					</li>
					<li>- jsPlumb-defaults-x.x.x.js
					<p>This contains the default Anchor, Endpoint, Connector and Overlay implementations.</p>
					</li>
					<li>- jsPlumb-renderers-canvas-x.x.x.js
					<p>This contains the HTML5 canvas render code.</p>
					</li>
					<li>- jsPlumb-renderers-svg-x.x.x.js
					<p>This contains the SVG render code.</p>
					</li>
					<li>- jsPlumb-renderers-vml-x.x.x.js
					<p>This contains the VML render code.</p>
					</li>
					<li>- jsPlumb-connectors-statemachine-x.x.x.js
					<p>This State Machine connector.</p>
					</li>
					<li>- &lt;LIBRARY_PREFIX&gt;.jsPlumb-x.x.x.js
					<p>This contains library-specific helper methods.  jsPlumb ships with three of these - one each for jQuery, MooTools and YUI3. See below for information on how to create a new library implementation.</p>
					</li>
					<li>- jsBezier-0.3-min.js
					<p>These are the Bezier curve functions; they are maintained in a separate project called <a href="http://code.google.com/p/jsbezier/">jsBezier</a></p>
					</li>
				</ul>
			These seven files are packaged together to form the scripts that people use, for example:
			<ul>
				<li>jquery.jsPlumb-1.4.0-all.js
				<p>Contains jsPlumb-1.4.0.js, jsPlumb-defaults-1.4.0.js, jsPlumb-renderers-canvas-1.4.0.js, jsPlumb-renderers-svg-1.4.0.js, jsPlumb-renderers-vml-1.4.0.js, jsPlumb-connectors-statemachine-1.4.0.js, jquery.jsPlumb-1.4.0.js and jsBezier-0.3-min.js</p>
				</li>
				<li>jquery.jsPlumb-1.4.0-all-min.js
				<p>A minified version of the script above (minified using the YUI Compressor)</p>
				</li>
			</ul>
			<h4><a id="pluggableLibrarySupport">Pluggable Library Support</a></h4>
		Out of the box, jsPlumb can be run on top of jQuery, MooTools or YUI3.  This is achieved by
		delegating several core methods - tasks such as finding an element by id, finding an element's
		position or dimensions, initialising a draggable, etc - to the library in question.
		<p>To develop one of these, your test page should include the first two scripts discussed above, and
		then your own script containing your library specific functionality.  The existing implementations
		may be documented well enough for you to create your own, but contact me if you need assistance.  If you do this, it would be
		great to share it with everyone...</p>   
		<p>There is a group of people working on an ExtJS adapter currently.  There is no schedule for when this will be completed though.</p>

			<!-- h4><a id="customConnectors">Custom Connectors</a></h4>			
					
			You can provide your own connectors if you need to. A Connector consists of two functions, which work as a pair.  First a call is made to the <em>compute</em> function:

			<div class="code">
<pre>
this.compute = function(sourcePos, targetPos, sourceAnchor, targetAnchor, lineWidth) {
	...
	return dimensions;
}
</pre>
			</div>
			which is expected to return a list that the <em>paint</em> function can make sense of.  The first four entries in the
			list <strong>must be</strong> the [x,y,width,height] values for the canvas that the connector will be drawn on; jsPlumb will
			use this information to size the canvas prior to calling the Connector's <em>paint</em> function.  Therefore it
			is the Connector's responsibility to ensure that the returned dimensions describe a large enough space for
			the line that will be drawn on it.</p><p>The next four elements <strong>must be</strong> the coordinates of the two endpoints of the line
			you are going to draw.</p><p>The remainder of the items in the returned list are arbitrary, and will
			vary between Connector implementations; this list is passed in to a Connector's <em>paint</em> function, so each
			implementation will put into the list whatever it needs to paint itself.  For instance, the straight line
			connector only needs the [x,y] location of each end of the line it will paint, and that is one of the required entries, so
			it does not have to do anything extra,  whereas the Bezier connector adds the location of the two control points.  Other types of
			Connectors will do whatever is appropriate for their particular situation.
			</p>
			This is the method signature for the <em>paint</em> function:
			<div class="code">
				<pre>this.paint = function(dimensions, ctx) { .. }</pre>
			</div>

			here, the 'dimensions' argument to the 'paint' function is the return value of the 'compute' function.  The 'ctx' argument is the Canvas context; you
			will do all your drawing on this.
			</p>
			To change the connector from the default, specify it in your connect call:
			<div class="code">
				<pre>jsPlumb.connect({source:'someWindow', target:'otherWindow', connector:new jsPlumb.Connectors.Straight()});</pre>
			</div>
			note that you can use shorthand for connectors if you don't need to specify parameters to it:
			<div class="code">
				<pre>jsPlumb.connect({source:'someWindow', target:'otherWindow', connector:"Straight"});</pre>
			</div>
			This works in the same way as specifying Anchors as string does.
<p>
The section below this discusses Overlays, which allow you to decorate Connectors with
			things such as labels or arrows or whatever else you like. Overlays can only work with Connectors that implement a few helper functions.
			<h4>The concept of <strong>location</strong></h4>
			Before discussing the helper functions you first must be across the concept of 'location' as used by this mechanism.  The <em>location</em>
			on a connector can be a decimal value between 0 and 1 inclusive, which marks a proportionate amount of travel <em>along the path
			inscribed by the Connector</em>.  For a straight line connector this is a simple piece of maths, but for Bezier connectors it's a little
			bit more involved.
			<h4>Required Helper Methods</h4>
			<ul>
				<li><strong>pointOnPath(location)</strong> - returns an [x,y] point corresponding to the given location</li>
				<li><strong>pointAlongPathFrom(location, distance)</strong> - returns an [x,y] point corresponding to travelling 'distance' pixels along the connector from 'location'.</li>
				<li><strong>gradientAtPoint(location)</strong> - returns the connector's gradient at the given location.  For linear connectors such as Straight this is constant, but for Bezier connectors the gradient changes continually.</li>
				<li><strong>perpendicularToPathAt(location, distance, length)</strong> - returns a line that is perpendicular to (and centered on) the connector at 'distance' from the given location, with length 'length'.</li>
			</ul>
</p>
<h4><a id="customEndpoints">Custom Endpoints</a></h4>
<p>To create your own Endpoint implementation, you need to implement a single method:
				<div class="code"><pre>paint : function(anchorPoint, orientation, canvas, endpointStyle, connectorPaintStyle) { ... }</pre></div>
				The arguments to this method are as follows:
				<ul>
					<li>anchorPoint - [x,y] location of the anchor point on screen</li>
					<li>orientation - [x,y] hints for the general direction the anchor points to</li>
					<li>canvas - the canvas to draw into</li>
					<li>endpointStyle - Javascript object containing style directives as discussed above.  The contents of this are arbitrary, so if you write a new Endpoint that needs some extra settings, you can add them no hassle.</li>
					<li>connectorPaintStyle - the style being used to paint the associated Connector.</li>
				</ul>
			</p>
			<p>
				It is your responsibility to size and locate the canvas to suit your needs. jsPlumb provides the following
				helper method to assist you:
				<div class="code"><pre>jsPlumb.sizeCanvas(canvas, x, y, width, height);</pre></div>
				Allows you to locate the canvas on screen and to size it.
			</p>
<h4><a id="customOverlays">Custom Overlays</a></h4>
			Overlays can only work with Connectors that implement the methods <strong>pointOnPath</strong>, <strong>pointAlongPathFrom</strong>,
			<strong>gradientAtPoint</strong>, and <strong>perpendicularToPathAt</strong>.  These are discussed in more detail in the Custom Connectors section above.  Both of the Connectors
			that come with jsPlumb - Straight and Bezier -implement these methods; if you write a custom connector, or have written a custom connector, you will need to supply
			them.   
			<h4>Overlay Interface</h4>
			An Overlay is required to implement two methods in order to be usable by jsPlumb:
			<ul>
				<li><strong>computeMaxSize(connector, context)</strong> - returns an integer value indicating the larger of this overlay's width and height.  It is used by jsPlumb to ensure that the canvas is large enough to accomodate the overlay.  The examples below should help to clarify this.</li>
				<li><strong>draw(connector, ctx)</strong> - draws the overlay.  What happens in this method is up to the given implementation.</li>
			</ul>
			<h4>computeMaxSize methods</h4>
			This is the Arrow overlay's computeMaxSize method:
			<div class="code">
<pre>
this.computeMaxSize = function() { return width; }
</pre>			
			</div>
Here, <em>width</em> is a private member of Arrow that indicates the width of the arrow's tail.  So the Arrow overlay reports that figure as the width it needs.					
Contrast this with the Label Overlay's computeMaxSize method:
		<div class="code">
<pre>
this.computeMaxSize = function(connector, ctx) {
  	if (labelText) {
  		ctx.save();
        if (self.labelStyle.font) ctx.font = self.labelStyle.font;
         var t = ctx.measureText(labelText).width;			            
		// a fake text height measurement: use the width of upper case M
		var h = ctx.measureText("M").width;					
		labelPadding = self.labelStyle.padding || 0.25;
		labelWidth = t + (2 * t * labelPadding);
		labelHeight = h + (2 * h * labelPadding);
		ctx.restore();
		return Math.max(labelWidth, labelHeight);
  	}
 	return 0;
 };
</pre>			
			</div>
The Label overlay has to use the context to determine how big it will be on screen.

<h4>draw methods</h4>
To give you a taste for how you can interact with a connector, consider the first few lines of the Arrow overlay's draw method:
<div class="code">
<pre>
this.draw = function(connector, ctx) {
	// this is the arrow head position
	var hxy = connector.pointAlongPathFrom(self.loc, length / 2);		
	// this is the center of the tail
	var txy = connector.pointAlongPathFrom(self.loc, -length / 2), tx = txy[0], ty = txy[1];
	// this is the tail vector
	var tail = connector.perpendicularToPathAt(self.loc, -length / 2, width);
	
	...
</pre>
</div>
	<p>The first two calls to the connector use the <strong>pointAlongPathFrom</strong> method, which passes <em>self.loc</em> as the location of the
	point on the path, and <em>length / 2</em> as the number of pixels along the path to traverse.</p>
	<p><em>self.loc</em> is Arrow's internal member describing the location of the overlay, and it is a decimal (between 0 and 1 inclusive) that points to
	a location at some distance along the path inscribed by the connector.  So these first two calls get us [x,y] locations of points on 
	the connector that mark the head and tail points for the arrow.  
	</p>		
	<p>
	The <strong>connector.perpendicularToPathAt(self.loc, -length / 2, width)</strong> call returns a line description of a line that is perpendicular to, and centered on, the connector
	at "-length / 2" pixels from the given point, with the given width (width is an internal member of Arrow).  At this point, the Arrow object has the three main points it
	needs in order to draw itself.
	</p>
		</div-->
</div>

</body>

</html>